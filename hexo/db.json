{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/CBDevices1_2x.png","path":"img/CBDevices1_2x.png","modified":0,"renderable":0},{"_id":"source/img/CBPeripheralData_Example_2x.png","path":"img/CBPeripheralData_Example_2x.png","modified":0,"renderable":0},{"_id":"source/img/TreeOfServicesAndCharacteristics_Remote_2x.png","path":"img/TreeOfServicesAndCharacteristics_Remote_2x.png","modified":0,"renderable":0},{"_id":"source/img/screenshotBluetooth.png","path":"img/screenshotBluetooth.png","modified":0,"renderable":0},{"_id":"source/img/LLVM循环优化/nointerchange.jpg","path":"img/LLVM循环优化/nointerchange.jpg","modified":0,"renderable":0},{"_id":"source/img/LLVM循环优化/reduce.png","path":"img/LLVM循环优化/reduce.png","modified":0,"renderable":0},{"_id":"source/img/LLVM循环优化/unswitch.jpg","path":"img/LLVM循环优化/unswitch.jpg","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/dmisswo.png","path":"img/LoopUnrolling/dmisswo.png","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/unrolling_vs.png","path":"img/LoopUnrolling/unrolling_vs.png","modified":0,"renderable":0},{"_id":"source/img/Pluto/console1.PNG","path":"img/Pluto/console1.PNG","modified":0,"renderable":0},{"_id":"source/img/Pluto/console2.PNG","path":"img/Pluto/console2.PNG","modified":0,"renderable":0},{"_id":"source/img/Pluto/logo.png","path":"img/Pluto/logo.png","modified":0,"renderable":0},{"_id":"source/img/Swift4新特性/substring.png","path":"img/Swift4新特性/substring.png","modified":0,"renderable":0},{"_id":"source/img/bubble_rebound/bb2.png","path":"img/bubble_rebound/bb2.png","modified":0,"renderable":0},{"_id":"source/img/layoutStudy/ios_screen_display.png","path":"img/layoutStudy/ios_screen_display.png","modified":0,"renderable":0},{"_id":"source/img/左滑删除图片/finish.png","path":"img/左滑删除图片/finish.png","modified":0,"renderable":0},{"_id":"themes/icarus/source/css/back-to-top.css","path":"css/back-to-top.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/insight.css","path":"css/insight.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/progressbar.css","path":"css/progressbar.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/images/thumbnail.svg","path":"images/thumbnail.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back-to-top.js","path":"js/back-to-top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/img/LLVM循环优化/interchange.png","path":"img/LLVM循环优化/interchange.png","modified":0,"renderable":0},{"_id":"source/img/LLVM循环优化/noreduce.png","path":"img/LLVM循环优化/noreduce.png","modified":0,"renderable":0},{"_id":"source/img/LLVM循环优化/nounswitch.jpg","path":"img/LLVM循环优化/nounswitch.jpg","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/asm_0.png","path":"img/LoopUnrolling/asm_0.png","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/dmissw.png","path":"img/LoopUnrolling/dmissw.png","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/imissw.png","path":"img/LoopUnrolling/imissw.png","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/dump.png","path":"img/LoopUnrolling/dump.png","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/imisswo.png","path":"img/LoopUnrolling/imisswo.png","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/ll0.png","path":"img/LoopUnrolling/ll0.png","modified":0,"renderable":0},{"_id":"source/img/iOS手势学习笔记/stateMachine.png","path":"img/iOS手势学习笔记/stateMachine.png","modified":0,"renderable":0},{"_id":"source/img/内存管理与多线程/dispatch.png","path":"img/内存管理与多线程/dispatch.png","modified":0,"renderable":0},{"_id":"themes/icarus/source/images/icon.jpg","path":"images/icon.jpg","modified":0,"renderable":1},{"_id":"source/img/LLVM循环优化/interchange_cache.png","path":"img/LLVM循环优化/interchange_cache.png","modified":0,"renderable":0},{"_id":"source/img/LLVM循环优化/no_interchange_cache.png","path":"img/LLVM循环优化/no_interchange_cache.png","modified":0,"renderable":0},{"_id":"source/img/左滑删除图片/leftswipe.PNG","path":"img/左滑删除图片/leftswipe.PNG","modified":0,"renderable":0},{"_id":"source/img/蓝牙测距/screenshot1.PNG","path":"img/蓝牙测距/screenshot1.PNG","modified":0,"renderable":0},{"_id":"source/img/蓝牙测距/screenshot2.PNG","path":"img/蓝牙测距/screenshot2.PNG","modified":0,"renderable":0},{"_id":"source/img/蓝牙测距/原理图.png","path":"img/蓝牙测距/原理图.png","modified":0,"renderable":0},{"_id":"source/img/JS调用Swift卡顿/screenshot.png","path":"img/JS调用Swift卡顿/screenshot.png","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/pipewo.png","path":"img/LoopUnrolling/pipewo.png","modified":0,"renderable":0},{"_id":"source/img/RunLoop/tsd.png","path":"img/RunLoop/tsd.png","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/ll3.png","path":"img/LoopUnrolling/ll3.png","modified":0,"renderable":0},{"_id":"source/img/bubble_rebound/bb1.png","path":"img/bubble_rebound/bb1.png","modified":0,"renderable":0},{"_id":"source/img/使用gperftools/screenshot.png","path":"img/使用gperftools/screenshot.png","modified":0,"renderable":0},{"_id":"source/img/静默推送/knuff.png","path":"img/静默推送/knuff.png","modified":0,"renderable":0},{"_id":"source/img/LoopUnrolling/pipew.png","path":"img/LoopUnrolling/pipew.png","modified":0,"renderable":0},{"_id":"source/img/左滑删除图片/hierarchy.png","path":"img/左滑删除图片/hierarchy.png","modified":0,"renderable":0},{"_id":"source/img/内存管理与多线程/zone.jpg","path":"img/内存管理与多线程/zone.jpg","modified":0,"renderable":0},{"_id":"source/img/内存管理与多线程/thread.JPG","path":"img/内存管理与多线程/thread.JPG","modified":0,"renderable":0},{"_id":"source/img/蓝牙测距/photo.jpg","path":"img/蓝牙测距/photo.jpg","modified":0,"renderable":0},{"_id":"source/img/ObjC-运行时系统/method.JPG","path":"img/ObjC-运行时系统/method.JPG","modified":0,"renderable":0},{"_id":"source/img/静默推送/p12.png","path":"img/静默推送/p12.png","modified":0,"renderable":0},{"_id":"source/img/layoutStudy/twoViews.gif","path":"img/layoutStudy/twoViews.gif","modified":0,"renderable":0},{"_id":"source/img/Pluto/wire.JPG","path":"img/Pluto/wire.JPG","modified":0,"renderable":0},{"_id":"source/img/Pluto/overview.JPG","path":"img/Pluto/overview.JPG","modified":0,"renderable":0},{"_id":"source/img/Pluto/sketch.JPG","path":"img/Pluto/sketch.JPG","modified":0,"renderable":0},{"_id":"source/img/arduinoWithBluetooth.JPG","path":"img/arduinoWithBluetooth.JPG","modified":0,"renderable":0},{"_id":"source/img/layoutStudy/screen.gif","path":"img/layoutStudy/screen.gif","modified":0,"renderable":0},{"_id":"source/img/限定ScrollView允许滑动角度/scroll.gif","path":"img/限定ScrollView允许滑动角度/scroll.gif","modified":0,"renderable":0},{"_id":"source/img/iOS动画学习笔记/screenshot.gif","path":"img/iOS动画学习笔记/screenshot.gif","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"254ed15c4ffe0599aa053615f1e051bc2fe9a9ab","modified":1578125776912},{"_id":"themes/icarus/LICENSE","hash":"41f72cd544612bc4589c924c776422b800a4eff7","modified":1578125881318},{"_id":"themes/icarus/README.md","hash":"c351bc76d3b4a138989c50f57bd3c52fa95eaa56","modified":1578125881318},{"_id":"themes/icarus/_config.yml","hash":"70ec556919c6aa7dd13a43c25040d90d1a255333","modified":1578130568630},{"_id":"themes/icarus/package.json","hash":"4f362aa241ad5d5d9422cc8f1e825edfcd8cbb1a","modified":1578125881340},{"_id":"source/about/index.md","hash":"37e039176f7b662ce71849d6aba0d7ad78d99125","modified":1578125776923},{"_id":"source/contact/index.md","hash":"4616ae319e3335a2e0769534cf845532d1bfb856","modified":1578125776923},{"_id":"source/_posts/AFNetworking设置HTTP-Header-Body.md","hash":"a83e03111b27fb86b15651c673f78fc89ce74067","modified":1578125776912},{"_id":"source/_posts/C语言extern关键字.md","hash":"cbad42468d48f3198df0688ddfca467f24fe2f8a","modified":1578125776912},{"_id":"source/_posts/Flutter-for-iOS-dev-翻译.md","hash":"31d75f6144cdf87cf4fbc1dae8ed0f625517fbf6","modified":1578125776913},{"_id":"source/_posts/JavaScript基础分享.md","hash":"6ce1855d3abfcd7dfe42978f91867b84418c6f68","modified":1578125776914},{"_id":"source/_posts/JS调用Swift造成卡顿问题.md","hash":"2098b3060626b5002e33cf2c785d3d0165266ccb","modified":1578125776913},{"_id":"source/_posts/Java以空格分割字符串.md","hash":"b356b2890127c6b79921fe260670c9c867a93f2a","modified":1578125776914},{"_id":"source/_posts/LLVM循环优化.md","hash":"54a9ac925c898dc24aa1c4c50b887e918527e1d4","modified":1578125776914},{"_id":"source/_posts/Linux下使用gperftools.md","hash":"d00d646d150557818ce344e4df95005694db8e02","modified":1578125776914},{"_id":"source/_posts/Obj-C内存管理.md","hash":"62b77a2dbd3fb852b4f7c266a5587184e820fdac","modified":1578125776915},{"_id":"source/_posts/LoopUnrolling优化效果对比.md","hash":"b1e6f9d693489657ec116883983186db9ffcb631","modified":1578125776914},{"_id":"source/_posts/Obj-C内存管理细节和多线程.md","hash":"a1aba3456b4fd696bbb22e02d864cc45bb8b99c1","modified":1578125776915},{"_id":"source/_posts/Obj-C运行时系统.md","hash":"fb91ab8bfab7506ff32330b67cd02df6d3c405e1","modified":1578125776915},{"_id":"source/_posts/Obj-C键值编程.md","hash":"68581dd8aacee5286e3d8f84fdbf1edad23535b3","modified":1578125776915},{"_id":"source/_posts/Promise是什么.md","hash":"10459de2fede9ddddcf96cce20204397f4c9eca0","modified":1578125776915},{"_id":"source/_posts/Python-import-崩溃问题.md","hash":"68980fccccd977b20f79e5573b0c55daaa020b05","modified":1578125776915},{"_id":"source/_posts/RaspberryPi3B-安装UbuntuMATE.md","hash":"400f428a9717174d5de25322aca02c44df586d9a","modified":1578125776916},{"_id":"source/_posts/RunLoop原理.md","hash":"5eb49d7304b64a3fc41eb74d320561a5cbc32bd5","modified":1578125776916},{"_id":"source/_posts/SQLite使用.md","hash":"e1a9da656eca543d55199ee530e0cfeeaedd6ec3","modified":1578125776916},{"_id":"source/_posts/Swift-Tips.md","hash":"92956a793d20c50096fb8d2a9ae1a7bcf32977e0","modified":1578125776916},{"_id":"source/_posts/Swift-多线程.md","hash":"9949cce45fb56cbc92cb9bef9a38ef590d4d5649","modified":1578125776916},{"_id":"source/_posts/Swift4新特性.md","hash":"078778d67123bd63295f0cfcfdf5ac0b9f105aa4","modified":1578125776917},{"_id":"source/_posts/Swift集成友盟数据统计.md","hash":"44b1fccdd6232c07406bf1fdbcac764a69f87cdf","modified":1578125776917},{"_id":"source/_posts/V-REP实现Bubble-Rebound算法.md","hash":"cf0a339867e2a6448be0cc13d79eb89f27e6f8d7","modified":1578125776917},{"_id":"source/_posts/WiFi监听UDP包.md","hash":"90fe224fe83bbade6eecb8646c6665e7a40f6873","modified":1578125776917},{"_id":"source/_posts/iOS-Layout学习笔记.md","hash":"9746ae25a94ef1915386eb172d1ba04f9242b310","modified":1578125776917},{"_id":"source/_posts/iOS-布局与自动布局.md","hash":"9bf157202ad6b3effb407c9ae408ad3c390e9086","modified":1578125776918},{"_id":"source/_posts/iOS-为TableView左滑删除添加图片.md","hash":"55cc3a78aaa393c00f1f67dbd2e7e4674d4cc714","modified":1578125776917},{"_id":"source/_posts/iOS-核心动画.md","hash":"dc68ffd69a49e17d37e38f6140ae42e15db1c1a5","modified":1578125776918},{"_id":"source/_posts/iOS-自定义TabBar的正确姿势.md","hash":"ff8b563e0c3882af6e601fd926b9d7538d67efff","modified":1578125776918},{"_id":"source/_posts/iOS-蓝牙开发初步.md","hash":"8e8eb3ae14891850b3d6881778ada6b0461e64eb","modified":1578125776918},{"_id":"source/_posts/iOS动画学习笔记.md","hash":"3f19d326bc0733d45cd7ad9034c93ac8880708b7","modified":1578125776918},{"_id":"source/_posts/iOS图片裁剪旋转格式转换.md","hash":"cdb9899a3f03de994adf394f50a1f61ae9cf8c98","modified":1578125776918},{"_id":"source/_posts/iOS多线程学习笔记.md","hash":"e48d5b259ed6e66be2c9ba52baf01f26045f6508","modified":1578125776919},{"_id":"source/_posts/iOS手势学习笔记.md","hash":"3fb43818bb6eb6f938f25129541b960e040f7962","modified":1578125776919},{"_id":"source/_posts/iOS蓝牙开发-超声波测距仪.md","hash":"be8506bfbb6ae2aa7954c0695f6928d99f7d3546","modified":1578125776919},{"_id":"source/_posts/iOS限制UIScrollView允许滑动角度.md","hash":"ee4cb0894b99033a0d95a7cbdcc6540d066f5920","modified":1578125776919},{"_id":"source/_posts/iOS静默推送.md","hash":"adb2b2d27ef22a8d869cff31875ff58bc19da2dc","modified":1578125776919},{"_id":"source/_posts/macOS上运行其他程序并获取实时输出.md","hash":"a54364b5ba23c46aa4729b84f43038688ec3560d","modified":1578125776919},{"_id":"source/_posts/what-are-dynamic-libraries.md","hash":"82a1c06bf0e2d8ebe77bc8ae4352883a4082f158","modified":1578125776920},{"_id":"source/_posts/使用PlutoSDR构建简易通信系统.md","hash":"8eed70e5bb7a5dcdb0585a05071174426c78a188","modified":1578125776920},{"_id":"source/_posts/动态规划法.md","hash":"11c602501b7632cec82cc92faefc6fc93a95a657","modified":1578125776920},{"_id":"source/_posts/在macOS下安装gem5模拟器.md","hash":"9844aeea8d86e46653371197f8c80603654934b9","modified":1578125776920},{"_id":"source/_posts/用Swift写算法-初等排序.md","hash":"ff7d8d0eea41ad57f8e72ac2e20dfe97e2a2d1c0","modified":1578125776920},{"_id":"source/_posts/用Swift写算法-搜索.md","hash":"f95380abc86fe04d0c38b1eb0b8d8030a4caec1c","modified":1578125776921},{"_id":"source/_posts/用Swift写算法-递归和分治法.md","hash":"dce9d28fbc6a9d61939d65f9cf82bb9acc9588c6","modified":1578125776921},{"_id":"source/_posts/用Swift写算法-高等排序.md","hash":"279c2a6669fa6d6ab764562d2b1c0de4ea746000","modified":1578125776921},{"_id":"source/_posts/解决Leak分析闪退问题.md","hash":"a63630b1190e03542c7b94dc3a0b78f655c6ea1a","modified":1578125776921},{"_id":"source/_posts/解决Unacceptable-Content-Type.md","hash":"235baac6f46d54332c82154fe70fa8a4245f2217","modified":1578125776922},{"_id":"source/_posts/让Xcode控制台打印彩色文字.md","hash":"5204e5eeab0b6d4fc6fcdee8f805795f6f0ecfd7","modified":1578125776922},{"_id":"source/_posts/设计模式-创建型模式.md","hash":"8115e4083dd5f6f1289204d101c1e2d2167cca91","modified":1578125776922},{"_id":"source/_posts/调试JSCore小技巧.md","hash":"5df9dbce32e9822369af3081edd89d4a8a116d52","modified":1578125776922},{"_id":"source/_posts/阿里一面凉了之旅.md","hash":"14ef6b7ade3ce61a708ad54be6aa1483b53ea86e","modified":1578125776922},{"_id":"source/img/CBDevices1_2x.png","hash":"565f6c331c58976d4b628474134cc626fb494328","modified":1578125776923},{"_id":"source/img/CBPeripheralData_Example_2x.png","hash":"de25cba0f873f7b262c8900cff2c946cb19a8b2d","modified":1578125776924},{"_id":"source/img/TreeOfServicesAndCharacteristics_Remote_2x.png","hash":"63b10df6289146ee2f09120db866a221b7b71a59","modified":1578125776961},{"_id":"source/img/screenshotBluetooth.png","hash":"13e184281eb98179e09f5fd41b9edf03f31523da","modified":1578125777006},{"_id":"themes/icarus/languages/de.yml","hash":"79d769768780b9a72eb256ab61f217b8bdebf85b","modified":1578125881324},{"_id":"themes/icarus/languages/en.yml","hash":"4f4bb840b7d2f90350d190713a3946e880ee950d","modified":1578129832730},{"_id":"themes/icarus/languages/es.yml","hash":"2e59e579d393c881dcbb885516d93eeaf469cec2","modified":1578125881325},{"_id":"themes/icarus/languages/fr.yml","hash":"0017f93a5d491a9c0e55911cdc35316762c5a94e","modified":1578125881325},{"_id":"themes/icarus/languages/id.yml","hash":"92d2d19a62a17b6e99f82a014309bbf6c13c9ae8","modified":1578125881325},{"_id":"themes/icarus/languages/ja.yml","hash":"6eed7771de2353d71b720c6e605cceb3f230b12e","modified":1578125881325},{"_id":"themes/icarus/languages/ko.yml","hash":"e7ac736b604429adedd67f3ca6043201eff7b23b","modified":1578125881325},{"_id":"themes/icarus/languages/pl.yml","hash":"43f5447c38c9be2e1f5ce6181a0f97eeb437b059","modified":1578125881325},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"bcf5bc81ca855d26bbc3b3bfabc7d84429e74b85","modified":1578125881325},{"_id":"themes/icarus/languages/ru.yml","hash":"ba8b4f7d77eb1d1e28aa1f9107bd0bbbdc4cba99","modified":1578125881326},{"_id":"themes/icarus/languages/tr.yml","hash":"eff1c0b3d5c4b328f6dd74a195ff378c898f4d29","modified":1578125881326},{"_id":"themes/icarus/languages/vn.yml","hash":"6d9f4fabca711a6cb0a0efd72aa75c3641beb4a6","modified":1578125881326},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"804f6a1edee49bb6a5ecb8e9d14d3e93eaca37c0","modified":1578125881326},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"6ff978a0c4c11e996925e1a912a1d805f4680a6c","modified":1578125881326},{"_id":"themes/icarus/layout/archive.ejs","hash":"2527527eaf3e757ab476325f691d2e2e0ff9c2d5","modified":1578125881326},{"_id":"themes/icarus/layout/categories.ejs","hash":"29d304f2b95a04fbc5e7529f9bdce9648e3545ef","modified":1578125881327},{"_id":"themes/icarus/layout/category.ejs","hash":"58aa84f75193b978b2072f29dbb84ed8279574b9","modified":1578125881327},{"_id":"themes/icarus/layout/index.ejs","hash":"8ab440868f721bb7256ab9f2be96996850b0cf44","modified":1578125881332},{"_id":"themes/icarus/layout/layout.ejs","hash":"c9ab786c4c4a95e403fc8ea7e536084f21a9ecc4","modified":1578125881332},{"_id":"themes/icarus/layout/page.ejs","hash":"ebf120d46074f67ea25a231d2f7a64fd1e751904","modified":1578125881332},{"_id":"themes/icarus/layout/post.ejs","hash":"ebf120d46074f67ea25a231d2f7a64fd1e751904","modified":1578125881335},{"_id":"themes/icarus/layout/tag.ejs","hash":"45eb077f2ac86f5c8090cb1a2361eed56a368e95","modified":1578125881337},{"_id":"themes/icarus/layout/tags.ejs","hash":"0c527c6b72386f11c18e8aa5249be8c601e69906","modified":1578125881337},{"_id":"themes/icarus/scripts/index.js","hash":"40839db58041e31eb06d428a91869b0789277e7e","modified":1578125881340},{"_id":"source/img/LLVM循环优化/nointerchange.jpg","hash":"2c1fa0ed9aa54975f407f465aa4a29422ab89c44","modified":1578125776928},{"_id":"source/img/LLVM循环优化/reduce.png","hash":"1614f6c227410155218d300e9858bf5b2948be7e","modified":1578125776929},{"_id":"source/img/LLVM循环优化/unswitch.jpg","hash":"769e23ecd6333913c724887a9ef2ad16cf138372","modified":1578125776930},{"_id":"source/img/LoopUnrolling/dmisswo.png","hash":"c55666c5ab2260c9b3ab9d7bc321c7e8762614f6","modified":1578125776932},{"_id":"source/img/LoopUnrolling/unrolling_vs.png","hash":"2fb1958d53aac592f0a5aa0d7d25c5c0b69fd87e","modified":1578125776938},{"_id":"source/img/Pluto/console1.PNG","hash":"c1db43729c62b992a849ca3b74ed85dc35edd3db","modified":1578125776941},{"_id":"source/img/Pluto/console2.PNG","hash":"c7cdfc37226dde133fc4f598f5322b92b9861ef5","modified":1578125776941},{"_id":"source/img/Pluto/logo.png","hash":"0bf22da57033f6d77ced7fbd2a9c40739ddec0e6","modified":1578125776941},{"_id":"source/img/Swift4新特性/substring.png","hash":"e57585629f57482590b637bffd89177a2d41202c","modified":1578125776961},{"_id":"source/img/bubble_rebound/bb2.png","hash":"f0941c36766abd2496d982a88023c2db1de81a95","modified":1578125776969},{"_id":"source/img/layoutStudy/ios_screen_display.png","hash":"cefc4140b84e5a5dc99204175089f63381649ee0","modified":1578125776989},{"_id":"source/img/左滑删除图片/finish.png","hash":"499eedb0d0d1dadd86663e7267524786a673d82e","modified":1578125777015},{"_id":"themes/icarus/includes/common/ConfigGenerator.js","hash":"451397efc7808787419fa3eb6b043c0bd8bbdf30","modified":1578125881319},{"_id":"themes/icarus/includes/common/ConfigValidator.js","hash":"48cff5402e93b11d5266370e9c4b78ee21369cb9","modified":1578125881319},{"_id":"themes/icarus/includes/common/utils.js","hash":"c0aeaeb57a42bcc71a92da2249762f91abd83ffe","modified":1578125881319},{"_id":"themes/icarus/includes/generators/categories.js","hash":"7cb370ac53a05d6b1b9203579716c0ca83d35c36","modified":1578125881319},{"_id":"themes/icarus/includes/generators/category.js","hash":"313e170e55d74526c4e1be7181ef7a21439147c9","modified":1578125881319},{"_id":"themes/icarus/includes/generators/insight.js","hash":"c4b981443927b87cc14a3a583029e13f819d6d71","modified":1578125881319},{"_id":"themes/icarus/includes/generators/tags.js","hash":"8195322c208706427a1cf56361669dca4d86f6f1","modified":1578125881319},{"_id":"themes/icarus/includes/helpers/cdn.js","hash":"7d34ea6400cb3611c374c135304abcb65ef291b7","modified":1578125881320},{"_id":"themes/icarus/includes/helpers/config.js","hash":"173e02987e7a7d5df1e686f6ee4edd8cf494bdd3","modified":1578125881320},{"_id":"themes/icarus/includes/helpers/layout.js","hash":"afdf5e9704cfc087526b4a0403fe7eb04f22190e","modified":1578125881320},{"_id":"themes/icarus/includes/helpers/override.js","hash":"223771860caddffcbce7d84dfb07798f6aa0bdda","modified":1578125881320},{"_id":"themes/icarus/includes/helpers/page.js","hash":"4ce98c781bcbc132672e6d16bf02df5bebcea7b3","modified":1578125881320},{"_id":"themes/icarus/includes/helpers/site.js","hash":"2f55818448fe83c73418dcf9751745c7918c10e3","modified":1578125881321},{"_id":"themes/icarus/includes/specs/article.spec.js","hash":"ce24279cd0cd39855216dab0cd5223c755757cdf","modified":1578125881321},{"_id":"themes/icarus/includes/specs/config.spec.js","hash":"7a9bac384a73cf9f39173fdb2dfc2813784d8891","modified":1578125881321},{"_id":"themes/icarus/includes/specs/comment.spec.js","hash":"b0ef033e363b918134fb5a003143e9bd8fafa300","modified":1578125881321},{"_id":"themes/icarus/includes/specs/donate.spec.js","hash":"722cb2662569957e8b1d1a467d9632b8cc6e69d6","modified":1578125881321},{"_id":"themes/icarus/includes/specs/footer.spec.js","hash":"8e6d7c5f9a13ce03241b6562259d210b389cb88e","modified":1578125881322},{"_id":"themes/icarus/includes/specs/icon_link.spec.js","hash":"f2a83ac5ccb74fc6f3dfbd25430e142297d8491c","modified":1578125881322},{"_id":"themes/icarus/includes/specs/meta.spec.js","hash":"ed1b818b929d71930608291514a72ef5a639efee","modified":1578125881322},{"_id":"themes/icarus/includes/specs/navbar.spec.js","hash":"7de29c0031738a4de4d31ed4f7b0c43447c7961c","modified":1578125881322},{"_id":"themes/icarus/includes/specs/plugins.spec.js","hash":"2fb7a28fdde9a46f576e69b9967f24d66adffb57","modified":1578125881322},{"_id":"themes/icarus/includes/specs/providers.spec.js","hash":"820cc6936ba75e3104cc2e8641716ed65ada8b6f","modified":1578125881322},{"_id":"themes/icarus/includes/specs/search.spec.js","hash":"1e3995cdc471e6a2817cd45e2b6f0fd39b4540ec","modified":1578125881323},{"_id":"themes/icarus/includes/specs/share.spec.js","hash":"5ec65409a17ead13974140fc5ddc19e526586d9f","modified":1578125881323},{"_id":"themes/icarus/includes/specs/sidebar.spec.js","hash":"630c9701affe2549abc61cd4d1e5153af2224fb6","modified":1578125881323},{"_id":"themes/icarus/includes/specs/widgets.spec.js","hash":"c5cedfe1074c0566baf8aca248f0392a501d9a74","modified":1578125881323},{"_id":"themes/icarus/includes/tasks/check_config.js","hash":"ce7626d643737c90dee6b75435ccdec26b89dacf","modified":1578125881323},{"_id":"themes/icarus/includes/tasks/check_deps.js","hash":"ab08051f785eab2a0685aa537270d2988bc13639","modified":1578125881324},{"_id":"themes/icarus/includes/tasks/welcome.js","hash":"00d1ef8c9609552b82e9a5140b838a9057c59508","modified":1578125881324},{"_id":"themes/icarus/includes/utils/lru.js","hash":"35c0ede3553549758ff5e4ded2bc650778793377","modified":1578125881324},{"_id":"themes/icarus/layout/comment/changyan.ejs","hash":"73038ac4fdfdfa71d92edaa98cc194b3446586a3","modified":1578125881327},{"_id":"themes/icarus/layout/comment/changyan.locals.js","hash":"49bce2ee742c7224bda97092d6e0a1a09184ef34","modified":1578125881327},{"_id":"themes/icarus/layout/comment/disqus.ejs","hash":"7a8c656c8651d48e21ed24c469ea75898b2b12df","modified":1578125881327},{"_id":"themes/icarus/layout/comment/disqus.locals.js","hash":"a8d2cecaa82ec9e2e2e61cb73417d63d115335d6","modified":1578125881327},{"_id":"themes/icarus/layout/comment/facebook.ejs","hash":"1c3751f36f737527e352c65bb1ca7172ff792979","modified":1578125881328},{"_id":"themes/icarus/layout/comment/facebook.locals.js","hash":"77e3ef1d933660d980b26d15968aa1a5c8a93a56","modified":1578125881328},{"_id":"themes/icarus/layout/comment/gitalk.ejs","hash":"eb1314badf793924b5786e92f8b3ebb0f21f3b58","modified":1578125881328},{"_id":"themes/icarus/layout/comment/gitalk.locals.js","hash":"f920f130598148b4d9f213c82f2d7f88a796012f","modified":1578125881328},{"_id":"themes/icarus/layout/comment/gitment.ejs","hash":"d5e1a396e23df4e75e139d12846290bdb08ba01e","modified":1578125881328},{"_id":"themes/icarus/layout/comment/gitment.locals.js","hash":"f920f130598148b4d9f213c82f2d7f88a796012f","modified":1578125881328},{"_id":"themes/icarus/layout/comment/isso.ejs","hash":"cc6a43bd24be764086f88ad7c5c97ff04df87e0b","modified":1578125881329},{"_id":"themes/icarus/layout/comment/isso.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881329},{"_id":"themes/icarus/layout/comment/livere.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881329},{"_id":"themes/icarus/layout/comment/livere.ejs","hash":"12ff9a345f6bba2f732f592e39508c2afde89b00","modified":1578125881329},{"_id":"themes/icarus/layout/comment/valine.ejs","hash":"31471cd05018583249b4c09a78cf1d02e7987244","modified":1578125881329},{"_id":"themes/icarus/layout/comment/valine.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881329},{"_id":"themes/icarus/layout/common/article.ejs","hash":"d2362964b2d9427067e1d7dfe100220b380b2f70","modified":1578125881330},{"_id":"themes/icarus/layout/common/article.locals.js","hash":"1f108fa96e61a681d7b1ee390b4f0ff60d042720","modified":1578125881330},{"_id":"themes/icarus/layout/common/footer.ejs","hash":"d70962fd1c8123c5314d73cf0aec08ffb96aeca5","modified":1578125881330},{"_id":"themes/icarus/layout/common/footer.locals.js","hash":"504ed92dc76723f19777463d690acfbe1d89e2ba","modified":1578125881330},{"_id":"themes/icarus/layout/common/head.ejs","hash":"0998072c9ece90e26339f2503633c4ca08da62e9","modified":1578125881330},{"_id":"themes/icarus/layout/common/navbar.ejs","hash":"0fe0c940fcb112828d465830713a0cdd42864951","modified":1578125881330},{"_id":"themes/icarus/layout/common/navbar.locals.js","hash":"7e523ba80667038f2e58cf4f9cb073e9afbc70e6","modified":1578125881330},{"_id":"themes/icarus/layout/common/paginator.ejs","hash":"7837d80b27f166161b3deeffb571680025c7d723","modified":1578125881330},{"_id":"themes/icarus/layout/common/scripts.ejs","hash":"99da87756d2bd234b058e90d2c6dabc1bc10f20e","modified":1578125881331},{"_id":"themes/icarus/layout/common/widget.ejs","hash":"02ffa7531d14b88e76bff5ff6d2b4482e7c5bbfd","modified":1578125881331},{"_id":"themes/icarus/layout/donate/alipay.ejs","hash":"3290058879973e403a05472a0fe2ac0219d5b961","modified":1578125881331},{"_id":"themes/icarus/layout/donate/alipay.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881331},{"_id":"themes/icarus/layout/donate/patreon.ejs","hash":"fc19da9674649c035d133535078ff7e37d0f54c1","modified":1578125881331},{"_id":"themes/icarus/layout/donate/patreon.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881331},{"_id":"themes/icarus/layout/donate/paypal.ejs","hash":"dbb90fa9214d659ea6bbd5a92ea00888adf3761e","modified":1578125881332},{"_id":"themes/icarus/layout/donate/paypal.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881332},{"_id":"themes/icarus/layout/donate/wechat.ejs","hash":"051b873e1fc28c1d7c2d6443991b6a2f43813e6b","modified":1578125881332},{"_id":"themes/icarus/layout/donate/wechat.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881332},{"_id":"themes/icarus/layout/plugin/animejs.ejs","hash":"c17ea2cfe5cb239342166e2ba72cbfc663c8160f","modified":1578125881332},{"_id":"themes/icarus/layout/plugin/animejs.locals.js","hash":"3bf911060a222f00b03be708c37f20e36cb66ba9","modified":1578125881333},{"_id":"themes/icarus/layout/plugin/back-to-top.ejs","hash":"5936b5fd2f2444605a21c6c422623f07f02d5c9a","modified":1578125881333},{"_id":"themes/icarus/layout/plugin/back-to-top.locals.js","hash":"3bf911060a222f00b03be708c37f20e36cb66ba9","modified":1578125881333},{"_id":"themes/icarus/layout/plugin/baidu-analytics.ejs","hash":"7dbbea5722277e00a624c1796ec83d5f9c12d059","modified":1578125881333},{"_id":"themes/icarus/layout/plugin/baidu-analytics.locals.js","hash":"c02eb152e6aff05833006e6edd32b74c1c4258c3","modified":1578125881333},{"_id":"themes/icarus/layout/plugin/busuanzi.ejs","hash":"4285b0ae608c7c54e4ecbebb6d22d4cd1be28f70","modified":1578125881333},{"_id":"themes/icarus/layout/plugin/busuanzi.locals.js","hash":"ec80bcfa4c1302c04130a746df4b1298d117de0b","modified":1578125881333},{"_id":"themes/icarus/layout/plugin/gallery.ejs","hash":"7d19b7a5713d08a614578f079f1327a651c472ae","modified":1578125881334},{"_id":"themes/icarus/layout/plugin/gallery.locals.js","hash":"037fb56dffc128d3a91c1cb8852998d9539d3fac","modified":1578125881334},{"_id":"themes/icarus/layout/plugin/google-analytics.ejs","hash":"13b298b0026bfc7bcb6a47b6c795fe15cc4584fc","modified":1578125881334},{"_id":"themes/icarus/layout/plugin/google-analytics.locals.js","hash":"c02eb152e6aff05833006e6edd32b74c1c4258c3","modified":1578125881334},{"_id":"themes/icarus/layout/plugin/hotjar.ejs","hash":"6df0d8f77ed39e4d32c78177844115e31bf3a776","modified":1578125881334},{"_id":"themes/icarus/layout/plugin/hotjar.locals.js","hash":"9258fc2af057d2545a43fae54790743b63450378","modified":1578125881334},{"_id":"themes/icarus/layout/plugin/mathjax.ejs","hash":"dddb6f37487286fe2080118bcbb4a8d82dc84d5e","modified":1578125881334},{"_id":"themes/icarus/layout/plugin/mathjax.locals.js","hash":"7faa26fa6da6a93dc3f7fdcf5a784d1f8825b031","modified":1578125881334},{"_id":"themes/icarus/layout/plugin/outdated-browser.ejs","hash":"1437d1ac085a8110e61317254f6c0a034121bc39","modified":1578125881335},{"_id":"themes/icarus/layout/plugin/outdated-browser.locals.js","hash":"037fb56dffc128d3a91c1cb8852998d9539d3fac","modified":1578125881335},{"_id":"themes/icarus/layout/plugin/progressbar.ejs","hash":"34423f74787cc9d67b2598dd69b07c84d5bf2280","modified":1578125881335},{"_id":"themes/icarus/layout/plugin/progressbar.locals.js","hash":"ec80bcfa4c1302c04130a746df4b1298d117de0b","modified":1578125881335},{"_id":"themes/icarus/layout/search/baidu.ejs","hash":"850aa91778100d693a52b10eaa8586c8e3215ee6","modified":1578125881335},{"_id":"themes/icarus/layout/search/baidu.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881335},{"_id":"themes/icarus/layout/search/google-cse.ejs","hash":"4b881a99325a6a0cebf97ac53e09d8fc67f87d29","modified":1578125881335},{"_id":"themes/icarus/layout/search/google-cse.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881336},{"_id":"themes/icarus/layout/search/insight.ejs","hash":"9a27db2a007582ceee7ca4b1eebddbd456893568","modified":1578125881336},{"_id":"themes/icarus/layout/search/insight.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881336},{"_id":"themes/icarus/layout/share/addthis.ejs","hash":"f1c5f337333009d5f00dfbac4864a16ef8f9cb8d","modified":1578125881336},{"_id":"themes/icarus/layout/share/addthis.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881336},{"_id":"themes/icarus/layout/share/addtoany.ejs","hash":"95d3bc1a841bd934b1ae9209ad1af74e743ecb10","modified":1578125881336},{"_id":"themes/icarus/layout/share/addtoany.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881337},{"_id":"themes/icarus/layout/share/bdshare.ejs","hash":"f14c8084b7ee16a091f0bd2ae9039e3bfff7e7b7","modified":1578125881337},{"_id":"themes/icarus/layout/share/bdshare.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881337},{"_id":"themes/icarus/layout/share/sharejs.ejs","hash":"65d08316cc479910ea4f526cd1c299d0104daf7f","modified":1578125881337},{"_id":"themes/icarus/layout/share/sharejs.locals.js","hash":"11976fd4cfed1044be29b476b34c33175c9b4308","modified":1578125881337},{"_id":"themes/icarus/layout/share/sharethis.ejs","hash":"4f2c40f790f3be0a4e79db04f02ea41ba2f4d4c0","modified":1578125881337},{"_id":"themes/icarus/layout/share/sharethis.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881337},{"_id":"themes/icarus/layout/widget/archive.ejs","hash":"eb738a2ac2935ce7a542964d90088613b281dd15","modified":1578125881338},{"_id":"themes/icarus/layout/widget/archive.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881338},{"_id":"themes/icarus/layout/widget/category.ejs","hash":"17e58e537645c4434a1140377ae3e7f43cca4927","modified":1578125881338},{"_id":"themes/icarus/layout/widget/category.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881338},{"_id":"themes/icarus/layout/widget/links.ejs","hash":"bb6510193632413e83227bdffad7c3b37629dcde","modified":1578125881338},{"_id":"themes/icarus/layout/widget/links.locals.js","hash":"872cf1a18e152361f5739c6d5fecc0bf46d59513","modified":1578125881338},{"_id":"themes/icarus/layout/widget/profile.ejs","hash":"b5dfd0db3851bf046f28431c9f2adcecc1e7b1df","modified":1578125881338},{"_id":"themes/icarus/layout/widget/profile.locals.js","hash":"9a43112ac0a58df98bb418563ec04558023e1fae","modified":1578125881339},{"_id":"themes/icarus/layout/widget/recent_posts.ejs","hash":"14a2f4587831e017b93818c06dbe18a7e8a27c1e","modified":1578125881339},{"_id":"themes/icarus/layout/widget/recent_posts.locals.js","hash":"5065aca74ec2c98ec88994636fee8408f769c5f2","modified":1578125881339},{"_id":"themes/icarus/layout/widget/subscribe_email.ejs","hash":"391622e9c1d17bf79180faa617ed8c1ee1871a87","modified":1578125881339},{"_id":"themes/icarus/layout/widget/subscribe_email.locals.js","hash":"aae87fbdb7a1245a0fc0637225a935fc39836916","modified":1578125881339},{"_id":"themes/icarus/layout/widget/tag.ejs","hash":"e41aff420cc4ea1c454de49bd8af0e7a93f3db3f","modified":1578125881339},{"_id":"themes/icarus/layout/widget/tagcloud.ejs","hash":"26fa17afaf0cb345a213816c44c39575a66759ba","modified":1578125881339},{"_id":"themes/icarus/layout/widget/tagcloud.locals.js","hash":"093f59d2f43e7ffa47bee79da15f98705300dfba","modified":1578125881340},{"_id":"themes/icarus/layout/widget/toc.ejs","hash":"e800b4b38eab716882389a09527e9f59a189dea6","modified":1578125881340},{"_id":"themes/icarus/layout/widget/toc.locals.js","hash":"e730a7fff2717f17741540e5ed77b89e289fdeab","modified":1578125881340},{"_id":"themes/icarus/source/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1578125881340},{"_id":"themes/icarus/source/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1578125881341},{"_id":"themes/icarus/source/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1578125881341},{"_id":"themes/icarus/source/css/search.css","hash":"d6a59894819e7431d42b249b6c2fc9ff3b99a488","modified":1578125881341},{"_id":"themes/icarus/source/css/style.styl","hash":"78fd2c55dc8a6b7197cabeb54ff503d081beee98","modified":1578125881341},{"_id":"themes/icarus/source/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1578125881342},{"_id":"themes/icarus/source/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1578125881342},{"_id":"themes/icarus/source/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1578125881343},{"_id":"themes/icarus/source/js/gallery.js","hash":"bb74e694457dc23b83ac80cf5aadcd26b60469fd","modified":1578125881343},{"_id":"themes/icarus/source/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1578125881343},{"_id":"themes/icarus/source/js/main.js","hash":"9d58a64d1168ef3ab7f498f2e8b4f53fb23db462","modified":1578125881343},{"_id":"source/img/LLVM循环优化/interchange.png","hash":"80e562cb03f41f291b3cb7fc89fc4f4eecb88164","modified":1578125776926},{"_id":"source/img/LLVM循环优化/noreduce.png","hash":"3d5557d2d6790585badd3104d311f9d95223b58c","modified":1578125776928},{"_id":"source/img/LLVM循环优化/nounswitch.jpg","hash":"6a24604581b153e855b59ff0daee9d1ec7df4ab5","modified":1578125776929},{"_id":"source/img/LoopUnrolling/asm_0.png","hash":"dfdac2f9735d60121444be4a7d7febaa1bb6c5e0","modified":1578125776930},{"_id":"source/img/LoopUnrolling/dmissw.png","hash":"13fda4be63e688bb5b0d4e3cc855153502b47970","modified":1578125776931},{"_id":"source/img/LoopUnrolling/imissw.png","hash":"69d1ce53a2729df686d79fe31e457408ce591d3f","modified":1578125776933},{"_id":"source/img/LoopUnrolling/dump.png","hash":"d66e81100ebde290febf9e3ad5a1952c96b3df53","modified":1578125776932},{"_id":"source/img/LoopUnrolling/imisswo.png","hash":"2324e83b5e03750697dea598c256323c70566057","modified":1578125776933},{"_id":"source/img/LoopUnrolling/ll0.png","hash":"515623982f9644f457a5c5f6056615650d37fd58","modified":1578125776933},{"_id":"source/img/iOS手势学习笔记/stateMachine.png","hash":"06d0074f81cd869835befd1ed6086d454fc55af1","modified":1578125776988},{"_id":"source/img/内存管理与多线程/dispatch.png","hash":"a3834c4d4df7b5b0af005d17dd242e9d542e8e11","modified":1578125777008},{"_id":"themes/icarus/source/images/icon.jpg","hash":"672bb35c59cf474d449f87db8361c3b6202b8586","modified":1578127175000},{"_id":"source/img/LLVM循环优化/interchange_cache.png","hash":"e7a9c6ab3e2018cc425aa42ddf5c26cac5cd2b7a","modified":1578125776927},{"_id":"source/img/LLVM循环优化/no_interchange_cache.png","hash":"a7e181870d3b39ba8aca7a6c7b69bb4d9517a99c","modified":1578125776927},{"_id":"source/img/左滑删除图片/leftswipe.PNG","hash":"3d24997669fd29ad73b16d7cd9ad083541813c02","modified":1578125777018},{"_id":"source/img/蓝牙测距/screenshot1.PNG","hash":"a6861399c38118690d1af134ded2cb01c829e0c5","modified":1578125777021},{"_id":"source/img/蓝牙测距/screenshot2.PNG","hash":"4f2d14a45147e39e5f10e26068d5b544397a8728","modified":1578125777021},{"_id":"source/img/蓝牙测距/原理图.png","hash":"22cbba96378cbcc0af403b11fb4f89819dc9c061","modified":1578125777022},{"_id":"source/img/JS调用Swift卡顿/screenshot.png","hash":"b284eff003a55f766185c0153be0a4306a64bd7c","modified":1578125776925},{"_id":"source/img/LoopUnrolling/pipewo.png","hash":"89ae9ccb021c5a520a33777a182e812f28cd1546","modified":1578125776938},{"_id":"source/img/RunLoop/tsd.png","hash":"36952f20f5b3683a93c545a6a9b95ebad40b8f5c","modified":1578125776961},{"_id":"source/img/LoopUnrolling/ll3.png","hash":"35907b752d8c8e5b64ab672727e29eca755a3915","modified":1578125776935},{"_id":"source/img/bubble_rebound/bb1.png","hash":"9b24bdc2364493a478f409a216df372e7effe10a","modified":1578125776968},{"_id":"source/img/使用gperftools/screenshot.png","hash":"7d7a1804aceaaeb9fef496d901a9708d19a2fb7c","modified":1578125777008},{"_id":"source/img/静默推送/knuff.png","hash":"6ef5771b98e1419d5bb13fbb1bfbd989caa3840c","modified":1578125777045},{"_id":"source/img/LoopUnrolling/pipew.png","hash":"db72e1f9222a1648f8653869eb91456a629fd029","modified":1578125776936},{"_id":"source/img/左滑删除图片/hierarchy.png","hash":"cd9e891c8982cf00fee75ff6eb942188387f398b","modified":1578125777017},{"_id":"source/img/内存管理与多线程/zone.jpg","hash":"a64eef4a7d7f1cfb843842a99c4f5ae43a405e10","modified":1578125777014},{"_id":"source/img/内存管理与多线程/thread.JPG","hash":"c9184820dd2078132de9794006a427d62af693bf","modified":1578125777011},{"_id":"source/img/蓝牙测距/photo.jpg","hash":"f51d8ef4b56986190ae4c74fe540336364296ffa","modified":1578125777020},{"_id":"source/img/ObjC-运行时系统/method.JPG","hash":"15d73af91be7f923116af237373f1a3fd2958507","modified":1578125776940},{"_id":"source/img/静默推送/p12.png","hash":"715c44fe8defd25e2b47354e2950052dd6955ece","modified":1578125777047},{"_id":"source/img/layoutStudy/twoViews.gif","hash":"575dcfe96111da01fbc9ad11ab1e810c0583972a","modified":1578125777006},{"_id":"source/img/Pluto/wire.JPG","hash":"b3b66ad232408284beadb86efda0e503b6a305c1","modified":1578125776958},{"_id":"source/img/Pluto/overview.JPG","hash":"b1ffb92e1164d62df042c60995900464d4050a04","modified":1578125776947},{"_id":"source/img/Pluto/sketch.JPG","hash":"f2721690e2e01c0939f4702212a1258caab5fcbf","modified":1578125776953},{"_id":"source/img/arduinoWithBluetooth.JPG","hash":"028da2ad4586aa261c3c830270b67bf813a42832","modified":1578125776966},{"_id":"source/img/layoutStudy/screen.gif","hash":"ea9affa59eab406ee15e393c7b285448cec322a1","modified":1578125777001},{"_id":"source/img/限定ScrollView允许滑动角度/scroll.gif","hash":"1e6987e3d324916865146390aa1118157cbb48a6","modified":1578125777043},{"_id":"source/img/iOS动画学习笔记/screenshot.gif","hash":"ab1e722cd756d3d3e179d01f45c8565078e9fe9f","modified":1578125776987},{"_id":"public/content.json","hash":"60634fa803ddb074709662fbf4f2f8dfad2533c5","modified":1578127996837},{"_id":"public/about/index.html","hash":"281d1db5dc2f2820a24bbe8897265f69c592463f","modified":1578130075880},{"_id":"public/contact/index.html","hash":"81ee6ead4bb9a62145e4756e6af7133ae5b22e45","modified":1578130075880},{"_id":"public/2019/12/23/RunLoop原理/index.html","hash":"cbac5201affb0c50e6c50c91321e634da8812d83","modified":1578130075880},{"_id":"public/2019/09/18/what-are-dynamic-libraries/index.html","hash":"d2d8f5912f09654b4701dc9ccac37687f4185328","modified":1578130075880},{"_id":"public/2019/04/27/LLVM循环优化/index.html","hash":"261bb4bdff4b30648de404d57058d8afe5aacdf7","modified":1578130075881},{"_id":"public/2019/04/22/WiFi监听UDP包/index.html","hash":"2ff0b19d1eaffbc1e972fcd5fbed0a4f89222ce9","modified":1578130075881},{"_id":"public/2019/03/26/LoopUnrolling优化效果对比/index.html","hash":"c9ea81e8c52c0173b03c53fe2c693ea353a8e8eb","modified":1578130075881},{"_id":"public/2019/03/23/Linux下使用gperftools/index.html","hash":"c6d85c34f715ab5b1d63cd8cfa90a325a1657f94","modified":1578130075881},{"_id":"public/2019/03/03/在macOS下安装gem5模拟器/index.html","hash":"d0b767255818017bd7180a134a50b7bd14ca6a04","modified":1578130075881},{"_id":"public/2019/02/15/JS调用Swift造成卡顿问题/index.html","hash":"84dedb26ce21cb1072671ea7c14301d051d39ab9","modified":1578130075881},{"_id":"public/2019/02/10/调试JSCore小技巧/index.html","hash":"36239b80a8d25d4ee7cbb3ffb6099c9cd80bd404","modified":1578130075881},{"_id":"public/2019/02/09/RaspberryPi3B-安装UbuntuMATE/index.html","hash":"99f007c3b60e341336b22234d8530f11175dff4b","modified":1578130075881},{"_id":"public/2019/02/07/C语言extern关键字/index.html","hash":"0c409c4ad84f0421db7b5f4549b6db6d28bd0fb4","modified":1578130075881},{"_id":"public/2018/12/12/Python-import-崩溃问题/index.html","hash":"fe31830fd7880eba657f01a454a7d77e9c5dd102","modified":1578130075881},{"_id":"public/2018/11/10/V-REP实现Bubble-Rebound算法/index.html","hash":"a0c4a215576807290ca184ade83be2d26e197996","modified":1578130075882},{"_id":"public/2018/08/08/iOS静默推送/index.html","hash":"d1a6cc476cd8503b0a6a0444cd2f5aa64c99115e","modified":1578130075882},{"_id":"public/2018/07/26/JavaScript基础分享/index.html","hash":"9043c0bbacf20339f16fa345565240c044b526bb","modified":1578130075882},{"_id":"public/2018/07/20/iOS图片裁剪旋转格式转换/index.html","hash":"10a022da0b87b3451785c958d64747198e0a6ba0","modified":1578130075882},{"_id":"public/2018/07/13/解决Unacceptable-Content-Type/index.html","hash":"d894927173a24daecbe4e9ff5049e5de9d673a92","modified":1578130075882},{"_id":"public/2018/07/13/AFNetworking设置HTTP-Header-Body/index.html","hash":"516c62272bca7e660d936014821c35558fba6d01","modified":1578130075882},{"_id":"public/2018/07/11/Flutter-for-iOS-dev-翻译/index.html","hash":"38f5fc73c0a8bee09e948283f488b9ebdd99d937","modified":1578130075882},{"_id":"public/2018/06/15/让Xcode控制台打印彩色文字/index.html","hash":"8c894bf38048157cec0084846ef3fa6ecb419978","modified":1578130075882},{"_id":"public/2018/05/28/iOS动画学习笔记/index.html","hash":"64b1fd164ca2965a8cfe191f23064099ef1f74d5","modified":1578130075882},{"_id":"public/2018/05/25/macOS上运行其他程序并获取实时输出/index.html","hash":"bb5205083b3c8ef2c07d8f4913a8d41816d3d11a","modified":1578130075883},{"_id":"public/2018/05/23/iOS手势学习笔记/index.html","hash":"4697321dbc49104e94284988a062fa6f21512d54","modified":1578130075883},{"_id":"public/2018/05/20/Promise是什么/index.html","hash":"2e744a1b4811e8660aca58759283e1f1bc6a728c","modified":1578130075883},{"_id":"public/2018/05/16/设计模式-创建型模式/index.html","hash":"152c08b95f956ee1aea4a77e876ee78e7031e882","modified":1578130075883},{"_id":"public/2018/05/02/iOS-Layout学习笔记/index.html","hash":"96c575406e8717a0184e5e7cb5ceca37f8d90adb","modified":1578130075883},{"_id":"public/2018/04/27/解决Leak分析闪退问题/index.html","hash":"6ec3a67e11e5cbf8d6a62d1ea1e220055e89cb97","modified":1578130075883},{"_id":"public/2018/04/14/iOS多线程学习笔记/index.html","hash":"e71e937993a721bbb54eae9ae753939bb47d00a4","modified":1578130075883},{"_id":"public/2018/04/07/Obj-C键值编程/index.html","hash":"d7566b06f330b6a92241f9f8c9b82f500f3082ef","modified":1578130075883},{"_id":"public/2018/04/02/Obj-C运行时系统/index.html","hash":"e02a552d2774aa8eb1efbb01122f22685e1227d2","modified":1578130075883},{"_id":"public/2018/04/01/Obj-C内存管理细节和多线程/index.html","hash":"0fa1b1836fde2b8182f3ae5315dedb4827a23348","modified":1578130075883},{"_id":"public/2018/03/27/阿里一面凉了之旅/index.html","hash":"002badb1643443cf1f6e0cc36cfa981044bb8fbe","modified":1578130075883},{"_id":"public/2018/03/25/动态规划法/index.html","hash":"ff4eecb9d9b1f805353a9a7b6beeec2170cfd3d5","modified":1578130075883},{"_id":"public/2018/03/18/Swift-Tips/index.html","hash":"cfe38eeb8d45138fbd16bc8e854bc58267e3b082","modified":1578130075884},{"_id":"public/2018/02/28/Obj-C内存管理/index.html","hash":"89f985beeea8763ca94548495c652cff25f8121a","modified":1578130075884},{"_id":"public/2018/02/15/Java以空格分割字符串/index.html","hash":"a2944163707ec80e2d28342d861a428894403e10","modified":1578130075884},{"_id":"public/2018/01/29/使用PlutoSDR构建简易通信系统/index.html","hash":"aeb4161d0ce13b8fe748dafc51377304e03833ed","modified":1578130075884},{"_id":"public/2017/12/31/SQLite使用/index.html","hash":"c9f4f704f42d3276ad32a75a25d17405ac811640","modified":1578130075886},{"_id":"public/2017/12/23/Swift集成友盟数据统计/index.html","hash":"0567b354d61a9a7fbe5bc837975279119b63e0d1","modified":1578130075887},{"_id":"public/2017/11/18/iOS-为TableView左滑删除添加图片/index.html","hash":"24cb444a48d100210341f1496d8eefae5a6a78fd","modified":1578130075887},{"_id":"public/2017/11/13/iOS限制UIScrollView允许滑动角度/index.html","hash":"de963462664ab4632eac28763643b67b1b5c5443","modified":1578130075887},{"_id":"public/2017/10/08/Swift4新特性/index.html","hash":"1c672ee339fb88abe85a9d5f4a387441937ed352","modified":1578130075887},{"_id":"public/2017/09/02/iOS-自定义TabBar的正确姿势/index.html","hash":"f1893394c1bdd2dd4c24c53d5deaec21f9da68c2","modified":1578130075889},{"_id":"public/2017/08/01/用Swift写算法-高等排序/index.html","hash":"83acb2af3bce01a7a49e0c1fb478a7afe741a099","modified":1578130075889},{"_id":"public/2017/07/30/iOS蓝牙开发-超声波测距仪/index.html","hash":"30c045a071d7a3c97d304b26c83a2b3281201408","modified":1578130075889},{"_id":"public/2017/07/14/用Swift写算法-递归和分治法/index.html","hash":"5c58a1fc4b6d58adb24d9a363734ebf2b846fe10","modified":1578130075889},{"_id":"public/2017/07/12/用Swift写算法-搜索/index.html","hash":"e6213491411923122d6571bb9758ba3aabaef029","modified":1578130075889},{"_id":"public/2017/07/11/用Swift写算法-初等排序/index.html","hash":"f7c2c0233bb893f4cda0ad47d9a005da3145c16e","modified":1578130075889},{"_id":"public/2017/07/04/iOS-蓝牙开发初步/index.html","hash":"96f2130ff65f8fc81b05d0e3d1a16fb2ad3f9e7c","modified":1578130075890},{"_id":"public/2017/06/23/Swift-多线程/index.html","hash":"5dcc409f5fc6bd8b425b8d2144e9742a493d18f3","modified":1578130075890},{"_id":"public/2017/06/04/iOS-核心动画/index.html","hash":"840817cabcc6376a891493e52eb8ac31c1d61624","modified":1578130075890},{"_id":"public/2017/04/25/iOS-布局与自动布局/index.html","hash":"e8bead8fff2b7b56a15e87f610cc82c8c8ee498e","modified":1578130075890},{"_id":"public/index.html","hash":"6076d16e58a720d1bf46d1260ca0c40923f979ea","modified":1578130075897},{"_id":"public/page/2/index.html","hash":"651bda38f884023bc5b5908b4e2935fd34a37cd8","modified":1578130075897},{"_id":"public/page/3/index.html","hash":"ca5bffe52470284ab47d8702be3271d817f4ec34","modified":1578130075898},{"_id":"public/page/4/index.html","hash":"4997a8b889fab7c753901cd9aae8926f860514fe","modified":1578130075898},{"_id":"public/page/5/index.html","hash":"d8f830c2f35bffbbed6878b31675e6dfa36059b3","modified":1578130075898},{"_id":"public/page/6/index.html","hash":"7775648c562d2332959314cde72f8e34ce890826","modified":1578130075898},{"_id":"public/archives/index.html","hash":"747354d1cf8dc0ae8dcab108a7b4a3252fce9b7e","modified":1578130075890},{"_id":"public/archives/page/2/index.html","hash":"e785919b2a72fbd40cc1fc0f4cc06c1ed44c8461","modified":1578130075890},{"_id":"public/archives/page/3/index.html","hash":"135a3980bdb0962608ca42d907a60be183edc97b","modified":1578130075890},{"_id":"public/archives/page/4/index.html","hash":"c871c28a8a2be94ab7dd3287c9f43d9f6ac2b83f","modified":1578130075890},{"_id":"public/archives/page/5/index.html","hash":"1d2382aab089ebc6a30b200f2baf9f8a79a7b1fd","modified":1578130075890},{"_id":"public/archives/page/6/index.html","hash":"1c6d12d8573c3c35b9c7c5f4d0caf1a8bc11f5ac","modified":1578130075891},{"_id":"public/archives/2017/index.html","hash":"890b590dda2b7c0b176123e9a2204800182f3ac4","modified":1578130075891},{"_id":"public/archives/2017/page/2/index.html","hash":"f041b4453f290351f061a704166fd56a33f64c90","modified":1578130075891},{"_id":"public/archives/2017/04/index.html","hash":"9f97ea801b13d16639e035ef4890d70310772da7","modified":1578130075891},{"_id":"public/archives/2017/06/index.html","hash":"8e170cd58bfda60a6632087939c9a5927f91334c","modified":1578130075891},{"_id":"public/archives/2017/07/index.html","hash":"8a470060312afbda9b0c37e02c843f21289238b8","modified":1578130075891},{"_id":"public/archives/2017/08/index.html","hash":"020b0741679eeaed580d9d823b8c3b4f36f2114e","modified":1578130075891},{"_id":"public/archives/2017/09/index.html","hash":"1e6d8f7adac3a8aea28a32d735a6be038c9af440","modified":1578130075891},{"_id":"public/archives/2017/10/index.html","hash":"da0792ec9111f2a62fda0732aa0f490aef6396d5","modified":1578130075891},{"_id":"public/archives/2017/11/index.html","hash":"be994956ec6877553bf0575e8c9f0cfc575dce15","modified":1578130075891},{"_id":"public/archives/2017/12/index.html","hash":"c002302c712816f6b81e53e3a85f3465e072d34e","modified":1578130075891},{"_id":"public/archives/2018/index.html","hash":"632144c61c98f65e0e6cd7bf4af6e04c64b68095","modified":1578130075892},{"_id":"public/archives/2018/page/2/index.html","hash":"ea06e2bb10caf7a615bc4b07beb27b8c537985e1","modified":1578130075892},{"_id":"public/archives/2018/page/3/index.html","hash":"b0c8e219d31de607485a5d172463cf7f4052e87c","modified":1578130075892},{"_id":"public/archives/2018/01/index.html","hash":"f0c551778b7a61ce8bd47c423a139edf6afcc98a","modified":1578130075892},{"_id":"public/archives/2018/02/index.html","hash":"981930c67745e475d77465b47ab26f69261ef131","modified":1578130075892},{"_id":"public/archives/2018/03/index.html","hash":"273dd6ac266a05c024b03d9a1ecd02596085e440","modified":1578130075892},{"_id":"public/archives/2018/04/index.html","hash":"c5ea2dbb9750e8d4927a703ffec0543882dcf4dd","modified":1578130075892},{"_id":"public/archives/2018/05/index.html","hash":"1afdd11a1720ece389ea302fee43bac1e2898c80","modified":1578130075892},{"_id":"public/archives/2018/06/index.html","hash":"caaa75770b7541cc7d8c53f3d6cbd897d861ce1d","modified":1578130075892},{"_id":"public/archives/2018/07/index.html","hash":"6bd8005e6371211230d7219a1ebccbb77e1a9823","modified":1578130075892},{"_id":"public/archives/2018/08/index.html","hash":"3f027ac9298686815d2866059320a8c679171007","modified":1578130075892},{"_id":"public/archives/2018/11/index.html","hash":"952f2ba47e9416b1c2f9b9713827dcd12f488c97","modified":1578130075893},{"_id":"public/archives/2018/12/index.html","hash":"5f38da75da29b231fac50721135c11926095e274","modified":1578130075893},{"_id":"public/archives/2019/index.html","hash":"456b774bb9a7f8b0152a31145a4b8f85e801ed8b","modified":1578130075893},{"_id":"public/archives/2019/page/2/index.html","hash":"2563d1c644ecb8a02ba8deeaa0cd21a8893b5797","modified":1578130075893},{"_id":"public/archives/2019/02/index.html","hash":"9f708161c16671b2e9574686bc550bf07fdc4f42","modified":1578130075893},{"_id":"public/archives/2019/03/index.html","hash":"8e8674052ec2c4bcc75e2a8a17bceed9fe9569f1","modified":1578130075893},{"_id":"public/archives/2019/04/index.html","hash":"1f6b71e69a3054351cae2672220ec1d08338f431","modified":1578130075893},{"_id":"public/archives/2019/09/index.html","hash":"8832f23a504e5e8bc0beee6fd257883ef38bc7c3","modified":1578130075893},{"_id":"public/archives/2019/12/index.html","hash":"3c5401dfb6412514ff91ee7b265024e5ac6a6c14","modified":1578130075893},{"_id":"public/tags/C-C/index.html","hash":"1c760314743efc15a10e47194f9a047e20e52a9c","modified":1578130075893},{"_id":"public/tags/AFNetworking/index.html","hash":"ac5baedfdca60bb76fd41225ea0f7b7fcf06b4da","modified":1578130075893},{"_id":"public/tags/Java/index.html","hash":"f578dcf24215dae7a7c0d9629541983c0def2713","modified":1578130075893},{"_id":"public/tags/Computer-Organization/index.html","hash":"e3e3e274bc53aa520329c8dbe7e8f5d34b5a2a50","modified":1578130075894},{"_id":"public/tags/Obj-C/index.html","hash":"b121fcda5d8997658f6e0f99adcaa66fd5932c81","modified":1578130075894},{"_id":"public/tags/perf/index.html","hash":"f16b46ed498bafa4b12b2a1c7190523f5c016b15","modified":1578130075894},{"_id":"public/tags/RaspberryPi/index.html","hash":"9b2d985265c91bdeb6af17427ae3e11a31cd19b8","modified":1578130075894},{"_id":"public/tags/SQLite/index.html","hash":"550975c481528566bba7d45f40ba3ad27de73ab1","modified":1578130075894},{"_id":"public/tags/Swift/index.html","hash":"1d45f02783a2117cd4fd5c3eb5cc58eddece4c32","modified":1578130075894},{"_id":"public/tags/network/index.html","hash":"68f5d009885a9e39ac1d1c06dd56279fcf86f0d3","modified":1578130075894},{"_id":"public/tags/Robotics/index.html","hash":"9badf38444463f8698ac59b22e956fe2b29f322b","modified":1578130075894},{"_id":"public/tags/UITableView/index.html","hash":"8e70342a2d380eb5be457a8b2497deefcaa9c672","modified":1578130075894},{"_id":"public/tags/CoreAnimation/index.html","hash":"38618e1f163b7b716e37621671828c7dcc733701","modified":1578130075894},{"_id":"public/tags/手势冲突/index.html","hash":"3aafaec2ad4df11855ccfa8ae79193fe3fc91099","modified":1578130075894},{"_id":"public/tags/CoreBluetooth/index.html","hash":"4a630e73d6bd9484f96ad500958f58b6a228daf7","modified":1578130075895},{"_id":"public/tags/Push/index.html","hash":"ea4d3dc270c32b28f75363aa79e6d8f21057aee5","modified":1578130075895},{"_id":"public/tags/dyld/index.html","hash":"9da5f84bf89328fc3c6728e77253b42101f1db01","modified":1578130075895},{"_id":"public/tags/macOS/index.html","hash":"74598452dda2edef1d1e2909b1ca601ac6ec322f","modified":1578130075895},{"_id":"public/tags/Algorithm/index.html","hash":"8e5db53484dff4342326c835312adbfe38484875","modified":1578130075895},{"_id":"public/tags/gem5/index.html","hash":"5a80f6d636ec54f38ff166860e6d7b1cf18ad8a6","modified":1578130075896},{"_id":"public/tags/Instruments/index.html","hash":"0191ad62c9d140e7f7c4142c47ed288d6f2e3a70","modified":1578130075896},{"_id":"public/tags/Xcode/index.html","hash":"b6da441af46af30819ab85a2df4c222d89b3abdf","modified":1578130075896},{"_id":"public/tags/DesignPattern/index.html","hash":"dba8a53f401bb6c035b4b99c449d4cbd8814ecba","modified":1578130075896},{"_id":"public/tags/JSCore/index.html","hash":"0818446daa61f3316624c2ade5cd102142fe92c2","modified":1578130075896},{"_id":"public/tags/Interview/index.html","hash":"a91d7c94afa36988c52f9f3cb71417857b41fe13","modified":1578130075896},{"_id":"public/tags/JavaScript/index.html","hash":"62aec5dfdd1d2840cbfa86f1dab2ed8af1a365de","modified":1578130075896},{"_id":"public/tags/Promise/index.html","hash":"2a1221a221d6c52d5ed88a5f3dd1691a1546777a","modified":1578130075896},{"_id":"public/tags/RunLoop/index.html","hash":"c69e3cc124c398b2c63ba54792ceefd0a975dbab","modified":1578130075896},{"_id":"public/tags/MultiThreading/index.html","hash":"83bd3f35302b19c90eb1e83299428b9650d4b892","modified":1578130075897},{"_id":"public/tags/Layout/index.html","hash":"2f878ef0918304611b670c8a69339a5712d189ab","modified":1578130075897},{"_id":"public/tags/AutoLayout/index.html","hash":"56c2d62255d649f39906b8882ccf79997b2410c1","modified":1578130075897},{"_id":"public/tags/Animation/index.html","hash":"cf2a4dc30c90cd83435d551098f14ae7fe44074f","modified":1578130075897},{"_id":"public/tags/Gesture/index.html","hash":"e90486440f1f331047b744a3fd13153ae2393db8","modified":1578130075897},{"_id":"public/tags/iOS/index.html","hash":"2c0e8546e92c6459f05ad9996bdb2f8ac92e9fd2","modified":1578130075897},{"_id":"public/tags/PlutoSDR/index.html","hash":"417c4e8ac26143003e43dfba7c9e6a275311afce","modified":1578130075897},{"_id":"public/tags/Flutter/index.html","hash":"b142407dcb94d64fadc8589b6120c44ecb96d9cd","modified":1578130075897},{"_id":"public/categories/index.html","hash":"4ffe03a2210e0822e6350a36312395a15d5b3d7b","modified":1578130075898},{"_id":"public/tags/index.html","hash":"a596ae0dc447b5d373b3bff4f1a869351d2c32a6","modified":1578130075898},{"_id":"public/CNAME","hash":"254ed15c4ffe0599aa053615f1e051bc2fe9a9ab","modified":1578127997713},{"_id":"public/img/CBDevices1_2x.png","hash":"565f6c331c58976d4b628474134cc626fb494328","modified":1578127997713},{"_id":"public/img/TreeOfServicesAndCharacteristics_Remote_2x.png","hash":"63b10df6289146ee2f09120db866a221b7b71a59","modified":1578127997713},{"_id":"public/img/CBPeripheralData_Example_2x.png","hash":"de25cba0f873f7b262c8900cff2c946cb19a8b2d","modified":1578127997713},{"_id":"public/img/screenshotBluetooth.png","hash":"13e184281eb98179e09f5fd41b9edf03f31523da","modified":1578127997713},{"_id":"public/img/LLVM循环优化/nointerchange.jpg","hash":"2c1fa0ed9aa54975f407f465aa4a29422ab89c44","modified":1578127997713},{"_id":"public/img/LoopUnrolling/unrolling_vs.png","hash":"2fb1958d53aac592f0a5aa0d7d25c5c0b69fd87e","modified":1578127997713},{"_id":"public/img/LLVM循环优化/reduce.png","hash":"1614f6c227410155218d300e9858bf5b2948be7e","modified":1578127997713},{"_id":"public/img/LLVM循环优化/unswitch.jpg","hash":"769e23ecd6333913c724887a9ef2ad16cf138372","modified":1578127997714},{"_id":"public/img/Pluto/console2.PNG","hash":"c7cdfc37226dde133fc4f598f5322b92b9861ef5","modified":1578127997714},{"_id":"public/img/Pluto/logo.png","hash":"0bf22da57033f6d77ced7fbd2a9c40739ddec0e6","modified":1578127997714},{"_id":"public/img/Swift4新特性/substring.png","hash":"e57585629f57482590b637bffd89177a2d41202c","modified":1578127997714},{"_id":"public/img/Pluto/console1.PNG","hash":"c1db43729c62b992a849ca3b74ed85dc35edd3db","modified":1578127997714},{"_id":"public/img/LoopUnrolling/dmisswo.png","hash":"c55666c5ab2260c9b3ab9d7bc321c7e8762614f6","modified":1578127997714},{"_id":"public/img/bubble_rebound/bb2.png","hash":"f0941c36766abd2496d982a88023c2db1de81a95","modified":1578127997714},{"_id":"public/img/layoutStudy/ios_screen_display.png","hash":"cefc4140b84e5a5dc99204175089f63381649ee0","modified":1578127997714},{"_id":"public/images/thumbnail.svg","hash":"b9c58ff09ed415e6cf08b42b35faa2bc000d5059","modified":1578127997714},{"_id":"public/img/左滑删除图片/finish.png","hash":"499eedb0d0d1dadd86663e7267524786a673d82e","modified":1578127997714},{"_id":"public/img/LLVM循环优化/interchange.png","hash":"80e562cb03f41f291b3cb7fc89fc4f4eecb88164","modified":1578127997714},{"_id":"public/img/LoopUnrolling/imisswo.png","hash":"2324e83b5e03750697dea598c256323c70566057","modified":1578127997715},{"_id":"public/img/LoopUnrolling/ll0.png","hash":"515623982f9644f457a5c5f6056615650d37fd58","modified":1578127997715},{"_id":"public/img/LLVM循环优化/noreduce.png","hash":"3d5557d2d6790585badd3104d311f9d95223b58c","modified":1578127997722},{"_id":"public/img/LLVM循环优化/nounswitch.jpg","hash":"6a24604581b153e855b59ff0daee9d1ec7df4ab5","modified":1578127997722},{"_id":"public/img/LoopUnrolling/dmissw.png","hash":"13fda4be63e688bb5b0d4e3cc855153502b47970","modified":1578127997725},{"_id":"public/img/LoopUnrolling/asm_0.png","hash":"dfdac2f9735d60121444be4a7d7febaa1bb6c5e0","modified":1578127997725},{"_id":"public/img/LoopUnrolling/imissw.png","hash":"69d1ce53a2729df686d79fe31e457408ce591d3f","modified":1578127997725},{"_id":"public/img/LoopUnrolling/dump.png","hash":"d66e81100ebde290febf9e3ad5a1952c96b3df53","modified":1578127997725},{"_id":"public/img/iOS手势学习笔记/stateMachine.png","hash":"06d0074f81cd869835befd1ed6086d454fc55af1","modified":1578127997725},{"_id":"public/img/内存管理与多线程/dispatch.png","hash":"a3834c4d4df7b5b0af005d17dd242e9d542e8e11","modified":1578127997725},{"_id":"public/images/icon.jpg","hash":"672bb35c59cf474d449f87db8361c3b6202b8586","modified":1578127997726},{"_id":"public/img/蓝牙测距/原理图.png","hash":"22cbba96378cbcc0af403b11fb4f89819dc9c061","modified":1578127997726},{"_id":"public/img/蓝牙测距/screenshot2.PNG","hash":"4f2d14a45147e39e5f10e26068d5b544397a8728","modified":1578127997726},{"_id":"public/css/back-to-top.css","hash":"5805bee2445e997d64dfe526b08b5fe0bce357eb","modified":1578127997901},{"_id":"public/css/insight.css","hash":"22943a610d5cfffedfb823c692f4db2b1f37a4c9","modified":1578127997901},{"_id":"public/css/search.css","hash":"d6a59894819e7431d42b249b6c2fc9ff3b99a488","modified":1578127997901},{"_id":"public/js/back-to-top.js","hash":"b1dcf30577cefe833dc6151757c0a05ea5b5a643","modified":1578127997901},{"_id":"public/css/progressbar.css","hash":"bbc737b7a8feb19901e792c447a846273779d5c3","modified":1578127997901},{"_id":"public/js/animation.js","hash":"d744581909d2d092a584be07c39f9d3f0d009ec7","modified":1578127997903},{"_id":"public/js/main.js","hash":"9d58a64d1168ef3ab7f498f2e8b4f53fb23db462","modified":1578127997903},{"_id":"public/js/gallery.js","hash":"bb74e694457dc23b83ac80cf5aadcd26b60469fd","modified":1578127997903},{"_id":"public/img/蓝牙测距/screenshot1.PNG","hash":"a6861399c38118690d1af134ded2cb01c829e0c5","modified":1578127997903},{"_id":"public/img/LLVM循环优化/interchange_cache.png","hash":"e7a9c6ab3e2018cc425aa42ddf5c26cac5cd2b7a","modified":1578127997903},{"_id":"public/css/style.css","hash":"02934ca4cc3537b1fd5e6a08566ce25eca7dd44f","modified":1578127997909},{"_id":"public/js/insight.js","hash":"8ba56fd5e4232a05ccef5f8b733c7ecca0814633","modified":1578127997909},{"_id":"public/img/LLVM循环优化/no_interchange_cache.png","hash":"a7e181870d3b39ba8aca7a6c7b69bb4d9517a99c","modified":1578127997909},{"_id":"public/img/JS调用Swift卡顿/screenshot.png","hash":"b284eff003a55f766185c0153be0a4306a64bd7c","modified":1578127997909},{"_id":"public/img/RunLoop/tsd.png","hash":"36952f20f5b3683a93c545a6a9b95ebad40b8f5c","modified":1578127997909},{"_id":"public/img/bubble_rebound/bb1.png","hash":"9b24bdc2364493a478f409a216df372e7effe10a","modified":1578127997914},{"_id":"public/img/静默推送/knuff.png","hash":"6ef5771b98e1419d5bb13fbb1bfbd989caa3840c","modified":1578127997914},{"_id":"public/img/LoopUnrolling/pipew.png","hash":"db72e1f9222a1648f8653869eb91456a629fd029","modified":1578127997914},{"_id":"public/img/左滑删除图片/leftswipe.PNG","hash":"3d24997669fd29ad73b16d7cd9ad083541813c02","modified":1578127997917},{"_id":"public/img/LoopUnrolling/pipewo.png","hash":"89ae9ccb021c5a520a33777a182e812f28cd1546","modified":1578127997917},{"_id":"public/img/使用gperftools/screenshot.png","hash":"7d7a1804aceaaeb9fef496d901a9708d19a2fb7c","modified":1578127997917},{"_id":"public/img/LoopUnrolling/ll3.png","hash":"35907b752d8c8e5b64ab672727e29eca755a3915","modified":1578127997921},{"_id":"public/img/左滑删除图片/hierarchy.png","hash":"cd9e891c8982cf00fee75ff6eb942188387f398b","modified":1578127997922},{"_id":"public/img/ObjC-运行时系统/method.JPG","hash":"15d73af91be7f923116af237373f1a3fd2958507","modified":1578127997927},{"_id":"public/img/内存管理与多线程/thread.JPG","hash":"c9184820dd2078132de9794006a427d62af693bf","modified":1578127997929},{"_id":"public/img/蓝牙测距/photo.jpg","hash":"f51d8ef4b56986190ae4c74fe540336364296ffa","modified":1578127997930},{"_id":"public/img/内存管理与多线程/zone.jpg","hash":"a64eef4a7d7f1cfb843842a99c4f5ae43a405e10","modified":1578127997931},{"_id":"public/img/静默推送/p12.png","hash":"715c44fe8defd25e2b47354e2950052dd6955ece","modified":1578127997938},{"_id":"public/img/layoutStudy/twoViews.gif","hash":"575dcfe96111da01fbc9ad11ab1e810c0583972a","modified":1578127997951},{"_id":"public/img/Pluto/wire.JPG","hash":"b3b66ad232408284beadb86efda0e503b6a305c1","modified":1578127997953},{"_id":"public/img/Pluto/overview.JPG","hash":"b1ffb92e1164d62df042c60995900464d4050a04","modified":1578127997955},{"_id":"public/img/arduinoWithBluetooth.JPG","hash":"028da2ad4586aa261c3c830270b67bf813a42832","modified":1578127997957},{"_id":"public/img/Pluto/sketch.JPG","hash":"f2721690e2e01c0939f4702212a1258caab5fcbf","modified":1578127997959},{"_id":"public/img/layoutStudy/screen.gif","hash":"ea9affa59eab406ee15e393c7b285448cec322a1","modified":1578127997964},{"_id":"public/img/限定ScrollView允许滑动角度/scroll.gif","hash":"1e6987e3d324916865146390aa1118157cbb48a6","modified":1578127997990},{"_id":"public/img/iOS动画学习笔记/screenshot.gif","hash":"ab1e722cd756d3d3e179d01f45c8565078e9fe9f","modified":1578127997999},{"_id":"themes/icarus/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1578129670696}],"Category":[],"Data":[],"Page":[{"title":"About Me","icon":"fa-info-circle","_content":"\n# 关于\n\n欢迎访问我的个人网站。\n\nWelcome to my personal website for more information.\n\n[www.wangluyuan.cc](http://www.wangluyuan.cc)","source":"about/index.md","raw":"---\ntitle: About Me\nicon: fa-info-circle\n---\n\n# 关于\n\n欢迎访问我的个人网站。\n\nWelcome to my personal website for more information.\n\n[www.wangluyuan.cc](http://www.wangluyuan.cc)","date":"2020-01-04T08:16:16.923Z","updated":"2020-01-04T08:16:16.923Z","path":"about/index.html","comments":1,"layout":"page","_id":"ck4zcnv2h0000ljc37ocmo5li","content":"<h1 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h1><p>欢迎访问我的个人网站。</p>\n<p>Welcome to my personal website for more information.</p>\n<p><a href=\"http://www.wangluyuan.cc\">www.wangluyuan.cc</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于\"><a href=\"#关于\" class=\"headerlink\" title=\"关于\"></a>关于</h1><p>欢迎访问我的个人网站。</p>\n<p>Welcome to my personal website for more information.</p>\n<p><a href=\"http://www.wangluyuan.cc\">www.wangluyuan.cc</a></p>\n"},{"title":"Contact Me","icon":"fa-at","_content":"\n# 联系我\n\n欢迎通过电子邮箱与我取得联系。\n\n我的个人邮箱：\n\ne@wangluyuan.cc","source":"contact/index.md","raw":"---\ntitle: Contact Me\nicon: fa-at\n---\n\n# 联系我\n\n欢迎通过电子邮箱与我取得联系。\n\n我的个人邮箱：\n\ne@wangluyuan.cc","date":"2020-01-04T08:16:16.923Z","updated":"2020-01-04T08:16:16.923Z","path":"contact/index.html","comments":1,"layout":"page","_id":"ck4zcnv2p0002ljc39bl5imq4","content":"<h1 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h1><p>欢迎通过电子邮箱与我取得联系。</p>\n<p>我的个人邮箱：</p>\n<p><a href=\"mailto:e@wangluyuan.cc\">e@wangluyuan.cc</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"联系我\"><a href=\"#联系我\" class=\"headerlink\" title=\"联系我\"></a>联系我</h1><p>欢迎通过电子邮箱与我取得联系。</p>\n<p>我的个人邮箱：</p>\n<p><a href=\"mailto:e@wangluyuan.cc\">e@wangluyuan.cc</a></p>\n"}],"Post":[{"title":"C语言extern关键字","date":"2019-02-07T02:01:38.000Z","_content":"\n# C语言extern关键字\n\n从刚上大学开始学习 C 语言的时候，就被老师告诫不要大量使用 `extern` ，自然也就没把这个关键字放在心上。结果到现在还不是很熟悉 `extern` 的用法，说来有点惭愧……\n\n## 一个例子\n\n先来看两个程序：\n\n```c\n#include <stdio.h>\nextern int x;\nint x = 10;\n\nvoid foo() {\n    printf(\"%d\", x); \n}\n\nint main() {\n    int x; //⚠️\n    x++;\n    foo();\n}\n```\n\n```c\n#include <stdio.h>\nextern int x;\nint x = 10;\n\nvoid foo() {\n    printf(\"%d\", x);\n}\n\nint main() {\n    extern int x; //⚠️\n    x++;\n    foo();\n}\n```\n\n这两段程序唯一的区别就是 main 函数的第一行，有没有 `extern` 关键字。请问，这两个程序的输出分别是多少呢？\n\n答案是，第一个程序输出 10，第二个程序输出 11。\n\n`extern` 关键字把一个 symbol 声明成外部的。它告诉编译器：这个符号（比如 x）你没有见过，但是不要紧，它在别的地方定义了。你只管放心地编译，链接器会找到它的。也就是说，\n\n```c\nextern int x;\n```\n\n只是一个 declaration，而不是 definition。而\n\n```c\nint x;\n```\n\n既 declare 了 x，又 define 了 x。而在链接的时候，所有标记了 `extern` 的同名变量，都会被链接到同一个变量上。在上面的两端代码中，如果没有 `extern` 修饰 x，那么就是在 main 函数中定义了一个新的局部变量 x，并对它加一。跳转到 foo 中，只有全局变量 x 才是可见的，而刚刚的局部变量对全局变量没有影响，故而打印出 10 。第二段程序，因为添加了 `extern` ，所以在 main 函数中的 `int x` 不是 **definition** ，而是 **declaration** ，被链接器链接到全局变量 x 上。所以执行加一操作，会改变全局变量的值，所以打印出 11 。在第二个程序中，所有出现的 `x` 都指向同一个变量。\n\n## 第二个例子\n\n我们有三个文件：\n\n```c\n// test.h\nextern int x;\nint x = 10;\n```\n\n```c\n// test1.c\n#include \"test.h\"\nint main() {\n    x = 5;\n    return 0;\n}\n```\n\n```c\n// test2.c\n#include \"test.h\"\nvoid foo() { x = 6; }\n```\n\n请问，如果执行 `gcc test1.c test2.c` 编译这个程序，会发生什么？\n\n答案是，linker 会报错：\n\n```\nld: 1 duplicate symbol for architecture x86_64\n```\n\n`#include` 引用的文件，会被 C 预处理器 （C PreProcessor, CPP）复制过来。也就是说，在这个程序中，x 被定义了两遍，且被声明成了外部的。刚刚说过，所有外部的同名变量都会被链接器链接到一起，指向同一个变量。那么这里，链接器就会发现有两个 x 的定义，那么该指向哪个呢？只好报错说有 `duplicate symbol` 。\n\n那么，如果我们把 test.h 文件修改成这样呢？\n\n```c\n// test.h\n// extern int x;\nint x = 10;\n```\n\n我们不声明 x 为外部变量。这样，当头文件被复制到 c 文件时，我们只是分别定义了两次全局变量，应该相安无事了吧？事实上，链接器还是会报同样的错误。因为，全局变量默认就是外部的，写不写 `extern` 都一样。类似的，函数默认也都是外部的，不用显示地写出 `extern` 。\n\n那么，怎么才能让全局变量不是外部的呢？答案是 `static` 关键字。显示地把变量定义为静态的，变量的生命周期就会变成整个程序的生命周期（即使在函数里面定义也是如此），而可见性就只局限在了同一个文件中。所以，如果把 test.h 文件改成这样，就可以通过编译，生成可执行文件了：\n\n```c\n// test.h\nstatic int x = 10;\n```\n\n现在，虽然 x 被定义了两次，但是井水不犯河水。\n\n\n\n","source":"_posts/C语言extern关键字.md","raw":"---\ntitle: C语言extern关键字\ndate: 2019-02-07 10:01:38\ntags: C/C++\n---\n\n# C语言extern关键字\n\n从刚上大学开始学习 C 语言的时候，就被老师告诫不要大量使用 `extern` ，自然也就没把这个关键字放在心上。结果到现在还不是很熟悉 `extern` 的用法，说来有点惭愧……\n\n## 一个例子\n\n先来看两个程序：\n\n```c\n#include <stdio.h>\nextern int x;\nint x = 10;\n\nvoid foo() {\n    printf(\"%d\", x); \n}\n\nint main() {\n    int x; //⚠️\n    x++;\n    foo();\n}\n```\n\n```c\n#include <stdio.h>\nextern int x;\nint x = 10;\n\nvoid foo() {\n    printf(\"%d\", x);\n}\n\nint main() {\n    extern int x; //⚠️\n    x++;\n    foo();\n}\n```\n\n这两段程序唯一的区别就是 main 函数的第一行，有没有 `extern` 关键字。请问，这两个程序的输出分别是多少呢？\n\n答案是，第一个程序输出 10，第二个程序输出 11。\n\n`extern` 关键字把一个 symbol 声明成外部的。它告诉编译器：这个符号（比如 x）你没有见过，但是不要紧，它在别的地方定义了。你只管放心地编译，链接器会找到它的。也就是说，\n\n```c\nextern int x;\n```\n\n只是一个 declaration，而不是 definition。而\n\n```c\nint x;\n```\n\n既 declare 了 x，又 define 了 x。而在链接的时候，所有标记了 `extern` 的同名变量，都会被链接到同一个变量上。在上面的两端代码中，如果没有 `extern` 修饰 x，那么就是在 main 函数中定义了一个新的局部变量 x，并对它加一。跳转到 foo 中，只有全局变量 x 才是可见的，而刚刚的局部变量对全局变量没有影响，故而打印出 10 。第二段程序，因为添加了 `extern` ，所以在 main 函数中的 `int x` 不是 **definition** ，而是 **declaration** ，被链接器链接到全局变量 x 上。所以执行加一操作，会改变全局变量的值，所以打印出 11 。在第二个程序中，所有出现的 `x` 都指向同一个变量。\n\n## 第二个例子\n\n我们有三个文件：\n\n```c\n// test.h\nextern int x;\nint x = 10;\n```\n\n```c\n// test1.c\n#include \"test.h\"\nint main() {\n    x = 5;\n    return 0;\n}\n```\n\n```c\n// test2.c\n#include \"test.h\"\nvoid foo() { x = 6; }\n```\n\n请问，如果执行 `gcc test1.c test2.c` 编译这个程序，会发生什么？\n\n答案是，linker 会报错：\n\n```\nld: 1 duplicate symbol for architecture x86_64\n```\n\n`#include` 引用的文件，会被 C 预处理器 （C PreProcessor, CPP）复制过来。也就是说，在这个程序中，x 被定义了两遍，且被声明成了外部的。刚刚说过，所有外部的同名变量都会被链接器链接到一起，指向同一个变量。那么这里，链接器就会发现有两个 x 的定义，那么该指向哪个呢？只好报错说有 `duplicate symbol` 。\n\n那么，如果我们把 test.h 文件修改成这样呢？\n\n```c\n// test.h\n// extern int x;\nint x = 10;\n```\n\n我们不声明 x 为外部变量。这样，当头文件被复制到 c 文件时，我们只是分别定义了两次全局变量，应该相安无事了吧？事实上，链接器还是会报同样的错误。因为，全局变量默认就是外部的，写不写 `extern` 都一样。类似的，函数默认也都是外部的，不用显示地写出 `extern` 。\n\n那么，怎么才能让全局变量不是外部的呢？答案是 `static` 关键字。显示地把变量定义为静态的，变量的生命周期就会变成整个程序的生命周期（即使在函数里面定义也是如此），而可见性就只局限在了同一个文件中。所以，如果把 test.h 文件改成这样，就可以通过编译，生成可执行文件了：\n\n```c\n// test.h\nstatic int x = 10;\n```\n\n现在，虽然 x 被定义了两次，但是井水不犯河水。\n\n\n\n","slug":"C语言extern关键字","published":1,"updated":"2020-01-04T08:16:16.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv2m0001ljc3h67k313p","content":"<h1 id=\"C语言extern关键字\"><a href=\"#C语言extern关键字\" class=\"headerlink\" title=\"C语言extern关键字\"></a>C语言extern关键字</h1><p>从刚上大学开始学习 C 语言的时候，就被老师告诫不要大量使用 <code>extern</code> ，自然也就没把这个关键字放在心上。结果到现在还不是很熟悉 <code>extern</code> 的用法，说来有点惭愧……</p>\n<h2 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h2><p>先来看两个程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, x); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x; <span class=\"comment\">//⚠️</span></span><br><span class=\"line\">    x++;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> x; <span class=\"comment\">//⚠️</span></span><br><span class=\"line\">    x++;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两段程序唯一的区别就是 main 函数的第一行，有没有 <code>extern</code> 关键字。请问，这两个程序的输出分别是多少呢？</p>\n<p>答案是，第一个程序输出 10，第二个程序输出 11。</p>\n<p><code>extern</code> 关键字把一个 symbol 声明成外部的。它告诉编译器：这个符号（比如 x）你没有见过，但是不要紧，它在别的地方定义了。你只管放心地编译，链接器会找到它的。也就是说，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> x;</span><br></pre></td></tr></table></figure>\n<p>只是一个 declaration，而不是 definition。而</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x;</span><br></pre></td></tr></table></figure>\n<p>既 declare 了 x，又 define 了 x。而在链接的时候，所有标记了 <code>extern</code> 的同名变量，都会被链接到同一个变量上。在上面的两端代码中，如果没有 <code>extern</code> 修饰 x，那么就是在 main 函数中定义了一个新的局部变量 x，并对它加一。跳转到 foo 中，只有全局变量 x 才是可见的，而刚刚的局部变量对全局变量没有影响，故而打印出 10 。第二段程序，因为添加了 <code>extern</code> ，所以在 main 函数中的 <code>int x</code> 不是 <strong>definition</strong> ，而是 <strong>declaration</strong> ，被链接器链接到全局变量 x 上。所以执行加一操作，会改变全局变量的值，所以打印出 11 。在第二个程序中，所有出现的 <code>x</code> 都指向同一个变量。</p>\n<h2 id=\"第二个例子\"><a href=\"#第二个例子\" class=\"headerlink\" title=\"第二个例子\"></a>第二个例子</h2><p>我们有三个文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test1.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"test.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test2.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"test.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123; x = <span class=\"number\">6</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>请问，如果执行 <code>gcc test1.c test2.c</code> 编译这个程序，会发生什么？</p>\n<p>答案是，linker 会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld: 1 duplicate symbol for architecture x86_64</span><br></pre></td></tr></table></figure>\n<p><code>#include</code> 引用的文件，会被 C 预处理器 （C PreProcessor, CPP）复制过来。也就是说，在这个程序中，x 被定义了两遍，且被声明成了外部的。刚刚说过，所有外部的同名变量都会被链接器链接到一起，指向同一个变量。那么这里，链接器就会发现有两个 x 的定义，那么该指向哪个呢？只好报错说有 <code>duplicate symbol</code> 。</p>\n<p>那么，如果我们把 test.h 文件修改成这样呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"comment\">// extern int x;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>我们不声明 x 为外部变量。这样，当头文件被复制到 c 文件时，我们只是分别定义了两次全局变量，应该相安无事了吧？事实上，链接器还是会报同样的错误。因为，全局变量默认就是外部的，写不写 <code>extern</code> 都一样。类似的，函数默认也都是外部的，不用显示地写出 <code>extern</code> 。</p>\n<p>那么，怎么才能让全局变量不是外部的呢？答案是 <code>static</code> 关键字。显示地把变量定义为静态的，变量的生命周期就会变成整个程序的生命周期（即使在函数里面定义也是如此），而可见性就只局限在了同一个文件中。所以，如果把 test.h 文件改成这样，就可以通过编译，生成可执行文件了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>现在，虽然 x 被定义了两次，但是井水不犯河水。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"C语言extern关键字\"><a href=\"#C语言extern关键字\" class=\"headerlink\" title=\"C语言extern关键字\"></a>C语言extern关键字</h1><p>从刚上大学开始学习 C 语言的时候，就被老师告诫不要大量使用 <code>extern</code> ，自然也就没把这个关键字放在心上。结果到现在还不是很熟悉 <code>extern</code> 的用法，说来有点惭愧……</p>\n<h2 id=\"一个例子\"><a href=\"#一个例子\" class=\"headerlink\" title=\"一个例子\"></a>一个例子</h2><p>先来看两个程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, x); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x; <span class=\"comment\">//⚠️</span></span><br><span class=\"line\">    x++;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> x; <span class=\"comment\">//⚠️</span></span><br><span class=\"line\">    x++;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这两段程序唯一的区别就是 main 函数的第一行，有没有 <code>extern</code> 关键字。请问，这两个程序的输出分别是多少呢？</p>\n<p>答案是，第一个程序输出 10，第二个程序输出 11。</p>\n<p><code>extern</code> 关键字把一个 symbol 声明成外部的。它告诉编译器：这个符号（比如 x）你没有见过，但是不要紧，它在别的地方定义了。你只管放心地编译，链接器会找到它的。也就是说，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> x;</span><br></pre></td></tr></table></figure>\n<p>只是一个 declaration，而不是 definition。而</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> x;</span><br></pre></td></tr></table></figure>\n<p>既 declare 了 x，又 define 了 x。而在链接的时候，所有标记了 <code>extern</code> 的同名变量，都会被链接到同一个变量上。在上面的两端代码中，如果没有 <code>extern</code> 修饰 x，那么就是在 main 函数中定义了一个新的局部变量 x，并对它加一。跳转到 foo 中，只有全局变量 x 才是可见的，而刚刚的局部变量对全局变量没有影响，故而打印出 10 。第二段程序，因为添加了 <code>extern</code> ，所以在 main 函数中的 <code>int x</code> 不是 <strong>definition</strong> ，而是 <strong>declaration</strong> ，被链接器链接到全局变量 x 上。所以执行加一操作，会改变全局变量的值，所以打印出 11 。在第二个程序中，所有出现的 <code>x</code> 都指向同一个变量。</p>\n<h2 id=\"第二个例子\"><a href=\"#第二个例子\" class=\"headerlink\" title=\"第二个例子\"></a>第二个例子</h2><p>我们有三个文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test1.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"test.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    x = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test2.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"test.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123; x = <span class=\"number\">6</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>请问，如果执行 <code>gcc test1.c test2.c</code> 编译这个程序，会发生什么？</p>\n<p>答案是，linker 会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ld: 1 duplicate symbol for architecture x86_64</span><br></pre></td></tr></table></figure>\n<p><code>#include</code> 引用的文件，会被 C 预处理器 （C PreProcessor, CPP）复制过来。也就是说，在这个程序中，x 被定义了两遍，且被声明成了外部的。刚刚说过，所有外部的同名变量都会被链接器链接到一起，指向同一个变量。那么这里，链接器就会发现有两个 x 的定义，那么该指向哪个呢？只好报错说有 <code>duplicate symbol</code> 。</p>\n<p>那么，如果我们把 test.h 文件修改成这样呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"comment\">// extern int x;</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>我们不声明 x 为外部变量。这样，当头文件被复制到 c 文件时，我们只是分别定义了两次全局变量，应该相安无事了吧？事实上，链接器还是会报同样的错误。因为，全局变量默认就是外部的，写不写 <code>extern</code> 都一样。类似的，函数默认也都是外部的，不用显示地写出 <code>extern</code> 。</p>\n<p>那么，怎么才能让全局变量不是外部的呢？答案是 <code>static</code> 关键字。显示地把变量定义为静态的，变量的生命周期就会变成整个程序的生命周期（即使在函数里面定义也是如此），而可见性就只局限在了同一个文件中。所以，如果把 test.h 文件改成这样，就可以通过编译，生成可执行文件了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> x = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n<p>现在，虽然 x 被定义了两次，但是井水不犯河水。</p>\n"},{"title":"AFNetworking设置HTTP的Header和Body","date":"2018-07-13T13:21:42.000Z","_content":"\n# AFNetworking 设置 HTTP Header / Body\n\n多数情况下，我们并不需要特别设置 HTTP 的 header 和 body，使用 AFNetworking 的 paramters 参数就够了。但是有些时候，我们需要用 Header 来放置一些授权码，或者 Body 来放置二进制数据，这个时候就要自己设置 Header 和 Body 了。\n\n## 如何设置 Header\n\n设置 Header 较为简单，只需要：\n\n```objc\nAFHTTPSessionManager *manager = [AFHTTPSessionManager manager];\n[manager.requestSerializer setValue:@\"Fri, 13 Jul 2018 07:28:11 GMT\" forHTTPHeaderField:@\"Date\"];\n```\n\n就可以了。之后，就可以按照我们熟悉的方式来发送请求，比如：\n\n```objc\n[manager GET:@\"https://your.url\" parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        //...\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        //...\n    }];\n```\n\n## 如何设置 Body\n\n如果你想故伎重演，就会发现刚刚的 `setValueForHeader` 方法并没有对应 `setValueForBody` 的方法。但是，AFNetworking 的请求函数里是提供了这样的参数的：\n\n```objc\n[self.manager POST:@\"http://your.url\" parameters:nil constructingBodyWithBlock:^(id<AFMultipartFormData>  _Nonnull formData) {\n        [formData appendPartWithFormData:yourData name:@\"yourDataName\"]; //设置form-data\n    } progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        //...\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        //...\n    }];\n```\n\n它可以让你用一个 block 来设置 body 的 form-data，这当然是没问题的。但是，一旦你通过这种方式设置了 form-data，那么你的 HTTP Header 中 `Content-Type` 属性就会被设置为 `multipart/form-data` （否则，服务端怎么解析呢？）。而有些场景下，我们需要指定自己的 Content-Type。\n\n比如，在腾讯云的有些接口中，需要使用 protobuf 来交互数据。那就需要我们把 Content-Type 设置为 `application/x-protobuf `，并把 protobuf 生成的二进制数据放倒 body 中。按照上述的操作，自己设置的 Content-Type 就会被覆盖，导致上传失败。有没有什么办法能干干净净地设置 body 呢？\n\n```objc\nself.manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];\nNSMutableURLRequest *request = [AFHTTPRequestSerializer.serializer requestWithMethod:@\"POST\" URLString:@\"http://your.url\" parameters:nil error:nil];\n[request setValue:@\"application/x-protobuf\" forHTTPHeaderField:@\"Content-Type\"]; //设置Header，和之前的方法类似\n[request setHTTPBody:protoBufData]; //设置Body\n[[self.manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {\n        //...\n    }] resume]; //发送请求，注意一定要调用 resume 方法来开始。\n```\n\n这样就可以啦！","source":"_posts/AFNetworking设置HTTP-Header-Body.md","raw":"---\ntitle: AFNetworking设置HTTP的Header和Body\ndate: 2018-07-13 21:21:42\ntags: AFNetworking\n---\n\n# AFNetworking 设置 HTTP Header / Body\n\n多数情况下，我们并不需要特别设置 HTTP 的 header 和 body，使用 AFNetworking 的 paramters 参数就够了。但是有些时候，我们需要用 Header 来放置一些授权码，或者 Body 来放置二进制数据，这个时候就要自己设置 Header 和 Body 了。\n\n## 如何设置 Header\n\n设置 Header 较为简单，只需要：\n\n```objc\nAFHTTPSessionManager *manager = [AFHTTPSessionManager manager];\n[manager.requestSerializer setValue:@\"Fri, 13 Jul 2018 07:28:11 GMT\" forHTTPHeaderField:@\"Date\"];\n```\n\n就可以了。之后，就可以按照我们熟悉的方式来发送请求，比如：\n\n```objc\n[manager GET:@\"https://your.url\" parameters:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        //...\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        //...\n    }];\n```\n\n## 如何设置 Body\n\n如果你想故伎重演，就会发现刚刚的 `setValueForHeader` 方法并没有对应 `setValueForBody` 的方法。但是，AFNetworking 的请求函数里是提供了这样的参数的：\n\n```objc\n[self.manager POST:@\"http://your.url\" parameters:nil constructingBodyWithBlock:^(id<AFMultipartFormData>  _Nonnull formData) {\n        [formData appendPartWithFormData:yourData name:@\"yourDataName\"]; //设置form-data\n    } progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {\n        //...\n    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {\n        //...\n    }];\n```\n\n它可以让你用一个 block 来设置 body 的 form-data，这当然是没问题的。但是，一旦你通过这种方式设置了 form-data，那么你的 HTTP Header 中 `Content-Type` 属性就会被设置为 `multipart/form-data` （否则，服务端怎么解析呢？）。而有些场景下，我们需要指定自己的 Content-Type。\n\n比如，在腾讯云的有些接口中，需要使用 protobuf 来交互数据。那就需要我们把 Content-Type 设置为 `application/x-protobuf `，并把 protobuf 生成的二进制数据放倒 body 中。按照上述的操作，自己设置的 Content-Type 就会被覆盖，导致上传失败。有没有什么办法能干干净净地设置 body 呢？\n\n```objc\nself.manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];\nNSMutableURLRequest *request = [AFHTTPRequestSerializer.serializer requestWithMethod:@\"POST\" URLString:@\"http://your.url\" parameters:nil error:nil];\n[request setValue:@\"application/x-protobuf\" forHTTPHeaderField:@\"Content-Type\"]; //设置Header，和之前的方法类似\n[request setHTTPBody:protoBufData]; //设置Body\n[[self.manager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {\n        //...\n    }] resume]; //发送请求，注意一定要调用 resume 方法来开始。\n```\n\n这样就可以啦！","slug":"AFNetworking设置HTTP-Header-Body","published":1,"updated":"2020-01-04T08:16:16.912Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv2q0003ljc3q6dvxiyp","content":"<h1 id=\"AFNetworking-设置-HTTP-Header-Body\"><a href=\"#AFNetworking-设置-HTTP-Header-Body\" class=\"headerlink\" title=\"AFNetworking 设置 HTTP Header / Body\"></a>AFNetworking 设置 HTTP Header / Body</h1><p>多数情况下，我们并不需要特别设置 HTTP 的 header 和 body，使用 AFNetworking 的 paramters 参数就够了。但是有些时候，我们需要用 Header 来放置一些授权码，或者 Body 来放置二进制数据，这个时候就要自己设置 Header 和 Body 了。</p>\n<h2 id=\"如何设置-Header\"><a href=\"#如何设置-Header\" class=\"headerlink\" title=\"如何设置 Header\"></a>如何设置 Header</h2><p>设置 Header 较为简单，只需要：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class=\"line\">[manager.requestSerializer setValue:<span class=\"string\">@\"Fri, 13 Jul 2018 07:28:11 GMT\"</span> forHTTPHeaderField:<span class=\"string\">@\"Date\"</span>];</span><br></pre></td></tr></table></figure>\n<p>就可以了。之后，就可以按照我们熟悉的方式来发送请求，比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[manager GET:<span class=\"string\">@\"https://your.url\"</span> parameters:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span> success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"keyword\">id</span>  _Nullable responseObject) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何设置-Body\"><a href=\"#如何设置-Body\" class=\"headerlink\" title=\"如何设置 Body\"></a>如何设置 Body</h2><p>如果你想故伎重演，就会发现刚刚的 <code>setValueForHeader</code> 方法并没有对应 <code>setValueForBody</code> 的方法。但是，AFNetworking 的请求函数里是提供了这样的参数的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.manager POST:<span class=\"string\">@\"http://your.url\"</span> parameters:<span class=\"literal\">nil</span> constructingBodyWithBlock:^(<span class=\"keyword\">id</span>&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class=\"line\">        [formData appendPartWithFormData:yourData name:<span class=\"string\">@\"yourDataName\"</span>]; <span class=\"comment\">//设置form-data</span></span><br><span class=\"line\">    &#125; progress:<span class=\"literal\">nil</span> success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"keyword\">id</span>  _Nullable responseObject) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<p>它可以让你用一个 block 来设置 body 的 form-data，这当然是没问题的。但是，一旦你通过这种方式设置了 form-data，那么你的 HTTP Header 中 <code>Content-Type</code> 属性就会被设置为 <code>multipart/form-data</code> （否则，服务端怎么解析呢？）。而有些场景下，我们需要指定自己的 Content-Type。</p>\n<p>比如，在腾讯云的有些接口中，需要使用 protobuf 来交互数据。那就需要我们把 Content-Type 设置为 <code>application/x-protobuf</code>，并把 protobuf 生成的二进制数据放倒 body 中。按照上述的操作，自己设置的 Content-Type 就会被覆盖，导致上传失败。有没有什么办法能干干净净地设置 body 呢？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> *request = [AFHTTPRequestSerializer.serializer requestWithMethod:<span class=\"string\">@\"POST\"</span> URLString:<span class=\"string\">@\"http://your.url\"</span> parameters:<span class=\"literal\">nil</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">[request setValue:<span class=\"string\">@\"application/x-protobuf\"</span> forHTTPHeaderField:<span class=\"string\">@\"Content-Type\"</span>]; <span class=\"comment\">//设置Header，和之前的方法类似</span></span><br><span class=\"line\">[request setHTTPBody:protoBufData]; <span class=\"comment\">//设置Body</span></span><br><span class=\"line\">[[<span class=\"keyword\">self</span>.manager dataTaskWithRequest:request uploadProgress:<span class=\"literal\">nil</span> downloadProgress:<span class=\"literal\">nil</span> completionHandler:^(<span class=\"built_in\">NSURLResponse</span> * _Nonnull response, <span class=\"keyword\">id</span>  _Nullable responseObject, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;] resume]; <span class=\"comment\">//发送请求，注意一定要调用 resume 方法来开始。</span></span><br></pre></td></tr></table></figure>\n<p>这样就可以啦！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AFNetworking-设置-HTTP-Header-Body\"><a href=\"#AFNetworking-设置-HTTP-Header-Body\" class=\"headerlink\" title=\"AFNetworking 设置 HTTP Header / Body\"></a>AFNetworking 设置 HTTP Header / Body</h1><p>多数情况下，我们并不需要特别设置 HTTP 的 header 和 body，使用 AFNetworking 的 paramters 参数就够了。但是有些时候，我们需要用 Header 来放置一些授权码，或者 Body 来放置二进制数据，这个时候就要自己设置 Header 和 Body 了。</p>\n<h2 id=\"如何设置-Header\"><a href=\"#如何设置-Header\" class=\"headerlink\" title=\"如何设置 Header\"></a>如何设置 Header</h2><p>设置 Header 较为简单，只需要：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</span><br><span class=\"line\">[manager.requestSerializer setValue:<span class=\"string\">@\"Fri, 13 Jul 2018 07:28:11 GMT\"</span> forHTTPHeaderField:<span class=\"string\">@\"Date\"</span>];</span><br></pre></td></tr></table></figure>\n<p>就可以了。之后，就可以按照我们熟悉的方式来发送请求，比如：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[manager GET:<span class=\"string\">@\"https://your.url\"</span> parameters:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span> success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"keyword\">id</span>  _Nullable responseObject) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<h2 id=\"如何设置-Body\"><a href=\"#如何设置-Body\" class=\"headerlink\" title=\"如何设置 Body\"></a>如何设置 Body</h2><p>如果你想故伎重演，就会发现刚刚的 <code>setValueForHeader</code> 方法并没有对应 <code>setValueForBody</code> 的方法。但是，AFNetworking 的请求函数里是提供了这样的参数的：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">self</span>.manager POST:<span class=\"string\">@\"http://your.url\"</span> parameters:<span class=\"literal\">nil</span> constructingBodyWithBlock:^(<span class=\"keyword\">id</span>&lt;AFMultipartFormData&gt;  _Nonnull formData) &#123;</span><br><span class=\"line\">        [formData appendPartWithFormData:yourData name:<span class=\"string\">@\"yourDataName\"</span>]; <span class=\"comment\">//设置form-data</span></span><br><span class=\"line\">    &#125; progress:<span class=\"literal\">nil</span> success:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nonnull task, <span class=\"keyword\">id</span>  _Nullable responseObject) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125; failure:^(<span class=\"built_in\">NSURLSessionDataTask</span> * _Nullable task, <span class=\"built_in\">NSError</span> * _Nonnull error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;];</span><br></pre></td></tr></table></figure>\n<p>它可以让你用一个 block 来设置 body 的 form-data，这当然是没问题的。但是，一旦你通过这种方式设置了 form-data，那么你的 HTTP Header 中 <code>Content-Type</code> 属性就会被设置为 <code>multipart/form-data</code> （否则，服务端怎么解析呢？）。而有些场景下，我们需要指定自己的 Content-Type。</p>\n<p>比如，在腾讯云的有些接口中，需要使用 protobuf 来交互数据。那就需要我们把 Content-Type 设置为 <code>application/x-protobuf</code>，并把 protobuf 生成的二进制数据放倒 body 中。按照上述的操作，自己设置的 Content-Type 就会被覆盖，导致上传失败。有没有什么办法能干干净净地设置 body 呢？</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class=\"built_in\">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> *request = [AFHTTPRequestSerializer.serializer requestWithMethod:<span class=\"string\">@\"POST\"</span> URLString:<span class=\"string\">@\"http://your.url\"</span> parameters:<span class=\"literal\">nil</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">[request setValue:<span class=\"string\">@\"application/x-protobuf\"</span> forHTTPHeaderField:<span class=\"string\">@\"Content-Type\"</span>]; <span class=\"comment\">//设置Header，和之前的方法类似</span></span><br><span class=\"line\">[request setHTTPBody:protoBufData]; <span class=\"comment\">//设置Body</span></span><br><span class=\"line\">[[<span class=\"keyword\">self</span>.manager dataTaskWithRequest:request uploadProgress:<span class=\"literal\">nil</span> downloadProgress:<span class=\"literal\">nil</span> completionHandler:^(<span class=\"built_in\">NSURLResponse</span> * _Nonnull response, <span class=\"keyword\">id</span>  _Nullable responseObject, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;] resume]; <span class=\"comment\">//发送请求，注意一定要调用 resume 方法来开始。</span></span><br></pre></td></tr></table></figure>\n<p>这样就可以啦！</p>\n"},{"title":"一个小坑-以空格分割字符串","date":"2018-02-15T07:44:37.000Z","_content":"\n# Java 以空格分割字符串\n\n刷到一道弱智级别的算法题，5 分钟写完信心满满的提交上去，却提示有两个 case 错误。\n\n仔细检查了几百遍自己的代码，感觉什么问题都没有。搞了很久一直过不了，后来把以空格分割字符串的写法从：\n\n```java\nString[] list = str.split(\" \"); //以空格进行分割\n```\n\n改成了：\n\n```java\nString[] list = str.split(\"\\\\s+\"); //正则表达式，以任意长空白符进行分割\n```\n\n竟然一下就过了……而题目明明说的输入格式是以空格进行分割啊！之前的写法理论上应该没问题啊！这不科学！\n\n这个问题困扰了我将近一个小时，虽然是个小问题，且到现在也不清楚为什么会这样……但还是记录一下吧，以后再也不敢直接用空格分割了……\n\n","source":"_posts/Java以空格分割字符串.md","raw":"---\ntitle: 一个小坑-以空格分割字符串\ndate: 2018-02-15 15:44:37\ntags: Java\n---\n\n# Java 以空格分割字符串\n\n刷到一道弱智级别的算法题，5 分钟写完信心满满的提交上去，却提示有两个 case 错误。\n\n仔细检查了几百遍自己的代码，感觉什么问题都没有。搞了很久一直过不了，后来把以空格分割字符串的写法从：\n\n```java\nString[] list = str.split(\" \"); //以空格进行分割\n```\n\n改成了：\n\n```java\nString[] list = str.split(\"\\\\s+\"); //正则表达式，以任意长空白符进行分割\n```\n\n竟然一下就过了……而题目明明说的输入格式是以空格进行分割啊！之前的写法理论上应该没问题啊！这不科学！\n\n这个问题困扰了我将近一个小时，虽然是个小问题，且到现在也不清楚为什么会这样……但还是记录一下吧，以后再也不敢直接用空格分割了……\n\n","slug":"Java以空格分割字符串","published":1,"updated":"2020-01-04T08:16:16.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv2u0005ljc3uki3lg5l","content":"<h1 id=\"Java-以空格分割字符串\"><a href=\"#Java-以空格分割字符串\" class=\"headerlink\" title=\"Java 以空格分割字符串\"></a>Java 以空格分割字符串</h1><p>刷到一道弱智级别的算法题，5 分钟写完信心满满的提交上去，却提示有两个 case 错误。</p>\n<p>仔细检查了几百遍自己的代码，感觉什么问题都没有。搞了很久一直过不了，后来把以空格分割字符串的写法从：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] list = str.split(<span class=\"string\">\" \"</span>); <span class=\"comment\">//以空格进行分割</span></span><br></pre></td></tr></table></figure>\n<p>改成了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] list = str.split(<span class=\"string\">\"\\\\s+\"</span>); <span class=\"comment\">//正则表达式，以任意长空白符进行分割</span></span><br></pre></td></tr></table></figure>\n<p>竟然一下就过了……而题目明明说的输入格式是以空格进行分割啊！之前的写法理论上应该没问题啊！这不科学！</p>\n<p>这个问题困扰了我将近一个小时，虽然是个小问题，且到现在也不清楚为什么会这样……但还是记录一下吧，以后再也不敢直接用空格分割了……</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Java-以空格分割字符串\"><a href=\"#Java-以空格分割字符串\" class=\"headerlink\" title=\"Java 以空格分割字符串\"></a>Java 以空格分割字符串</h1><p>刷到一道弱智级别的算法题，5 分钟写完信心满满的提交上去，却提示有两个 case 错误。</p>\n<p>仔细检查了几百遍自己的代码，感觉什么问题都没有。搞了很久一直过不了，后来把以空格分割字符串的写法从：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] list = str.split(<span class=\"string\">\" \"</span>); <span class=\"comment\">//以空格进行分割</span></span><br></pre></td></tr></table></figure>\n<p>改成了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String[] list = str.split(<span class=\"string\">\"\\\\s+\"</span>); <span class=\"comment\">//正则表达式，以任意长空白符进行分割</span></span><br></pre></td></tr></table></figure>\n<p>竟然一下就过了……而题目明明说的输入格式是以空格进行分割啊！之前的写法理论上应该没问题啊！这不科学！</p>\n<p>这个问题困扰了我将近一个小时，虽然是个小问题，且到现在也不清楚为什么会这样……但还是记录一下吧，以后再也不敢直接用空格分割了……</p>\n"},{"title":"LLVM循环优化","date":"2019-04-27T15:59:25.000Z","_content":"\n# LLVM 循环优化\n\nLLVM 是一个广为使用的编译器套件，也是苹果官方的编译器。LLVM 前端可以把高级代码转换成 LLVM 自身的中间代码（IR），而后端再把 IR 翻译为目标平台的机器码。而 LLVM 提供的优化器 opt 可以优化 IR 代码，并生成优化过的 IR 代码。在之前的博客中，我已经探索过使用 clang 来优化一个简单的程序。在那个简单的循环程序中，较为影响性能的就是 Loop Unrolling 优化。我也做出了一些性能测试。\n\n但是，单纯的用 `clang -O3` 来分析 Loop Unrolling 的性能影响是不科学的。在一个较为复杂的程序中，会有很多处可以优化的地方。而如果想要对比某一种优化策略带来的效果，则最好只做这一种优化（控制变量）。比如，用下面的命令来做 Loop Unrolling 优化，则带来的副作用就少得多：\n\n```\nopt -mem2reg -simplifycfg -loops -lcssa -loop-simplify -loop-rotate -loop-\nunroll -unroll-count=4 -unroll-allow-partial input.ll -S -o output.ll\n```\n\n## 编译 LLVM\n\n指定 LLVM opt 要运行的 pass 来控制优化种类没有想象中的那么直观，经常会得不到想要的结果。如果在输入命令的时候带上 `-debug` 或者 `-debug-only=<pass name>` 标签，就可以获得一些 debug 的信息，会非常有帮助。然而，直接下载安装的 LLVM 是默认关闭这个选项的。这就需要我们自己编译 LLVM，并在编译时指定打开 assertion `-DLLVM_ENABLE_ASSERTIONS=On`。\n\n下载最新版本的 LLVM：\n\n`git clone https://github.com/llvm/llvm-project.git`\n\nclone 后，cd 进入 llvm-project 文件夹。\n\nLLVM 不支持直接在工程文件夹下编译，需要我们自己新建一个构建文件夹：\n\n`mkdir build`\n\n`cd build`\n\n然后开始生成编译所需的文件：\n\n`cmake -G <generator> [options] ../llvm`\n\n多数开发者都会选择用 Ninja 来编译。所以，要先安装 Ninja。如果在 macOS 下，可以用 brew 来安装：\n\n`brew install ninja`\n\n一个例子：\n\n```\ncmake -G 'Ninja' -DLLVM_ENABLE_PROJECTS='clang;<other build targets>' -DCMAKE_INSTALL_PREFIX=<your install path> -DLLVM_ENABLE_ASSERTIONS=On\n```\n\n稍等一段时间后，就会生成所需要的文件。然后就可以用 Ninja 来编译了：\n\n`ninja`\n\n编译花费的时间比较久，可能需要几个小时。编译完成之后，就可以用 Ninja 来安装了，安装地址就是之前指定的地址。\n\n`ninja install`\n\nRef: http://llvm.org/docs/GettingStarted.html#getting-started-quickly-a-summary\n\n## Loop Interchange\n\n下面的代码可用来测试 Loop Interchange：\n\n```c\n#include <stdio.h>\nint main() {\n\tint i=0;\n\tint j=0;\n\tint a[333][222];\n\tfor (i=0; i <222; i++) {\n    \t\tfor (j=0; j <333; j++) {\n            \t\ta[j][i] = a[j][i] + 970815;\n    \t\t}\n\t}\n\treturn 0;\n}\n```\n\n由于二维数组在内存中仍是线性排列，因此先在行内循环效率更优。这是因为行内元素的距离更近，符合空间局部性原理，缓存命中率会更高。在上面的程序中，先做了列内循环，所以可能会被 Loop Interchange 优化循环顺序。\n\n生成 IR 代码，为下一步优化做准备：\n\n```\nclang -O3 -mllvm -disable-llvm-optzns interchange.c -emit-llvm -S -o interchange.ll\n```\n\n这里用 O3 是因为，如果是 O0 的话，LLVM 就会阻止后面的优化器进行优化（可参见 LLVM 源码）。所以后面又先暂时禁止了 opt 直接自动优化。\n\n之后开始使用 opt 进行优化。虽然 LLVM 的 pass 依赖会自动管理，但有些必要的准备工作还是不可避免的：\n\n```\nopt -mem2reg interchange.ll -S -o  interchange.ll\nopt -loop-rotate interchange.ll -S -o interchange.ll\nopt -loop-interchange interchange.ll -S -o opt.ll\n```\n\n这样就生成了 `interchange.ll` 和 `opt.ll` 两个 IR 代码文件。用 llc 来将他们转换成汇编代码：\n\n```\nllc interchange.ll -o un.s\nllc opt.ll -o opt.s\n```\n\n![nointerchange](/img/LLVM循环优化/nointerchange.jpg)\n\n在未优化的汇编代码中，可以看到循环和 C 语言中的一样，内层为 333 次，而外层为 222 次。\n\n![interchange](/img/LLVM循环优化/interchange.png)\n\n而在 Loop Interchange 之后，我们可以发现两个循环的顺序被颠倒了。\n\n将汇编代码编译为可执行文件。为了让 gem5 模拟器运行，需要静态链接：\n\n```\nclang opt.s -o interchange --static\nclang un.s -o interchange_no --static\n```\n\n经过 gem5 模拟，优化前执行了 1837199000 个 tick，优化后是 1767821000 个 tick。可以发现优化后程序运行的时间变短了。之前提到过，interchange 可以提高 cache 的命中率。优化前的数据：\n\n![no_interchange_cache](/img/LLVM循环优化/no_interchange_cache.png)\n\n优化后：\n\n![interchange_cache](/img/LLVM循环优化/interchange_cache.png)\n\n我们可以看到 data cache 的 miss rate 确实下降了一点，好像不是很明显，但是，miss 次数确实是大幅下降了的。\n\n## Loop Unswitch\n\n下面的代码可以用来测试 Loop Unswitch：\n\n```c\nint main() {\n    int i=0, a[1024];\n    int w = 0;\n    for (i = 0; i < 1024; i++) {\n        if (w == 999) {\n            a[i] = 555;\n        } else {\n            a[i] = 666;\n        }\n    }\n\n    return 0;\n}\n```\n\nLoop Unswitch 可以将循环内的条件判断语句移到循环外部，从而在不影响运行结果的前提下节约不必要的判断语句。\n\n```\nclang -O3 -mllvm -disable-llvm-optzns unswitch.c -emit-llvm -S -o unswitch.ll\nopt -mem2reg unswitch.ll -S -o unswitch.ll\nopt -loop-unswitch unswitch.ll -S -o opt.ll\n```\n\n未优化时的 IR 代码如下：\n\n![nounswitch](/img/LLVM循环优化/nounswitch.jpg)\n\n可以看到判断语句和 C 语言中的一致，在循环内部。而优化后：\n\n![unswitch](/img/LLVM循环优化/unswitch.jpg)\n\n原来的循环被拆成了两个独立的循环（判断语句在循环外）。我有时展示 IR 代码，有时展示汇编代码的原因是，有时 IR 代码更加易读，有时汇编代码更易读。但由于汇编代码时从 IR 代码翻译来的，所以本质上是一致的。\n\n经 gem5 模拟，未优化时用了 101847000 个 tick，而优化后使用了 93526000 个 tick。程序耗时减少了。\n\n## Loop Reduce\n\n下面的代码可以用来测试 Loop Reduce：\n\n```c\nint main() {\n    int a[1024];\n    int i=0;\n    int c = 97;\n    for (i=0; i<1024; i++) {\n        a[i] = i * c;\n    }\n    return 0;\n}\n```\n\n在 CPU 指令中，有的指令更加耗时。比较耗时的指令一般有 load, store, 以及乘除法等等。Loop Reduce 可以把一些较为耗时的代码转化为更快的指令。比如，这里的乘法就可以优化为累加。\n\n```\nclang -O3 -mllvm -disable-llvm-optzns reduce.c -emit-llvm -S -o reduce.ll\nopt -mem2reg -loop-reduce reduce.ll -S -o opt.ll\n```\n\n未优化时：\n\n![noreduce](/img/LLVM循环优化/noreduce.png)\n\n可以看大 IR 代码中使用了 mul 指令。这是比较耗时的。\n\n而优化后：\n\n![reduce](/img/LLVM循环优化/reduce.png)\n\n可以看到 LLVM 把乘法转换成了加法。而加法操作就要快多了。\n\n经过 gem5 模拟，未优化时消耗了 115056000 个 tick，而优化后只用了 98250000 个 tick。还是加快了许多的。\n\n## 总结\n\nLLVM 还有很多循环优化选项，亦有 polly 循环优化器可以执行更多的优化操作。然而，直接选择优化级别进行优化较为简单，而想要具体指定优化 pass 就较为困难了。一开始我以为是有相关的依赖，但是经过发送邮件询问 LLVM 社区，有人回答 pass 依赖是自动被管理的。想要知道具体的步骤还是较为困难的，我目前也没有找到什么特别好的方法。所以虽然对一些其他的优化很感兴趣，但也没有机会尝试了。有点遗憾。\n\n\n\n","source":"_posts/LLVM循环优化.md","raw":"---\ntitle: LLVM循环优化\ndate: 2019-04-27 23:59:25\ntags: Computer Organization\n---\n\n# LLVM 循环优化\n\nLLVM 是一个广为使用的编译器套件，也是苹果官方的编译器。LLVM 前端可以把高级代码转换成 LLVM 自身的中间代码（IR），而后端再把 IR 翻译为目标平台的机器码。而 LLVM 提供的优化器 opt 可以优化 IR 代码，并生成优化过的 IR 代码。在之前的博客中，我已经探索过使用 clang 来优化一个简单的程序。在那个简单的循环程序中，较为影响性能的就是 Loop Unrolling 优化。我也做出了一些性能测试。\n\n但是，单纯的用 `clang -O3` 来分析 Loop Unrolling 的性能影响是不科学的。在一个较为复杂的程序中，会有很多处可以优化的地方。而如果想要对比某一种优化策略带来的效果，则最好只做这一种优化（控制变量）。比如，用下面的命令来做 Loop Unrolling 优化，则带来的副作用就少得多：\n\n```\nopt -mem2reg -simplifycfg -loops -lcssa -loop-simplify -loop-rotate -loop-\nunroll -unroll-count=4 -unroll-allow-partial input.ll -S -o output.ll\n```\n\n## 编译 LLVM\n\n指定 LLVM opt 要运行的 pass 来控制优化种类没有想象中的那么直观，经常会得不到想要的结果。如果在输入命令的时候带上 `-debug` 或者 `-debug-only=<pass name>` 标签，就可以获得一些 debug 的信息，会非常有帮助。然而，直接下载安装的 LLVM 是默认关闭这个选项的。这就需要我们自己编译 LLVM，并在编译时指定打开 assertion `-DLLVM_ENABLE_ASSERTIONS=On`。\n\n下载最新版本的 LLVM：\n\n`git clone https://github.com/llvm/llvm-project.git`\n\nclone 后，cd 进入 llvm-project 文件夹。\n\nLLVM 不支持直接在工程文件夹下编译，需要我们自己新建一个构建文件夹：\n\n`mkdir build`\n\n`cd build`\n\n然后开始生成编译所需的文件：\n\n`cmake -G <generator> [options] ../llvm`\n\n多数开发者都会选择用 Ninja 来编译。所以，要先安装 Ninja。如果在 macOS 下，可以用 brew 来安装：\n\n`brew install ninja`\n\n一个例子：\n\n```\ncmake -G 'Ninja' -DLLVM_ENABLE_PROJECTS='clang;<other build targets>' -DCMAKE_INSTALL_PREFIX=<your install path> -DLLVM_ENABLE_ASSERTIONS=On\n```\n\n稍等一段时间后，就会生成所需要的文件。然后就可以用 Ninja 来编译了：\n\n`ninja`\n\n编译花费的时间比较久，可能需要几个小时。编译完成之后，就可以用 Ninja 来安装了，安装地址就是之前指定的地址。\n\n`ninja install`\n\nRef: http://llvm.org/docs/GettingStarted.html#getting-started-quickly-a-summary\n\n## Loop Interchange\n\n下面的代码可用来测试 Loop Interchange：\n\n```c\n#include <stdio.h>\nint main() {\n\tint i=0;\n\tint j=0;\n\tint a[333][222];\n\tfor (i=0; i <222; i++) {\n    \t\tfor (j=0; j <333; j++) {\n            \t\ta[j][i] = a[j][i] + 970815;\n    \t\t}\n\t}\n\treturn 0;\n}\n```\n\n由于二维数组在内存中仍是线性排列，因此先在行内循环效率更优。这是因为行内元素的距离更近，符合空间局部性原理，缓存命中率会更高。在上面的程序中，先做了列内循环，所以可能会被 Loop Interchange 优化循环顺序。\n\n生成 IR 代码，为下一步优化做准备：\n\n```\nclang -O3 -mllvm -disable-llvm-optzns interchange.c -emit-llvm -S -o interchange.ll\n```\n\n这里用 O3 是因为，如果是 O0 的话，LLVM 就会阻止后面的优化器进行优化（可参见 LLVM 源码）。所以后面又先暂时禁止了 opt 直接自动优化。\n\n之后开始使用 opt 进行优化。虽然 LLVM 的 pass 依赖会自动管理，但有些必要的准备工作还是不可避免的：\n\n```\nopt -mem2reg interchange.ll -S -o  interchange.ll\nopt -loop-rotate interchange.ll -S -o interchange.ll\nopt -loop-interchange interchange.ll -S -o opt.ll\n```\n\n这样就生成了 `interchange.ll` 和 `opt.ll` 两个 IR 代码文件。用 llc 来将他们转换成汇编代码：\n\n```\nllc interchange.ll -o un.s\nllc opt.ll -o opt.s\n```\n\n![nointerchange](/img/LLVM循环优化/nointerchange.jpg)\n\n在未优化的汇编代码中，可以看到循环和 C 语言中的一样，内层为 333 次，而外层为 222 次。\n\n![interchange](/img/LLVM循环优化/interchange.png)\n\n而在 Loop Interchange 之后，我们可以发现两个循环的顺序被颠倒了。\n\n将汇编代码编译为可执行文件。为了让 gem5 模拟器运行，需要静态链接：\n\n```\nclang opt.s -o interchange --static\nclang un.s -o interchange_no --static\n```\n\n经过 gem5 模拟，优化前执行了 1837199000 个 tick，优化后是 1767821000 个 tick。可以发现优化后程序运行的时间变短了。之前提到过，interchange 可以提高 cache 的命中率。优化前的数据：\n\n![no_interchange_cache](/img/LLVM循环优化/no_interchange_cache.png)\n\n优化后：\n\n![interchange_cache](/img/LLVM循环优化/interchange_cache.png)\n\n我们可以看到 data cache 的 miss rate 确实下降了一点，好像不是很明显，但是，miss 次数确实是大幅下降了的。\n\n## Loop Unswitch\n\n下面的代码可以用来测试 Loop Unswitch：\n\n```c\nint main() {\n    int i=0, a[1024];\n    int w = 0;\n    for (i = 0; i < 1024; i++) {\n        if (w == 999) {\n            a[i] = 555;\n        } else {\n            a[i] = 666;\n        }\n    }\n\n    return 0;\n}\n```\n\nLoop Unswitch 可以将循环内的条件判断语句移到循环外部，从而在不影响运行结果的前提下节约不必要的判断语句。\n\n```\nclang -O3 -mllvm -disable-llvm-optzns unswitch.c -emit-llvm -S -o unswitch.ll\nopt -mem2reg unswitch.ll -S -o unswitch.ll\nopt -loop-unswitch unswitch.ll -S -o opt.ll\n```\n\n未优化时的 IR 代码如下：\n\n![nounswitch](/img/LLVM循环优化/nounswitch.jpg)\n\n可以看到判断语句和 C 语言中的一致，在循环内部。而优化后：\n\n![unswitch](/img/LLVM循环优化/unswitch.jpg)\n\n原来的循环被拆成了两个独立的循环（判断语句在循环外）。我有时展示 IR 代码，有时展示汇编代码的原因是，有时 IR 代码更加易读，有时汇编代码更易读。但由于汇编代码时从 IR 代码翻译来的，所以本质上是一致的。\n\n经 gem5 模拟，未优化时用了 101847000 个 tick，而优化后使用了 93526000 个 tick。程序耗时减少了。\n\n## Loop Reduce\n\n下面的代码可以用来测试 Loop Reduce：\n\n```c\nint main() {\n    int a[1024];\n    int i=0;\n    int c = 97;\n    for (i=0; i<1024; i++) {\n        a[i] = i * c;\n    }\n    return 0;\n}\n```\n\n在 CPU 指令中，有的指令更加耗时。比较耗时的指令一般有 load, store, 以及乘除法等等。Loop Reduce 可以把一些较为耗时的代码转化为更快的指令。比如，这里的乘法就可以优化为累加。\n\n```\nclang -O3 -mllvm -disable-llvm-optzns reduce.c -emit-llvm -S -o reduce.ll\nopt -mem2reg -loop-reduce reduce.ll -S -o opt.ll\n```\n\n未优化时：\n\n![noreduce](/img/LLVM循环优化/noreduce.png)\n\n可以看大 IR 代码中使用了 mul 指令。这是比较耗时的。\n\n而优化后：\n\n![reduce](/img/LLVM循环优化/reduce.png)\n\n可以看到 LLVM 把乘法转换成了加法。而加法操作就要快多了。\n\n经过 gem5 模拟，未优化时消耗了 115056000 个 tick，而优化后只用了 98250000 个 tick。还是加快了许多的。\n\n## 总结\n\nLLVM 还有很多循环优化选项，亦有 polly 循环优化器可以执行更多的优化操作。然而，直接选择优化级别进行优化较为简单，而想要具体指定优化 pass 就较为困难了。一开始我以为是有相关的依赖，但是经过发送邮件询问 LLVM 社区，有人回答 pass 依赖是自动被管理的。想要知道具体的步骤还是较为困难的，我目前也没有找到什么特别好的方法。所以虽然对一些其他的优化很感兴趣，但也没有机会尝试了。有点遗憾。\n\n\n\n","slug":"LLVM循环优化","published":1,"updated":"2020-01-04T08:16:16.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv2v0006ljc3naict7gj","content":"<h1 id=\"LLVM-循环优化\"><a href=\"#LLVM-循环优化\" class=\"headerlink\" title=\"LLVM 循环优化\"></a>LLVM 循环优化</h1><p>LLVM 是一个广为使用的编译器套件，也是苹果官方的编译器。LLVM 前端可以把高级代码转换成 LLVM 自身的中间代码（IR），而后端再把 IR 翻译为目标平台的机器码。而 LLVM 提供的优化器 opt 可以优化 IR 代码，并生成优化过的 IR 代码。在之前的博客中，我已经探索过使用 clang 来优化一个简单的程序。在那个简单的循环程序中，较为影响性能的就是 Loop Unrolling 优化。我也做出了一些性能测试。</p>\n<p>但是，单纯的用 <code>clang -O3</code> 来分析 Loop Unrolling 的性能影响是不科学的。在一个较为复杂的程序中，会有很多处可以优化的地方。而如果想要对比某一种优化策略带来的效果，则最好只做这一种优化（控制变量）。比如，用下面的命令来做 Loop Unrolling 优化，则带来的副作用就少得多：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opt -mem2reg -simplifycfg -loops -lcssa -loop-simplify -loop-rotate -loop-</span><br><span class=\"line\">unroll -unroll-count=4 -unroll-allow-partial input.ll -S -o output.ll</span><br></pre></td></tr></table></figure>\n<h2 id=\"编译-LLVM\"><a href=\"#编译-LLVM\" class=\"headerlink\" title=\"编译 LLVM\"></a>编译 LLVM</h2><p>指定 LLVM opt 要运行的 pass 来控制优化种类没有想象中的那么直观，经常会得不到想要的结果。如果在输入命令的时候带上 <code>-debug</code> 或者 <code>-debug-only=&lt;pass name&gt;</code> 标签，就可以获得一些 debug 的信息，会非常有帮助。然而，直接下载安装的 LLVM 是默认关闭这个选项的。这就需要我们自己编译 LLVM，并在编译时指定打开 assertion <code>-DLLVM_ENABLE_ASSERTIONS=On</code>。</p>\n<p>下载最新版本的 LLVM：</p>\n<p><code>git clone https://github.com/llvm/llvm-project.git</code></p>\n<p>clone 后，cd 进入 llvm-project 文件夹。</p>\n<p>LLVM 不支持直接在工程文件夹下编译，需要我们自己新建一个构建文件夹：</p>\n<p><code>mkdir build</code></p>\n<p><code>cd build</code></p>\n<p>然后开始生成编译所需的文件：</p>\n<p><code>cmake -G &lt;generator&gt; [options] ../llvm</code></p>\n<p>多数开发者都会选择用 Ninja 来编译。所以，要先安装 Ninja。如果在 macOS 下，可以用 brew 来安装：</p>\n<p><code>brew install ninja</code></p>\n<p>一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake -G &apos;Ninja&apos; -DLLVM_ENABLE_PROJECTS=&apos;clang;&lt;other build targets&gt;&apos; -DCMAKE_INSTALL_PREFIX=&lt;your install path&gt; -DLLVM_ENABLE_ASSERTIONS=On</span><br></pre></td></tr></table></figure>\n<p>稍等一段时间后，就会生成所需要的文件。然后就可以用 Ninja 来编译了：</p>\n<p><code>ninja</code></p>\n<p>编译花费的时间比较久，可能需要几个小时。编译完成之后，就可以用 Ninja 来安装了，安装地址就是之前指定的地址。</p>\n<p><code>ninja install</code></p>\n<p>Ref: <a href=\"http://llvm.org/docs/GettingStarted.html#getting-started-quickly-a-summary\">http://llvm.org/docs/GettingStarted.html#getting-started-quickly-a-summary</a></p>\n<h2 id=\"Loop-Interchange\"><a href=\"#Loop-Interchange\" class=\"headerlink\" title=\"Loop Interchange\"></a>Loop Interchange</h2><p>下面的代码可用来测试 Loop Interchange：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">333</span>][<span class=\"number\">222</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i &lt;<span class=\"number\">222</span>; i++) &#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; j &lt;<span class=\"number\">333</span>; j++) &#123;</span><br><span class=\"line\">            \t\ta[j][i] = a[j][i] + <span class=\"number\">970815</span>;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于二维数组在内存中仍是线性排列，因此先在行内循环效率更优。这是因为行内元素的距离更近，符合空间局部性原理，缓存命中率会更高。在上面的程序中，先做了列内循环，所以可能会被 Loop Interchange 优化循环顺序。</p>\n<p>生成 IR 代码，为下一步优化做准备：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -O3 -mllvm -disable-llvm-optzns interchange.c -emit-llvm -S -o interchange.ll</span><br></pre></td></tr></table></figure>\n<p>这里用 O3 是因为，如果是 O0 的话，LLVM 就会阻止后面的优化器进行优化（可参见 LLVM 源码）。所以后面又先暂时禁止了 opt 直接自动优化。</p>\n<p>之后开始使用 opt 进行优化。虽然 LLVM 的 pass 依赖会自动管理，但有些必要的准备工作还是不可避免的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opt -mem2reg interchange.ll -S -o  interchange.ll</span><br><span class=\"line\">opt -loop-rotate interchange.ll -S -o interchange.ll</span><br><span class=\"line\">opt -loop-interchange interchange.ll -S -o opt.ll</span><br></pre></td></tr></table></figure>\n<p>这样就生成了 <code>interchange.ll</code> 和 <code>opt.ll</code> 两个 IR 代码文件。用 llc 来将他们转换成汇编代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">llc interchange.ll -o un.s</span><br><span class=\"line\">llc opt.ll -o opt.s</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/LLVM循环优化/nointerchange.jpg\" alt=\"nointerchange\"></p>\n<p>在未优化的汇编代码中，可以看到循环和 C 语言中的一样，内层为 333 次，而外层为 222 次。</p>\n<p><img src=\"/img/LLVM循环优化/interchange.png\" alt=\"interchange\"></p>\n<p>而在 Loop Interchange 之后，我们可以发现两个循环的顺序被颠倒了。</p>\n<p>将汇编代码编译为可执行文件。为了让 gem5 模拟器运行，需要静态链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang opt.s -o interchange --static</span><br><span class=\"line\">clang un.s -o interchange_no --static</span><br></pre></td></tr></table></figure>\n<p>经过 gem5 模拟，优化前执行了 1837199000 个 tick，优化后是 1767821000 个 tick。可以发现优化后程序运行的时间变短了。之前提到过，interchange 可以提高 cache 的命中率。优化前的数据：</p>\n<p><img src=\"/img/LLVM循环优化/no_interchange_cache.png\" alt=\"no_interchange_cache\"></p>\n<p>优化后：</p>\n<p><img src=\"/img/LLVM循环优化/interchange_cache.png\" alt=\"interchange_cache\"></p>\n<p>我们可以看到 data cache 的 miss rate 确实下降了一点，好像不是很明显，但是，miss 次数确实是大幅下降了的。</p>\n<h2 id=\"Loop-Unswitch\"><a href=\"#Loop-Unswitch\" class=\"headerlink\" title=\"Loop Unswitch\"></a>Loop Unswitch</h2><p>下面的代码可以用来测试 Loop Unswitch：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, a[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> w = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1024</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w == <span class=\"number\">999</span>) &#123;</span><br><span class=\"line\">            a[i] = <span class=\"number\">555</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            a[i] = <span class=\"number\">666</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Loop Unswitch 可以将循环内的条件判断语句移到循环外部，从而在不影响运行结果的前提下节约不必要的判断语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -O3 -mllvm -disable-llvm-optzns unswitch.c -emit-llvm -S -o unswitch.ll</span><br><span class=\"line\">opt -mem2reg unswitch.ll -S -o unswitch.ll</span><br><span class=\"line\">opt -loop-unswitch unswitch.ll -S -o opt.ll</span><br></pre></td></tr></table></figure>\n<p>未优化时的 IR 代码如下：</p>\n<p><img src=\"/img/LLVM循环优化/nounswitch.jpg\" alt=\"nounswitch\"></p>\n<p>可以看到判断语句和 C 语言中的一致，在循环内部。而优化后：</p>\n<p><img src=\"/img/LLVM循环优化/unswitch.jpg\" alt=\"unswitch\"></p>\n<p>原来的循环被拆成了两个独立的循环（判断语句在循环外）。我有时展示 IR 代码，有时展示汇编代码的原因是，有时 IR 代码更加易读，有时汇编代码更易读。但由于汇编代码时从 IR 代码翻译来的，所以本质上是一致的。</p>\n<p>经 gem5 模拟，未优化时用了 101847000 个 tick，而优化后使用了 93526000 个 tick。程序耗时减少了。</p>\n<h2 id=\"Loop-Reduce\"><a href=\"#Loop-Reduce\" class=\"headerlink\" title=\"Loop Reduce\"></a>Loop Reduce</h2><p>下面的代码可以用来测试 Loop Reduce：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">97</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1024</span>; i++) &#123;</span><br><span class=\"line\">        a[i] = i * c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 CPU 指令中，有的指令更加耗时。比较耗时的指令一般有 load, store, 以及乘除法等等。Loop Reduce 可以把一些较为耗时的代码转化为更快的指令。比如，这里的乘法就可以优化为累加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -O3 -mllvm -disable-llvm-optzns reduce.c -emit-llvm -S -o reduce.ll</span><br><span class=\"line\">opt -mem2reg -loop-reduce reduce.ll -S -o opt.ll</span><br></pre></td></tr></table></figure>\n<p>未优化时：</p>\n<p><img src=\"/img/LLVM循环优化/noreduce.png\" alt=\"noreduce\"></p>\n<p>可以看大 IR 代码中使用了 mul 指令。这是比较耗时的。</p>\n<p>而优化后：</p>\n<p><img src=\"/img/LLVM循环优化/reduce.png\" alt=\"reduce\"></p>\n<p>可以看到 LLVM 把乘法转换成了加法。而加法操作就要快多了。</p>\n<p>经过 gem5 模拟，未优化时消耗了 115056000 个 tick，而优化后只用了 98250000 个 tick。还是加快了许多的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>LLVM 还有很多循环优化选项，亦有 polly 循环优化器可以执行更多的优化操作。然而，直接选择优化级别进行优化较为简单，而想要具体指定优化 pass 就较为困难了。一开始我以为是有相关的依赖，但是经过发送邮件询问 LLVM 社区，有人回答 pass 依赖是自动被管理的。想要知道具体的步骤还是较为困难的，我目前也没有找到什么特别好的方法。所以虽然对一些其他的优化很感兴趣，但也没有机会尝试了。有点遗憾。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"LLVM-循环优化\"><a href=\"#LLVM-循环优化\" class=\"headerlink\" title=\"LLVM 循环优化\"></a>LLVM 循环优化</h1><p>LLVM 是一个广为使用的编译器套件，也是苹果官方的编译器。LLVM 前端可以把高级代码转换成 LLVM 自身的中间代码（IR），而后端再把 IR 翻译为目标平台的机器码。而 LLVM 提供的优化器 opt 可以优化 IR 代码，并生成优化过的 IR 代码。在之前的博客中，我已经探索过使用 clang 来优化一个简单的程序。在那个简单的循环程序中，较为影响性能的就是 Loop Unrolling 优化。我也做出了一些性能测试。</p>\n<p>但是，单纯的用 <code>clang -O3</code> 来分析 Loop Unrolling 的性能影响是不科学的。在一个较为复杂的程序中，会有很多处可以优化的地方。而如果想要对比某一种优化策略带来的效果，则最好只做这一种优化（控制变量）。比如，用下面的命令来做 Loop Unrolling 优化，则带来的副作用就少得多：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opt -mem2reg -simplifycfg -loops -lcssa -loop-simplify -loop-rotate -loop-</span><br><span class=\"line\">unroll -unroll-count=4 -unroll-allow-partial input.ll -S -o output.ll</span><br></pre></td></tr></table></figure>\n<h2 id=\"编译-LLVM\"><a href=\"#编译-LLVM\" class=\"headerlink\" title=\"编译 LLVM\"></a>编译 LLVM</h2><p>指定 LLVM opt 要运行的 pass 来控制优化种类没有想象中的那么直观，经常会得不到想要的结果。如果在输入命令的时候带上 <code>-debug</code> 或者 <code>-debug-only=&lt;pass name&gt;</code> 标签，就可以获得一些 debug 的信息，会非常有帮助。然而，直接下载安装的 LLVM 是默认关闭这个选项的。这就需要我们自己编译 LLVM，并在编译时指定打开 assertion <code>-DLLVM_ENABLE_ASSERTIONS=On</code>。</p>\n<p>下载最新版本的 LLVM：</p>\n<p><code>git clone https://github.com/llvm/llvm-project.git</code></p>\n<p>clone 后，cd 进入 llvm-project 文件夹。</p>\n<p>LLVM 不支持直接在工程文件夹下编译，需要我们自己新建一个构建文件夹：</p>\n<p><code>mkdir build</code></p>\n<p><code>cd build</code></p>\n<p>然后开始生成编译所需的文件：</p>\n<p><code>cmake -G &lt;generator&gt; [options] ../llvm</code></p>\n<p>多数开发者都会选择用 Ninja 来编译。所以，要先安装 Ninja。如果在 macOS 下，可以用 brew 来安装：</p>\n<p><code>brew install ninja</code></p>\n<p>一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmake -G &apos;Ninja&apos; -DLLVM_ENABLE_PROJECTS=&apos;clang;&lt;other build targets&gt;&apos; -DCMAKE_INSTALL_PREFIX=&lt;your install path&gt; -DLLVM_ENABLE_ASSERTIONS=On</span><br></pre></td></tr></table></figure>\n<p>稍等一段时间后，就会生成所需要的文件。然后就可以用 Ninja 来编译了：</p>\n<p><code>ninja</code></p>\n<p>编译花费的时间比较久，可能需要几个小时。编译完成之后，就可以用 Ninja 来安装了，安装地址就是之前指定的地址。</p>\n<p><code>ninja install</code></p>\n<p>Ref: <a href=\"http://llvm.org/docs/GettingStarted.html#getting-started-quickly-a-summary\">http://llvm.org/docs/GettingStarted.html#getting-started-quickly-a-summary</a></p>\n<h2 id=\"Loop-Interchange\"><a href=\"#Loop-Interchange\" class=\"headerlink\" title=\"Loop Interchange\"></a>Loop Interchange</h2><p>下面的代码可用来测试 Loop Interchange：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a[<span class=\"number\">333</span>][<span class=\"number\">222</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i &lt;<span class=\"number\">222</span>; i++) &#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">for</span> (j=<span class=\"number\">0</span>; j &lt;<span class=\"number\">333</span>; j++) &#123;</span><br><span class=\"line\">            \t\ta[j][i] = a[j][i] + <span class=\"number\">970815</span>;</span><br><span class=\"line\">    \t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于二维数组在内存中仍是线性排列，因此先在行内循环效率更优。这是因为行内元素的距离更近，符合空间局部性原理，缓存命中率会更高。在上面的程序中，先做了列内循环，所以可能会被 Loop Interchange 优化循环顺序。</p>\n<p>生成 IR 代码，为下一步优化做准备：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -O3 -mllvm -disable-llvm-optzns interchange.c -emit-llvm -S -o interchange.ll</span><br></pre></td></tr></table></figure>\n<p>这里用 O3 是因为，如果是 O0 的话，LLVM 就会阻止后面的优化器进行优化（可参见 LLVM 源码）。所以后面又先暂时禁止了 opt 直接自动优化。</p>\n<p>之后开始使用 opt 进行优化。虽然 LLVM 的 pass 依赖会自动管理，但有些必要的准备工作还是不可避免的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">opt -mem2reg interchange.ll -S -o  interchange.ll</span><br><span class=\"line\">opt -loop-rotate interchange.ll -S -o interchange.ll</span><br><span class=\"line\">opt -loop-interchange interchange.ll -S -o opt.ll</span><br></pre></td></tr></table></figure>\n<p>这样就生成了 <code>interchange.ll</code> 和 <code>opt.ll</code> 两个 IR 代码文件。用 llc 来将他们转换成汇编代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">llc interchange.ll -o un.s</span><br><span class=\"line\">llc opt.ll -o opt.s</span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/LLVM循环优化/nointerchange.jpg\" alt=\"nointerchange\"></p>\n<p>在未优化的汇编代码中，可以看到循环和 C 语言中的一样，内层为 333 次，而外层为 222 次。</p>\n<p><img src=\"/img/LLVM循环优化/interchange.png\" alt=\"interchange\"></p>\n<p>而在 Loop Interchange 之后，我们可以发现两个循环的顺序被颠倒了。</p>\n<p>将汇编代码编译为可执行文件。为了让 gem5 模拟器运行，需要静态链接：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang opt.s -o interchange --static</span><br><span class=\"line\">clang un.s -o interchange_no --static</span><br></pre></td></tr></table></figure>\n<p>经过 gem5 模拟，优化前执行了 1837199000 个 tick，优化后是 1767821000 个 tick。可以发现优化后程序运行的时间变短了。之前提到过，interchange 可以提高 cache 的命中率。优化前的数据：</p>\n<p><img src=\"/img/LLVM循环优化/no_interchange_cache.png\" alt=\"no_interchange_cache\"></p>\n<p>优化后：</p>\n<p><img src=\"/img/LLVM循环优化/interchange_cache.png\" alt=\"interchange_cache\"></p>\n<p>我们可以看到 data cache 的 miss rate 确实下降了一点，好像不是很明显，但是，miss 次数确实是大幅下降了的。</p>\n<h2 id=\"Loop-Unswitch\"><a href=\"#Loop-Unswitch\" class=\"headerlink\" title=\"Loop Unswitch\"></a>Loop Unswitch</h2><p>下面的代码可以用来测试 Loop Unswitch：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>, a[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> w = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1024</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w == <span class=\"number\">999</span>) &#123;</span><br><span class=\"line\">            a[i] = <span class=\"number\">555</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            a[i] = <span class=\"number\">666</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Loop Unswitch 可以将循环内的条件判断语句移到循环外部，从而在不影响运行结果的前提下节约不必要的判断语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -O3 -mllvm -disable-llvm-optzns unswitch.c -emit-llvm -S -o unswitch.ll</span><br><span class=\"line\">opt -mem2reg unswitch.ll -S -o unswitch.ll</span><br><span class=\"line\">opt -loop-unswitch unswitch.ll -S -o opt.ll</span><br></pre></td></tr></table></figure>\n<p>未优化时的 IR 代码如下：</p>\n<p><img src=\"/img/LLVM循环优化/nounswitch.jpg\" alt=\"nounswitch\"></p>\n<p>可以看到判断语句和 C 语言中的一致，在循环内部。而优化后：</p>\n<p><img src=\"/img/LLVM循环优化/unswitch.jpg\" alt=\"unswitch\"></p>\n<p>原来的循环被拆成了两个独立的循环（判断语句在循环外）。我有时展示 IR 代码，有时展示汇编代码的原因是，有时 IR 代码更加易读，有时汇编代码更易读。但由于汇编代码时从 IR 代码翻译来的，所以本质上是一致的。</p>\n<p>经 gem5 模拟，未优化时用了 101847000 个 tick，而优化后使用了 93526000 个 tick。程序耗时减少了。</p>\n<h2 id=\"Loop-Reduce\"><a href=\"#Loop-Reduce\" class=\"headerlink\" title=\"Loop Reduce\"></a>Loop Reduce</h2><p>下面的代码可以用来测试 Loop Reduce：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = <span class=\"number\">97</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">1024</span>; i++) &#123;</span><br><span class=\"line\">        a[i] = i * c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 CPU 指令中，有的指令更加耗时。比较耗时的指令一般有 load, store, 以及乘除法等等。Loop Reduce 可以把一些较为耗时的代码转化为更快的指令。比如，这里的乘法就可以优化为累加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clang -O3 -mllvm -disable-llvm-optzns reduce.c -emit-llvm -S -o reduce.ll</span><br><span class=\"line\">opt -mem2reg -loop-reduce reduce.ll -S -o opt.ll</span><br></pre></td></tr></table></figure>\n<p>未优化时：</p>\n<p><img src=\"/img/LLVM循环优化/noreduce.png\" alt=\"noreduce\"></p>\n<p>可以看大 IR 代码中使用了 mul 指令。这是比较耗时的。</p>\n<p>而优化后：</p>\n<p><img src=\"/img/LLVM循环优化/reduce.png\" alt=\"reduce\"></p>\n<p>可以看到 LLVM 把乘法转换成了加法。而加法操作就要快多了。</p>\n<p>经过 gem5 模拟，未优化时消耗了 115056000 个 tick，而优化后只用了 98250000 个 tick。还是加快了许多的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>LLVM 还有很多循环优化选项，亦有 polly 循环优化器可以执行更多的优化操作。然而，直接选择优化级别进行优化较为简单，而想要具体指定优化 pass 就较为困难了。一开始我以为是有相关的依赖，但是经过发送邮件询问 LLVM 社区，有人回答 pass 依赖是自动被管理的。想要知道具体的步骤还是较为困难的，我目前也没有找到什么特别好的方法。所以虽然对一些其他的优化很感兴趣，但也没有机会尝试了。有点遗憾。</p>\n"},{"title":"Obj-C内存管理","date":"2018-02-28T09:07:35.000Z","_content":"\n# Obj-C 内存管理\n\n### 手动引用计数（Manual Reference Counting, MRC)\n\n对一个对象发送 `retain` 消息，该对象引用计数加一；反之，对它发送 `release` 消息，对象的引用计数会减一。但是，实际上释放内存的消息并不是 release，而是 `dealloc` 方法。当对象的引用计数达到 0 时，OC 会自动调用 `dealloc` 方法去释放内存，而不需要手动调用。\n\n### 测试 MRC\n\n首先需要关闭 Xcode 的自动引用计数功能，否则编译器会报错。\n\n在 Building Settings 中搜索 reference counting，将 `Objective-C Automatic Reference Counting` 设置为 NO。\n\n执行下面的代码：\n\n```objective-c\n#import <Foundation/NSObject.h>\n#import <stdio.h>\n\nint main() {\n    id obj = [[NSObject alloc] init];\n    printf(\"%d\\n\", (int)[obj retainCount]); //打印当前对象的引用计数\n    [obj retain];\n    [obj retain];\n    printf(\"%d\\n\", (int)[obj retainCount]);\n    [obj release];\n    printf(\"%d\\n\", (int)[obj retainCount]);\n    return 0;\n}\n```\n\n控制台输出：\n\n```\n1\n3\n2\n```\n\n### 释放对象\n\n为了彻底销毁对象，也需要给对象所持有的变量发送 release 消息。\n\n由于真正释放内存的是 `dealloc` 方法，因此需要重写该方法，向类中所有变量发送 release 消息，放弃它们的所有权（ownership）。\n\n```objective-c\n- (void)dealloc {\n    /* 发送 release 消息\n    和其他的善后工作 */\n    [super dealloc];\n}\n```\n\n### 自动释放 (Autorelease)\n\n许多对象使用一次后就不再使用了。Cocoa 提供了自动释放机制，可以把要发送 release 消息的对象都记录下来，再统一发送。\n\n```objective-c\n#import <Foundation/Foundation.h>\n#import <stdio.h>\n\nint main() {\n    id pool = [[NSAutoreleasePool alloc] init];\n    //池内\n    id obj = [[NSObject alloc] init];\n    [obj retain];\n    printf(\"%d\\n\", (int)[obj retainCount]);\n    [obj autorelease];\n    printf(\"%d\\n\", (int)[obj retainCount]);\n    [pool release];\n    printf(\"%d\\n\", (int)[obj retainCount]);\n    return 0;\n}\n```\n\n控制台打印：\n\n```\n2\n2\n1\n```\n\n也可以用新的方式：\n\n```objective-c\n@autoreleasepool {\n//池内\n}\n```\n\n使用新方式更加高效、性能更好，且可以在池内使用 `break` `return` `goto` 等语句，因为只要运行到块外就会出发自动释放池释放内存，而传统方式中，如果使用跳转语句越过 `[pool release];` 将会导致内存无法释放。\n\n一般在大量使用临时变量的循环开始前创建自己的自动释放池，并在循环结束后释放。\n\nCocoa 会在程序开始处理事件前，隐式的创造一个自动释放池以支持 runloop 的资源释放。因此在做 GUI 编程时，不需要手动创造自动释放池也可以使用临时对象。\n\n在支持垃圾回收的环境中，`[pool release]` 不做任何操作(no-op)，而应该使用 `drain` 去触发 GC （抽干池子）。在 iOS 中，drain 和 release 等价，因为 iOS 不支持 GC。\n\n### 便利构造函数\n\n在内部调用别的构造函数的构造函数，成为便利构造函数。\n\nOC 中的一些便利构造函数可以创建临时变量，并自动加入到自动释放池中，而无需关心如何销毁它们。这些便利构造函数不以 init 开头，而是以类型名开头，如 `+ (id) stringWithUTF8String: (const char*) bytes` 。\n\n### 自动引用计数 (ARC)\n\n手动引用计数需要程序员管理所有生成对象的所有权，在适当的地方插入 `retain` , `release` , `autorelease` 代码。自动引用计数会在编译时推断应在何处插入这些代码，并自动插入，不需要程序员自己管理。\n\n使用 ARC 并不意味着完全不需要管理内存了。ARC 只能管理 OC 对象，不能管理 `malloc` 申请的内存，需要程序员自己用 `free` 函数释放。\n\n使用 ARC，与引用计数相关的方法将被禁止使用，`NSAutoreleasePool` 也无法使用，但是仍可以使用 `@autoreleasepool{}` 。\n\n不能随意定义 `alloc/init/new/copy/mutableCopy` 开头的，且以所有权操作无关的方法。\n\n### 什么时候需要用 @autoreleasepool\n\n多数情况我们不需要显示地使用 @autoreleasepool，因为 runloop 会自动创建自动释放池。\n\n但是在以下情况下需要使用：\n\n- 不基于 UI Framework 的程序，如控制台程序。因为没有 runloop 为我们创建自动释放池了。\n- 循环中大量创建临时变量，可能在 runloop 没结束时就已经耗尽内存。\n\n```objective-c\nint main() {\n    for(int i = 0; i <10000000; i++) {\n        @autoreleasepool {\n            NSNumber *num = [NSNumber numberWithInt:i];\n            NSString *str = [NSString stringWithFormat:@\"%d \", i];\n            [NSString stringWithFormat:@\"%@%@\", num, str]; //为什么这行是必要的？\n        }\n    }\n    return 0;\n}\n```\n\n如果不使用 autoreleasepool，内存将会激增。使用之后，则一直维持在一个很低的水平。注意，如果是在循环中实例化了类，就不会出现类似的问题。在作用域之外，系统会自动帮我们释放对象。\n\n**遗留的问题** 为什么一定要使用 num 和 str ？如果把该行注释掉，就观察不到实验现象了。\n\n### 弱引用\n\n为避免交叉引用导致内存泄漏，我们需要弱引用。弱引用指向对象，却不改变它的引用计数。弱引用会在它指向的对象被释放掉后自动变成 nil 从而避免出现野指针，这被称为自动 nil 化。\n\n使用 ARC 时应该尽量让对象之间的关系成树状结构，避免循环引用。如果一定要互相引用，一方面可以使用弱引用，另一方面也可以手动给一个引用赋值为 nil 从而打破循环。","source":"_posts/Obj-C内存管理.md","raw":"---\ntitle: Obj-C内存管理\ndate: 2018-02-28 17:07:35\ntags: Obj-C\n---\n\n# Obj-C 内存管理\n\n### 手动引用计数（Manual Reference Counting, MRC)\n\n对一个对象发送 `retain` 消息，该对象引用计数加一；反之，对它发送 `release` 消息，对象的引用计数会减一。但是，实际上释放内存的消息并不是 release，而是 `dealloc` 方法。当对象的引用计数达到 0 时，OC 会自动调用 `dealloc` 方法去释放内存，而不需要手动调用。\n\n### 测试 MRC\n\n首先需要关闭 Xcode 的自动引用计数功能，否则编译器会报错。\n\n在 Building Settings 中搜索 reference counting，将 `Objective-C Automatic Reference Counting` 设置为 NO。\n\n执行下面的代码：\n\n```objective-c\n#import <Foundation/NSObject.h>\n#import <stdio.h>\n\nint main() {\n    id obj = [[NSObject alloc] init];\n    printf(\"%d\\n\", (int)[obj retainCount]); //打印当前对象的引用计数\n    [obj retain];\n    [obj retain];\n    printf(\"%d\\n\", (int)[obj retainCount]);\n    [obj release];\n    printf(\"%d\\n\", (int)[obj retainCount]);\n    return 0;\n}\n```\n\n控制台输出：\n\n```\n1\n3\n2\n```\n\n### 释放对象\n\n为了彻底销毁对象，也需要给对象所持有的变量发送 release 消息。\n\n由于真正释放内存的是 `dealloc` 方法，因此需要重写该方法，向类中所有变量发送 release 消息，放弃它们的所有权（ownership）。\n\n```objective-c\n- (void)dealloc {\n    /* 发送 release 消息\n    和其他的善后工作 */\n    [super dealloc];\n}\n```\n\n### 自动释放 (Autorelease)\n\n许多对象使用一次后就不再使用了。Cocoa 提供了自动释放机制，可以把要发送 release 消息的对象都记录下来，再统一发送。\n\n```objective-c\n#import <Foundation/Foundation.h>\n#import <stdio.h>\n\nint main() {\n    id pool = [[NSAutoreleasePool alloc] init];\n    //池内\n    id obj = [[NSObject alloc] init];\n    [obj retain];\n    printf(\"%d\\n\", (int)[obj retainCount]);\n    [obj autorelease];\n    printf(\"%d\\n\", (int)[obj retainCount]);\n    [pool release];\n    printf(\"%d\\n\", (int)[obj retainCount]);\n    return 0;\n}\n```\n\n控制台打印：\n\n```\n2\n2\n1\n```\n\n也可以用新的方式：\n\n```objective-c\n@autoreleasepool {\n//池内\n}\n```\n\n使用新方式更加高效、性能更好，且可以在池内使用 `break` `return` `goto` 等语句，因为只要运行到块外就会出发自动释放池释放内存，而传统方式中，如果使用跳转语句越过 `[pool release];` 将会导致内存无法释放。\n\n一般在大量使用临时变量的循环开始前创建自己的自动释放池，并在循环结束后释放。\n\nCocoa 会在程序开始处理事件前，隐式的创造一个自动释放池以支持 runloop 的资源释放。因此在做 GUI 编程时，不需要手动创造自动释放池也可以使用临时对象。\n\n在支持垃圾回收的环境中，`[pool release]` 不做任何操作(no-op)，而应该使用 `drain` 去触发 GC （抽干池子）。在 iOS 中，drain 和 release 等价，因为 iOS 不支持 GC。\n\n### 便利构造函数\n\n在内部调用别的构造函数的构造函数，成为便利构造函数。\n\nOC 中的一些便利构造函数可以创建临时变量，并自动加入到自动释放池中，而无需关心如何销毁它们。这些便利构造函数不以 init 开头，而是以类型名开头，如 `+ (id) stringWithUTF8String: (const char*) bytes` 。\n\n### 自动引用计数 (ARC)\n\n手动引用计数需要程序员管理所有生成对象的所有权，在适当的地方插入 `retain` , `release` , `autorelease` 代码。自动引用计数会在编译时推断应在何处插入这些代码，并自动插入，不需要程序员自己管理。\n\n使用 ARC 并不意味着完全不需要管理内存了。ARC 只能管理 OC 对象，不能管理 `malloc` 申请的内存，需要程序员自己用 `free` 函数释放。\n\n使用 ARC，与引用计数相关的方法将被禁止使用，`NSAutoreleasePool` 也无法使用，但是仍可以使用 `@autoreleasepool{}` 。\n\n不能随意定义 `alloc/init/new/copy/mutableCopy` 开头的，且以所有权操作无关的方法。\n\n### 什么时候需要用 @autoreleasepool\n\n多数情况我们不需要显示地使用 @autoreleasepool，因为 runloop 会自动创建自动释放池。\n\n但是在以下情况下需要使用：\n\n- 不基于 UI Framework 的程序，如控制台程序。因为没有 runloop 为我们创建自动释放池了。\n- 循环中大量创建临时变量，可能在 runloop 没结束时就已经耗尽内存。\n\n```objective-c\nint main() {\n    for(int i = 0; i <10000000; i++) {\n        @autoreleasepool {\n            NSNumber *num = [NSNumber numberWithInt:i];\n            NSString *str = [NSString stringWithFormat:@\"%d \", i];\n            [NSString stringWithFormat:@\"%@%@\", num, str]; //为什么这行是必要的？\n        }\n    }\n    return 0;\n}\n```\n\n如果不使用 autoreleasepool，内存将会激增。使用之后，则一直维持在一个很低的水平。注意，如果是在循环中实例化了类，就不会出现类似的问题。在作用域之外，系统会自动帮我们释放对象。\n\n**遗留的问题** 为什么一定要使用 num 和 str ？如果把该行注释掉，就观察不到实验现象了。\n\n### 弱引用\n\n为避免交叉引用导致内存泄漏，我们需要弱引用。弱引用指向对象，却不改变它的引用计数。弱引用会在它指向的对象被释放掉后自动变成 nil 从而避免出现野指针，这被称为自动 nil 化。\n\n使用 ARC 时应该尽量让对象之间的关系成树状结构，避免循环引用。如果一定要互相引用，一方面可以使用弱引用，另一方面也可以手动给一个引用赋值为 nil 从而打破循环。","slug":"Obj-C内存管理","published":1,"updated":"2020-01-04T08:16:16.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv2v0007ljc3skwvpnii","content":"<h1 id=\"Obj-C-内存管理\"><a href=\"#Obj-C-内存管理\" class=\"headerlink\" title=\"Obj-C 内存管理\"></a>Obj-C 内存管理</h1><h3 id=\"手动引用计数（Manual-Reference-Counting-MRC\"><a href=\"#手动引用计数（Manual-Reference-Counting-MRC\" class=\"headerlink\" title=\"手动引用计数（Manual Reference Counting, MRC)\"></a>手动引用计数（Manual Reference Counting, MRC)</h3><p>对一个对象发送 <code>retain</code> 消息，该对象引用计数加一；反之，对它发送 <code>release</code> 消息，对象的引用计数会减一。但是，实际上释放内存的消息并不是 release，而是 <code>dealloc</code> 方法。当对象的引用计数达到 0 时，OC 会自动调用 <code>dealloc</code> 方法去释放内存，而不需要手动调用。</p>\n<h3 id=\"测试-MRC\"><a href=\"#测试-MRC\" class=\"headerlink\" title=\"测试 MRC\"></a>测试 MRC</h3><p>首先需要关闭 Xcode 的自动引用计数功能，否则编译器会报错。</p>\n<p>在 Building Settings 中搜索 reference counting，将 <code>Objective-C Automatic Reference Counting</code> 设置为 NO。</p>\n<p>执行下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/NSObject.h&gt;</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    id obj = [[NSObject alloc] init];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]); //打印当前对象的引用计数</span><br><span class=\"line\">    [obj retain];</span><br><span class=\"line\">    [obj retain];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]);</span><br><span class=\"line\">    [obj release];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<h3 id=\"释放对象\"><a href=\"#释放对象\" class=\"headerlink\" title=\"释放对象\"></a>释放对象</h3><p>为了彻底销毁对象，也需要给对象所持有的变量发送 release 消息。</p>\n<p>由于真正释放内存的是 <code>dealloc</code> 方法，因此需要重写该方法，向类中所有变量发送 release 消息，放弃它们的所有权（ownership）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)dealloc &#123;</span><br><span class=\"line\">    /* 发送 release 消息</span><br><span class=\"line\">    和其他的善后工作 */</span><br><span class=\"line\">    [super dealloc];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动释放-Autorelease\"><a href=\"#自动释放-Autorelease\" class=\"headerlink\" title=\"自动释放 (Autorelease)\"></a>自动释放 (Autorelease)</h3><p>许多对象使用一次后就不再使用了。Cocoa 提供了自动释放机制，可以把要发送 release 消息的对象都记录下来，再统一发送。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    id pool = [[NSAutoreleasePool alloc] init];</span><br><span class=\"line\">    //池内</span><br><span class=\"line\">    id obj = [[NSObject alloc] init];</span><br><span class=\"line\">    [obj retain];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]);</span><br><span class=\"line\">    [obj autorelease];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]);</span><br><span class=\"line\">    [pool release];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台打印：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n<p>也可以用新的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autoreleasepool &#123;</span><br><span class=\"line\">//池内</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用新方式更加高效、性能更好，且可以在池内使用 <code>break</code> <code>return</code> <code>goto</code> 等语句，因为只要运行到块外就会出发自动释放池释放内存，而传统方式中，如果使用跳转语句越过 <code>[pool release];</code> 将会导致内存无法释放。</p>\n<p>一般在大量使用临时变量的循环开始前创建自己的自动释放池，并在循环结束后释放。</p>\n<p>Cocoa 会在程序开始处理事件前，隐式的创造一个自动释放池以支持 runloop 的资源释放。因此在做 GUI 编程时，不需要手动创造自动释放池也可以使用临时对象。</p>\n<p>在支持垃圾回收的环境中，<code>[pool release]</code> 不做任何操作(no-op)，而应该使用 <code>drain</code> 去触发 GC （抽干池子）。在 iOS 中，drain 和 release 等价，因为 iOS 不支持 GC。</p>\n<h3 id=\"便利构造函数\"><a href=\"#便利构造函数\" class=\"headerlink\" title=\"便利构造函数\"></a>便利构造函数</h3><p>在内部调用别的构造函数的构造函数，成为便利构造函数。</p>\n<p>OC 中的一些便利构造函数可以创建临时变量，并自动加入到自动释放池中，而无需关心如何销毁它们。这些便利构造函数不以 init 开头，而是以类型名开头，如 <code>+ (id) stringWithUTF8String: (const char*) bytes</code> 。</p>\n<h3 id=\"自动引用计数-ARC\"><a href=\"#自动引用计数-ARC\" class=\"headerlink\" title=\"自动引用计数 (ARC)\"></a>自动引用计数 (ARC)</h3><p>手动引用计数需要程序员管理所有生成对象的所有权，在适当的地方插入 <code>retain</code> , <code>release</code> , <code>autorelease</code> 代码。自动引用计数会在编译时推断应在何处插入这些代码，并自动插入，不需要程序员自己管理。</p>\n<p>使用 ARC 并不意味着完全不需要管理内存了。ARC 只能管理 OC 对象，不能管理 <code>malloc</code> 申请的内存，需要程序员自己用 <code>free</code> 函数释放。</p>\n<p>使用 ARC，与引用计数相关的方法将被禁止使用，<code>NSAutoreleasePool</code> 也无法使用，但是仍可以使用 <code>@autoreleasepool{}</code> 。</p>\n<p>不能随意定义 <code>alloc/init/new/copy/mutableCopy</code> 开头的，且以所有权操作无关的方法。</p>\n<h3 id=\"什么时候需要用-autoreleasepool\"><a href=\"#什么时候需要用-autoreleasepool\" class=\"headerlink\" title=\"什么时候需要用 @autoreleasepool\"></a>什么时候需要用 @autoreleasepool</h3><p>多数情况我们不需要显示地使用 @autoreleasepool，因为 runloop 会自动创建自动释放池。</p>\n<p>但是在以下情况下需要使用：</p>\n<ul>\n<li>不基于 UI Framework 的程序，如控制台程序。因为没有 runloop 为我们创建自动释放池了。</li>\n<li>循环中大量创建临时变量，可能在 runloop 没结束时就已经耗尽内存。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    for(int i = 0; i &lt;10000000; i++) &#123;</span><br><span class=\"line\">        @autoreleasepool &#123;</span><br><span class=\"line\">            NSNumber *num = [NSNumber numberWithInt:i];</span><br><span class=\"line\">            NSString *str = [NSString stringWithFormat:@&quot;%d &quot;, i];</span><br><span class=\"line\">            [NSString stringWithFormat:@&quot;%@%@&quot;, num, str]; //为什么这行是必要的？</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果不使用 autoreleasepool，内存将会激增。使用之后，则一直维持在一个很低的水平。注意，如果是在循环中实例化了类，就不会出现类似的问题。在作用域之外，系统会自动帮我们释放对象。</p>\n<p><strong>遗留的问题</strong> 为什么一定要使用 num 和 str ？如果把该行注释掉，就观察不到实验现象了。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>为避免交叉引用导致内存泄漏，我们需要弱引用。弱引用指向对象，却不改变它的引用计数。弱引用会在它指向的对象被释放掉后自动变成 nil 从而避免出现野指针，这被称为自动 nil 化。</p>\n<p>使用 ARC 时应该尽量让对象之间的关系成树状结构，避免循环引用。如果一定要互相引用，一方面可以使用弱引用，另一方面也可以手动给一个引用赋值为 nil 从而打破循环。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Obj-C-内存管理\"><a href=\"#Obj-C-内存管理\" class=\"headerlink\" title=\"Obj-C 内存管理\"></a>Obj-C 内存管理</h1><h3 id=\"手动引用计数（Manual-Reference-Counting-MRC\"><a href=\"#手动引用计数（Manual-Reference-Counting-MRC\" class=\"headerlink\" title=\"手动引用计数（Manual Reference Counting, MRC)\"></a>手动引用计数（Manual Reference Counting, MRC)</h3><p>对一个对象发送 <code>retain</code> 消息，该对象引用计数加一；反之，对它发送 <code>release</code> 消息，对象的引用计数会减一。但是，实际上释放内存的消息并不是 release，而是 <code>dealloc</code> 方法。当对象的引用计数达到 0 时，OC 会自动调用 <code>dealloc</code> 方法去释放内存，而不需要手动调用。</p>\n<h3 id=\"测试-MRC\"><a href=\"#测试-MRC\" class=\"headerlink\" title=\"测试 MRC\"></a>测试 MRC</h3><p>首先需要关闭 Xcode 的自动引用计数功能，否则编译器会报错。</p>\n<p>在 Building Settings 中搜索 reference counting，将 <code>Objective-C Automatic Reference Counting</code> 设置为 NO。</p>\n<p>执行下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/NSObject.h&gt;</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    id obj = [[NSObject alloc] init];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]); //打印当前对象的引用计数</span><br><span class=\"line\">    [obj retain];</span><br><span class=\"line\">    [obj retain];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]);</span><br><span class=\"line\">    [obj release];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n<h3 id=\"释放对象\"><a href=\"#释放对象\" class=\"headerlink\" title=\"释放对象\"></a>释放对象</h3><p>为了彻底销毁对象，也需要给对象所持有的变量发送 release 消息。</p>\n<p>由于真正释放内存的是 <code>dealloc</code> 方法，因此需要重写该方法，向类中所有变量发送 release 消息，放弃它们的所有权（ownership）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)dealloc &#123;</span><br><span class=\"line\">    /* 发送 release 消息</span><br><span class=\"line\">    和其他的善后工作 */</span><br><span class=\"line\">    [super dealloc];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动释放-Autorelease\"><a href=\"#自动释放-Autorelease\" class=\"headerlink\" title=\"自动释放 (Autorelease)\"></a>自动释放 (Autorelease)</h3><p>许多对象使用一次后就不再使用了。Cocoa 提供了自动释放机制，可以把要发送 release 消息的对象都记录下来，再统一发送。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#import &lt;Foundation/Foundation.h&gt;</span><br><span class=\"line\">#import &lt;stdio.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    id pool = [[NSAutoreleasePool alloc] init];</span><br><span class=\"line\">    //池内</span><br><span class=\"line\">    id obj = [[NSObject alloc] init];</span><br><span class=\"line\">    [obj retain];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]);</span><br><span class=\"line\">    [obj autorelease];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]);</span><br><span class=\"line\">    [pool release];</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, (int)[obj retainCount]);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台打印：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">2</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n<p>也可以用新的方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autoreleasepool &#123;</span><br><span class=\"line\">//池内</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用新方式更加高效、性能更好，且可以在池内使用 <code>break</code> <code>return</code> <code>goto</code> 等语句，因为只要运行到块外就会出发自动释放池释放内存，而传统方式中，如果使用跳转语句越过 <code>[pool release];</code> 将会导致内存无法释放。</p>\n<p>一般在大量使用临时变量的循环开始前创建自己的自动释放池，并在循环结束后释放。</p>\n<p>Cocoa 会在程序开始处理事件前，隐式的创造一个自动释放池以支持 runloop 的资源释放。因此在做 GUI 编程时，不需要手动创造自动释放池也可以使用临时对象。</p>\n<p>在支持垃圾回收的环境中，<code>[pool release]</code> 不做任何操作(no-op)，而应该使用 <code>drain</code> 去触发 GC （抽干池子）。在 iOS 中，drain 和 release 等价，因为 iOS 不支持 GC。</p>\n<h3 id=\"便利构造函数\"><a href=\"#便利构造函数\" class=\"headerlink\" title=\"便利构造函数\"></a>便利构造函数</h3><p>在内部调用别的构造函数的构造函数，成为便利构造函数。</p>\n<p>OC 中的一些便利构造函数可以创建临时变量，并自动加入到自动释放池中，而无需关心如何销毁它们。这些便利构造函数不以 init 开头，而是以类型名开头，如 <code>+ (id) stringWithUTF8String: (const char*) bytes</code> 。</p>\n<h3 id=\"自动引用计数-ARC\"><a href=\"#自动引用计数-ARC\" class=\"headerlink\" title=\"自动引用计数 (ARC)\"></a>自动引用计数 (ARC)</h3><p>手动引用计数需要程序员管理所有生成对象的所有权，在适当的地方插入 <code>retain</code> , <code>release</code> , <code>autorelease</code> 代码。自动引用计数会在编译时推断应在何处插入这些代码，并自动插入，不需要程序员自己管理。</p>\n<p>使用 ARC 并不意味着完全不需要管理内存了。ARC 只能管理 OC 对象，不能管理 <code>malloc</code> 申请的内存，需要程序员自己用 <code>free</code> 函数释放。</p>\n<p>使用 ARC，与引用计数相关的方法将被禁止使用，<code>NSAutoreleasePool</code> 也无法使用，但是仍可以使用 <code>@autoreleasepool{}</code> 。</p>\n<p>不能随意定义 <code>alloc/init/new/copy/mutableCopy</code> 开头的，且以所有权操作无关的方法。</p>\n<h3 id=\"什么时候需要用-autoreleasepool\"><a href=\"#什么时候需要用-autoreleasepool\" class=\"headerlink\" title=\"什么时候需要用 @autoreleasepool\"></a>什么时候需要用 @autoreleasepool</h3><p>多数情况我们不需要显示地使用 @autoreleasepool，因为 runloop 会自动创建自动释放池。</p>\n<p>但是在以下情况下需要使用：</p>\n<ul>\n<li>不基于 UI Framework 的程序，如控制台程序。因为没有 runloop 为我们创建自动释放池了。</li>\n<li>循环中大量创建临时变量，可能在 runloop 没结束时就已经耗尽内存。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main() &#123;</span><br><span class=\"line\">    for(int i = 0; i &lt;10000000; i++) &#123;</span><br><span class=\"line\">        @autoreleasepool &#123;</span><br><span class=\"line\">            NSNumber *num = [NSNumber numberWithInt:i];</span><br><span class=\"line\">            NSString *str = [NSString stringWithFormat:@&quot;%d &quot;, i];</span><br><span class=\"line\">            [NSString stringWithFormat:@&quot;%@%@&quot;, num, str]; //为什么这行是必要的？</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果不使用 autoreleasepool，内存将会激增。使用之后，则一直维持在一个很低的水平。注意，如果是在循环中实例化了类，就不会出现类似的问题。在作用域之外，系统会自动帮我们释放对象。</p>\n<p><strong>遗留的问题</strong> 为什么一定要使用 num 和 str ？如果把该行注释掉，就观察不到实验现象了。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>为避免交叉引用导致内存泄漏，我们需要弱引用。弱引用指向对象，却不改变它的引用计数。弱引用会在它指向的对象被释放掉后自动变成 nil 从而避免出现野指针，这被称为自动 nil 化。</p>\n<p>使用 ARC 时应该尽量让对象之间的关系成树状结构，避免循环引用。如果一定要互相引用，一方面可以使用弱引用，另一方面也可以手动给一个引用赋值为 nil 从而打破循环。</p>\n"},{"title":"Linux下使用gperftools","date":"2019-03-23T14:20:50.000Z","_content":"\n# Linux 下使用 gperftools\n\n常用的性能分析工具有很多，比如 gprof，perf 等等。然而，它们似乎对 GCC 更友好。如果想要对 LLVM 编译出来的程序做分析，推荐 Google 的性能分析工具，Google gperftools。\n\n凭借官方只言片语的解释，安装使用 gperftools 还是有点困难的：\n\nhttps://gperftools.github.io/gperftools/cpuprofile.html\n\nhttps://github.com/gperftools/gperftools\n\n## 安装\n\n`sudo apt-get install libunwind-dev`\n\n`sudo apt-get install google-perftools libgoogle-perftools-dev`\n\n推荐安装一款可视化软件，方便查看性能分析结果：\n\n`sudo apt-get install kcachegrind`\n\n## 使用\n\n编写测试程序的时候，注意需要让程序有一定的运行时间。由于 gperftools 是通过采样来做分析的，如果程序太短很快就退出了，就不会有输出结果。\n\n之后，在用 Clang 编译的时候，链接上 gperftools 的库：\n\n`clang test.c -lprofiler -o test`\n\n这样，性能分析的代码就已经注入到程序里了。运行时，要指定输出文件路径：\n\n`env CPUPROFILE=./test.prof ./test`\n\n这样，输出文件会存放在当前目录下的 `test.prof` 文件中。\n\n可以通过 `pprof` 工具来查看：\n\n`google-pprof -text test test.prof`\n\n如果要使用刚刚所说的可视化工具，要先把输出文件转换成该工具支持的类型：\n\n`google-pprof --callgrind /usr/bin/python ./test.prof > ./test.txt `\n\n然后再用 `kcachegrind` 工具打开：\n\n`kcachegrind test.txt`\n\n截图如下：\n\n![screenshot](/img/使用gperftools/screenshot.png)\n\n当然，Google gproftools 是非常强大的工具，还有更多的功能值得探索。","source":"_posts/Linux下使用gperftools.md","raw":"---\ntitle: Linux下使用gperftools\ndate: 2019-03-23 22:20:50\ntags: perf\n---\n\n# Linux 下使用 gperftools\n\n常用的性能分析工具有很多，比如 gprof，perf 等等。然而，它们似乎对 GCC 更友好。如果想要对 LLVM 编译出来的程序做分析，推荐 Google 的性能分析工具，Google gperftools。\n\n凭借官方只言片语的解释，安装使用 gperftools 还是有点困难的：\n\nhttps://gperftools.github.io/gperftools/cpuprofile.html\n\nhttps://github.com/gperftools/gperftools\n\n## 安装\n\n`sudo apt-get install libunwind-dev`\n\n`sudo apt-get install google-perftools libgoogle-perftools-dev`\n\n推荐安装一款可视化软件，方便查看性能分析结果：\n\n`sudo apt-get install kcachegrind`\n\n## 使用\n\n编写测试程序的时候，注意需要让程序有一定的运行时间。由于 gperftools 是通过采样来做分析的，如果程序太短很快就退出了，就不会有输出结果。\n\n之后，在用 Clang 编译的时候，链接上 gperftools 的库：\n\n`clang test.c -lprofiler -o test`\n\n这样，性能分析的代码就已经注入到程序里了。运行时，要指定输出文件路径：\n\n`env CPUPROFILE=./test.prof ./test`\n\n这样，输出文件会存放在当前目录下的 `test.prof` 文件中。\n\n可以通过 `pprof` 工具来查看：\n\n`google-pprof -text test test.prof`\n\n如果要使用刚刚所说的可视化工具，要先把输出文件转换成该工具支持的类型：\n\n`google-pprof --callgrind /usr/bin/python ./test.prof > ./test.txt `\n\n然后再用 `kcachegrind` 工具打开：\n\n`kcachegrind test.txt`\n\n截图如下：\n\n![screenshot](/img/使用gperftools/screenshot.png)\n\n当然，Google gproftools 是非常强大的工具，还有更多的功能值得探索。","slug":"Linux下使用gperftools","published":1,"updated":"2020-01-04T08:16:16.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv2w000aljc31ll0atwc","content":"<h1 id=\"Linux-下使用-gperftools\"><a href=\"#Linux-下使用-gperftools\" class=\"headerlink\" title=\"Linux 下使用 gperftools\"></a>Linux 下使用 gperftools</h1><p>常用的性能分析工具有很多，比如 gprof，perf 等等。然而，它们似乎对 GCC 更友好。如果想要对 LLVM 编译出来的程序做分析，推荐 Google 的性能分析工具，Google gperftools。</p>\n<p>凭借官方只言片语的解释，安装使用 gperftools 还是有点困难的：</p>\n<p><a href=\"https://gperftools.github.io/gperftools/cpuprofile.html\">https://gperftools.github.io/gperftools/cpuprofile.html</a></p>\n<p><a href=\"https://github.com/gperftools/gperftools\">https://github.com/gperftools/gperftools</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><code>sudo apt-get install libunwind-dev</code></p>\n<p><code>sudo apt-get install google-perftools libgoogle-perftools-dev</code></p>\n<p>推荐安装一款可视化软件，方便查看性能分析结果：</p>\n<p><code>sudo apt-get install kcachegrind</code></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>编写测试程序的时候，注意需要让程序有一定的运行时间。由于 gperftools 是通过采样来做分析的，如果程序太短很快就退出了，就不会有输出结果。</p>\n<p>之后，在用 Clang 编译的时候，链接上 gperftools 的库：</p>\n<p><code>clang test.c -lprofiler -o test</code></p>\n<p>这样，性能分析的代码就已经注入到程序里了。运行时，要指定输出文件路径：</p>\n<p><code>env CPUPROFILE=./test.prof ./test</code></p>\n<p>这样，输出文件会存放在当前目录下的 <code>test.prof</code> 文件中。</p>\n<p>可以通过 <code>pprof</code> 工具来查看：</p>\n<p><code>google-pprof -text test test.prof</code></p>\n<p>如果要使用刚刚所说的可视化工具，要先把输出文件转换成该工具支持的类型：</p>\n<p><code>google-pprof --callgrind /usr/bin/python ./test.prof &gt; ./test.txt</code></p>\n<p>然后再用 <code>kcachegrind</code> 工具打开：</p>\n<p><code>kcachegrind test.txt</code></p>\n<p>截图如下：</p>\n<p><img src=\"/img/使用gperftools/screenshot.png\" alt=\"screenshot\"></p>\n<p>当然，Google gproftools 是非常强大的工具，还有更多的功能值得探索。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Linux-下使用-gperftools\"><a href=\"#Linux-下使用-gperftools\" class=\"headerlink\" title=\"Linux 下使用 gperftools\"></a>Linux 下使用 gperftools</h1><p>常用的性能分析工具有很多，比如 gprof，perf 等等。然而，它们似乎对 GCC 更友好。如果想要对 LLVM 编译出来的程序做分析，推荐 Google 的性能分析工具，Google gperftools。</p>\n<p>凭借官方只言片语的解释，安装使用 gperftools 还是有点困难的：</p>\n<p><a href=\"https://gperftools.github.io/gperftools/cpuprofile.html\">https://gperftools.github.io/gperftools/cpuprofile.html</a></p>\n<p><a href=\"https://github.com/gperftools/gperftools\">https://github.com/gperftools/gperftools</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p><code>sudo apt-get install libunwind-dev</code></p>\n<p><code>sudo apt-get install google-perftools libgoogle-perftools-dev</code></p>\n<p>推荐安装一款可视化软件，方便查看性能分析结果：</p>\n<p><code>sudo apt-get install kcachegrind</code></p>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>编写测试程序的时候，注意需要让程序有一定的运行时间。由于 gperftools 是通过采样来做分析的，如果程序太短很快就退出了，就不会有输出结果。</p>\n<p>之后，在用 Clang 编译的时候，链接上 gperftools 的库：</p>\n<p><code>clang test.c -lprofiler -o test</code></p>\n<p>这样，性能分析的代码就已经注入到程序里了。运行时，要指定输出文件路径：</p>\n<p><code>env CPUPROFILE=./test.prof ./test</code></p>\n<p>这样，输出文件会存放在当前目录下的 <code>test.prof</code> 文件中。</p>\n<p>可以通过 <code>pprof</code> 工具来查看：</p>\n<p><code>google-pprof -text test test.prof</code></p>\n<p>如果要使用刚刚所说的可视化工具，要先把输出文件转换成该工具支持的类型：</p>\n<p><code>google-pprof --callgrind /usr/bin/python ./test.prof &gt; ./test.txt</code></p>\n<p>然后再用 <code>kcachegrind</code> 工具打开：</p>\n<p><code>kcachegrind test.txt</code></p>\n<p>截图如下：</p>\n<p><img src=\"/img/使用gperftools/screenshot.png\" alt=\"screenshot\"></p>\n<p>当然，Google gproftools 是非常强大的工具，还有更多的功能值得探索。</p>\n"},{"title":"Obj-C内存管理细节和多线程","date":"2018-04-01T13:51:58.000Z","_content":"\n# Obj-C 内存管理细节和多线程\n\n### 引用计数的实现\n\niOS 中内存管理的部分是由 NSObject 类实现的。Foundation 框架并没有开源，但是 Cocoa 的互换框架 GNUstep 是开放源码的。互换框架是指，虽然实现的机制可能不一样，但对使用者来说，他们的行为应该是一致的。\n\n首先来看 GNUstep 中是怎么做的：\n\n在 alloc 时，会给对象分配一个 NSZone 作为内存空间。把对象的内存空间置为全 0，并在其头部加上引用计数字段，保存它的引用计数值。retain 方法将使这个值加一，而 release 方法将使它减一。而在 release 方法中，每次都会去判断此时的引用计数是不是 0。如果到了 0，则调用 dealloc 方法把对象的空间释放掉。\n\n其中，NSZone 是为了防止内存碎片化而引入的结构。但是，现代运行时系统的内存管理本身效率已经很高，使用区域（Zone）来管理内存反而会引起内存使用效率低下及源代码复杂化等问题，所以区域已经单纯地被忽略了。\n\n![zone](/img/内存管理与多线程/zone.jpg)\n\n而苹果的实现与它不太一样。苹果使用了一个哈希表（引用计数表）来管理引用计数。表的 key 为内存块地址的哈希值。这样带来的好处有：\n\n- 对象的内存块不用再考虑预留头部记录引用计数。\n- 引用计数表中存有对象的内存块地址，可以通过记录追溯到内存块。\n\n在利用工具检测内存泄露时，引用计数表的记录也有助于检测各对象的持有者是否还存在。\n\n### ARC 模式下的 AutoRelease\n\n在 ARC 下，`[obj autorelease];` 不允许被调用，但是可以显示地给对象添加修饰符：\n\n```objective-c\n@autoreleasepool {\n    id __autoreleasing obj = [[NSObject alloc] init];\n}\n```\n\n但是这种情况就与显示地声明 __strong 一样罕见（对象默认就是强引用）。因为编译器会判断方法名是否以 alloc / new / copy / mutableCopy 开头，如果不是，则自动地将返回值的对象注册到 autoreleasepool 中。这也是为什么 OC 中自己定义的函数一般不要以这些单词开头的原因。\n\n所有标记了 weak 修饰符的对象也都会被注册到自动释放池中。这是因为它只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果添加到自动释放池中，在 @autoreleasepool 结束前，都能确保该对象存在。\n\n### C 语言的结构体\n\nC 语言的结构体（struct / union）中的成员变量不能时 OC 的对象，否则会引起编译错误。这是因为 C 语言并没有方法来管理结构体成员的生命周期。\n\n如果一定要用，可以把对象强制转化成 void *，或者附加 `__unsafe_unretained` 修饰符。正如该修饰符的名称，该变量不在编译器所管理的对象之中，因此不安全，一切都需要程序员手动管理。\n\n### __weak 修饰符\n\n附有 __weak 修饰符的变量所引用的对象一旦被废弃，则该变量会被自动赋值为 nil，这是怎么实现的呢？\n\n原来，系统会调用一个 `objc_storeWeak` 的方法，把变量存储进一个 weak 表中。weak 表与引用计数表很像，也是一个哈希表，同样以赋值对象的地址作为 key。当对象被废弃时，会从 weak 表中查找以废弃的对象地址作为 key 的记录，把包含在记录中的所有赋有 weak 关键字的对象的地址找到，并给这些变量赋值为 nil。之后，从 weak 表和引用计数表中删除对应的记录。\n\n从上面的过程中可以看到，如果大量的 weak 对象被废弃，将会消耗更多的 CPU 资源。因此建议只有在必需的情况下使用 weak 来修饰变量。\n\n### 什么是线程\n\n一个 CPU 一次只能执行一个命令，虽然有时命令列的地址会发生迁移，但它永远不可能在某处分开而产生并列执行两条指令的情况。这条无分叉的路径就被称为线程。\n\n<img src=\"/img/内存管理与多线程/thread.JPG\" style=\"zoom:10%\"/>\n\n但是，当这样的无分叉路经不只一条时，就被称为“多线程了”。\n\nOS X 和 iOS 的 XNU 内核每隔一段时间会切换执行路经。例如将 CPU 的寄存器等信息保存到各个路径专用的内存块中，再复原目标路径内存块中的信息，来切换不同的路径。这被称为“上下文切换”。反复切换时，看上去就是一个 CPU 能并列地执行多个线程一样。当然，如果计算机本身就有多核 CPU，那么就可以真正的使用多个 CPU 核心并行地执行多线程程序。\n\n### 两种 Dispatch Queue\n\n| 种类                      | 说明                     |\n| ------------------------- | ------------------------ |\n| Serial Dispatch Queue     | 等待现在执行中处理结束   |\n| Concurrent Dispatch Queue | 不等待现在执行中处理结束 |\n\n例如，当 queue 为 serial 类型时，会 1 2 3 4 5 这样等待一个任务执行完后再执行下一个任务。而如果为 concurrent 类型时，就会并行执行多个任务。不过，具体开启几个线程由操作系统根据处理数、CPU 核心数、当前 CPU 负载等状态来决定。\n\n这里，如果创建了多个 queue，这多个 queue 则是并行执行的。虽然在 1 个 Serial Queue 中只能同时执行 1 个处理，但是如果有多个 queue，每个 queue 之间就同时执行了。你可以添加任意多个 queue，从而突破限制，发起任意多个线程。当然，开启的线程数量越多，消耗的内存也就越多。大量的上下文切换也会大幅降低系统的响应性能。\n\n为了避免多个线程竞争数据，可以使用 Serial Dispatch Queue。\n\n生成的 queue 需要自己释放，而不能通过 ARC 自动释放。不过一般不需要我们自己创建 queue，因为系统给我们提供了两个队列：Global Dispatch Queue 和 Main Dispatch Queue。显然，Global 时 Concurrent 的，而 Main 是 Serial 的。\n\n### dispatch_barrier_async\n\n多个线程读取文件时是安全的，但是当写入时就会出现问题。使用 dispatch_barrier_async 函数，可以等待追加到 concurrent queue 上的并行处理都执行完之后，再来执行特定的处理。在这个函数执行完后，queue 又恢复成一般的动作。\n\n利用这个函数可以高效的实现文件访问。\n\n### sync\n\n`dispatch_sync` 函数在指定的处理执行结束前不会返回。因此下面的情况会造成死锁：\n\n```objective-c\ndispatch_queue_t queue = dispatch_get_main_queue();\ndispatch_sync(queue, ^{NSLog(@\"World\");});\n```\n\n该段代码在主线程执行 block，并等待它结束。而主线程正在执行这段代码，又在等待它返回，就造成了死锁。![ispatc](/img/内存管理与多线程/dispatch.png)\n\n所以在用此函数时要特别小心构成死锁。\n\n### 挂起和恢复\n\n可以用以下两个函数：\n\n```objective-c\ndispatch_suspend(queue);\ndispatch_resume(queue);\n```\n\n### 信号量\n\n通过 Dispatch Semaphore 可以进行排它控制，或用来限制最多执行的线程数。\n\n`dispatch-semaphore_create(信号量)` 用来创建信号量，如果信号量小于 0 会返回 NULL。\n\n`dispatch_semaphore_wait(信号量, 等待时间)` 用来等待计数值大于或等于 1。计数值等于 0 时等待。DISPATCH_TIME_FOREVER 表示永久等待。\n\n`dispatch_semaphore_signal(信号量)` 用于提高信号量。\n\n我们一般在执行一段任务时，先用 wait 来等待（如果该函数返回 0，代表计数值大于等于 1，同时会把计数值降低 1）。在任务结束时，用 signal 来把信号量加一。\n\n### dispatch_once\n\n该函数保证了引用程序执行中只执行一次特定的处理。我们可以利用这个函数来生成单例对象，实现单例模式。\n\n","source":"_posts/Obj-C内存管理细节和多线程.md","raw":"---\ntitle: Obj-C内存管理细节和多线程\ndate: 2018-04-01 21:51:58\ntags: Obj-C\n---\n\n# Obj-C 内存管理细节和多线程\n\n### 引用计数的实现\n\niOS 中内存管理的部分是由 NSObject 类实现的。Foundation 框架并没有开源，但是 Cocoa 的互换框架 GNUstep 是开放源码的。互换框架是指，虽然实现的机制可能不一样，但对使用者来说，他们的行为应该是一致的。\n\n首先来看 GNUstep 中是怎么做的：\n\n在 alloc 时，会给对象分配一个 NSZone 作为内存空间。把对象的内存空间置为全 0，并在其头部加上引用计数字段，保存它的引用计数值。retain 方法将使这个值加一，而 release 方法将使它减一。而在 release 方法中，每次都会去判断此时的引用计数是不是 0。如果到了 0，则调用 dealloc 方法把对象的空间释放掉。\n\n其中，NSZone 是为了防止内存碎片化而引入的结构。但是，现代运行时系统的内存管理本身效率已经很高，使用区域（Zone）来管理内存反而会引起内存使用效率低下及源代码复杂化等问题，所以区域已经单纯地被忽略了。\n\n![zone](/img/内存管理与多线程/zone.jpg)\n\n而苹果的实现与它不太一样。苹果使用了一个哈希表（引用计数表）来管理引用计数。表的 key 为内存块地址的哈希值。这样带来的好处有：\n\n- 对象的内存块不用再考虑预留头部记录引用计数。\n- 引用计数表中存有对象的内存块地址，可以通过记录追溯到内存块。\n\n在利用工具检测内存泄露时，引用计数表的记录也有助于检测各对象的持有者是否还存在。\n\n### ARC 模式下的 AutoRelease\n\n在 ARC 下，`[obj autorelease];` 不允许被调用，但是可以显示地给对象添加修饰符：\n\n```objective-c\n@autoreleasepool {\n    id __autoreleasing obj = [[NSObject alloc] init];\n}\n```\n\n但是这种情况就与显示地声明 __strong 一样罕见（对象默认就是强引用）。因为编译器会判断方法名是否以 alloc / new / copy / mutableCopy 开头，如果不是，则自动地将返回值的对象注册到 autoreleasepool 中。这也是为什么 OC 中自己定义的函数一般不要以这些单词开头的原因。\n\n所有标记了 weak 修饰符的对象也都会被注册到自动释放池中。这是因为它只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果添加到自动释放池中，在 @autoreleasepool 结束前，都能确保该对象存在。\n\n### C 语言的结构体\n\nC 语言的结构体（struct / union）中的成员变量不能时 OC 的对象，否则会引起编译错误。这是因为 C 语言并没有方法来管理结构体成员的生命周期。\n\n如果一定要用，可以把对象强制转化成 void *，或者附加 `__unsafe_unretained` 修饰符。正如该修饰符的名称，该变量不在编译器所管理的对象之中，因此不安全，一切都需要程序员手动管理。\n\n### __weak 修饰符\n\n附有 __weak 修饰符的变量所引用的对象一旦被废弃，则该变量会被自动赋值为 nil，这是怎么实现的呢？\n\n原来，系统会调用一个 `objc_storeWeak` 的方法，把变量存储进一个 weak 表中。weak 表与引用计数表很像，也是一个哈希表，同样以赋值对象的地址作为 key。当对象被废弃时，会从 weak 表中查找以废弃的对象地址作为 key 的记录，把包含在记录中的所有赋有 weak 关键字的对象的地址找到，并给这些变量赋值为 nil。之后，从 weak 表和引用计数表中删除对应的记录。\n\n从上面的过程中可以看到，如果大量的 weak 对象被废弃，将会消耗更多的 CPU 资源。因此建议只有在必需的情况下使用 weak 来修饰变量。\n\n### 什么是线程\n\n一个 CPU 一次只能执行一个命令，虽然有时命令列的地址会发生迁移，但它永远不可能在某处分开而产生并列执行两条指令的情况。这条无分叉的路径就被称为线程。\n\n<img src=\"/img/内存管理与多线程/thread.JPG\" style=\"zoom:10%\"/>\n\n但是，当这样的无分叉路经不只一条时，就被称为“多线程了”。\n\nOS X 和 iOS 的 XNU 内核每隔一段时间会切换执行路经。例如将 CPU 的寄存器等信息保存到各个路径专用的内存块中，再复原目标路径内存块中的信息，来切换不同的路径。这被称为“上下文切换”。反复切换时，看上去就是一个 CPU 能并列地执行多个线程一样。当然，如果计算机本身就有多核 CPU，那么就可以真正的使用多个 CPU 核心并行地执行多线程程序。\n\n### 两种 Dispatch Queue\n\n| 种类                      | 说明                     |\n| ------------------------- | ------------------------ |\n| Serial Dispatch Queue     | 等待现在执行中处理结束   |\n| Concurrent Dispatch Queue | 不等待现在执行中处理结束 |\n\n例如，当 queue 为 serial 类型时，会 1 2 3 4 5 这样等待一个任务执行完后再执行下一个任务。而如果为 concurrent 类型时，就会并行执行多个任务。不过，具体开启几个线程由操作系统根据处理数、CPU 核心数、当前 CPU 负载等状态来决定。\n\n这里，如果创建了多个 queue，这多个 queue 则是并行执行的。虽然在 1 个 Serial Queue 中只能同时执行 1 个处理，但是如果有多个 queue，每个 queue 之间就同时执行了。你可以添加任意多个 queue，从而突破限制，发起任意多个线程。当然，开启的线程数量越多，消耗的内存也就越多。大量的上下文切换也会大幅降低系统的响应性能。\n\n为了避免多个线程竞争数据，可以使用 Serial Dispatch Queue。\n\n生成的 queue 需要自己释放，而不能通过 ARC 自动释放。不过一般不需要我们自己创建 queue，因为系统给我们提供了两个队列：Global Dispatch Queue 和 Main Dispatch Queue。显然，Global 时 Concurrent 的，而 Main 是 Serial 的。\n\n### dispatch_barrier_async\n\n多个线程读取文件时是安全的，但是当写入时就会出现问题。使用 dispatch_barrier_async 函数，可以等待追加到 concurrent queue 上的并行处理都执行完之后，再来执行特定的处理。在这个函数执行完后，queue 又恢复成一般的动作。\n\n利用这个函数可以高效的实现文件访问。\n\n### sync\n\n`dispatch_sync` 函数在指定的处理执行结束前不会返回。因此下面的情况会造成死锁：\n\n```objective-c\ndispatch_queue_t queue = dispatch_get_main_queue();\ndispatch_sync(queue, ^{NSLog(@\"World\");});\n```\n\n该段代码在主线程执行 block，并等待它结束。而主线程正在执行这段代码，又在等待它返回，就造成了死锁。![ispatc](/img/内存管理与多线程/dispatch.png)\n\n所以在用此函数时要特别小心构成死锁。\n\n### 挂起和恢复\n\n可以用以下两个函数：\n\n```objective-c\ndispatch_suspend(queue);\ndispatch_resume(queue);\n```\n\n### 信号量\n\n通过 Dispatch Semaphore 可以进行排它控制，或用来限制最多执行的线程数。\n\n`dispatch-semaphore_create(信号量)` 用来创建信号量，如果信号量小于 0 会返回 NULL。\n\n`dispatch_semaphore_wait(信号量, 等待时间)` 用来等待计数值大于或等于 1。计数值等于 0 时等待。DISPATCH_TIME_FOREVER 表示永久等待。\n\n`dispatch_semaphore_signal(信号量)` 用于提高信号量。\n\n我们一般在执行一段任务时，先用 wait 来等待（如果该函数返回 0，代表计数值大于等于 1，同时会把计数值降低 1）。在任务结束时，用 signal 来把信号量加一。\n\n### dispatch_once\n\n该函数保证了引用程序执行中只执行一次特定的处理。我们可以利用这个函数来生成单例对象，实现单例模式。\n\n","slug":"Obj-C内存管理细节和多线程","published":1,"updated":"2020-01-04T08:16:16.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv2x000bljc3cu11mocy","content":"<h1 id=\"Obj-C-内存管理细节和多线程\"><a href=\"#Obj-C-内存管理细节和多线程\" class=\"headerlink\" title=\"Obj-C 内存管理细节和多线程\"></a>Obj-C 内存管理细节和多线程</h1><h3 id=\"引用计数的实现\"><a href=\"#引用计数的实现\" class=\"headerlink\" title=\"引用计数的实现\"></a>引用计数的实现</h3><p>iOS 中内存管理的部分是由 NSObject 类实现的。Foundation 框架并没有开源，但是 Cocoa 的互换框架 GNUstep 是开放源码的。互换框架是指，虽然实现的机制可能不一样，但对使用者来说，他们的行为应该是一致的。</p>\n<p>首先来看 GNUstep 中是怎么做的：</p>\n<p>在 alloc 时，会给对象分配一个 NSZone 作为内存空间。把对象的内存空间置为全 0，并在其头部加上引用计数字段，保存它的引用计数值。retain 方法将使这个值加一，而 release 方法将使它减一。而在 release 方法中，每次都会去判断此时的引用计数是不是 0。如果到了 0，则调用 dealloc 方法把对象的空间释放掉。</p>\n<p>其中，NSZone 是为了防止内存碎片化而引入的结构。但是，现代运行时系统的内存管理本身效率已经很高，使用区域（Zone）来管理内存反而会引起内存使用效率低下及源代码复杂化等问题，所以区域已经单纯地被忽略了。</p>\n<p><img src=\"/img/内存管理与多线程/zone.jpg\" alt=\"zone\"></p>\n<p>而苹果的实现与它不太一样。苹果使用了一个哈希表（引用计数表）来管理引用计数。表的 key 为内存块地址的哈希值。这样带来的好处有：</p>\n<ul>\n<li>对象的内存块不用再考虑预留头部记录引用计数。</li>\n<li>引用计数表中存有对象的内存块地址，可以通过记录追溯到内存块。</li>\n</ul>\n<p>在利用工具检测内存泄露时，引用计数表的记录也有助于检测各对象的持有者是否还存在。</p>\n<h3 id=\"ARC-模式下的-AutoRelease\"><a href=\"#ARC-模式下的-AutoRelease\" class=\"headerlink\" title=\"ARC 模式下的 AutoRelease\"></a>ARC 模式下的 AutoRelease</h3><p>在 ARC 下，<code>[obj autorelease];</code> 不允许被调用，但是可以显示地给对象添加修饰符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autoreleasepool &#123;</span><br><span class=\"line\">    id __autoreleasing obj = [[NSObject alloc] init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这种情况就与显示地声明 __strong 一样罕见（对象默认就是强引用）。因为编译器会判断方法名是否以 alloc / new / copy / mutableCopy 开头，如果不是，则自动地将返回值的对象注册到 autoreleasepool 中。这也是为什么 OC 中自己定义的函数一般不要以这些单词开头的原因。</p>\n<p>所有标记了 weak 修饰符的对象也都会被注册到自动释放池中。这是因为它只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果添加到自动释放池中，在 @autoreleasepool 结束前，都能确保该对象存在。</p>\n<h3 id=\"C-语言的结构体\"><a href=\"#C-语言的结构体\" class=\"headerlink\" title=\"C 语言的结构体\"></a>C 语言的结构体</h3><p>C 语言的结构体（struct / union）中的成员变量不能时 OC 的对象，否则会引起编译错误。这是因为 C 语言并没有方法来管理结构体成员的生命周期。</p>\n<p>如果一定要用，可以把对象强制转化成 void *，或者附加 <code>__unsafe_unretained</code> 修饰符。正如该修饰符的名称，该变量不在编译器所管理的对象之中，因此不安全，一切都需要程序员手动管理。</p>\n<h3 id=\"weak-修饰符\"><a href=\"#weak-修饰符\" class=\"headerlink\" title=\"__weak 修饰符\"></a>__weak 修饰符</h3><p>附有 __weak 修饰符的变量所引用的对象一旦被废弃，则该变量会被自动赋值为 nil，这是怎么实现的呢？</p>\n<p>原来，系统会调用一个 <code>objc_storeWeak</code> 的方法，把变量存储进一个 weak 表中。weak 表与引用计数表很像，也是一个哈希表，同样以赋值对象的地址作为 key。当对象被废弃时，会从 weak 表中查找以废弃的对象地址作为 key 的记录，把包含在记录中的所有赋有 weak 关键字的对象的地址找到，并给这些变量赋值为 nil。之后，从 weak 表和引用计数表中删除对应的记录。</p>\n<p>从上面的过程中可以看到，如果大量的 weak 对象被废弃，将会消耗更多的 CPU 资源。因此建议只有在必需的情况下使用 weak 来修饰变量。</p>\n<h3 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h3><p>一个 CPU 一次只能执行一个命令，虽然有时命令列的地址会发生迁移，但它永远不可能在某处分开而产生并列执行两条指令的情况。这条无分叉的路径就被称为线程。</p>\n<p><img src=\"/img/内存管理与多线程/thread.JPG\" style=\"zoom:10%\"/></p>\n<p>但是，当这样的无分叉路经不只一条时，就被称为“多线程了”。</p>\n<p>OS X 和 iOS 的 XNU 内核每隔一段时间会切换执行路经。例如将 CPU 的寄存器等信息保存到各个路径专用的内存块中，再复原目标路径内存块中的信息，来切换不同的路径。这被称为“上下文切换”。反复切换时，看上去就是一个 CPU 能并列地执行多个线程一样。当然，如果计算机本身就有多核 CPU，那么就可以真正的使用多个 CPU 核心并行地执行多线程程序。</p>\n<h3 id=\"两种-Dispatch-Queue\"><a href=\"#两种-Dispatch-Queue\" class=\"headerlink\" title=\"两种 Dispatch Queue\"></a>两种 Dispatch Queue</h3><table>\n<thead>\n<tr>\n<th>种类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Serial Dispatch Queue</td>\n<td>等待现在执行中处理结束</td>\n</tr>\n<tr>\n<td>Concurrent Dispatch Queue</td>\n<td>不等待现在执行中处理结束</td>\n</tr>\n</tbody>\n</table>\n<p>例如，当 queue 为 serial 类型时，会 1 2 3 4 5 这样等待一个任务执行完后再执行下一个任务。而如果为 concurrent 类型时，就会并行执行多个任务。不过，具体开启几个线程由操作系统根据处理数、CPU 核心数、当前 CPU 负载等状态来决定。</p>\n<p>这里，如果创建了多个 queue，这多个 queue 则是并行执行的。虽然在 1 个 Serial Queue 中只能同时执行 1 个处理，但是如果有多个 queue，每个 queue 之间就同时执行了。你可以添加任意多个 queue，从而突破限制，发起任意多个线程。当然，开启的线程数量越多，消耗的内存也就越多。大量的上下文切换也会大幅降低系统的响应性能。</p>\n<p>为了避免多个线程竞争数据，可以使用 Serial Dispatch Queue。</p>\n<p>生成的 queue 需要自己释放，而不能通过 ARC 自动释放。不过一般不需要我们自己创建 queue，因为系统给我们提供了两个队列：Global Dispatch Queue 和 Main Dispatch Queue。显然，Global 时 Concurrent 的，而 Main 是 Serial 的。</p>\n<h3 id=\"dispatch-barrier-async\"><a href=\"#dispatch-barrier-async\" class=\"headerlink\" title=\"dispatch_barrier_async\"></a>dispatch_barrier_async</h3><p>多个线程读取文件时是安全的，但是当写入时就会出现问题。使用 dispatch_barrier_async 函数，可以等待追加到 concurrent queue 上的并行处理都执行完之后，再来执行特定的处理。在这个函数执行完后，queue 又恢复成一般的动作。</p>\n<p>利用这个函数可以高效的实现文件访问。</p>\n<h3 id=\"sync\"><a href=\"#sync\" class=\"headerlink\" title=\"sync\"></a>sync</h3><p><code>dispatch_sync</code> 函数在指定的处理执行结束前不会返回。因此下面的情况会造成死锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\">dispatch_sync(queue, ^&#123;NSLog(@&quot;World&quot;);&#125;);</span><br></pre></td></tr></table></figure>\n<p>该段代码在主线程执行 block，并等待它结束。而主线程正在执行这段代码，又在等待它返回，就造成了死锁。<img src=\"/img/内存管理与多线程/dispatch.png\" alt=\"ispatc\"></p>\n<p>所以在用此函数时要特别小心构成死锁。</p>\n<h3 id=\"挂起和恢复\"><a href=\"#挂起和恢复\" class=\"headerlink\" title=\"挂起和恢复\"></a>挂起和恢复</h3><p>可以用以下两个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_suspend(queue);</span><br><span class=\"line\">dispatch_resume(queue);</span><br></pre></td></tr></table></figure>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>通过 Dispatch Semaphore 可以进行排它控制，或用来限制最多执行的线程数。</p>\n<p><code>dispatch-semaphore_create(信号量)</code> 用来创建信号量，如果信号量小于 0 会返回 NULL。</p>\n<p><code>dispatch_semaphore_wait(信号量, 等待时间)</code> 用来等待计数值大于或等于 1。计数值等于 0 时等待。DISPATCH_TIME_FOREVER 表示永久等待。</p>\n<p><code>dispatch_semaphore_signal(信号量)</code> 用于提高信号量。</p>\n<p>我们一般在执行一段任务时，先用 wait 来等待（如果该函数返回 0，代表计数值大于等于 1，同时会把计数值降低 1）。在任务结束时，用 signal 来把信号量加一。</p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><p>该函数保证了引用程序执行中只执行一次特定的处理。我们可以利用这个函数来生成单例对象，实现单例模式。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Obj-C-内存管理细节和多线程\"><a href=\"#Obj-C-内存管理细节和多线程\" class=\"headerlink\" title=\"Obj-C 内存管理细节和多线程\"></a>Obj-C 内存管理细节和多线程</h1><h3 id=\"引用计数的实现\"><a href=\"#引用计数的实现\" class=\"headerlink\" title=\"引用计数的实现\"></a>引用计数的实现</h3><p>iOS 中内存管理的部分是由 NSObject 类实现的。Foundation 框架并没有开源，但是 Cocoa 的互换框架 GNUstep 是开放源码的。互换框架是指，虽然实现的机制可能不一样，但对使用者来说，他们的行为应该是一致的。</p>\n<p>首先来看 GNUstep 中是怎么做的：</p>\n<p>在 alloc 时，会给对象分配一个 NSZone 作为内存空间。把对象的内存空间置为全 0，并在其头部加上引用计数字段，保存它的引用计数值。retain 方法将使这个值加一，而 release 方法将使它减一。而在 release 方法中，每次都会去判断此时的引用计数是不是 0。如果到了 0，则调用 dealloc 方法把对象的空间释放掉。</p>\n<p>其中，NSZone 是为了防止内存碎片化而引入的结构。但是，现代运行时系统的内存管理本身效率已经很高，使用区域（Zone）来管理内存反而会引起内存使用效率低下及源代码复杂化等问题，所以区域已经单纯地被忽略了。</p>\n<p><img src=\"/img/内存管理与多线程/zone.jpg\" alt=\"zone\"></p>\n<p>而苹果的实现与它不太一样。苹果使用了一个哈希表（引用计数表）来管理引用计数。表的 key 为内存块地址的哈希值。这样带来的好处有：</p>\n<ul>\n<li>对象的内存块不用再考虑预留头部记录引用计数。</li>\n<li>引用计数表中存有对象的内存块地址，可以通过记录追溯到内存块。</li>\n</ul>\n<p>在利用工具检测内存泄露时，引用计数表的记录也有助于检测各对象的持有者是否还存在。</p>\n<h3 id=\"ARC-模式下的-AutoRelease\"><a href=\"#ARC-模式下的-AutoRelease\" class=\"headerlink\" title=\"ARC 模式下的 AutoRelease\"></a>ARC 模式下的 AutoRelease</h3><p>在 ARC 下，<code>[obj autorelease];</code> 不允许被调用，但是可以显示地给对象添加修饰符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@autoreleasepool &#123;</span><br><span class=\"line\">    id __autoreleasing obj = [[NSObject alloc] init];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这种情况就与显示地声明 __strong 一样罕见（对象默认就是强引用）。因为编译器会判断方法名是否以 alloc / new / copy / mutableCopy 开头，如果不是，则自动地将返回值的对象注册到 autoreleasepool 中。这也是为什么 OC 中自己定义的函数一般不要以这些单词开头的原因。</p>\n<p>所有标记了 weak 修饰符的对象也都会被注册到自动释放池中。这是因为它只持有对象的弱引用，而在访问引用对象的过程中，该对象有可能被废弃。如果添加到自动释放池中，在 @autoreleasepool 结束前，都能确保该对象存在。</p>\n<h3 id=\"C-语言的结构体\"><a href=\"#C-语言的结构体\" class=\"headerlink\" title=\"C 语言的结构体\"></a>C 语言的结构体</h3><p>C 语言的结构体（struct / union）中的成员变量不能时 OC 的对象，否则会引起编译错误。这是因为 C 语言并没有方法来管理结构体成员的生命周期。</p>\n<p>如果一定要用，可以把对象强制转化成 void *，或者附加 <code>__unsafe_unretained</code> 修饰符。正如该修饰符的名称，该变量不在编译器所管理的对象之中，因此不安全，一切都需要程序员手动管理。</p>\n<h3 id=\"weak-修饰符\"><a href=\"#weak-修饰符\" class=\"headerlink\" title=\"__weak 修饰符\"></a>__weak 修饰符</h3><p>附有 __weak 修饰符的变量所引用的对象一旦被废弃，则该变量会被自动赋值为 nil，这是怎么实现的呢？</p>\n<p>原来，系统会调用一个 <code>objc_storeWeak</code> 的方法，把变量存储进一个 weak 表中。weak 表与引用计数表很像，也是一个哈希表，同样以赋值对象的地址作为 key。当对象被废弃时，会从 weak 表中查找以废弃的对象地址作为 key 的记录，把包含在记录中的所有赋有 weak 关键字的对象的地址找到，并给这些变量赋值为 nil。之后，从 weak 表和引用计数表中删除对应的记录。</p>\n<p>从上面的过程中可以看到，如果大量的 weak 对象被废弃，将会消耗更多的 CPU 资源。因此建议只有在必需的情况下使用 weak 来修饰变量。</p>\n<h3 id=\"什么是线程\"><a href=\"#什么是线程\" class=\"headerlink\" title=\"什么是线程\"></a>什么是线程</h3><p>一个 CPU 一次只能执行一个命令，虽然有时命令列的地址会发生迁移，但它永远不可能在某处分开而产生并列执行两条指令的情况。这条无分叉的路径就被称为线程。</p>\n<p><img src=\"/img/内存管理与多线程/thread.JPG\" style=\"zoom:10%\"/></p>\n<p>但是，当这样的无分叉路经不只一条时，就被称为“多线程了”。</p>\n<p>OS X 和 iOS 的 XNU 内核每隔一段时间会切换执行路经。例如将 CPU 的寄存器等信息保存到各个路径专用的内存块中，再复原目标路径内存块中的信息，来切换不同的路径。这被称为“上下文切换”。反复切换时，看上去就是一个 CPU 能并列地执行多个线程一样。当然，如果计算机本身就有多核 CPU，那么就可以真正的使用多个 CPU 核心并行地执行多线程程序。</p>\n<h3 id=\"两种-Dispatch-Queue\"><a href=\"#两种-Dispatch-Queue\" class=\"headerlink\" title=\"两种 Dispatch Queue\"></a>两种 Dispatch Queue</h3><table>\n<thead>\n<tr>\n<th>种类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Serial Dispatch Queue</td>\n<td>等待现在执行中处理结束</td>\n</tr>\n<tr>\n<td>Concurrent Dispatch Queue</td>\n<td>不等待现在执行中处理结束</td>\n</tr>\n</tbody>\n</table>\n<p>例如，当 queue 为 serial 类型时，会 1 2 3 4 5 这样等待一个任务执行完后再执行下一个任务。而如果为 concurrent 类型时，就会并行执行多个任务。不过，具体开启几个线程由操作系统根据处理数、CPU 核心数、当前 CPU 负载等状态来决定。</p>\n<p>这里，如果创建了多个 queue，这多个 queue 则是并行执行的。虽然在 1 个 Serial Queue 中只能同时执行 1 个处理，但是如果有多个 queue，每个 queue 之间就同时执行了。你可以添加任意多个 queue，从而突破限制，发起任意多个线程。当然，开启的线程数量越多，消耗的内存也就越多。大量的上下文切换也会大幅降低系统的响应性能。</p>\n<p>为了避免多个线程竞争数据，可以使用 Serial Dispatch Queue。</p>\n<p>生成的 queue 需要自己释放，而不能通过 ARC 自动释放。不过一般不需要我们自己创建 queue，因为系统给我们提供了两个队列：Global Dispatch Queue 和 Main Dispatch Queue。显然，Global 时 Concurrent 的，而 Main 是 Serial 的。</p>\n<h3 id=\"dispatch-barrier-async\"><a href=\"#dispatch-barrier-async\" class=\"headerlink\" title=\"dispatch_barrier_async\"></a>dispatch_barrier_async</h3><p>多个线程读取文件时是安全的，但是当写入时就会出现问题。使用 dispatch_barrier_async 函数，可以等待追加到 concurrent queue 上的并行处理都执行完之后，再来执行特定的处理。在这个函数执行完后，queue 又恢复成一般的动作。</p>\n<p>利用这个函数可以高效的实现文件访问。</p>\n<h3 id=\"sync\"><a href=\"#sync\" class=\"headerlink\" title=\"sync\"></a>sync</h3><p><code>dispatch_sync</code> 函数在指定的处理执行结束前不会返回。因此下面的情况会造成死锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class=\"line\">dispatch_sync(queue, ^&#123;NSLog(@&quot;World&quot;);&#125;);</span><br></pre></td></tr></table></figure>\n<p>该段代码在主线程执行 block，并等待它结束。而主线程正在执行这段代码，又在等待它返回，就造成了死锁。<img src=\"/img/内存管理与多线程/dispatch.png\" alt=\"ispatc\"></p>\n<p>所以在用此函数时要特别小心构成死锁。</p>\n<h3 id=\"挂起和恢复\"><a href=\"#挂起和恢复\" class=\"headerlink\" title=\"挂起和恢复\"></a>挂起和恢复</h3><p>可以用以下两个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch_suspend(queue);</span><br><span class=\"line\">dispatch_resume(queue);</span><br></pre></td></tr></table></figure>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><p>通过 Dispatch Semaphore 可以进行排它控制，或用来限制最多执行的线程数。</p>\n<p><code>dispatch-semaphore_create(信号量)</code> 用来创建信号量，如果信号量小于 0 会返回 NULL。</p>\n<p><code>dispatch_semaphore_wait(信号量, 等待时间)</code> 用来等待计数值大于或等于 1。计数值等于 0 时等待。DISPATCH_TIME_FOREVER 表示永久等待。</p>\n<p><code>dispatch_semaphore_signal(信号量)</code> 用于提高信号量。</p>\n<p>我们一般在执行一段任务时，先用 wait 来等待（如果该函数返回 0，代表计数值大于等于 1，同时会把计数值降低 1）。在任务结束时，用 signal 来把信号量加一。</p>\n<h3 id=\"dispatch-once\"><a href=\"#dispatch-once\" class=\"headerlink\" title=\"dispatch_once\"></a>dispatch_once</h3><p>该函数保证了引用程序执行中只执行一次特定的处理。我们可以利用这个函数来生成单例对象，实现单例模式。</p>\n"},{"title":"Obj-C运行时系统","date":"2018-04-02T13:46:22.000Z","_content":"\n# Objective-C 运行时系统\n\nObjective-C 会在运行时执行许多其他语言在编译或链接时执行的常规操作，如确定类型和方法解析。这些处理会带来额外的开销，Objective-C 通过缓存来节约这些开销。\n\n### 选择器\n\n在 Objective-C 的对象消息传递中，通过被称为 *选择器* 的字符串来指明调用对象的哪个方法。选择器是一种分为多个段的文本字符串，与方法的声明对应，例如：\n\n```\n分段1:分段2:分段3\n```\n\n如果创建了一个叫做 calculator 的变量，想调用它的方法，就要在接受器对象（calculator）后跟带输入参数的选择器：\n\n```objective-c\n[calculator sumAddend1:25 addend2:10];\n```\n\n选择器类型（SEL）是用于在编译源代码时替换选择器值的唯一标识符，Objective-C 运行时系统会保证每个选择器标识符的唯一性。可以用关键字 @selector 来创建 SEL 类型的变量。\n\n```objective-c\nSEL myMethod = @selector(myMethod);\n```\n\n也可以用 Foundation 框架中的 NSSelectorFromString 在运行时创建选择器：\n\n```objective-c\nSEL myMethod = NSSelectorFromString(@\"myMethod\");\n```\n\n### 方法签名\n\n方法签名定义了**输入参数**的数据类型和**返回值**。编译器会把 `[接收器 消息]` 形式的对象消息转换为生命中带有方法签名的 C 函数调用语句。因此，为了生成对象消息传递代码，编译器需要获得选择器值和方法签名。从对象消息表达式中提取选择器很容易，但怎么提取方法签名呢？由于接受器和接受器的方法是在程序运行时确定的，因此编译时没有办法知道怎样的数据类型能和要调用的方法对应起来。所以编译器只能根据已知的方法声明进行猜测。如果找不到方法签名，或者方法签名与运行时实际的执行方法不匹配，就会导致从编译器警告到运行时错误的各种问题产生。\n\n### 动态类型\n\n运行时系统通过动态类型功能，可以在运行时决定对象的类型。Objective-C 既支持静态类型，又支持动态类型。使用静态类型时，能在编译期检查类型，而使用动态类型时，就只能在运行时检查类型了。Objective-C 通过 id 类型来支持动态类型。id 类型的变量可以存储任何数据类型的对象。\n\nObjective-C 还为运行时的对象内省（如检查对象属于哪个类）提供了 API。通过内省我们可以在运行时检查对象类型，从而确定对象是否能够执行特定的操作。\n\n### 动态绑定\n\n动态绑定是指在运行时将消息和方法对应起来的过程。在运行时发送消息前，消息和接收消息的对象不会对应。由于许多接受器可能会实现相同的方法，所以调用方法的方式会动态变化，因而这也实现了 OOP 的多态。\n\n### 动态方法决议\n\n使用动态方法决议能够以动态的方式实现方法。可以通过重写 NSObject 的 `resolveInstanceMethod` 和 `resolveClassMethod` 方法来动态实现实例方法和类方法。\n\n可以通过 `class_addMethod()` API 来将函数添加到类中，需要先 `#import <objc/runtime.h> ` 。\n\n### 动态加载\n\n通过动态加载功能，可以在需要时加载可执行代码和源代码，而不必在程序启动时就加载所有的组件。这种 lazy loading 方式可以提高程序的性能和可拓展性。可以通过 NSBundle 来动态加载。\n\n### 内省\n\n通过系统提供的 API 可以动态查询与方法有关的信息，并测试对象的继承性、行为和一致性信息。\n\n### 运行时系统的组成结构\n\nObjective-C 的运行时系统由以下两部分组成：编译器和运行时系统库。\n\n### 编译器\n\n当编译器解析到使用了上述动态特性的 Objective-C 源代码时，会使用适当的运行时系统库函数来生成可执行代码。\n\n当编译器解析对象消息时，会生成调用运行时系统库函数 `objc_msgSend()` 中的代码，该函数以接受器、选择器和消息传递的参数一起作为参数。每条消息都是动态处理的，因此接受器类型和方法的实际实现都是在运行时决定的。\n\n当编译器解析含有类定义和对象的代码时，会生成相应的运行时数据结构。所有运行时类型都以 isa 指针开头。\n\n### 运行时系统库\n\n运行时系统库也提供了 C 语言的公共 API 供我们使用，这些 API 在 runtime.h 中声明。比如，可以动态的创建一个类。\n\n```objective-c\nClass dynamicClass = objc_allocateClassPair([NSObject class], \"DynamicClass\", 0);\n```\n\n当向对象发送消息时，运行时系统会通过自定义代码中的类方法缓存或虚函数表来查找类的方法。虚函数表也叫分派表，是一种动态绑定支持机制。最近调用过的方法的指针会被缓存起来，以优化性能。\n\n运行时系统库定义的方法数据类型 objc_method 定义如下:\n\n```c\nstruct objc_method {\n    SEL method_name;\n    char * method_types;\n    IMP method_imp;\n}\ntypedef objc_method Method;\n```\n\n其中，IMP 类型的变量用来提供方法的地址。\n\n方法查询逻辑如下：\n\n![etho](/img/ObjC-运行时系统/method.JPG)\n\n类方法是如何寻找的呢？运行时系统是通过元类（metaclass）来实现的。每个类都拥有一个独一无二的元类（可认为元类是类的类），元类向普通的类一样，也通过父类指针指向父类的元类。基类的元类会让它的父类指针指向基类本身。","source":"_posts/Obj-C运行时系统.md","raw":"---\ntitle: Obj-C运行时系统\ndate: 2018-04-02 21:46:22\ntags: Obj-C\n---\n\n# Objective-C 运行时系统\n\nObjective-C 会在运行时执行许多其他语言在编译或链接时执行的常规操作，如确定类型和方法解析。这些处理会带来额外的开销，Objective-C 通过缓存来节约这些开销。\n\n### 选择器\n\n在 Objective-C 的对象消息传递中，通过被称为 *选择器* 的字符串来指明调用对象的哪个方法。选择器是一种分为多个段的文本字符串，与方法的声明对应，例如：\n\n```\n分段1:分段2:分段3\n```\n\n如果创建了一个叫做 calculator 的变量，想调用它的方法，就要在接受器对象（calculator）后跟带输入参数的选择器：\n\n```objective-c\n[calculator sumAddend1:25 addend2:10];\n```\n\n选择器类型（SEL）是用于在编译源代码时替换选择器值的唯一标识符，Objective-C 运行时系统会保证每个选择器标识符的唯一性。可以用关键字 @selector 来创建 SEL 类型的变量。\n\n```objective-c\nSEL myMethod = @selector(myMethod);\n```\n\n也可以用 Foundation 框架中的 NSSelectorFromString 在运行时创建选择器：\n\n```objective-c\nSEL myMethod = NSSelectorFromString(@\"myMethod\");\n```\n\n### 方法签名\n\n方法签名定义了**输入参数**的数据类型和**返回值**。编译器会把 `[接收器 消息]` 形式的对象消息转换为生命中带有方法签名的 C 函数调用语句。因此，为了生成对象消息传递代码，编译器需要获得选择器值和方法签名。从对象消息表达式中提取选择器很容易，但怎么提取方法签名呢？由于接受器和接受器的方法是在程序运行时确定的，因此编译时没有办法知道怎样的数据类型能和要调用的方法对应起来。所以编译器只能根据已知的方法声明进行猜测。如果找不到方法签名，或者方法签名与运行时实际的执行方法不匹配，就会导致从编译器警告到运行时错误的各种问题产生。\n\n### 动态类型\n\n运行时系统通过动态类型功能，可以在运行时决定对象的类型。Objective-C 既支持静态类型，又支持动态类型。使用静态类型时，能在编译期检查类型，而使用动态类型时，就只能在运行时检查类型了。Objective-C 通过 id 类型来支持动态类型。id 类型的变量可以存储任何数据类型的对象。\n\nObjective-C 还为运行时的对象内省（如检查对象属于哪个类）提供了 API。通过内省我们可以在运行时检查对象类型，从而确定对象是否能够执行特定的操作。\n\n### 动态绑定\n\n动态绑定是指在运行时将消息和方法对应起来的过程。在运行时发送消息前，消息和接收消息的对象不会对应。由于许多接受器可能会实现相同的方法，所以调用方法的方式会动态变化，因而这也实现了 OOP 的多态。\n\n### 动态方法决议\n\n使用动态方法决议能够以动态的方式实现方法。可以通过重写 NSObject 的 `resolveInstanceMethod` 和 `resolveClassMethod` 方法来动态实现实例方法和类方法。\n\n可以通过 `class_addMethod()` API 来将函数添加到类中，需要先 `#import <objc/runtime.h> ` 。\n\n### 动态加载\n\n通过动态加载功能，可以在需要时加载可执行代码和源代码，而不必在程序启动时就加载所有的组件。这种 lazy loading 方式可以提高程序的性能和可拓展性。可以通过 NSBundle 来动态加载。\n\n### 内省\n\n通过系统提供的 API 可以动态查询与方法有关的信息，并测试对象的继承性、行为和一致性信息。\n\n### 运行时系统的组成结构\n\nObjective-C 的运行时系统由以下两部分组成：编译器和运行时系统库。\n\n### 编译器\n\n当编译器解析到使用了上述动态特性的 Objective-C 源代码时，会使用适当的运行时系统库函数来生成可执行代码。\n\n当编译器解析对象消息时，会生成调用运行时系统库函数 `objc_msgSend()` 中的代码，该函数以接受器、选择器和消息传递的参数一起作为参数。每条消息都是动态处理的，因此接受器类型和方法的实际实现都是在运行时决定的。\n\n当编译器解析含有类定义和对象的代码时，会生成相应的运行时数据结构。所有运行时类型都以 isa 指针开头。\n\n### 运行时系统库\n\n运行时系统库也提供了 C 语言的公共 API 供我们使用，这些 API 在 runtime.h 中声明。比如，可以动态的创建一个类。\n\n```objective-c\nClass dynamicClass = objc_allocateClassPair([NSObject class], \"DynamicClass\", 0);\n```\n\n当向对象发送消息时，运行时系统会通过自定义代码中的类方法缓存或虚函数表来查找类的方法。虚函数表也叫分派表，是一种动态绑定支持机制。最近调用过的方法的指针会被缓存起来，以优化性能。\n\n运行时系统库定义的方法数据类型 objc_method 定义如下:\n\n```c\nstruct objc_method {\n    SEL method_name;\n    char * method_types;\n    IMP method_imp;\n}\ntypedef objc_method Method;\n```\n\n其中，IMP 类型的变量用来提供方法的地址。\n\n方法查询逻辑如下：\n\n![etho](/img/ObjC-运行时系统/method.JPG)\n\n类方法是如何寻找的呢？运行时系统是通过元类（metaclass）来实现的。每个类都拥有一个独一无二的元类（可认为元类是类的类），元类向普通的类一样，也通过父类指针指向父类的元类。基类的元类会让它的父类指针指向基类本身。","slug":"Obj-C运行时系统","published":1,"updated":"2020-01-04T08:16:16.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv2y000dljc3l2ikmr6q","content":"<h1 id=\"Objective-C-运行时系统\"><a href=\"#Objective-C-运行时系统\" class=\"headerlink\" title=\"Objective-C 运行时系统\"></a>Objective-C 运行时系统</h1><p>Objective-C 会在运行时执行许多其他语言在编译或链接时执行的常规操作，如确定类型和方法解析。这些处理会带来额外的开销，Objective-C 通过缓存来节约这些开销。</p>\n<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><p>在 Objective-C 的对象消息传递中，通过被称为 <em>选择器</em> 的字符串来指明调用对象的哪个方法。选择器是一种分为多个段的文本字符串，与方法的声明对应，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">分段1:分段2:分段3</span><br></pre></td></tr></table></figure>\n<p>如果创建了一个叫做 calculator 的变量，想调用它的方法，就要在接受器对象（calculator）后跟带输入参数的选择器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[calculator sumAddend1:25 addend2:10];</span><br></pre></td></tr></table></figure>\n<p>选择器类型（SEL）是用于在编译源代码时替换选择器值的唯一标识符，Objective-C 运行时系统会保证每个选择器标识符的唯一性。可以用关键字 @selector 来创建 SEL 类型的变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SEL myMethod = @selector(myMethod);</span><br></pre></td></tr></table></figure>\n<p>也可以用 Foundation 框架中的 NSSelectorFromString 在运行时创建选择器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SEL myMethod = NSSelectorFromString(@&quot;myMethod&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法签名\"><a href=\"#方法签名\" class=\"headerlink\" title=\"方法签名\"></a>方法签名</h3><p>方法签名定义了<strong>输入参数</strong>的数据类型和<strong>返回值</strong>。编译器会把 <code>[接收器 消息]</code> 形式的对象消息转换为生命中带有方法签名的 C 函数调用语句。因此，为了生成对象消息传递代码，编译器需要获得选择器值和方法签名。从对象消息表达式中提取选择器很容易，但怎么提取方法签名呢？由于接受器和接受器的方法是在程序运行时确定的，因此编译时没有办法知道怎样的数据类型能和要调用的方法对应起来。所以编译器只能根据已知的方法声明进行猜测。如果找不到方法签名，或者方法签名与运行时实际的执行方法不匹配，就会导致从编译器警告到运行时错误的各种问题产生。</p>\n<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p>运行时系统通过动态类型功能，可以在运行时决定对象的类型。Objective-C 既支持静态类型，又支持动态类型。使用静态类型时，能在编译期检查类型，而使用动态类型时，就只能在运行时检查类型了。Objective-C 通过 id 类型来支持动态类型。id 类型的变量可以存储任何数据类型的对象。</p>\n<p>Objective-C 还为运行时的对象内省（如检查对象属于哪个类）提供了 API。通过内省我们可以在运行时检查对象类型，从而确定对象是否能够执行特定的操作。</p>\n<h3 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h3><p>动态绑定是指在运行时将消息和方法对应起来的过程。在运行时发送消息前，消息和接收消息的对象不会对应。由于许多接受器可能会实现相同的方法，所以调用方法的方式会动态变化，因而这也实现了 OOP 的多态。</p>\n<h3 id=\"动态方法决议\"><a href=\"#动态方法决议\" class=\"headerlink\" title=\"动态方法决议\"></a>动态方法决议</h3><p>使用动态方法决议能够以动态的方式实现方法。可以通过重写 NSObject 的 <code>resolveInstanceMethod</code> 和 <code>resolveClassMethod</code> 方法来动态实现实例方法和类方法。</p>\n<p>可以通过 <code>class_addMethod()</code> API 来将函数添加到类中，需要先 <code>#import &lt;objc/runtime.h&gt;</code> 。</p>\n<h3 id=\"动态加载\"><a href=\"#动态加载\" class=\"headerlink\" title=\"动态加载\"></a>动态加载</h3><p>通过动态加载功能，可以在需要时加载可执行代码和源代码，而不必在程序启动时就加载所有的组件。这种 lazy loading 方式可以提高程序的性能和可拓展性。可以通过 NSBundle 来动态加载。</p>\n<h3 id=\"内省\"><a href=\"#内省\" class=\"headerlink\" title=\"内省\"></a>内省</h3><p>通过系统提供的 API 可以动态查询与方法有关的信息，并测试对象的继承性、行为和一致性信息。</p>\n<h3 id=\"运行时系统的组成结构\"><a href=\"#运行时系统的组成结构\" class=\"headerlink\" title=\"运行时系统的组成结构\"></a>运行时系统的组成结构</h3><p>Objective-C 的运行时系统由以下两部分组成：编译器和运行时系统库。</p>\n<h3 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h3><p>当编译器解析到使用了上述动态特性的 Objective-C 源代码时，会使用适当的运行时系统库函数来生成可执行代码。</p>\n<p>当编译器解析对象消息时，会生成调用运行时系统库函数 <code>objc_msgSend()</code> 中的代码，该函数以接受器、选择器和消息传递的参数一起作为参数。每条消息都是动态处理的，因此接受器类型和方法的实际实现都是在运行时决定的。</p>\n<p>当编译器解析含有类定义和对象的代码时，会生成相应的运行时数据结构。所有运行时类型都以 isa 指针开头。</p>\n<h3 id=\"运行时系统库\"><a href=\"#运行时系统库\" class=\"headerlink\" title=\"运行时系统库\"></a>运行时系统库</h3><p>运行时系统库也提供了 C 语言的公共 API 供我们使用，这些 API 在 runtime.h 中声明。比如，可以动态的创建一个类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class dynamicClass = objc_allocateClassPair([NSObject class], &quot;DynamicClass&quot;, 0);</span><br></pre></td></tr></table></figure>\n<p>当向对象发送消息时，运行时系统会通过自定义代码中的类方法缓存或虚函数表来查找类的方法。虚函数表也叫分派表，是一种动态绑定支持机制。最近调用过的方法的指针会被缓存起来，以优化性能。</p>\n<p>运行时系统库定义的方法数据类型 objc_method 定义如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method</span> &#123;</span></span><br><span class=\"line\">    SEL method_name;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * method_types;</span><br><span class=\"line\">    IMP method_imp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> objc_method Method;</span><br></pre></td></tr></table></figure>\n<p>其中，IMP 类型的变量用来提供方法的地址。</p>\n<p>方法查询逻辑如下：</p>\n<p><img src=\"/img/ObjC-运行时系统/method.JPG\" alt=\"etho\"></p>\n<p>类方法是如何寻找的呢？运行时系统是通过元类（metaclass）来实现的。每个类都拥有一个独一无二的元类（可认为元类是类的类），元类向普通的类一样，也通过父类指针指向父类的元类。基类的元类会让它的父类指针指向基类本身。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Objective-C-运行时系统\"><a href=\"#Objective-C-运行时系统\" class=\"headerlink\" title=\"Objective-C 运行时系统\"></a>Objective-C 运行时系统</h1><p>Objective-C 会在运行时执行许多其他语言在编译或链接时执行的常规操作，如确定类型和方法解析。这些处理会带来额外的开销，Objective-C 通过缓存来节约这些开销。</p>\n<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><p>在 Objective-C 的对象消息传递中，通过被称为 <em>选择器</em> 的字符串来指明调用对象的哪个方法。选择器是一种分为多个段的文本字符串，与方法的声明对应，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">分段1:分段2:分段3</span><br></pre></td></tr></table></figure>\n<p>如果创建了一个叫做 calculator 的变量，想调用它的方法，就要在接受器对象（calculator）后跟带输入参数的选择器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[calculator sumAddend1:25 addend2:10];</span><br></pre></td></tr></table></figure>\n<p>选择器类型（SEL）是用于在编译源代码时替换选择器值的唯一标识符，Objective-C 运行时系统会保证每个选择器标识符的唯一性。可以用关键字 @selector 来创建 SEL 类型的变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SEL myMethod = @selector(myMethod);</span><br></pre></td></tr></table></figure>\n<p>也可以用 Foundation 框架中的 NSSelectorFromString 在运行时创建选择器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SEL myMethod = NSSelectorFromString(@&quot;myMethod&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"方法签名\"><a href=\"#方法签名\" class=\"headerlink\" title=\"方法签名\"></a>方法签名</h3><p>方法签名定义了<strong>输入参数</strong>的数据类型和<strong>返回值</strong>。编译器会把 <code>[接收器 消息]</code> 形式的对象消息转换为生命中带有方法签名的 C 函数调用语句。因此，为了生成对象消息传递代码，编译器需要获得选择器值和方法签名。从对象消息表达式中提取选择器很容易，但怎么提取方法签名呢？由于接受器和接受器的方法是在程序运行时确定的，因此编译时没有办法知道怎样的数据类型能和要调用的方法对应起来。所以编译器只能根据已知的方法声明进行猜测。如果找不到方法签名，或者方法签名与运行时实际的执行方法不匹配，就会导致从编译器警告到运行时错误的各种问题产生。</p>\n<h3 id=\"动态类型\"><a href=\"#动态类型\" class=\"headerlink\" title=\"动态类型\"></a>动态类型</h3><p>运行时系统通过动态类型功能，可以在运行时决定对象的类型。Objective-C 既支持静态类型，又支持动态类型。使用静态类型时，能在编译期检查类型，而使用动态类型时，就只能在运行时检查类型了。Objective-C 通过 id 类型来支持动态类型。id 类型的变量可以存储任何数据类型的对象。</p>\n<p>Objective-C 还为运行时的对象内省（如检查对象属于哪个类）提供了 API。通过内省我们可以在运行时检查对象类型，从而确定对象是否能够执行特定的操作。</p>\n<h3 id=\"动态绑定\"><a href=\"#动态绑定\" class=\"headerlink\" title=\"动态绑定\"></a>动态绑定</h3><p>动态绑定是指在运行时将消息和方法对应起来的过程。在运行时发送消息前，消息和接收消息的对象不会对应。由于许多接受器可能会实现相同的方法，所以调用方法的方式会动态变化，因而这也实现了 OOP 的多态。</p>\n<h3 id=\"动态方法决议\"><a href=\"#动态方法决议\" class=\"headerlink\" title=\"动态方法决议\"></a>动态方法决议</h3><p>使用动态方法决议能够以动态的方式实现方法。可以通过重写 NSObject 的 <code>resolveInstanceMethod</code> 和 <code>resolveClassMethod</code> 方法来动态实现实例方法和类方法。</p>\n<p>可以通过 <code>class_addMethod()</code> API 来将函数添加到类中，需要先 <code>#import &lt;objc/runtime.h&gt;</code> 。</p>\n<h3 id=\"动态加载\"><a href=\"#动态加载\" class=\"headerlink\" title=\"动态加载\"></a>动态加载</h3><p>通过动态加载功能，可以在需要时加载可执行代码和源代码，而不必在程序启动时就加载所有的组件。这种 lazy loading 方式可以提高程序的性能和可拓展性。可以通过 NSBundle 来动态加载。</p>\n<h3 id=\"内省\"><a href=\"#内省\" class=\"headerlink\" title=\"内省\"></a>内省</h3><p>通过系统提供的 API 可以动态查询与方法有关的信息，并测试对象的继承性、行为和一致性信息。</p>\n<h3 id=\"运行时系统的组成结构\"><a href=\"#运行时系统的组成结构\" class=\"headerlink\" title=\"运行时系统的组成结构\"></a>运行时系统的组成结构</h3><p>Objective-C 的运行时系统由以下两部分组成：编译器和运行时系统库。</p>\n<h3 id=\"编译器\"><a href=\"#编译器\" class=\"headerlink\" title=\"编译器\"></a>编译器</h3><p>当编译器解析到使用了上述动态特性的 Objective-C 源代码时，会使用适当的运行时系统库函数来生成可执行代码。</p>\n<p>当编译器解析对象消息时，会生成调用运行时系统库函数 <code>objc_msgSend()</code> 中的代码，该函数以接受器、选择器和消息传递的参数一起作为参数。每条消息都是动态处理的，因此接受器类型和方法的实际实现都是在运行时决定的。</p>\n<p>当编译器解析含有类定义和对象的代码时，会生成相应的运行时数据结构。所有运行时类型都以 isa 指针开头。</p>\n<h3 id=\"运行时系统库\"><a href=\"#运行时系统库\" class=\"headerlink\" title=\"运行时系统库\"></a>运行时系统库</h3><p>运行时系统库也提供了 C 语言的公共 API 供我们使用，这些 API 在 runtime.h 中声明。比如，可以动态的创建一个类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class dynamicClass = objc_allocateClassPair([NSObject class], &quot;DynamicClass&quot;, 0);</span><br></pre></td></tr></table></figure>\n<p>当向对象发送消息时，运行时系统会通过自定义代码中的类方法缓存或虚函数表来查找类的方法。虚函数表也叫分派表，是一种动态绑定支持机制。最近调用过的方法的指针会被缓存起来，以优化性能。</p>\n<p>运行时系统库定义的方法数据类型 objc_method 定义如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">objc_method</span> &#123;</span></span><br><span class=\"line\">    SEL method_name;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> * method_types;</span><br><span class=\"line\">    IMP method_imp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> objc_method Method;</span><br></pre></td></tr></table></figure>\n<p>其中，IMP 类型的变量用来提供方法的地址。</p>\n<p>方法查询逻辑如下：</p>\n<p><img src=\"/img/ObjC-运行时系统/method.JPG\" alt=\"etho\"></p>\n<p>类方法是如何寻找的呢？运行时系统是通过元类（metaclass）来实现的。每个类都拥有一个独一无二的元类（可认为元类是类的类），元类向普通的类一样，也通过父类指针指向父类的元类。基类的元类会让它的父类指针指向基类本身。</p>\n"},{"title":"Obj-C键值编程","date":"2018-04-07T12:23:35.000Z","_content":"\n# Objective-C 键值编程\n\nObjective-C 键值编程包括键值编码 KVC 和键值观察 KVO 两部分。\n\n### 键值编码\n\n对象内部的属性由于被封装起来，无法直接访问，而要用到属性的 getter 和 setter 方法。KVC 提供了一种用于访问属性的键值对机制，其中 key 是属性的名称，而 value 是属性的值。这种机制与访问字典条目的机制相同。如：\n\n```objective-c\n[object valueForKey: @\"var1\"];\n[object setValue: @\"value\" forKey: @\"var1\"];\n```\n\n通过 KVC，可以用能在运行时改变的字符串来访问属性，从而动态而灵活地访问和操作对象的状态。\n\n也可以通过键路径来指明需要便利的对象属性序列，下面两行代码的功能是相同的：\n\n```objective-c\nperson.name.firstName = @\"Bob\";\n[person setValue: @\"Bob\" forKeyPath: @\"name.firstName\"];\n```\n\n还可以通过 `dictionaryWithValuesForKeys` 方法设置或获取多个属性的值。\n\nNSObject 遵守 NSKeyValueCoding 协议，因此它的所有子类都为键值编码提供了内置支持。\n\n你可以通过在类中重写 NSKeyValueCoding 的一些方法来控制类的行为。比如通过重写 `accessInstanceVariablesDirectly` 可以让类控制如果没有找到属性的访问方法，能不能直接让键值编码访问属性的支持变量。\n\n### 键值搜索模式\n\nKVC 如何来去获取和设置属性的值呢？\n\n- KVC 首先会搜索目标类名称符合 set\\<Key> 的访问方法。例如，如果调用了 `setValue:forKey:` 方法，为 key 提供了参数 name，那么 KVC 就会搜索目标类中 `setName:` 的访问方法。\n- 如果没找到访问方法，且接收对象的类方法 `accessInstanceVariablesDirectly` 返回 YES（默认返回 YES，可以设置为 NO），KVC 就会搜索接收对象的类，寻找名称匹配 _key / _isKey / key / isKey 格式的实例变量。\n- 如果找到了，就会设置值。\n- 如果没找到，接收对象的 `setValue:forUndefinedKey:` 就会被调用。通过重写这些方法可以处理无法找到属性的情况。\n\n由此可见，写代码时应该遵循 Cocoa 的命名规范，这样才能让 KVC 正常工作。\n\n### 集合操作符\n\nKVC 也可以对集合类型的元素进行操作。格式为 `集合键路径.@操作符.属性键路径` 。\n\n```objective-c\nNSNumber *totalPrice = [orderItems valueForKeyPath: @\"@sum.price\"]; //计算总和\nNSNumber *totalItems = [orderItems valueForKeyPath: @\"@count\"]; //确定集合含有的对象数量\nNSArray *itemTypes = [orderItems valueForKeyPath: @\"@distinctUnionOfObjects.description\"]; //获取每个集合元素的描述\n```\n\n### 键值观察\n\nKVO 是一种通知机制，它使对象能够在其他对象的属性发生更改时获得通知。\n\n通过 `addObserver:forKeyPath:options:context:` 方法，在观察对象和被观察对象之间建立联系。当被观察属性的值发生改变时，被观察对象就会调用观察对象中的 `observeValueForKeyPath:ofObject:change:context:` 方法。在该方法中，观察者类会实现用于处理被观察属性发生更改的逻辑。\n\nNSObject 遵守 NSKeyValueObserving 协议，因此它的所有子类都对键值观察提供了内置的支持。\n\n### 键值观察和通知\n\n键值观察和通知都提供了对象间的传递信息机制，功能有些类似。下面对两者进行比较。\n\nNSNotification 能够封装通用信息，可以为更广泛的系统事件提供支持。而 KVO 只能支持对象属性更改通知功能。\n\n通知使用交互的广播模型，信息会通过集中式通知中心分发，可以向多个对象发送消息。通知支持同步传递通知，也支持通过 NSNotificationQueue 来异步传递通知。KVO 使用点对点的交互模型，被观察对象会直接向已注册的观察着发送通知，且程序会一直处于阻塞状态，直到相应的处理执行完为止。通知的非阻塞交互模式可以提高应用程序的响应性。\n\n通知双方是分隔开的，而 KVO 会通过 addObserver 方法为观察对象建立一个强引用。因此在释放被观察对象前，应该先通过 removeObserver 删除观察对象。\n\n### KVO 的实现\n\n键值观察是通过 Objective-C 的 Runtime 实现的。当你为对象注册观察者时，KVO 的基础设施会动态创建一个被观察对象的子类。然后，它将被观察对象的 isa 指针指向这个新建的子类，这样向原所属类发送的消息实际上就会被发送给这个子类。正常来说，isa 指针会指向对象的所属类，而该类拥有一个列出指针与该类中方法关系的分派表。这个新建的子类会拦截向被观察者发送的消息，向观察者发送通知等。以动态方式置换 isa 指针指向的类被称为 isa-swizzling。","source":"_posts/Obj-C键值编程.md","raw":"---\ntitle: Obj-C键值编程\ndate: 2018-04-07 20:23:35\ntags: Obj-C\n---\n\n# Objective-C 键值编程\n\nObjective-C 键值编程包括键值编码 KVC 和键值观察 KVO 两部分。\n\n### 键值编码\n\n对象内部的属性由于被封装起来，无法直接访问，而要用到属性的 getter 和 setter 方法。KVC 提供了一种用于访问属性的键值对机制，其中 key 是属性的名称，而 value 是属性的值。这种机制与访问字典条目的机制相同。如：\n\n```objective-c\n[object valueForKey: @\"var1\"];\n[object setValue: @\"value\" forKey: @\"var1\"];\n```\n\n通过 KVC，可以用能在运行时改变的字符串来访问属性，从而动态而灵活地访问和操作对象的状态。\n\n也可以通过键路径来指明需要便利的对象属性序列，下面两行代码的功能是相同的：\n\n```objective-c\nperson.name.firstName = @\"Bob\";\n[person setValue: @\"Bob\" forKeyPath: @\"name.firstName\"];\n```\n\n还可以通过 `dictionaryWithValuesForKeys` 方法设置或获取多个属性的值。\n\nNSObject 遵守 NSKeyValueCoding 协议，因此它的所有子类都为键值编码提供了内置支持。\n\n你可以通过在类中重写 NSKeyValueCoding 的一些方法来控制类的行为。比如通过重写 `accessInstanceVariablesDirectly` 可以让类控制如果没有找到属性的访问方法，能不能直接让键值编码访问属性的支持变量。\n\n### 键值搜索模式\n\nKVC 如何来去获取和设置属性的值呢？\n\n- KVC 首先会搜索目标类名称符合 set\\<Key> 的访问方法。例如，如果调用了 `setValue:forKey:` 方法，为 key 提供了参数 name，那么 KVC 就会搜索目标类中 `setName:` 的访问方法。\n- 如果没找到访问方法，且接收对象的类方法 `accessInstanceVariablesDirectly` 返回 YES（默认返回 YES，可以设置为 NO），KVC 就会搜索接收对象的类，寻找名称匹配 _key / _isKey / key / isKey 格式的实例变量。\n- 如果找到了，就会设置值。\n- 如果没找到，接收对象的 `setValue:forUndefinedKey:` 就会被调用。通过重写这些方法可以处理无法找到属性的情况。\n\n由此可见，写代码时应该遵循 Cocoa 的命名规范，这样才能让 KVC 正常工作。\n\n### 集合操作符\n\nKVC 也可以对集合类型的元素进行操作。格式为 `集合键路径.@操作符.属性键路径` 。\n\n```objective-c\nNSNumber *totalPrice = [orderItems valueForKeyPath: @\"@sum.price\"]; //计算总和\nNSNumber *totalItems = [orderItems valueForKeyPath: @\"@count\"]; //确定集合含有的对象数量\nNSArray *itemTypes = [orderItems valueForKeyPath: @\"@distinctUnionOfObjects.description\"]; //获取每个集合元素的描述\n```\n\n### 键值观察\n\nKVO 是一种通知机制，它使对象能够在其他对象的属性发生更改时获得通知。\n\n通过 `addObserver:forKeyPath:options:context:` 方法，在观察对象和被观察对象之间建立联系。当被观察属性的值发生改变时，被观察对象就会调用观察对象中的 `observeValueForKeyPath:ofObject:change:context:` 方法。在该方法中，观察者类会实现用于处理被观察属性发生更改的逻辑。\n\nNSObject 遵守 NSKeyValueObserving 协议，因此它的所有子类都对键值观察提供了内置的支持。\n\n### 键值观察和通知\n\n键值观察和通知都提供了对象间的传递信息机制，功能有些类似。下面对两者进行比较。\n\nNSNotification 能够封装通用信息，可以为更广泛的系统事件提供支持。而 KVO 只能支持对象属性更改通知功能。\n\n通知使用交互的广播模型，信息会通过集中式通知中心分发，可以向多个对象发送消息。通知支持同步传递通知，也支持通过 NSNotificationQueue 来异步传递通知。KVO 使用点对点的交互模型，被观察对象会直接向已注册的观察着发送通知，且程序会一直处于阻塞状态，直到相应的处理执行完为止。通知的非阻塞交互模式可以提高应用程序的响应性。\n\n通知双方是分隔开的，而 KVO 会通过 addObserver 方法为观察对象建立一个强引用。因此在释放被观察对象前，应该先通过 removeObserver 删除观察对象。\n\n### KVO 的实现\n\n键值观察是通过 Objective-C 的 Runtime 实现的。当你为对象注册观察者时，KVO 的基础设施会动态创建一个被观察对象的子类。然后，它将被观察对象的 isa 指针指向这个新建的子类，这样向原所属类发送的消息实际上就会被发送给这个子类。正常来说，isa 指针会指向对象的所属类，而该类拥有一个列出指针与该类中方法关系的分派表。这个新建的子类会拦截向被观察者发送的消息，向观察者发送通知等。以动态方式置换 isa 指针指向的类被称为 isa-swizzling。","slug":"Obj-C键值编程","published":1,"updated":"2020-01-04T08:16:16.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv2z000fljc33u1wr3ky","content":"<h1 id=\"Objective-C-键值编程\"><a href=\"#Objective-C-键值编程\" class=\"headerlink\" title=\"Objective-C 键值编程\"></a>Objective-C 键值编程</h1><p>Objective-C 键值编程包括键值编码 KVC 和键值观察 KVO 两部分。</p>\n<h3 id=\"键值编码\"><a href=\"#键值编码\" class=\"headerlink\" title=\"键值编码\"></a>键值编码</h3><p>对象内部的属性由于被封装起来，无法直接访问，而要用到属性的 getter 和 setter 方法。KVC 提供了一种用于访问属性的键值对机制，其中 key 是属性的名称，而 value 是属性的值。这种机制与访问字典条目的机制相同。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[object valueForKey: @&quot;var1&quot;];</span><br><span class=\"line\">[object setValue: @&quot;value&quot; forKey: @&quot;var1&quot;];</span><br></pre></td></tr></table></figure>\n<p>通过 KVC，可以用能在运行时改变的字符串来访问属性，从而动态而灵活地访问和操作对象的状态。</p>\n<p>也可以通过键路径来指明需要便利的对象属性序列，下面两行代码的功能是相同的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.name.firstName = @&quot;Bob&quot;;</span><br><span class=\"line\">[person setValue: @&quot;Bob&quot; forKeyPath: @&quot;name.firstName&quot;];</span><br></pre></td></tr></table></figure>\n<p>还可以通过 <code>dictionaryWithValuesForKeys</code> 方法设置或获取多个属性的值。</p>\n<p>NSObject 遵守 NSKeyValueCoding 协议，因此它的所有子类都为键值编码提供了内置支持。</p>\n<p>你可以通过在类中重写 NSKeyValueCoding 的一些方法来控制类的行为。比如通过重写 <code>accessInstanceVariablesDirectly</code> 可以让类控制如果没有找到属性的访问方法，能不能直接让键值编码访问属性的支持变量。</p>\n<h3 id=\"键值搜索模式\"><a href=\"#键值搜索模式\" class=\"headerlink\" title=\"键值搜索模式\"></a>键值搜索模式</h3><p>KVC 如何来去获取和设置属性的值呢？</p>\n<ul>\n<li>KVC 首先会搜索目标类名称符合 set\\<Key> 的访问方法。例如，如果调用了 <code>setValue:forKey:</code> 方法，为 key 提供了参数 name，那么 KVC 就会搜索目标类中 <code>setName:</code> 的访问方法。</li>\n<li>如果没找到访问方法，且接收对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回 YES（默认返回 YES，可以设置为 NO），KVC 就会搜索接收对象的类，寻找名称匹配 _key / _isKey / key / isKey 格式的实例变量。</li>\n<li>如果找到了，就会设置值。</li>\n<li>如果没找到，接收对象的 <code>setValue:forUndefinedKey:</code> 就会被调用。通过重写这些方法可以处理无法找到属性的情况。</li>\n</ul>\n<p>由此可见，写代码时应该遵循 Cocoa 的命名规范，这样才能让 KVC 正常工作。</p>\n<h3 id=\"集合操作符\"><a href=\"#集合操作符\" class=\"headerlink\" title=\"集合操作符\"></a>集合操作符</h3><p>KVC 也可以对集合类型的元素进行操作。格式为 <code>集合键路径.@操作符.属性键路径</code> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSNumber *totalPrice = [orderItems valueForKeyPath: @&quot;@sum.price&quot;]; //计算总和</span><br><span class=\"line\">NSNumber *totalItems = [orderItems valueForKeyPath: @&quot;@count&quot;]; //确定集合含有的对象数量</span><br><span class=\"line\">NSArray *itemTypes = [orderItems valueForKeyPath: @&quot;@distinctUnionOfObjects.description&quot;]; //获取每个集合元素的描述</span><br></pre></td></tr></table></figure>\n<h3 id=\"键值观察\"><a href=\"#键值观察\" class=\"headerlink\" title=\"键值观察\"></a>键值观察</h3><p>KVO 是一种通知机制，它使对象能够在其他对象的属性发生更改时获得通知。</p>\n<p>通过 <code>addObserver:forKeyPath:options:context:</code> 方法，在观察对象和被观察对象之间建立联系。当被观察属性的值发生改变时，被观察对象就会调用观察对象中的 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法。在该方法中，观察者类会实现用于处理被观察属性发生更改的逻辑。</p>\n<p>NSObject 遵守 NSKeyValueObserving 协议，因此它的所有子类都对键值观察提供了内置的支持。</p>\n<h3 id=\"键值观察和通知\"><a href=\"#键值观察和通知\" class=\"headerlink\" title=\"键值观察和通知\"></a>键值观察和通知</h3><p>键值观察和通知都提供了对象间的传递信息机制，功能有些类似。下面对两者进行比较。</p>\n<p>NSNotification 能够封装通用信息，可以为更广泛的系统事件提供支持。而 KVO 只能支持对象属性更改通知功能。</p>\n<p>通知使用交互的广播模型，信息会通过集中式通知中心分发，可以向多个对象发送消息。通知支持同步传递通知，也支持通过 NSNotificationQueue 来异步传递通知。KVO 使用点对点的交互模型，被观察对象会直接向已注册的观察着发送通知，且程序会一直处于阻塞状态，直到相应的处理执行完为止。通知的非阻塞交互模式可以提高应用程序的响应性。</p>\n<p>通知双方是分隔开的，而 KVO 会通过 addObserver 方法为观察对象建立一个强引用。因此在释放被观察对象前，应该先通过 removeObserver 删除观察对象。</p>\n<h3 id=\"KVO-的实现\"><a href=\"#KVO-的实现\" class=\"headerlink\" title=\"KVO 的实现\"></a>KVO 的实现</h3><p>键值观察是通过 Objective-C 的 Runtime 实现的。当你为对象注册观察者时，KVO 的基础设施会动态创建一个被观察对象的子类。然后，它将被观察对象的 isa 指针指向这个新建的子类，这样向原所属类发送的消息实际上就会被发送给这个子类。正常来说，isa 指针会指向对象的所属类，而该类拥有一个列出指针与该类中方法关系的分派表。这个新建的子类会拦截向被观察者发送的消息，向观察者发送通知等。以动态方式置换 isa 指针指向的类被称为 isa-swizzling。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Objective-C-键值编程\"><a href=\"#Objective-C-键值编程\" class=\"headerlink\" title=\"Objective-C 键值编程\"></a>Objective-C 键值编程</h1><p>Objective-C 键值编程包括键值编码 KVC 和键值观察 KVO 两部分。</p>\n<h3 id=\"键值编码\"><a href=\"#键值编码\" class=\"headerlink\" title=\"键值编码\"></a>键值编码</h3><p>对象内部的属性由于被封装起来，无法直接访问，而要用到属性的 getter 和 setter 方法。KVC 提供了一种用于访问属性的键值对机制，其中 key 是属性的名称，而 value 是属性的值。这种机制与访问字典条目的机制相同。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[object valueForKey: @&quot;var1&quot;];</span><br><span class=\"line\">[object setValue: @&quot;value&quot; forKey: @&quot;var1&quot;];</span><br></pre></td></tr></table></figure>\n<p>通过 KVC，可以用能在运行时改变的字符串来访问属性，从而动态而灵活地访问和操作对象的状态。</p>\n<p>也可以通过键路径来指明需要便利的对象属性序列，下面两行代码的功能是相同的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person.name.firstName = @&quot;Bob&quot;;</span><br><span class=\"line\">[person setValue: @&quot;Bob&quot; forKeyPath: @&quot;name.firstName&quot;];</span><br></pre></td></tr></table></figure>\n<p>还可以通过 <code>dictionaryWithValuesForKeys</code> 方法设置或获取多个属性的值。</p>\n<p>NSObject 遵守 NSKeyValueCoding 协议，因此它的所有子类都为键值编码提供了内置支持。</p>\n<p>你可以通过在类中重写 NSKeyValueCoding 的一些方法来控制类的行为。比如通过重写 <code>accessInstanceVariablesDirectly</code> 可以让类控制如果没有找到属性的访问方法，能不能直接让键值编码访问属性的支持变量。</p>\n<h3 id=\"键值搜索模式\"><a href=\"#键值搜索模式\" class=\"headerlink\" title=\"键值搜索模式\"></a>键值搜索模式</h3><p>KVC 如何来去获取和设置属性的值呢？</p>\n<ul>\n<li>KVC 首先会搜索目标类名称符合 set\\<Key> 的访问方法。例如，如果调用了 <code>setValue:forKey:</code> 方法，为 key 提供了参数 name，那么 KVC 就会搜索目标类中 <code>setName:</code> 的访问方法。</li>\n<li>如果没找到访问方法，且接收对象的类方法 <code>accessInstanceVariablesDirectly</code> 返回 YES（默认返回 YES，可以设置为 NO），KVC 就会搜索接收对象的类，寻找名称匹配 _key / _isKey / key / isKey 格式的实例变量。</li>\n<li>如果找到了，就会设置值。</li>\n<li>如果没找到，接收对象的 <code>setValue:forUndefinedKey:</code> 就会被调用。通过重写这些方法可以处理无法找到属性的情况。</li>\n</ul>\n<p>由此可见，写代码时应该遵循 Cocoa 的命名规范，这样才能让 KVC 正常工作。</p>\n<h3 id=\"集合操作符\"><a href=\"#集合操作符\" class=\"headerlink\" title=\"集合操作符\"></a>集合操作符</h3><p>KVC 也可以对集合类型的元素进行操作。格式为 <code>集合键路径.@操作符.属性键路径</code> 。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NSNumber *totalPrice = [orderItems valueForKeyPath: @&quot;@sum.price&quot;]; //计算总和</span><br><span class=\"line\">NSNumber *totalItems = [orderItems valueForKeyPath: @&quot;@count&quot;]; //确定集合含有的对象数量</span><br><span class=\"line\">NSArray *itemTypes = [orderItems valueForKeyPath: @&quot;@distinctUnionOfObjects.description&quot;]; //获取每个集合元素的描述</span><br></pre></td></tr></table></figure>\n<h3 id=\"键值观察\"><a href=\"#键值观察\" class=\"headerlink\" title=\"键值观察\"></a>键值观察</h3><p>KVO 是一种通知机制，它使对象能够在其他对象的属性发生更改时获得通知。</p>\n<p>通过 <code>addObserver:forKeyPath:options:context:</code> 方法，在观察对象和被观察对象之间建立联系。当被观察属性的值发生改变时，被观察对象就会调用观察对象中的 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法。在该方法中，观察者类会实现用于处理被观察属性发生更改的逻辑。</p>\n<p>NSObject 遵守 NSKeyValueObserving 协议，因此它的所有子类都对键值观察提供了内置的支持。</p>\n<h3 id=\"键值观察和通知\"><a href=\"#键值观察和通知\" class=\"headerlink\" title=\"键值观察和通知\"></a>键值观察和通知</h3><p>键值观察和通知都提供了对象间的传递信息机制，功能有些类似。下面对两者进行比较。</p>\n<p>NSNotification 能够封装通用信息，可以为更广泛的系统事件提供支持。而 KVO 只能支持对象属性更改通知功能。</p>\n<p>通知使用交互的广播模型，信息会通过集中式通知中心分发，可以向多个对象发送消息。通知支持同步传递通知，也支持通过 NSNotificationQueue 来异步传递通知。KVO 使用点对点的交互模型，被观察对象会直接向已注册的观察着发送通知，且程序会一直处于阻塞状态，直到相应的处理执行完为止。通知的非阻塞交互模式可以提高应用程序的响应性。</p>\n<p>通知双方是分隔开的，而 KVO 会通过 addObserver 方法为观察对象建立一个强引用。因此在释放被观察对象前，应该先通过 removeObserver 删除观察对象。</p>\n<h3 id=\"KVO-的实现\"><a href=\"#KVO-的实现\" class=\"headerlink\" title=\"KVO 的实现\"></a>KVO 的实现</h3><p>键值观察是通过 Objective-C 的 Runtime 实现的。当你为对象注册观察者时，KVO 的基础设施会动态创建一个被观察对象的子类。然后，它将被观察对象的 isa 指针指向这个新建的子类，这样向原所属类发送的消息实际上就会被发送给这个子类。正常来说，isa 指针会指向对象的所属类，而该类拥有一个列出指针与该类中方法关系的分派表。这个新建的子类会拦截向被观察者发送的消息，向观察者发送通知等。以动态方式置换 isa 指针指向的类被称为 isa-swizzling。</p>\n"},{"title":"Python import 崩溃问题","date":"2018-12-12T13:38:50.000Z","_content":"\n# Python import 崩溃问题\n\n最近遇到了一个比较诡异的问题，在一个 Python 文件中，我 import 了如下几个库：\n\n- turtle\n- time\n- numpy\n\n在另一个 Python `navigation.py` 中，我 import 了另外几个库：\n\n- numpy\n- skfuzzy\n- from skfuzzy import control\n- matplotlib.pyplot\n\n两个文件分别运行时，都非常正常。但是，我在第一个文件中一旦 import `navigation.py` 文件（我想使用其中定义的函数），就会收到操作系统抛出的终端异常：\n\n```\nTerminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[NSApplication _setup:]: unrecognized selector sent to instance 0x114c65a40'\n```\n\n可以看到，这个异常是 macOS 给出来的，而并不是 Python 报给我的。\n\n经过测试，我发现如下情况可以让程序执行：不调用 turtle 的绘图语句，或者，同时注释掉 `from skfuzzy import control` 和 `import matplotlib.pyplot` 。这就让问题显得十分诡异。\n\n最终的解决方案是，在程序的最开始添加如下代码：\n\n```python\nfrom sys import platform as sys_pf\nif sys_pf == 'darwin':\n    import matplotlib\n    matplotlib.use(\"TkAgg\")\n```\n\n这应该是 matplotlib 的一个 bug，在 macOS 环境下，要显示指明使用 TkAgg 作为界面库。崩溃的原因或许是 turtle 和 matplotlib 绘图的机制有所冲突？\n\n## 附记\n\n使用 `skfuzzy` （scikit-fuzzy）库的时候，直接调用 `view()` 方法画 membership function 的曲线图无效（图片不显示），必须要先 `import matplotlib.pyplot as plt` 然后调用 `plt.show()` 才可以显示。也是个很奇怪的问题呢……\n\n本来只是想把 Python 当作一个顺手的工具，没想到越是着急写东西越是遇到大坑，由此可见把底层原理搞明白有多么重要。","source":"_posts/Python-import-崩溃问题.md","raw":"---\ntitle: Python import 崩溃问题\ndate: 2018-12-12 21:38:50\ntags: \n---\n\n# Python import 崩溃问题\n\n最近遇到了一个比较诡异的问题，在一个 Python 文件中，我 import 了如下几个库：\n\n- turtle\n- time\n- numpy\n\n在另一个 Python `navigation.py` 中，我 import 了另外几个库：\n\n- numpy\n- skfuzzy\n- from skfuzzy import control\n- matplotlib.pyplot\n\n两个文件分别运行时，都非常正常。但是，我在第一个文件中一旦 import `navigation.py` 文件（我想使用其中定义的函数），就会收到操作系统抛出的终端异常：\n\n```\nTerminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[NSApplication _setup:]: unrecognized selector sent to instance 0x114c65a40'\n```\n\n可以看到，这个异常是 macOS 给出来的，而并不是 Python 报给我的。\n\n经过测试，我发现如下情况可以让程序执行：不调用 turtle 的绘图语句，或者，同时注释掉 `from skfuzzy import control` 和 `import matplotlib.pyplot` 。这就让问题显得十分诡异。\n\n最终的解决方案是，在程序的最开始添加如下代码：\n\n```python\nfrom sys import platform as sys_pf\nif sys_pf == 'darwin':\n    import matplotlib\n    matplotlib.use(\"TkAgg\")\n```\n\n这应该是 matplotlib 的一个 bug，在 macOS 环境下，要显示指明使用 TkAgg 作为界面库。崩溃的原因或许是 turtle 和 matplotlib 绘图的机制有所冲突？\n\n## 附记\n\n使用 `skfuzzy` （scikit-fuzzy）库的时候，直接调用 `view()` 方法画 membership function 的曲线图无效（图片不显示），必须要先 `import matplotlib.pyplot as plt` 然后调用 `plt.show()` 才可以显示。也是个很奇怪的问题呢……\n\n本来只是想把 Python 当作一个顺手的工具，没想到越是着急写东西越是遇到大坑，由此可见把底层原理搞明白有多么重要。","slug":"Python-import-崩溃问题","published":1,"updated":"2020-01-04T08:16:16.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv30000hljc3ic1fxekg","content":"<h1 id=\"Python-import-崩溃问题\"><a href=\"#Python-import-崩溃问题\" class=\"headerlink\" title=\"Python import 崩溃问题\"></a>Python import 崩溃问题</h1><p>最近遇到了一个比较诡异的问题，在一个 Python 文件中，我 import 了如下几个库：</p>\n<ul>\n<li>turtle</li>\n<li>time</li>\n<li>numpy</li>\n</ul>\n<p>在另一个 Python <code>navigation.py</code> 中，我 import 了另外几个库：</p>\n<ul>\n<li>numpy</li>\n<li>skfuzzy</li>\n<li>from skfuzzy import control</li>\n<li>matplotlib.pyplot</li>\n</ul>\n<p>两个文件分别运行时，都非常正常。但是，我在第一个文件中一旦 import <code>navigation.py</code> 文件（我想使用其中定义的函数），就会收到操作系统抛出的终端异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[NSApplication _setup:]: unrecognized selector sent to instance 0x114c65a40&apos;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这个异常是 macOS 给出来的，而并不是 Python 报给我的。</p>\n<p>经过测试，我发现如下情况可以让程序执行：不调用 turtle 的绘图语句，或者，同时注释掉 <code>from skfuzzy import control</code> 和 <code>import matplotlib.pyplot</code> 。这就让问题显得十分诡异。</p>\n<p>最终的解决方案是，在程序的最开始添加如下代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sys <span class=\"keyword\">import</span> platform <span class=\"keyword\">as</span> sys_pf</span><br><span class=\"line\"><span class=\"keyword\">if</span> sys_pf == <span class=\"string\">'darwin'</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> matplotlib</span><br><span class=\"line\">    matplotlib.use(<span class=\"string\">\"TkAgg\"</span>)</span><br></pre></td></tr></table></figure>\n<p>这应该是 matplotlib 的一个 bug，在 macOS 环境下，要显示指明使用 TkAgg 作为界面库。崩溃的原因或许是 turtle 和 matplotlib 绘图的机制有所冲突？</p>\n<h2 id=\"附记\"><a href=\"#附记\" class=\"headerlink\" title=\"附记\"></a>附记</h2><p>使用 <code>skfuzzy</code> （scikit-fuzzy）库的时候，直接调用 <code>view()</code> 方法画 membership function 的曲线图无效（图片不显示），必须要先 <code>import matplotlib.pyplot as plt</code> 然后调用 <code>plt.show()</code> 才可以显示。也是个很奇怪的问题呢……</p>\n<p>本来只是想把 Python 当作一个顺手的工具，没想到越是着急写东西越是遇到大坑，由此可见把底层原理搞明白有多么重要。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Python-import-崩溃问题\"><a href=\"#Python-import-崩溃问题\" class=\"headerlink\" title=\"Python import 崩溃问题\"></a>Python import 崩溃问题</h1><p>最近遇到了一个比较诡异的问题，在一个 Python 文件中，我 import 了如下几个库：</p>\n<ul>\n<li>turtle</li>\n<li>time</li>\n<li>numpy</li>\n</ul>\n<p>在另一个 Python <code>navigation.py</code> 中，我 import 了另外几个库：</p>\n<ul>\n<li>numpy</li>\n<li>skfuzzy</li>\n<li>from skfuzzy import control</li>\n<li>matplotlib.pyplot</li>\n</ul>\n<p>两个文件分别运行时，都非常正常。但是，我在第一个文件中一旦 import <code>navigation.py</code> 文件（我想使用其中定义的函数），就会收到操作系统抛出的终端异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Terminating app due to uncaught exception &apos;NSInvalidArgumentException&apos;, reason: &apos;-[NSApplication _setup:]: unrecognized selector sent to instance 0x114c65a40&apos;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这个异常是 macOS 给出来的，而并不是 Python 报给我的。</p>\n<p>经过测试，我发现如下情况可以让程序执行：不调用 turtle 的绘图语句，或者，同时注释掉 <code>from skfuzzy import control</code> 和 <code>import matplotlib.pyplot</code> 。这就让问题显得十分诡异。</p>\n<p>最终的解决方案是，在程序的最开始添加如下代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sys <span class=\"keyword\">import</span> platform <span class=\"keyword\">as</span> sys_pf</span><br><span class=\"line\"><span class=\"keyword\">if</span> sys_pf == <span class=\"string\">'darwin'</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> matplotlib</span><br><span class=\"line\">    matplotlib.use(<span class=\"string\">\"TkAgg\"</span>)</span><br></pre></td></tr></table></figure>\n<p>这应该是 matplotlib 的一个 bug，在 macOS 环境下，要显示指明使用 TkAgg 作为界面库。崩溃的原因或许是 turtle 和 matplotlib 绘图的机制有所冲突？</p>\n<h2 id=\"附记\"><a href=\"#附记\" class=\"headerlink\" title=\"附记\"></a>附记</h2><p>使用 <code>skfuzzy</code> （scikit-fuzzy）库的时候，直接调用 <code>view()</code> 方法画 membership function 的曲线图无效（图片不显示），必须要先 <code>import matplotlib.pyplot as plt</code> 然后调用 <code>plt.show()</code> 才可以显示。也是个很奇怪的问题呢……</p>\n<p>本来只是想把 Python 当作一个顺手的工具，没想到越是着急写东西越是遇到大坑，由此可见把底层原理搞明白有多么重要。</p>\n"},{"title":"Raspberry Pi 3B+ 安装 Ubuntu MATE","date":"2019-02-08T16:02:07.000Z","_content":"\n# Raspberry Pi 3B+ 安装 Ubuntu MATE\n\n在实验室当 Undergraduate Researcher，需要多个树莓派和主机之间互相通信，果断考虑使用 ROS。采购时，本着电子产品买新不买旧的原则，选择了树莓派 3B+ 型号。Ubuntu 下安装 ROS 较为方便，于是打算安装 Ubuntu MATE 作为操作系统。没想到，Ubuntu Mate 竟然还没有官方支持最新的 Pi 3B+。好在最后经过一番折腾，最终还是安装成功了。\n\n## 第一步 烧录 Ubuntu MATE\n\n先前往 Ubuntu MATE 官网 https://ubuntu-mate.org/download/ 下载镜像。\n\n下载完毕后，安装 `ddrescue` 工具并拷贝镜像到 SD 卡：\n\n```shell\nsudo apt-get install gddrescue xz-utils\nunxz ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img.xz\nsudo ddrescue -D --force ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img /dev/sdx\n```\n\n注意，这里的 `sdx` 需要被替换成你的 SD 卡文件。使用 `lsblk` 命令可以看到所有块设备的信息，以及他们的依赖关系。一般根据 SD 卡的容量就可以看出那个文件是 SD 卡了。当然用 Linux 自带的设备管理程序也可以看到。比如，在我实际操作过程中，我的 SD 卡在 `/dev/sdb` 下。\n\n经过漫长的等待，就可以看到镜像已经烧录成功了。SD 卡被分成了两个区，BOOT 和 ROOT。\n\n## 第二步 更改 boot loader\n\n由于 Raspberry Pi 3B+ 把处理器换成了 Cortex-A53 (ARMv8)，如果这个时候直接把 SD 卡插入树莓派，是 boot 不起来的。表现为树莓派红灯闪烁，绿灯不亮，接上显示器只有彩虹屏。\n\n解决方法是，下载最新的树莓派固件：https://github.com/raspberrypi/firmware\n\n把 SD 卡中 Boot 区所有文件替换成该固件 boot 文件夹的内容。把 Root 区 lib/modules 下所有文件替换成该固件 modules 文件夹的内容。GUI 界面下拖拽文件可能无效，因为是只读权限。可以命令行下在 sudo 权限下复制文件。\n\n插入 SD 卡，树莓派已经可以运行 Ubuntu MATE 了。但是还没结束……\n\n## 第三步 Wifi 怎么办\n\nUbuntu 下，似乎直接在 boot 分区里增加 `wpa_config` 文件配置 Wifi 无效。所以还是要给树莓派接上鼠标、键盘、显示器来操作。但是，内置的 Wifi 不工作，怀疑是这个版本的 Ubuntu MATE 的 Wifi 驱动不支持新的树莓派。现在我的临时解决方案是给树莓派接上了一个 USB 的无线网卡。\n\n## 第四步 扩展存储空间\n\nUbuntu MATE 的默认文件系统空间很小，远远没有占满整个 SD 卡。我们需要 resize file system。\n\n```shell\nsudo fdisk /dev/mmcblk0\n```\n\n出现 fdisk 的界面后，依次输入 `d` `2` `n` `p` `2` ，然后按两次空的回车，然后输入 `w` 。然后 reboot。\n\n重启完成后，\n\n```shell\nsudo resize2fs /dev/mmcblk0p2\n```\n\n现在，文件系统已经是整个 SD 卡的大小了。\n\n## 第五步 设置自动登录\n\n如果不设置自动登录，每次树莓派上电后会卡在输入密码的页面，连接不上 Wifi。在 `/usr/share/lightdm/lightdm.conf.d/60-lightdm-gtk-greeter.conf` 文件里增加一行：\n\n```shell\nautologin-user=yourUserName\n```\n\n就可以自动登录了。\n\n现在打开 SSH 服务，就可以愉快的玩耍树莓派了。如果需要配置静态 IP 地址，去路由器的 LAN 设置中，给树莓派的 MAC 地址分配一个固定 IP 就可以了。毕竟使用 DHCP 不能保证树莓派的 IP 永远不变，这在实验室里会造成麻烦。\n\n## 总结\n\n可以看到给 3B+ 安装 Ubuntu MATE 还是比较麻烦的。如果没有安装 ROS 的需求，还是建议安装 Raspbian。或者如果没有特别高的性能要求，购买老款的树莓派也会省事不少。关于内置 Wifi 不可用的问题，我还在继续寻找解决方案。\n\n\n\n## 更新\n\n现在已经解决无法使用内置 WiFi 的问题。将 Raspbian 下面的 `/lib/firmware/brcm` 文件夹替换过来。","source":"_posts/RaspberryPi3B-安装UbuntuMATE.md","raw":"---\ntitle: Raspberry Pi 3B+ 安装 Ubuntu MATE\ndate: 2019-02-09 00:02:07\ntags: RaspberryPi\n---\n\n# Raspberry Pi 3B+ 安装 Ubuntu MATE\n\n在实验室当 Undergraduate Researcher，需要多个树莓派和主机之间互相通信，果断考虑使用 ROS。采购时，本着电子产品买新不买旧的原则，选择了树莓派 3B+ 型号。Ubuntu 下安装 ROS 较为方便，于是打算安装 Ubuntu MATE 作为操作系统。没想到，Ubuntu Mate 竟然还没有官方支持最新的 Pi 3B+。好在最后经过一番折腾，最终还是安装成功了。\n\n## 第一步 烧录 Ubuntu MATE\n\n先前往 Ubuntu MATE 官网 https://ubuntu-mate.org/download/ 下载镜像。\n\n下载完毕后，安装 `ddrescue` 工具并拷贝镜像到 SD 卡：\n\n```shell\nsudo apt-get install gddrescue xz-utils\nunxz ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img.xz\nsudo ddrescue -D --force ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img /dev/sdx\n```\n\n注意，这里的 `sdx` 需要被替换成你的 SD 卡文件。使用 `lsblk` 命令可以看到所有块设备的信息，以及他们的依赖关系。一般根据 SD 卡的容量就可以看出那个文件是 SD 卡了。当然用 Linux 自带的设备管理程序也可以看到。比如，在我实际操作过程中，我的 SD 卡在 `/dev/sdb` 下。\n\n经过漫长的等待，就可以看到镜像已经烧录成功了。SD 卡被分成了两个区，BOOT 和 ROOT。\n\n## 第二步 更改 boot loader\n\n由于 Raspberry Pi 3B+ 把处理器换成了 Cortex-A53 (ARMv8)，如果这个时候直接把 SD 卡插入树莓派，是 boot 不起来的。表现为树莓派红灯闪烁，绿灯不亮，接上显示器只有彩虹屏。\n\n解决方法是，下载最新的树莓派固件：https://github.com/raspberrypi/firmware\n\n把 SD 卡中 Boot 区所有文件替换成该固件 boot 文件夹的内容。把 Root 区 lib/modules 下所有文件替换成该固件 modules 文件夹的内容。GUI 界面下拖拽文件可能无效，因为是只读权限。可以命令行下在 sudo 权限下复制文件。\n\n插入 SD 卡，树莓派已经可以运行 Ubuntu MATE 了。但是还没结束……\n\n## 第三步 Wifi 怎么办\n\nUbuntu 下，似乎直接在 boot 分区里增加 `wpa_config` 文件配置 Wifi 无效。所以还是要给树莓派接上鼠标、键盘、显示器来操作。但是，内置的 Wifi 不工作，怀疑是这个版本的 Ubuntu MATE 的 Wifi 驱动不支持新的树莓派。现在我的临时解决方案是给树莓派接上了一个 USB 的无线网卡。\n\n## 第四步 扩展存储空间\n\nUbuntu MATE 的默认文件系统空间很小，远远没有占满整个 SD 卡。我们需要 resize file system。\n\n```shell\nsudo fdisk /dev/mmcblk0\n```\n\n出现 fdisk 的界面后，依次输入 `d` `2` `n` `p` `2` ，然后按两次空的回车，然后输入 `w` 。然后 reboot。\n\n重启完成后，\n\n```shell\nsudo resize2fs /dev/mmcblk0p2\n```\n\n现在，文件系统已经是整个 SD 卡的大小了。\n\n## 第五步 设置自动登录\n\n如果不设置自动登录，每次树莓派上电后会卡在输入密码的页面，连接不上 Wifi。在 `/usr/share/lightdm/lightdm.conf.d/60-lightdm-gtk-greeter.conf` 文件里增加一行：\n\n```shell\nautologin-user=yourUserName\n```\n\n就可以自动登录了。\n\n现在打开 SSH 服务，就可以愉快的玩耍树莓派了。如果需要配置静态 IP 地址，去路由器的 LAN 设置中，给树莓派的 MAC 地址分配一个固定 IP 就可以了。毕竟使用 DHCP 不能保证树莓派的 IP 永远不变，这在实验室里会造成麻烦。\n\n## 总结\n\n可以看到给 3B+ 安装 Ubuntu MATE 还是比较麻烦的。如果没有安装 ROS 的需求，还是建议安装 Raspbian。或者如果没有特别高的性能要求，购买老款的树莓派也会省事不少。关于内置 Wifi 不可用的问题，我还在继续寻找解决方案。\n\n\n\n## 更新\n\n现在已经解决无法使用内置 WiFi 的问题。将 Raspbian 下面的 `/lib/firmware/brcm` 文件夹替换过来。","slug":"RaspberryPi3B-安装UbuntuMATE","published":1,"updated":"2020-01-04T08:16:16.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv30000jljc3xatzc9bi","content":"<h1 id=\"Raspberry-Pi-3B-安装-Ubuntu-MATE\"><a href=\"#Raspberry-Pi-3B-安装-Ubuntu-MATE\" class=\"headerlink\" title=\"Raspberry Pi 3B+ 安装 Ubuntu MATE\"></a>Raspberry Pi 3B+ 安装 Ubuntu MATE</h1><p>在实验室当 Undergraduate Researcher，需要多个树莓派和主机之间互相通信，果断考虑使用 ROS。采购时，本着电子产品买新不买旧的原则，选择了树莓派 3B+ 型号。Ubuntu 下安装 ROS 较为方便，于是打算安装 Ubuntu MATE 作为操作系统。没想到，Ubuntu Mate 竟然还没有官方支持最新的 Pi 3B+。好在最后经过一番折腾，最终还是安装成功了。</p>\n<h2 id=\"第一步-烧录-Ubuntu-MATE\"><a href=\"#第一步-烧录-Ubuntu-MATE\" class=\"headerlink\" title=\"第一步 烧录 Ubuntu MATE\"></a>第一步 烧录 Ubuntu MATE</h2><p>先前往 Ubuntu MATE 官网 <a href=\"https://ubuntu-mate.org/download/\">https://ubuntu-mate.org/download/</a> 下载镜像。</p>\n<p>下载完毕后，安装 <code>ddrescue</code> 工具并拷贝镜像到 SD 卡：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gddrescue xz-utils</span><br><span class=\"line\">unxz ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img.xz</span><br><span class=\"line\">sudo ddrescue -D --force ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img /dev/sdx</span><br></pre></td></tr></table></figure>\n<p>注意，这里的 <code>sdx</code> 需要被替换成你的 SD 卡文件。使用 <code>lsblk</code> 命令可以看到所有块设备的信息，以及他们的依赖关系。一般根据 SD 卡的容量就可以看出那个文件是 SD 卡了。当然用 Linux 自带的设备管理程序也可以看到。比如，在我实际操作过程中，我的 SD 卡在 <code>/dev/sdb</code> 下。</p>\n<p>经过漫长的等待，就可以看到镜像已经烧录成功了。SD 卡被分成了两个区，BOOT 和 ROOT。</p>\n<h2 id=\"第二步-更改-boot-loader\"><a href=\"#第二步-更改-boot-loader\" class=\"headerlink\" title=\"第二步 更改 boot loader\"></a>第二步 更改 boot loader</h2><p>由于 Raspberry Pi 3B+ 把处理器换成了 Cortex-A53 (ARMv8)，如果这个时候直接把 SD 卡插入树莓派，是 boot 不起来的。表现为树莓派红灯闪烁，绿灯不亮，接上显示器只有彩虹屏。</p>\n<p>解决方法是，下载最新的树莓派固件：<a href=\"https://github.com/raspberrypi/firmware\">https://github.com/raspberrypi/firmware</a></p>\n<p>把 SD 卡中 Boot 区所有文件替换成该固件 boot 文件夹的内容。把 Root 区 lib/modules 下所有文件替换成该固件 modules 文件夹的内容。GUI 界面下拖拽文件可能无效，因为是只读权限。可以命令行下在 sudo 权限下复制文件。</p>\n<p>插入 SD 卡，树莓派已经可以运行 Ubuntu MATE 了。但是还没结束……</p>\n<h2 id=\"第三步-Wifi-怎么办\"><a href=\"#第三步-Wifi-怎么办\" class=\"headerlink\" title=\"第三步 Wifi 怎么办\"></a>第三步 Wifi 怎么办</h2><p>Ubuntu 下，似乎直接在 boot 分区里增加 <code>wpa_config</code> 文件配置 Wifi 无效。所以还是要给树莓派接上鼠标、键盘、显示器来操作。但是，内置的 Wifi 不工作，怀疑是这个版本的 Ubuntu MATE 的 Wifi 驱动不支持新的树莓派。现在我的临时解决方案是给树莓派接上了一个 USB 的无线网卡。</p>\n<h2 id=\"第四步-扩展存储空间\"><a href=\"#第四步-扩展存储空间\" class=\"headerlink\" title=\"第四步 扩展存储空间\"></a>第四步 扩展存储空间</h2><p>Ubuntu MATE 的默认文件系统空间很小，远远没有占满整个 SD 卡。我们需要 resize file system。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo fdisk /dev/mmcblk0</span><br></pre></td></tr></table></figure>\n<p>出现 fdisk 的界面后，依次输入 <code>d</code> <code>2</code> <code>n</code> <code>p</code> <code>2</code> ，然后按两次空的回车，然后输入 <code>w</code> 。然后 reboot。</p>\n<p>重启完成后，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo resize2fs /dev/mmcblk0p2</span><br></pre></td></tr></table></figure>\n<p>现在，文件系统已经是整个 SD 卡的大小了。</p>\n<h2 id=\"第五步-设置自动登录\"><a href=\"#第五步-设置自动登录\" class=\"headerlink\" title=\"第五步 设置自动登录\"></a>第五步 设置自动登录</h2><p>如果不设置自动登录，每次树莓派上电后会卡在输入密码的页面，连接不上 Wifi。在 <code>/usr/share/lightdm/lightdm.conf.d/60-lightdm-gtk-greeter.conf</code> 文件里增加一行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">autologin-user=yourUserName</span><br></pre></td></tr></table></figure>\n<p>就可以自动登录了。</p>\n<p>现在打开 SSH 服务，就可以愉快的玩耍树莓派了。如果需要配置静态 IP 地址，去路由器的 LAN 设置中，给树莓派的 MAC 地址分配一个固定 IP 就可以了。毕竟使用 DHCP 不能保证树莓派的 IP 永远不变，这在实验室里会造成麻烦。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>可以看到给 3B+ 安装 Ubuntu MATE 还是比较麻烦的。如果没有安装 ROS 的需求，还是建议安装 Raspbian。或者如果没有特别高的性能要求，购买老款的树莓派也会省事不少。关于内置 Wifi 不可用的问题，我还在继续寻找解决方案。</p>\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><p>现在已经解决无法使用内置 WiFi 的问题。将 Raspbian 下面的 <code>/lib/firmware/brcm</code> 文件夹替换过来。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Raspberry-Pi-3B-安装-Ubuntu-MATE\"><a href=\"#Raspberry-Pi-3B-安装-Ubuntu-MATE\" class=\"headerlink\" title=\"Raspberry Pi 3B+ 安装 Ubuntu MATE\"></a>Raspberry Pi 3B+ 安装 Ubuntu MATE</h1><p>在实验室当 Undergraduate Researcher，需要多个树莓派和主机之间互相通信，果断考虑使用 ROS。采购时，本着电子产品买新不买旧的原则，选择了树莓派 3B+ 型号。Ubuntu 下安装 ROS 较为方便，于是打算安装 Ubuntu MATE 作为操作系统。没想到，Ubuntu Mate 竟然还没有官方支持最新的 Pi 3B+。好在最后经过一番折腾，最终还是安装成功了。</p>\n<h2 id=\"第一步-烧录-Ubuntu-MATE\"><a href=\"#第一步-烧录-Ubuntu-MATE\" class=\"headerlink\" title=\"第一步 烧录 Ubuntu MATE\"></a>第一步 烧录 Ubuntu MATE</h2><p>先前往 Ubuntu MATE 官网 <a href=\"https://ubuntu-mate.org/download/\">https://ubuntu-mate.org/download/</a> 下载镜像。</p>\n<p>下载完毕后，安装 <code>ddrescue</code> 工具并拷贝镜像到 SD 卡：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gddrescue xz-utils</span><br><span class=\"line\">unxz ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img.xz</span><br><span class=\"line\">sudo ddrescue -D --force ubuntu-mate-16.04.2-desktop-armhf-raspberry-pi.img /dev/sdx</span><br></pre></td></tr></table></figure>\n<p>注意，这里的 <code>sdx</code> 需要被替换成你的 SD 卡文件。使用 <code>lsblk</code> 命令可以看到所有块设备的信息，以及他们的依赖关系。一般根据 SD 卡的容量就可以看出那个文件是 SD 卡了。当然用 Linux 自带的设备管理程序也可以看到。比如，在我实际操作过程中，我的 SD 卡在 <code>/dev/sdb</code> 下。</p>\n<p>经过漫长的等待，就可以看到镜像已经烧录成功了。SD 卡被分成了两个区，BOOT 和 ROOT。</p>\n<h2 id=\"第二步-更改-boot-loader\"><a href=\"#第二步-更改-boot-loader\" class=\"headerlink\" title=\"第二步 更改 boot loader\"></a>第二步 更改 boot loader</h2><p>由于 Raspberry Pi 3B+ 把处理器换成了 Cortex-A53 (ARMv8)，如果这个时候直接把 SD 卡插入树莓派，是 boot 不起来的。表现为树莓派红灯闪烁，绿灯不亮，接上显示器只有彩虹屏。</p>\n<p>解决方法是，下载最新的树莓派固件：<a href=\"https://github.com/raspberrypi/firmware\">https://github.com/raspberrypi/firmware</a></p>\n<p>把 SD 卡中 Boot 区所有文件替换成该固件 boot 文件夹的内容。把 Root 区 lib/modules 下所有文件替换成该固件 modules 文件夹的内容。GUI 界面下拖拽文件可能无效，因为是只读权限。可以命令行下在 sudo 权限下复制文件。</p>\n<p>插入 SD 卡，树莓派已经可以运行 Ubuntu MATE 了。但是还没结束……</p>\n<h2 id=\"第三步-Wifi-怎么办\"><a href=\"#第三步-Wifi-怎么办\" class=\"headerlink\" title=\"第三步 Wifi 怎么办\"></a>第三步 Wifi 怎么办</h2><p>Ubuntu 下，似乎直接在 boot 分区里增加 <code>wpa_config</code> 文件配置 Wifi 无效。所以还是要给树莓派接上鼠标、键盘、显示器来操作。但是，内置的 Wifi 不工作，怀疑是这个版本的 Ubuntu MATE 的 Wifi 驱动不支持新的树莓派。现在我的临时解决方案是给树莓派接上了一个 USB 的无线网卡。</p>\n<h2 id=\"第四步-扩展存储空间\"><a href=\"#第四步-扩展存储空间\" class=\"headerlink\" title=\"第四步 扩展存储空间\"></a>第四步 扩展存储空间</h2><p>Ubuntu MATE 的默认文件系统空间很小，远远没有占满整个 SD 卡。我们需要 resize file system。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo fdisk /dev/mmcblk0</span><br></pre></td></tr></table></figure>\n<p>出现 fdisk 的界面后，依次输入 <code>d</code> <code>2</code> <code>n</code> <code>p</code> <code>2</code> ，然后按两次空的回车，然后输入 <code>w</code> 。然后 reboot。</p>\n<p>重启完成后，</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo resize2fs /dev/mmcblk0p2</span><br></pre></td></tr></table></figure>\n<p>现在，文件系统已经是整个 SD 卡的大小了。</p>\n<h2 id=\"第五步-设置自动登录\"><a href=\"#第五步-设置自动登录\" class=\"headerlink\" title=\"第五步 设置自动登录\"></a>第五步 设置自动登录</h2><p>如果不设置自动登录，每次树莓派上电后会卡在输入密码的页面，连接不上 Wifi。在 <code>/usr/share/lightdm/lightdm.conf.d/60-lightdm-gtk-greeter.conf</code> 文件里增加一行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">autologin-user=yourUserName</span><br></pre></td></tr></table></figure>\n<p>就可以自动登录了。</p>\n<p>现在打开 SSH 服务，就可以愉快的玩耍树莓派了。如果需要配置静态 IP 地址，去路由器的 LAN 设置中，给树莓派的 MAC 地址分配一个固定 IP 就可以了。毕竟使用 DHCP 不能保证树莓派的 IP 永远不变，这在实验室里会造成麻烦。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>可以看到给 3B+ 安装 Ubuntu MATE 还是比较麻烦的。如果没有安装 ROS 的需求，还是建议安装 Raspbian。或者如果没有特别高的性能要求，购买老款的树莓派也会省事不少。关于内置 Wifi 不可用的问题，我还在继续寻找解决方案。</p>\n<h2 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h2><p>现在已经解决无法使用内置 WiFi 的问题。将 Raspbian 下面的 <code>/lib/firmware/brcm</code> 文件夹替换过来。</p>\n"},{"title":"SQLite.Swift 简单使用","date":"2017-12-30T17:18:14.000Z","_content":"\n# SQLite.Swift + Codable 简单使用\n\nSQLite.Swift 在新版本中支持了 Swift4 的新特性 Codable。SQLite 体积小，是一个轻量级的数据库，而 SQLite.Swift 则是用 Swift 对其进行了封装，而在多数情况下不必撰写 SQL 语句。得益于 Codale，使用 SQLite.Swift 进行数据持久化将更加简单。\n\n下面，我用 SQLite.Swift 构建了一个简单的笔记本应用，来熟悉它的基本使用方式。\n\n### 定义数据模型\n\n每一条笔记是一个 NoteItem 类型的结构体。由于我打算让它的主键自增，所以要重写 encode 方法。否则，可能就要用 uuid 来作为主键了，有点杀鸡用牛刀的感觉。\n\n```swift\nstruct NoteItem: Codable {\n    var id = 0\n    var title = \"\"\n    var content = \"\"\n    var timeStamp = 0\n    \n    init(title: String, content: String, timeStamp: Int) {\n        self.title = title\n        self.content = content\n        self.timeStamp = timeStamp\n    }\n    \n    func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: CodingKeys.self)\n        try container.encode(title, forKey: .title)\n        try container.encode(content, forKey: .content)\n        try container.encode(timeStamp, forKey: .timeStamp)\n    }\n}\n```\n\n因为要用自增主键，就不能自己设定 id，否则 SQLite 会报错。因此要重写 encode 方法，不对对 id 进行编码。而 decode 方法不覆盖，即使用默认方法，把所有属性全部赋值。\n\n### 连接数据库\n\n构建一个数据库管理类，叫 DataBaseHandler。首先要连接数据库才能进行使用。\n\n```swift\nclass DataBaseHandler {\n    var db: Connection!\n    func connect() {\n        do {\n            db = try Connection(getFilePath())\n        } catch {\n            print(\"连接数据库失败\")\n        }\n    }\n  \tfunc getFilePath() -> String {\n        return NSHomeDirectory() + \"/Documents/db.sqlite3\"\n    }\n}\n```\n\n### 新建 Table\n\n```swift\nlet id = Expression<Int64>(\"id\")\nlet title = Expression<String>(\"title\")\nlet content = Expression<String>(\"content\")\nlet timeStamp = Expression<Int64>(\"timeStamp\")\n    \nlet noteList = Table(\"NoteList\")\nfunc createTable() {\n    do {\n        try db.run(noteList.create(ifNotExists: true) {\n            t in\n            t.column(id, primaryKey: .autoincrement)\n            t.column(title)\n            t.column(content)\n            t.column(timeStamp)\n        })\n    } catch {\n        print(\"建表失败\")\n    }\n}\n```\n\n这里指定只有在 Table 不存在的时候才创建。按照数据模型添加列，并把 id 指定为自增主键以获得更好的查找性能。\n\n### 删除行\n\n作为一个笔记本应用，当然要支持滑动删除。\n\n```swift\nfunc deleteItem(id: Int) {\n    let item = noteList.filter(Int64(id) == self.id)\n    do {\n        try db.run(item.delete())\n    } catch {\n        print(\"删除失败\")\n    }\n}\n```\n\n这里先通过 id 查找出元素，再调用 `db.run(item.delete())` 就可以了，等价于 SQL 语句 `DELETE FROM \"NoteList\" WHERE (\"id\" = \\(id))` 。\n\n### 插入行\n\n```swift\nfunc insert(_ item: NoteItem) -> Int {\n    do {\n        try db.run(noteList.insert(item))\n        return Int(db.lastInsertRowid)\n    } catch {\n        print(error)\n        print(\"插入失败\")\n    }\n    return 0\n}\n```\n\n由于 id 是数据库自己生成的，为了让外界能拿到 id 号来进行其他的操作，必须把新插入的 id 号返回。可以用 `db.lastInsertRowid` 拿到最新插入的 id，但其实 `run()` 函数也是有返回值的，返回值就是 rowid，也可以直接返回。\n\n### 更新行\n\n笔记本应用一个常见的操作是编辑已有的笔记，因此需要把已有的行更新。也可以删除旧行再插入新行，但更新的效率更高。\n\n```swift\nfunc update(_ item: NoteItem) {\n    let oldItem = noteList.filter(Int64(item.id) == self.id)\n    do {\n        try db.run(oldItem.update(item))\n    } catch {\n        print(\"更新失败\")\n    }\n}\n```\n\n### 获取所有行\n\n在笔记本应用打开时，应该展示所有已有的笔记，因此需要将数据库所有的元素都取出。\n\n```swift\nfunc getAllItems() -> [NoteItem] {\n    do {\n        return try db.prepare(noteList).map({ row in\n            return try row.decode()\n        })\n    } catch {\n        print(\"查找失败\")\n    }\n    return []\n}\n```\n\n------\n\n数据持久化的部分到这里就完成了，剩下的操作就只有构建界面了。需要注意的是，应该尽量减少操作文件，毕竟读硬盘的速度比内存操作慢得多，因此各个界面中应该通过其他方式传值，而不是都根据数据库的内容来更新界面。","source":"_posts/SQLite使用.md","raw":"---\ntitle: SQLite.Swift 简单使用\ndate: 2017-12-31 01:18:14\ntags: SQLite\n---\n\n# SQLite.Swift + Codable 简单使用\n\nSQLite.Swift 在新版本中支持了 Swift4 的新特性 Codable。SQLite 体积小，是一个轻量级的数据库，而 SQLite.Swift 则是用 Swift 对其进行了封装，而在多数情况下不必撰写 SQL 语句。得益于 Codale，使用 SQLite.Swift 进行数据持久化将更加简单。\n\n下面，我用 SQLite.Swift 构建了一个简单的笔记本应用，来熟悉它的基本使用方式。\n\n### 定义数据模型\n\n每一条笔记是一个 NoteItem 类型的结构体。由于我打算让它的主键自增，所以要重写 encode 方法。否则，可能就要用 uuid 来作为主键了，有点杀鸡用牛刀的感觉。\n\n```swift\nstruct NoteItem: Codable {\n    var id = 0\n    var title = \"\"\n    var content = \"\"\n    var timeStamp = 0\n    \n    init(title: String, content: String, timeStamp: Int) {\n        self.title = title\n        self.content = content\n        self.timeStamp = timeStamp\n    }\n    \n    func encode(to encoder: Encoder) throws {\n        var container = encoder.container(keyedBy: CodingKeys.self)\n        try container.encode(title, forKey: .title)\n        try container.encode(content, forKey: .content)\n        try container.encode(timeStamp, forKey: .timeStamp)\n    }\n}\n```\n\n因为要用自增主键，就不能自己设定 id，否则 SQLite 会报错。因此要重写 encode 方法，不对对 id 进行编码。而 decode 方法不覆盖，即使用默认方法，把所有属性全部赋值。\n\n### 连接数据库\n\n构建一个数据库管理类，叫 DataBaseHandler。首先要连接数据库才能进行使用。\n\n```swift\nclass DataBaseHandler {\n    var db: Connection!\n    func connect() {\n        do {\n            db = try Connection(getFilePath())\n        } catch {\n            print(\"连接数据库失败\")\n        }\n    }\n  \tfunc getFilePath() -> String {\n        return NSHomeDirectory() + \"/Documents/db.sqlite3\"\n    }\n}\n```\n\n### 新建 Table\n\n```swift\nlet id = Expression<Int64>(\"id\")\nlet title = Expression<String>(\"title\")\nlet content = Expression<String>(\"content\")\nlet timeStamp = Expression<Int64>(\"timeStamp\")\n    \nlet noteList = Table(\"NoteList\")\nfunc createTable() {\n    do {\n        try db.run(noteList.create(ifNotExists: true) {\n            t in\n            t.column(id, primaryKey: .autoincrement)\n            t.column(title)\n            t.column(content)\n            t.column(timeStamp)\n        })\n    } catch {\n        print(\"建表失败\")\n    }\n}\n```\n\n这里指定只有在 Table 不存在的时候才创建。按照数据模型添加列，并把 id 指定为自增主键以获得更好的查找性能。\n\n### 删除行\n\n作为一个笔记本应用，当然要支持滑动删除。\n\n```swift\nfunc deleteItem(id: Int) {\n    let item = noteList.filter(Int64(id) == self.id)\n    do {\n        try db.run(item.delete())\n    } catch {\n        print(\"删除失败\")\n    }\n}\n```\n\n这里先通过 id 查找出元素，再调用 `db.run(item.delete())` 就可以了，等价于 SQL 语句 `DELETE FROM \"NoteList\" WHERE (\"id\" = \\(id))` 。\n\n### 插入行\n\n```swift\nfunc insert(_ item: NoteItem) -> Int {\n    do {\n        try db.run(noteList.insert(item))\n        return Int(db.lastInsertRowid)\n    } catch {\n        print(error)\n        print(\"插入失败\")\n    }\n    return 0\n}\n```\n\n由于 id 是数据库自己生成的，为了让外界能拿到 id 号来进行其他的操作，必须把新插入的 id 号返回。可以用 `db.lastInsertRowid` 拿到最新插入的 id，但其实 `run()` 函数也是有返回值的，返回值就是 rowid，也可以直接返回。\n\n### 更新行\n\n笔记本应用一个常见的操作是编辑已有的笔记，因此需要把已有的行更新。也可以删除旧行再插入新行，但更新的效率更高。\n\n```swift\nfunc update(_ item: NoteItem) {\n    let oldItem = noteList.filter(Int64(item.id) == self.id)\n    do {\n        try db.run(oldItem.update(item))\n    } catch {\n        print(\"更新失败\")\n    }\n}\n```\n\n### 获取所有行\n\n在笔记本应用打开时，应该展示所有已有的笔记，因此需要将数据库所有的元素都取出。\n\n```swift\nfunc getAllItems() -> [NoteItem] {\n    do {\n        return try db.prepare(noteList).map({ row in\n            return try row.decode()\n        })\n    } catch {\n        print(\"查找失败\")\n    }\n    return []\n}\n```\n\n------\n\n数据持久化的部分到这里就完成了，剩下的操作就只有构建界面了。需要注意的是，应该尽量减少操作文件，毕竟读硬盘的速度比内存操作慢得多，因此各个界面中应该通过其他方式传值，而不是都根据数据库的内容来更新界面。","slug":"SQLite使用","published":1,"updated":"2020-01-04T08:16:16.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv31000lljc36msnw7gu","content":"<h1 id=\"SQLite-Swift-Codable-简单使用\"><a href=\"#SQLite-Swift-Codable-简单使用\" class=\"headerlink\" title=\"SQLite.Swift + Codable 简单使用\"></a>SQLite.Swift + Codable 简单使用</h1><p>SQLite.Swift 在新版本中支持了 Swift4 的新特性 Codable。SQLite 体积小，是一个轻量级的数据库，而 SQLite.Swift 则是用 Swift 对其进行了封装，而在多数情况下不必撰写 SQL 语句。得益于 Codale，使用 SQLite.Swift 进行数据持久化将更加简单。</p>\n<p>下面，我用 SQLite.Swift 构建了一个简单的笔记本应用，来熟悉它的基本使用方式。</p>\n<h3 id=\"定义数据模型\"><a href=\"#定义数据模型\" class=\"headerlink\" title=\"定义数据模型\"></a>定义数据模型</h3><p>每一条笔记是一个 NoteItem 类型的结构体。由于我打算让它的主键自增，所以要重写 encode 方法。否则，可能就要用 uuid 来作为主键了，有点杀鸡用牛刀的感觉。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NoteItem</span>: <span class=\"title\">Codable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> title = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> content = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeStamp = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(title: <span class=\"type\">String</span>, content: <span class=\"type\">String</span>, timeStamp: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title = title</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.content = content</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.timeStamp = timeStamp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">encode</span><span class=\"params\">(to encoder: Encoder)</span></span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> container = encoder.container(keyedBy: <span class=\"type\">CodingKeys</span>.<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span> container.encode(title, forKey: .title)</span><br><span class=\"line\">        <span class=\"keyword\">try</span> container.encode(content, forKey: .content)</span><br><span class=\"line\">        <span class=\"keyword\">try</span> container.encode(timeStamp, forKey: .timeStamp)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为要用自增主键，就不能自己设定 id，否则 SQLite 会报错。因此要重写 encode 方法，不对对 id 进行编码。而 decode 方法不覆盖，即使用默认方法，把所有属性全部赋值。</p>\n<h3 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h3><p>构建一个数据库管理类，叫 DataBaseHandler。首先要连接数据库才能进行使用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataBaseHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> db: <span class=\"type\">Connection!</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">connect</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            db = <span class=\"keyword\">try</span> <span class=\"type\">Connection</span>(getFilePath())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"连接数据库失败\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFilePath</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">NSHomeDirectory</span>() + <span class=\"string\">\"/Documents/db.sqlite3\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建-Table\"><a href=\"#新建-Table\" class=\"headerlink\" title=\"新建 Table\"></a>新建 Table</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> id = <span class=\"type\">Expression</span>&lt;<span class=\"type\">Int64</span>&gt;(<span class=\"string\">\"id\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> title = <span class=\"type\">Expression</span>&lt;<span class=\"type\">String</span>&gt;(<span class=\"string\">\"title\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> content = <span class=\"type\">Expression</span>&lt;<span class=\"type\">String</span>&gt;(<span class=\"string\">\"content\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> timeStamp = <span class=\"type\">Expression</span>&lt;<span class=\"type\">Int64</span>&gt;(<span class=\"string\">\"timeStamp\"</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">let</span> noteList = <span class=\"type\">Table</span>(<span class=\"string\">\"NoteList\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createTable</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> db.run(noteList.create(ifNotExists: <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            t <span class=\"keyword\">in</span></span><br><span class=\"line\">            t.column(id, primaryKey: .autoincrement)</span><br><span class=\"line\">            t.column(title)</span><br><span class=\"line\">            t.column(content)</span><br><span class=\"line\">            t.column(timeStamp)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"建表失败\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里指定只有在 Table 不存在的时候才创建。按照数据模型添加列，并把 id 指定为自增主键以获得更好的查找性能。</p>\n<h3 id=\"删除行\"><a href=\"#删除行\" class=\"headerlink\" title=\"删除行\"></a>删除行</h3><p>作为一个笔记本应用，当然要支持滑动删除。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deleteItem</span><span class=\"params\">(id: Int)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = noteList.<span class=\"built_in\">filter</span>(<span class=\"type\">Int64</span>(id) == <span class=\"keyword\">self</span>.id)</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> db.run(item.delete())</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"删除失败\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里先通过 id 查找出元素，再调用 <code>db.run(item.delete())</code> 就可以了，等价于 SQL 语句 <code>DELETE FROM &quot;NoteList&quot; WHERE (&quot;id&quot; = \\(id))</code> 。</p>\n<h3 id=\"插入行\"><a href=\"#插入行\" class=\"headerlink\" title=\"插入行\"></a>插入行</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"number\">_</span> item: NoteItem)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> db.run(noteList.insert(item))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Int</span>(db.lastInsertRowid)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(error)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"插入失败\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 id 是数据库自己生成的，为了让外界能拿到 id 号来进行其他的操作，必须把新插入的 id 号返回。可以用 <code>db.lastInsertRowid</code> 拿到最新插入的 id，但其实 <code>run()</code> 函数也是有返回值的，返回值就是 rowid，也可以直接返回。</p>\n<h3 id=\"更新行\"><a href=\"#更新行\" class=\"headerlink\" title=\"更新行\"></a>更新行</h3><p>笔记本应用一个常见的操作是编辑已有的笔记，因此需要把已有的行更新。也可以删除旧行再插入新行，但更新的效率更高。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"number\">_</span> item: NoteItem)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldItem = noteList.<span class=\"built_in\">filter</span>(<span class=\"type\">Int64</span>(item.id) == <span class=\"keyword\">self</span>.id)</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> db.run(oldItem.update(item))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"更新失败\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取所有行\"><a href=\"#获取所有行\" class=\"headerlink\" title=\"获取所有行\"></a>获取所有行</h3><p>在笔记本应用打开时，应该展示所有已有的笔记，因此需要将数据库所有的元素都取出。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getAllItems</span><span class=\"params\">()</span></span> -&gt; [<span class=\"type\">NoteItem</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> db.prepare(noteList).<span class=\"built_in\">map</span>(&#123; row <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> row.decode()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"查找失败\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>数据持久化的部分到这里就完成了，剩下的操作就只有构建界面了。需要注意的是，应该尽量减少操作文件，毕竟读硬盘的速度比内存操作慢得多，因此各个界面中应该通过其他方式传值，而不是都根据数据库的内容来更新界面。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SQLite-Swift-Codable-简单使用\"><a href=\"#SQLite-Swift-Codable-简单使用\" class=\"headerlink\" title=\"SQLite.Swift + Codable 简单使用\"></a>SQLite.Swift + Codable 简单使用</h1><p>SQLite.Swift 在新版本中支持了 Swift4 的新特性 Codable。SQLite 体积小，是一个轻量级的数据库，而 SQLite.Swift 则是用 Swift 对其进行了封装，而在多数情况下不必撰写 SQL 语句。得益于 Codale，使用 SQLite.Swift 进行数据持久化将更加简单。</p>\n<p>下面，我用 SQLite.Swift 构建了一个简单的笔记本应用，来熟悉它的基本使用方式。</p>\n<h3 id=\"定义数据模型\"><a href=\"#定义数据模型\" class=\"headerlink\" title=\"定义数据模型\"></a>定义数据模型</h3><p>每一条笔记是一个 NoteItem 类型的结构体。由于我打算让它的主键自增，所以要重写 encode 方法。否则，可能就要用 uuid 来作为主键了，有点杀鸡用牛刀的感觉。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NoteItem</span>: <span class=\"title\">Codable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> title = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> content = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeStamp = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(title: <span class=\"type\">String</span>, content: <span class=\"type\">String</span>, timeStamp: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.title = title</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.content = content</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.timeStamp = timeStamp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">encode</span><span class=\"params\">(to encoder: Encoder)</span></span> <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> container = encoder.container(keyedBy: <span class=\"type\">CodingKeys</span>.<span class=\"keyword\">self</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span> container.encode(title, forKey: .title)</span><br><span class=\"line\">        <span class=\"keyword\">try</span> container.encode(content, forKey: .content)</span><br><span class=\"line\">        <span class=\"keyword\">try</span> container.encode(timeStamp, forKey: .timeStamp)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为要用自增主键，就不能自己设定 id，否则 SQLite 会报错。因此要重写 encode 方法，不对对 id 进行编码。而 decode 方法不覆盖，即使用默认方法，把所有属性全部赋值。</p>\n<h3 id=\"连接数据库\"><a href=\"#连接数据库\" class=\"headerlink\" title=\"连接数据库\"></a>连接数据库</h3><p>构建一个数据库管理类，叫 DataBaseHandler。首先要连接数据库才能进行使用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataBaseHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> db: <span class=\"type\">Connection!</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">connect</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            db = <span class=\"keyword\">try</span> <span class=\"type\">Connection</span>(getFilePath())</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"连接数据库失败\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFilePath</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">NSHomeDirectory</span>() + <span class=\"string\">\"/Documents/db.sqlite3\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"新建-Table\"><a href=\"#新建-Table\" class=\"headerlink\" title=\"新建 Table\"></a>新建 Table</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> id = <span class=\"type\">Expression</span>&lt;<span class=\"type\">Int64</span>&gt;(<span class=\"string\">\"id\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> title = <span class=\"type\">Expression</span>&lt;<span class=\"type\">String</span>&gt;(<span class=\"string\">\"title\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> content = <span class=\"type\">Expression</span>&lt;<span class=\"type\">String</span>&gt;(<span class=\"string\">\"content\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> timeStamp = <span class=\"type\">Expression</span>&lt;<span class=\"type\">Int64</span>&gt;(<span class=\"string\">\"timeStamp\"</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">let</span> noteList = <span class=\"type\">Table</span>(<span class=\"string\">\"NoteList\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">createTable</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> db.run(noteList.create(ifNotExists: <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            t <span class=\"keyword\">in</span></span><br><span class=\"line\">            t.column(id, primaryKey: .autoincrement)</span><br><span class=\"line\">            t.column(title)</span><br><span class=\"line\">            t.column(content)</span><br><span class=\"line\">            t.column(timeStamp)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"建表失败\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里指定只有在 Table 不存在的时候才创建。按照数据模型添加列，并把 id 指定为自增主键以获得更好的查找性能。</p>\n<h3 id=\"删除行\"><a href=\"#删除行\" class=\"headerlink\" title=\"删除行\"></a>删除行</h3><p>作为一个笔记本应用，当然要支持滑动删除。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">deleteItem</span><span class=\"params\">(id: Int)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> item = noteList.<span class=\"built_in\">filter</span>(<span class=\"type\">Int64</span>(id) == <span class=\"keyword\">self</span>.id)</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> db.run(item.delete())</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"删除失败\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里先通过 id 查找出元素，再调用 <code>db.run(item.delete())</code> 就可以了，等价于 SQL 语句 <code>DELETE FROM &quot;NoteList&quot; WHERE (&quot;id&quot; = \\(id))</code> 。</p>\n<h3 id=\"插入行\"><a href=\"#插入行\" class=\"headerlink\" title=\"插入行\"></a>插入行</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"number\">_</span> item: NoteItem)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> db.run(noteList.insert(item))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Int</span>(db.lastInsertRowid)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(error)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"插入失败\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于 id 是数据库自己生成的，为了让外界能拿到 id 号来进行其他的操作，必须把新插入的 id 号返回。可以用 <code>db.lastInsertRowid</code> 拿到最新插入的 id，但其实 <code>run()</code> 函数也是有返回值的，返回值就是 rowid，也可以直接返回。</p>\n<h3 id=\"更新行\"><a href=\"#更新行\" class=\"headerlink\" title=\"更新行\"></a>更新行</h3><p>笔记本应用一个常见的操作是编辑已有的笔记，因此需要把已有的行更新。也可以删除旧行再插入新行，但更新的效率更高。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"number\">_</span> item: NoteItem)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> oldItem = noteList.<span class=\"built_in\">filter</span>(<span class=\"type\">Int64</span>(item.id) == <span class=\"keyword\">self</span>.id)</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> db.run(oldItem.update(item))</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"更新失败\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"获取所有行\"><a href=\"#获取所有行\" class=\"headerlink\" title=\"获取所有行\"></a>获取所有行</h3><p>在笔记本应用打开时，应该展示所有已有的笔记，因此需要将数据库所有的元素都取出。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getAllItems</span><span class=\"params\">()</span></span> -&gt; [<span class=\"type\">NoteItem</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> db.prepare(noteList).<span class=\"built_in\">map</span>(&#123; row <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">try</span> row.decode()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"查找失败\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>数据持久化的部分到这里就完成了，剩下的操作就只有构建界面了。需要注意的是，应该尽量减少操作文件，毕竟读硬盘的速度比内存操作慢得多，因此各个界面中应该通过其他方式传值，而不是都根据数据库的内容来更新界面。</p>\n"},{"title":"Swift Tips","date":"2018-03-18T06:54:59.000Z","_content":"\n# Swift Tips\n\n### 结构相等&引用相等\n\n结构相等符 `==` 被用来判断两个值是否相等。而引用相等 `===` 用来检查两个引用是否具有**同一性**，即是否指向同一个对象。\n\n```swift\nclass A {\n    var p = 0\n}\n\nvar a = A()\nvar b = a\nprint(b == a)\n```\n\n上面的代码会报错误信息 `Binary operator '==' cannot be applied to two 'A' operands`，提示你需要自己实现结构相等运算符。而如果把 == 改为 \\=== 就会 print 出 true。若将 class 改为 struct，则 === 也一样会报错。因为结构体是值类型，就谈不上引用了。\n\n### forEach\n\n一下两段代码有什么不同？\n\n```swift\nfunc foo1() {\n    array.forEach { num in\n        print(num)\n        if num > 2 {\n            return\n        }\n    }\n}\n\nfunc foo2() {\n    for num in array {\n    \tprint(num)\n    \tif num > 2 {\n        \treturn\n    \t}\n\t}\n}\n\nlet array = [1,2,3,4,5]\nfoo1()\nfoo2()\n```\n\n使用 for each in 循环的函数会在打印出 3 之后停止，而使用 forEach 函数的函数会打印出所有的值。这是因为 forEach 的 return 语句只会将 forEach 的尾随闭包返回，而不会终止 forEach 本身的循环。这一点从刚刚**“函数的函数”**这个说法中也可以看出来。\n\n### mutating 关键字\n\n```swift\nstruct A {\n    var a = 0\n    mutating func change() {\n        a += 1\n    }\n}\n```\n\n结构体中的方法若想改变自身的属性，则需要在 func 前添加 mutating 关键字，而类中不用。可以这样看待这个问题的：可以理解成 self 是函数的一个隐式参数，添加 mutating 关键字代表 self 是可变的（相当于用 var 来声明这个结构体的感觉），否则 self 就是不可变的（相当于用 let 声明，自然不可以改变结构体内属性的值）。而 class 无论是 var 还是 let 来声明，都可以改变属性的值（var 和 let 对引用类型只限制了引用本身是否可以改变，而不是引用指向的对象），故不存在这个问题。更精确地来说，可以理解为 mutating 相当于对隐式变量 self 添加了关键字 inout。\n\n### 捕获列表\n\n将一个对象的属性设置为弱引用是打破循环引用的重要手段。但是，weak 关键字只能运用于 class 类变量，故不适用于同样是引用类型的函数变量。以下代码通过闭包，间接的构成了循环引用：\n\n```swift\nclass Child {\n    var parent: Parent\n    init(parent: Parent) {\n        self.parent = parent\n    }\n    deinit {\n        print(\"child deinit\")\n    }\n}\n\nclass Parent {\n    weak var child: Child?\n    var closure: (()->())?\n    deinit {\n        print(\"parent deinit\")\n    }\n}\n\nvar p: Parent? = Parent()\nvar c: Child? = Child(parent: p!)\np?.child = c\np?.closure = {\n    print(c)\n}\np = nil\nc = nil\n```\n\n为了打破这个循环引用，可以通过闭包的捕获列表，将 c 设置为弱引用：\n\n```swift\np?.closure = { [weak c] in\n    print(c)\n}\n```\n\n闭包中，self 关键字会被强制写出来，也是为了明确的提示我们可能构成的循环引用。如果构成了循环引用，一般通过将 self 设置为 unowned 无主引用来打破循环。无主引用与弱引用的区别是，在引用的对象释放掉之后，它不会被设置为 nil，因此也不用像弱引用那样，必须是可选值，每次使用时都要解包。\n\n### &\n\n在传递 inout 关键字时，需要在变量名前添加 &。这里的 & 不像 c/c++ 中的那样表示传递的是引用，而是把值复制，再粘贴回来。\n\n如果函数接受的是一个 UnsafeMutablePointer 的话，我们还是需要在变量名前加上 &。但是，这里的 & 表示的确实是传递引用了，更准确地说，传递的是指针。\n\n### @autoclosure 关键字\n\n@autoclosure 关键字可以自动为参数创建闭包，让我们的代码更加整洁。\n\n如果不加此关键字，我们必须手动写闭包语法 `{}`：\n\n```swift\nfunc foo(_ a: () -> Bool) {\n    a()\n}\nfoo( {1+1==2} )\n```\n\n有了 @autoclosure：\n\n```swift\nfunc foo(_ a: @autoclosure () -> Bool) {\n    a()\n}\nfoo(1+1==2)\n```\n\n### defer\n\ndefer 块会在即将离开函数作用域之前执行。如果有多个 defer 块，则逆序执行（像一个栈）。\n\n```swift\nlet database = openDatabase()\ndefer {\n    closeDatabase()\n}\nlet connection = openConnection(to: database)\ndefer {\n    closeConnection(to: database)\n}\n```\n\n### 自定义/重载运算符\n\n定义一个幂运算符 `**` :\n\n```swift\nprecedencegroup ExponentiationPrecedence { //自定义优先级\n    associativity: left //左结合性\n    higherThan: MultiplicationPrecedence //优先级高于乘法优先级\n}\n\ninfix operator **: ExponentiationPrecedence //使用 prefix infix 和 postfix 定义前缀、中缀、后缀\n\nfunc **(lhs: Double, rhs: Double) -> Double {\n    return pow(lhs, rhs)\n}\n\n2**3 // 8.0\n```\n\n","source":"_posts/Swift-Tips.md","raw":"---\ntitle: Swift Tips\ndate: 2018-03-18 14:54:59\ntags: Swift\n---\n\n# Swift Tips\n\n### 结构相等&引用相等\n\n结构相等符 `==` 被用来判断两个值是否相等。而引用相等 `===` 用来检查两个引用是否具有**同一性**，即是否指向同一个对象。\n\n```swift\nclass A {\n    var p = 0\n}\n\nvar a = A()\nvar b = a\nprint(b == a)\n```\n\n上面的代码会报错误信息 `Binary operator '==' cannot be applied to two 'A' operands`，提示你需要自己实现结构相等运算符。而如果把 == 改为 \\=== 就会 print 出 true。若将 class 改为 struct，则 === 也一样会报错。因为结构体是值类型，就谈不上引用了。\n\n### forEach\n\n一下两段代码有什么不同？\n\n```swift\nfunc foo1() {\n    array.forEach { num in\n        print(num)\n        if num > 2 {\n            return\n        }\n    }\n}\n\nfunc foo2() {\n    for num in array {\n    \tprint(num)\n    \tif num > 2 {\n        \treturn\n    \t}\n\t}\n}\n\nlet array = [1,2,3,4,5]\nfoo1()\nfoo2()\n```\n\n使用 for each in 循环的函数会在打印出 3 之后停止，而使用 forEach 函数的函数会打印出所有的值。这是因为 forEach 的 return 语句只会将 forEach 的尾随闭包返回，而不会终止 forEach 本身的循环。这一点从刚刚**“函数的函数”**这个说法中也可以看出来。\n\n### mutating 关键字\n\n```swift\nstruct A {\n    var a = 0\n    mutating func change() {\n        a += 1\n    }\n}\n```\n\n结构体中的方法若想改变自身的属性，则需要在 func 前添加 mutating 关键字，而类中不用。可以这样看待这个问题的：可以理解成 self 是函数的一个隐式参数，添加 mutating 关键字代表 self 是可变的（相当于用 var 来声明这个结构体的感觉），否则 self 就是不可变的（相当于用 let 声明，自然不可以改变结构体内属性的值）。而 class 无论是 var 还是 let 来声明，都可以改变属性的值（var 和 let 对引用类型只限制了引用本身是否可以改变，而不是引用指向的对象），故不存在这个问题。更精确地来说，可以理解为 mutating 相当于对隐式变量 self 添加了关键字 inout。\n\n### 捕获列表\n\n将一个对象的属性设置为弱引用是打破循环引用的重要手段。但是，weak 关键字只能运用于 class 类变量，故不适用于同样是引用类型的函数变量。以下代码通过闭包，间接的构成了循环引用：\n\n```swift\nclass Child {\n    var parent: Parent\n    init(parent: Parent) {\n        self.parent = parent\n    }\n    deinit {\n        print(\"child deinit\")\n    }\n}\n\nclass Parent {\n    weak var child: Child?\n    var closure: (()->())?\n    deinit {\n        print(\"parent deinit\")\n    }\n}\n\nvar p: Parent? = Parent()\nvar c: Child? = Child(parent: p!)\np?.child = c\np?.closure = {\n    print(c)\n}\np = nil\nc = nil\n```\n\n为了打破这个循环引用，可以通过闭包的捕获列表，将 c 设置为弱引用：\n\n```swift\np?.closure = { [weak c] in\n    print(c)\n}\n```\n\n闭包中，self 关键字会被强制写出来，也是为了明确的提示我们可能构成的循环引用。如果构成了循环引用，一般通过将 self 设置为 unowned 无主引用来打破循环。无主引用与弱引用的区别是，在引用的对象释放掉之后，它不会被设置为 nil，因此也不用像弱引用那样，必须是可选值，每次使用时都要解包。\n\n### &\n\n在传递 inout 关键字时，需要在变量名前添加 &。这里的 & 不像 c/c++ 中的那样表示传递的是引用，而是把值复制，再粘贴回来。\n\n如果函数接受的是一个 UnsafeMutablePointer 的话，我们还是需要在变量名前加上 &。但是，这里的 & 表示的确实是传递引用了，更准确地说，传递的是指针。\n\n### @autoclosure 关键字\n\n@autoclosure 关键字可以自动为参数创建闭包，让我们的代码更加整洁。\n\n如果不加此关键字，我们必须手动写闭包语法 `{}`：\n\n```swift\nfunc foo(_ a: () -> Bool) {\n    a()\n}\nfoo( {1+1==2} )\n```\n\n有了 @autoclosure：\n\n```swift\nfunc foo(_ a: @autoclosure () -> Bool) {\n    a()\n}\nfoo(1+1==2)\n```\n\n### defer\n\ndefer 块会在即将离开函数作用域之前执行。如果有多个 defer 块，则逆序执行（像一个栈）。\n\n```swift\nlet database = openDatabase()\ndefer {\n    closeDatabase()\n}\nlet connection = openConnection(to: database)\ndefer {\n    closeConnection(to: database)\n}\n```\n\n### 自定义/重载运算符\n\n定义一个幂运算符 `**` :\n\n```swift\nprecedencegroup ExponentiationPrecedence { //自定义优先级\n    associativity: left //左结合性\n    higherThan: MultiplicationPrecedence //优先级高于乘法优先级\n}\n\ninfix operator **: ExponentiationPrecedence //使用 prefix infix 和 postfix 定义前缀、中缀、后缀\n\nfunc **(lhs: Double, rhs: Double) -> Double {\n    return pow(lhs, rhs)\n}\n\n2**3 // 8.0\n```\n\n","slug":"Swift-Tips","published":1,"updated":"2020-01-04T08:16:16.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv32000nljc3jiy3exfp","content":"<h1 id=\"Swift-Tips\"><a href=\"#Swift-Tips\" class=\"headerlink\" title=\"Swift Tips\"></a>Swift Tips</h1><h3 id=\"结构相等-amp-引用相等\"><a href=\"#结构相等-amp-引用相等\" class=\"headerlink\" title=\"结构相等&amp;引用相等\"></a>结构相等&amp;引用相等</h3><p>结构相等符 <code>==</code> 被用来判断两个值是否相等。而引用相等 <code>===</code> 用来检查两个引用是否具有<strong>同一性</strong>，即是否指向同一个对象。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"type\">A</span>()</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b == a)</span><br></pre></td></tr></table></figure>\n<p>上面的代码会报错误信息 <code>Binary operator &#39;==&#39; cannot be applied to two &#39;A&#39; operands</code>，提示你需要自己实现结构相等运算符。而如果把 == 改为 \\=== 就会 print 出 true。若将 class 改为 struct，则 === 也一样会报错。因为结构体是值类型，就谈不上引用了。</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p>一下两段代码有什么不同？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    array.forEach &#123; num <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(num)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num &gt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> array &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">print</span>(num)</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> num &gt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span></span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">foo1()</span><br><span class=\"line\">foo2()</span><br></pre></td></tr></table></figure>\n<p>使用 for each in 循环的函数会在打印出 3 之后停止，而使用 forEach 函数的函数会打印出所有的值。这是因为 forEach 的 return 语句只会将 forEach 的尾随闭包返回，而不会终止 forEach 本身的循环。这一点从刚刚<strong>“函数的函数”</strong>这个说法中也可以看出来。</p>\n<h3 id=\"mutating-关键字\"><a href=\"#mutating-关键字\" class=\"headerlink\" title=\"mutating 关键字\"></a>mutating 关键字</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">change</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        a += <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构体中的方法若想改变自身的属性，则需要在 func 前添加 mutating 关键字，而类中不用。可以这样看待这个问题的：可以理解成 self 是函数的一个隐式参数，添加 mutating 关键字代表 self 是可变的（相当于用 var 来声明这个结构体的感觉），否则 self 就是不可变的（相当于用 let 声明，自然不可以改变结构体内属性的值）。而 class 无论是 var 还是 let 来声明，都可以改变属性的值（var 和 let 对引用类型只限制了引用本身是否可以改变，而不是引用指向的对象），故不存在这个问题。更精确地来说，可以理解为 mutating 相当于对隐式变量 self 添加了关键字 inout。</p>\n<h3 id=\"捕获列表\"><a href=\"#捕获列表\" class=\"headerlink\" title=\"捕获列表\"></a>捕获列表</h3><p>将一个对象的属性设置为弱引用是打破循环引用的重要手段。但是，weak 关键字只能运用于 class 类变量，故不适用于同样是引用类型的函数变量。以下代码通过闭包，间接的构成了循环引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> parent: <span class=\"type\">Parent</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(parent: <span class=\"type\">Parent</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent = parent</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"child deinit\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> child: <span class=\"type\">Child?</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> closure: (()-&gt;())?</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"parent deinit\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p: <span class=\"type\">Parent?</span> = <span class=\"type\">Parent</span>()</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">c</span>: <span class=\"type\">Child?</span> = <span class=\"type\">Child</span>(parent: p!)</span><br><span class=\"line\">p?.child = <span class=\"built_in\">c</span></span><br><span class=\"line\">p?.closure = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p = <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"built_in\">c</span> = <span class=\"literal\">nil</span></span><br></pre></td></tr></table></figure>\n<p>为了打破这个循环引用，可以通过闭包的捕获列表，将 c 设置为弱引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p?.closure = &#123; [<span class=\"keyword\">weak</span> <span class=\"built_in\">c</span>] <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>闭包中，self 关键字会被强制写出来，也是为了明确的提示我们可能构成的循环引用。如果构成了循环引用，一般通过将 self 设置为 unowned 无主引用来打破循环。无主引用与弱引用的区别是，在引用的对象释放掉之后，它不会被设置为 nil，因此也不用像弱引用那样，必须是可选值，每次使用时都要解包。</p>\n<h3 id=\"amp\"><a href=\"#amp\" class=\"headerlink\" title=\"&amp;\"></a>&amp;</h3><p>在传递 inout 关键字时，需要在变量名前添加 &amp;。这里的 &amp; 不像 c/c++ 中的那样表示传递的是引用，而是把值复制，再粘贴回来。</p>\n<p>如果函数接受的是一个 UnsafeMutablePointer 的话，我们还是需要在变量名前加上 &amp;。但是，这里的 &amp; 表示的确实是传递引用了，更准确地说，传递的是指针。</p>\n<h3 id=\"autoclosure-关键字\"><a href=\"#autoclosure-关键字\" class=\"headerlink\" title=\"@autoclosure 关键字\"></a>@autoclosure 关键字</h3><p>@autoclosure 关键字可以自动为参数创建闭包，让我们的代码更加整洁。</p>\n<p>如果不加此关键字，我们必须手动写闭包语法 <code>{}</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Bool</span>) &#123;</span><br><span class=\"line\">    a()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( &#123;<span class=\"number\">1</span>+<span class=\"number\">1</span>==<span class=\"number\">2</span>&#125; )</span><br></pre></td></tr></table></figure>\n<p>有了 @autoclosure：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">_</span> a: @autoclosure <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Bool</span>) &#123;</span><br><span class=\"line\">    a()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(<span class=\"number\">1</span>+<span class=\"number\">1</span>==<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h3><p>defer 块会在即将离开函数作用域之前执行。如果有多个 defer 块，则逆序执行（像一个栈）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> database = openDatabase()</span><br><span class=\"line\"><span class=\"keyword\">defer</span> &#123;</span><br><span class=\"line\">    closeDatabase()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> connection = openConnection(to: database)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> &#123;</span><br><span class=\"line\">    closeConnection(to: database)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义-重载运算符\"><a href=\"#自定义-重载运算符\" class=\"headerlink\" title=\"自定义/重载运算符\"></a>自定义/重载运算符</h3><p>定义一个幂运算符 <code>**</code> :</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precedencegroup <span class=\"type\">ExponentiationPrecedence</span> &#123; <span class=\"comment\">//自定义优先级</span></span><br><span class=\"line\">    <span class=\"keyword\">associativity</span>: <span class=\"keyword\">left</span> <span class=\"comment\">//左结合性</span></span><br><span class=\"line\">    higherThan: <span class=\"type\">MultiplicationPrecedence</span> <span class=\"comment\">//优先级高于乘法优先级</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> **: <span class=\"type\">ExponentiationPrecedence</span> <span class=\"comment\">//使用 prefix infix 和 postfix 定义前缀、中缀、后缀</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> **<span class=\"params\">(lhs: Double, rhs: Double)</span></span> -&gt; <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pow(lhs, rhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>**<span class=\"number\">3</span> <span class=\"comment\">// 8.0</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Swift-Tips\"><a href=\"#Swift-Tips\" class=\"headerlink\" title=\"Swift Tips\"></a>Swift Tips</h1><h3 id=\"结构相等-amp-引用相等\"><a href=\"#结构相等-amp-引用相等\" class=\"headerlink\" title=\"结构相等&amp;引用相等\"></a>结构相等&amp;引用相等</h3><p>结构相等符 <code>==</code> 被用来判断两个值是否相等。而引用相等 <code>===</code> 用来检查两个引用是否具有<strong>同一性</strong>，即是否指向同一个对象。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> p = <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"type\">A</span>()</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a</span><br><span class=\"line\"><span class=\"built_in\">print</span>(b == a)</span><br></pre></td></tr></table></figure>\n<p>上面的代码会报错误信息 <code>Binary operator &#39;==&#39; cannot be applied to two &#39;A&#39; operands</code>，提示你需要自己实现结构相等运算符。而如果把 == 改为 \\=== 就会 print 出 true。若将 class 改为 struct，则 === 也一样会报错。因为结构体是值类型，就谈不上引用了。</p>\n<h3 id=\"forEach\"><a href=\"#forEach\" class=\"headerlink\" title=\"forEach\"></a>forEach</h3><p>一下两段代码有什么不同？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo1</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    array.forEach &#123; num <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(num)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> num &gt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo2</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> num <span class=\"keyword\">in</span> array &#123;</span><br><span class=\"line\">    \t<span class=\"built_in\">print</span>(num)</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> num &gt; <span class=\"number\">2</span> &#123;</span><br><span class=\"line\">        \t<span class=\"keyword\">return</span></span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">foo1()</span><br><span class=\"line\">foo2()</span><br></pre></td></tr></table></figure>\n<p>使用 for each in 循环的函数会在打印出 3 之后停止，而使用 forEach 函数的函数会打印出所有的值。这是因为 forEach 的 return 语句只会将 forEach 的尾随闭包返回，而不会终止 forEach 本身的循环。这一点从刚刚<strong>“函数的函数”</strong>这个说法中也可以看出来。</p>\n<h3 id=\"mutating-关键字\"><a href=\"#mutating-关键字\" class=\"headerlink\" title=\"mutating 关键字\"></a>mutating 关键字</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">change</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        a += <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结构体中的方法若想改变自身的属性，则需要在 func 前添加 mutating 关键字，而类中不用。可以这样看待这个问题的：可以理解成 self 是函数的一个隐式参数，添加 mutating 关键字代表 self 是可变的（相当于用 var 来声明这个结构体的感觉），否则 self 就是不可变的（相当于用 let 声明，自然不可以改变结构体内属性的值）。而 class 无论是 var 还是 let 来声明，都可以改变属性的值（var 和 let 对引用类型只限制了引用本身是否可以改变，而不是引用指向的对象），故不存在这个问题。更精确地来说，可以理解为 mutating 相当于对隐式变量 self 添加了关键字 inout。</p>\n<h3 id=\"捕获列表\"><a href=\"#捕获列表\" class=\"headerlink\" title=\"捕获列表\"></a>捕获列表</h3><p>将一个对象的属性设置为弱引用是打破循环引用的重要手段。但是，weak 关键字只能运用于 class 类变量，故不适用于同样是引用类型的函数变量。以下代码通过闭包，间接的构成了循环引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Child</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> parent: <span class=\"type\">Parent</span></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(parent: <span class=\"type\">Parent</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.parent = parent</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"child deinit\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">weak</span> <span class=\"keyword\">var</span> child: <span class=\"type\">Child?</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> closure: (()-&gt;())?</span><br><span class=\"line\">    <span class=\"keyword\">deinit</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"parent deinit\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p: <span class=\"type\">Parent?</span> = <span class=\"type\">Parent</span>()</span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">c</span>: <span class=\"type\">Child?</span> = <span class=\"type\">Child</span>(parent: p!)</span><br><span class=\"line\">p?.child = <span class=\"built_in\">c</span></span><br><span class=\"line\">p?.closure = &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">p = <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"built_in\">c</span> = <span class=\"literal\">nil</span></span><br></pre></td></tr></table></figure>\n<p>为了打破这个循环引用，可以通过闭包的捕获列表，将 c 设置为弱引用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p?.closure = &#123; [<span class=\"keyword\">weak</span> <span class=\"built_in\">c</span>] <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>闭包中，self 关键字会被强制写出来，也是为了明确的提示我们可能构成的循环引用。如果构成了循环引用，一般通过将 self 设置为 unowned 无主引用来打破循环。无主引用与弱引用的区别是，在引用的对象释放掉之后，它不会被设置为 nil，因此也不用像弱引用那样，必须是可选值，每次使用时都要解包。</p>\n<h3 id=\"amp\"><a href=\"#amp\" class=\"headerlink\" title=\"&amp;\"></a>&amp;</h3><p>在传递 inout 关键字时，需要在变量名前添加 &amp;。这里的 &amp; 不像 c/c++ 中的那样表示传递的是引用，而是把值复制，再粘贴回来。</p>\n<p>如果函数接受的是一个 UnsafeMutablePointer 的话，我们还是需要在变量名前加上 &amp;。但是，这里的 &amp; 表示的确实是传递引用了，更准确地说，传递的是指针。</p>\n<h3 id=\"autoclosure-关键字\"><a href=\"#autoclosure-关键字\" class=\"headerlink\" title=\"@autoclosure 关键字\"></a>@autoclosure 关键字</h3><p>@autoclosure 关键字可以自动为参数创建闭包，让我们的代码更加整洁。</p>\n<p>如果不加此关键字，我们必须手动写闭包语法 <code>{}</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">_</span> a: <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Bool</span>) &#123;</span><br><span class=\"line\">    a()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo( &#123;<span class=\"number\">1</span>+<span class=\"number\">1</span>==<span class=\"number\">2</span>&#125; )</span><br></pre></td></tr></table></figure>\n<p>有了 @autoclosure：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">foo</span><span class=\"params\">(<span class=\"number\">_</span> a: @autoclosure <span class=\"params\">()</span></span></span> -&gt; <span class=\"type\">Bool</span>) &#123;</span><br><span class=\"line\">    a()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(<span class=\"number\">1</span>+<span class=\"number\">1</span>==<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"defer\"><a href=\"#defer\" class=\"headerlink\" title=\"defer\"></a>defer</h3><p>defer 块会在即将离开函数作用域之前执行。如果有多个 defer 块，则逆序执行（像一个栈）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> database = openDatabase()</span><br><span class=\"line\"><span class=\"keyword\">defer</span> &#123;</span><br><span class=\"line\">    closeDatabase()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> connection = openConnection(to: database)</span><br><span class=\"line\"><span class=\"keyword\">defer</span> &#123;</span><br><span class=\"line\">    closeConnection(to: database)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自定义-重载运算符\"><a href=\"#自定义-重载运算符\" class=\"headerlink\" title=\"自定义/重载运算符\"></a>自定义/重载运算符</h3><p>定义一个幂运算符 <code>**</code> :</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">precedencegroup <span class=\"type\">ExponentiationPrecedence</span> &#123; <span class=\"comment\">//自定义优先级</span></span><br><span class=\"line\">    <span class=\"keyword\">associativity</span>: <span class=\"keyword\">left</span> <span class=\"comment\">//左结合性</span></span><br><span class=\"line\">    higherThan: <span class=\"type\">MultiplicationPrecedence</span> <span class=\"comment\">//优先级高于乘法优先级</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">infix</span> <span class=\"keyword\">operator</span> **: <span class=\"type\">ExponentiationPrecedence</span> <span class=\"comment\">//使用 prefix infix 和 postfix 定义前缀、中缀、后缀</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> **<span class=\"params\">(lhs: Double, rhs: Double)</span></span> -&gt; <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pow(lhs, rhs)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>**<span class=\"number\">3</span> <span class=\"comment\">// 8.0</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Swift4新特性","date":"2017-10-08T04:52:08.000Z","_content":"\n# Swift4 新特性\n\n参考自：Ray Wenderlich - iOS11 by Tutorials\n\n### One-sided ranges\n\n我们现在可以这样表示一个范围：\n\n```swift\nlet array = [\"通信电子线路\", \"电磁场与电磁波\", \"数字信号处理\", \"通信原理\", \"计算机网络\"]\nprint(array[...3])\n\\\\打印出: [\"通信电子线路\", \"电磁场与电磁波\", \"数字信号处理\", \"通信原理\"]\n```\n\n也可以这样：\n\n```swift\narray[..<3]\narray[2...]\n```\n\n单边范围也可以用来产生一个无限序列：\n\n```swift\nlet uppercase = [\"A\", \"B\", \"C\", \"D\"]\nlet asciiCodes = zip(65..., uppercase)\nprint(Array(asciiCodes))\n\\\\打印出: [(65, \"A\"), (66, \"B\"), (67, \"C\"), (68, \"D\")]\n```\n\n这里 `zip` 是函数式编程中常用的一个函数，就像 map, flatmap 那样。它表示把两个序列“齿合”成一个序列。别忘了 zip 有“拉链”的意思。\n\n在模式匹配中也可以应用：\n\n```swift\nslet value = 2\nswitch value {\ncase ...2:\n    print(2)\ncase 3...:\n    print(3)\ndefault:\n    break\n}\n```\n\n而且并不仅限于整型！Double 型也是支持的。\n\n### Strings\n\nString 现在回归了集合类型（就像 Swift1 中的那样）。这意味着集合可以做的事情，String 都可以做。\n\n```swift\nlet str = \"How are you Indian Mi fans?\"\nfor char in str {\n    print(char)\n}\nstr.count\nstr.isEmpty\nString(str.reversed())\n```\n\n这里注意，`str.reversed()` 返回的是一个 `ReversedCollection<String>` ，所以必须强制转换成 String。\n\nString 虽是集合类型，但是 Int 和 Swift3 中一样不能作为其下标。下标必须是一个 `String.Index` 。\n\n```swift\nlet index = str.index(str.startIndex, offsetBy: 4)\nstr[index...] //are you Indian Mi fans?\n```\n\nSwift4 还带来了一个新的类型：**Substring**\n\n为什么不继续使用 String 类型，而要构造一个新的 Substring 类型呢？我们知道，为了保证高效率，Swift 大量使用了 copy-on-write 技术。在你提取出一个子串的时候，并不会真的复制出一个新的字符串出来，而是多了一个指向原有字符串其中一部分的指针。就像这样：\n\n![substring](/img/Swift4新特性/substring.png)\n\n这回使得该字符串的引用计数增加。当你不在使用原有的字符串而转而只用子串时，原有的字符串就无法被自动释放。而如果引入了新的类型 Substring，而大量的 api 要求传入的类型是 String，你就不得不强制将 Substring 转化为 String（Swift 是强类型语言的缘故）。这个被强制转化出来的 String 就与之前的字符串无关了（被 copy 出来），从而避免了内存泄露。\n\n在上面的例子中就已经出现了 Substring：\n\n```swift\nlet sub = str[index...]\ntype(of: sub) //Substring.Type\n```\n\n由于 String 和 Substring 都遵守 StringProtocol，所以大多数用法都是一致的。重点需要记住的就是内存中的关系。\n\nRange<String.Index> 和 NSRange 之间的转化也变得更方便了：\n\n```swift\nlet str = \"🙈🙉🙊🐵🐒\"\nstr.count //5\nstr.utf16.count //10\nlet nsRange = NSRange(str.startIndex..., in: str) //{0, 10}\n```\n\n（NSRange 和 UTF-16 是对应的）\n\nSwift4 还带来了多行字符串，就像 Python 中的那样：\n\n```swift\nlet str = \"\"\"\n大鹏一日同风起，\n抟摇直上九万里。\n\"\"\"\n```\n\n### Dictionary enhancements\n\n有了新的初始化函数，现在可以使用键值序列来构造字典了：\n\n```swift\nlet dic = Dictionary(uniqueKeysWithValues: zip(1..., [\"1\",\"2\",\"3\"]))\n//dic: [2: \"2\", 3: \"3\", 1: \"1\"]\n```\n\n或者用元组的序列也可以：\n\n```swift\nlet dic = Dictionary(uniqueKeysWithValues: [(1,\"1\"), (2,\"2\")])\n```\n\n并且增加了一个 merge 函数，用来合并两个字典。在闭包中定义遇到冲突时的处理方法：\n\n```swift\nlet defaultStyling: [String: UIColor] = [\n    \"body\": .black, \"title\": .blue, \"byline\": .green\n]\nvar userStyling: [String: UIColor] = [\n    \"body\": .purple, \"title\": .blue\n]\nuserStyling.merge(defaultStyling) { (user, _) -> UIColor in\n    user\n}\n// [\"body\": .purple, \"title\": .blue, \"byline\": .green]\n```\n\n新的 mapValues 函数可以不改变字典的结构（map 会返回一个数组，而不是字典）：\n\n```swift\nvar dic = Dictionary(uniqueKeysWithValues: zip(1..., [\"1\",\"2\",\"3\"]))\ndic = dic.mapValues{\n    String(Int($0)! + 1)\n}\n```\n\n字典也可以依据某一个特征来进行分组（Grouping）：\n\n```swift\nlet names = [\"Harry\", \"ron\", \"Hermione\", \"Hannah\", \"neville\", \"pansy\", \"Padma\"].map { $0.capitalized } //大写\nlet nameList = Dictionary(grouping: names) { $0.prefix(1) }\n//[\"H\": [\"Harry\", \"Hermione\", \"Hannah\"], \"R\": [\"Ron\"], \"N\": [\"Neville\"], \"P\": [\"Pansy\", \"Padma\"]]\n```\n\n自定义下标可以返回范型了：\n\n```swift\nstruct Grade {\n    private var data: [String: Any]\n    \n    init(data: [String: Any]) {\n        self.data = data\n    }\n    \n    subscript<T>(key: String) -> T? {\n        return data[key] as? T\n    }\n}\n\nlet gradebook = Grade(data: [\"name\": \"Neil Armstrong\",\n                             \"exam\": \"LEM Landing\",\n                             \"grade\": 97])\nlet who: String? = gradebook[\"name\"]\nlet grade: Int?  = gradebook[\"grade\"]\n```\n\n这样就不必写 as 语句把 Any 类型转化了。但是指明类型仍是必不可少的（即`:String？`不可缺少）。\n\n### 还有一些其他的小变化\n\n- extension 中可以访问到 private 成员变量了。\n- 出于内存安全性的考虑，一个变量不能被当作两个 `inout` 参数传入同一个函数，这被称为“排他性”（exclusivity）。所以 Swift3 中的 swap 函数在 Swift4 中就非法了：\n\n```swift\nswap(&numbers[1], &numbers[3]) // illegal in Swift4\n//numbers 不能被当作两个 inout 参数传入 swap 函数\n```\n\n​\t现在可以用：\n\n```swift\nnumbers.swapAt(1, 3)\n```\n\n​\t更详细的介绍参看[这里](https://github.com/apple/swift-evolution/blob/master/proposals/0173-swap-indices.md)。\n\n- Swift4 中对 NSNumber 的桥接做了安全性检测：\n\n```swift\nlet n = NSNumber(value: 603)\nlet v = n as? Int8\n```\n\n​\t在 Swift3 中，会出现一个不正确的值。而现在会是 nil 了。也可以用 is 语句来判断是否可以转换。\n\n- 可以具体指明一个对象既是某个类型，又遵守某个协议了：\n\n```swift\nprotocol MySpecialDelegateProtocol {}\nclass MySpecialView: UIView {}\nclass MyController {\n  var delegate: (UIView & MySpecialDelegateProtocol)?\n}\n```\n\n### 还有一些参考资料：\n\nhttps://github.com/apple/swift-evolution\n\nhttps://developer.apple.com/videos/play/wwdc2017/402/","source":"_posts/Swift4新特性.md","raw":"---\ntitle: Swift4新特性\ndate: 2017-10-08 12:52:08\ntags: Swift\n---\n\n# Swift4 新特性\n\n参考自：Ray Wenderlich - iOS11 by Tutorials\n\n### One-sided ranges\n\n我们现在可以这样表示一个范围：\n\n```swift\nlet array = [\"通信电子线路\", \"电磁场与电磁波\", \"数字信号处理\", \"通信原理\", \"计算机网络\"]\nprint(array[...3])\n\\\\打印出: [\"通信电子线路\", \"电磁场与电磁波\", \"数字信号处理\", \"通信原理\"]\n```\n\n也可以这样：\n\n```swift\narray[..<3]\narray[2...]\n```\n\n单边范围也可以用来产生一个无限序列：\n\n```swift\nlet uppercase = [\"A\", \"B\", \"C\", \"D\"]\nlet asciiCodes = zip(65..., uppercase)\nprint(Array(asciiCodes))\n\\\\打印出: [(65, \"A\"), (66, \"B\"), (67, \"C\"), (68, \"D\")]\n```\n\n这里 `zip` 是函数式编程中常用的一个函数，就像 map, flatmap 那样。它表示把两个序列“齿合”成一个序列。别忘了 zip 有“拉链”的意思。\n\n在模式匹配中也可以应用：\n\n```swift\nslet value = 2\nswitch value {\ncase ...2:\n    print(2)\ncase 3...:\n    print(3)\ndefault:\n    break\n}\n```\n\n而且并不仅限于整型！Double 型也是支持的。\n\n### Strings\n\nString 现在回归了集合类型（就像 Swift1 中的那样）。这意味着集合可以做的事情，String 都可以做。\n\n```swift\nlet str = \"How are you Indian Mi fans?\"\nfor char in str {\n    print(char)\n}\nstr.count\nstr.isEmpty\nString(str.reversed())\n```\n\n这里注意，`str.reversed()` 返回的是一个 `ReversedCollection<String>` ，所以必须强制转换成 String。\n\nString 虽是集合类型，但是 Int 和 Swift3 中一样不能作为其下标。下标必须是一个 `String.Index` 。\n\n```swift\nlet index = str.index(str.startIndex, offsetBy: 4)\nstr[index...] //are you Indian Mi fans?\n```\n\nSwift4 还带来了一个新的类型：**Substring**\n\n为什么不继续使用 String 类型，而要构造一个新的 Substring 类型呢？我们知道，为了保证高效率，Swift 大量使用了 copy-on-write 技术。在你提取出一个子串的时候，并不会真的复制出一个新的字符串出来，而是多了一个指向原有字符串其中一部分的指针。就像这样：\n\n![substring](/img/Swift4新特性/substring.png)\n\n这回使得该字符串的引用计数增加。当你不在使用原有的字符串而转而只用子串时，原有的字符串就无法被自动释放。而如果引入了新的类型 Substring，而大量的 api 要求传入的类型是 String，你就不得不强制将 Substring 转化为 String（Swift 是强类型语言的缘故）。这个被强制转化出来的 String 就与之前的字符串无关了（被 copy 出来），从而避免了内存泄露。\n\n在上面的例子中就已经出现了 Substring：\n\n```swift\nlet sub = str[index...]\ntype(of: sub) //Substring.Type\n```\n\n由于 String 和 Substring 都遵守 StringProtocol，所以大多数用法都是一致的。重点需要记住的就是内存中的关系。\n\nRange<String.Index> 和 NSRange 之间的转化也变得更方便了：\n\n```swift\nlet str = \"🙈🙉🙊🐵🐒\"\nstr.count //5\nstr.utf16.count //10\nlet nsRange = NSRange(str.startIndex..., in: str) //{0, 10}\n```\n\n（NSRange 和 UTF-16 是对应的）\n\nSwift4 还带来了多行字符串，就像 Python 中的那样：\n\n```swift\nlet str = \"\"\"\n大鹏一日同风起，\n抟摇直上九万里。\n\"\"\"\n```\n\n### Dictionary enhancements\n\n有了新的初始化函数，现在可以使用键值序列来构造字典了：\n\n```swift\nlet dic = Dictionary(uniqueKeysWithValues: zip(1..., [\"1\",\"2\",\"3\"]))\n//dic: [2: \"2\", 3: \"3\", 1: \"1\"]\n```\n\n或者用元组的序列也可以：\n\n```swift\nlet dic = Dictionary(uniqueKeysWithValues: [(1,\"1\"), (2,\"2\")])\n```\n\n并且增加了一个 merge 函数，用来合并两个字典。在闭包中定义遇到冲突时的处理方法：\n\n```swift\nlet defaultStyling: [String: UIColor] = [\n    \"body\": .black, \"title\": .blue, \"byline\": .green\n]\nvar userStyling: [String: UIColor] = [\n    \"body\": .purple, \"title\": .blue\n]\nuserStyling.merge(defaultStyling) { (user, _) -> UIColor in\n    user\n}\n// [\"body\": .purple, \"title\": .blue, \"byline\": .green]\n```\n\n新的 mapValues 函数可以不改变字典的结构（map 会返回一个数组，而不是字典）：\n\n```swift\nvar dic = Dictionary(uniqueKeysWithValues: zip(1..., [\"1\",\"2\",\"3\"]))\ndic = dic.mapValues{\n    String(Int($0)! + 1)\n}\n```\n\n字典也可以依据某一个特征来进行分组（Grouping）：\n\n```swift\nlet names = [\"Harry\", \"ron\", \"Hermione\", \"Hannah\", \"neville\", \"pansy\", \"Padma\"].map { $0.capitalized } //大写\nlet nameList = Dictionary(grouping: names) { $0.prefix(1) }\n//[\"H\": [\"Harry\", \"Hermione\", \"Hannah\"], \"R\": [\"Ron\"], \"N\": [\"Neville\"], \"P\": [\"Pansy\", \"Padma\"]]\n```\n\n自定义下标可以返回范型了：\n\n```swift\nstruct Grade {\n    private var data: [String: Any]\n    \n    init(data: [String: Any]) {\n        self.data = data\n    }\n    \n    subscript<T>(key: String) -> T? {\n        return data[key] as? T\n    }\n}\n\nlet gradebook = Grade(data: [\"name\": \"Neil Armstrong\",\n                             \"exam\": \"LEM Landing\",\n                             \"grade\": 97])\nlet who: String? = gradebook[\"name\"]\nlet grade: Int?  = gradebook[\"grade\"]\n```\n\n这样就不必写 as 语句把 Any 类型转化了。但是指明类型仍是必不可少的（即`:String？`不可缺少）。\n\n### 还有一些其他的小变化\n\n- extension 中可以访问到 private 成员变量了。\n- 出于内存安全性的考虑，一个变量不能被当作两个 `inout` 参数传入同一个函数，这被称为“排他性”（exclusivity）。所以 Swift3 中的 swap 函数在 Swift4 中就非法了：\n\n```swift\nswap(&numbers[1], &numbers[3]) // illegal in Swift4\n//numbers 不能被当作两个 inout 参数传入 swap 函数\n```\n\n​\t现在可以用：\n\n```swift\nnumbers.swapAt(1, 3)\n```\n\n​\t更详细的介绍参看[这里](https://github.com/apple/swift-evolution/blob/master/proposals/0173-swap-indices.md)。\n\n- Swift4 中对 NSNumber 的桥接做了安全性检测：\n\n```swift\nlet n = NSNumber(value: 603)\nlet v = n as? Int8\n```\n\n​\t在 Swift3 中，会出现一个不正确的值。而现在会是 nil 了。也可以用 is 语句来判断是否可以转换。\n\n- 可以具体指明一个对象既是某个类型，又遵守某个协议了：\n\n```swift\nprotocol MySpecialDelegateProtocol {}\nclass MySpecialView: UIView {}\nclass MyController {\n  var delegate: (UIView & MySpecialDelegateProtocol)?\n}\n```\n\n### 还有一些参考资料：\n\nhttps://github.com/apple/swift-evolution\n\nhttps://developer.apple.com/videos/play/wwdc2017/402/","slug":"Swift4新特性","published":1,"updated":"2020-01-04T08:16:16.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv32000oljc3wr6068j5","content":"<h1 id=\"Swift4-新特性\"><a href=\"#Swift4-新特性\" class=\"headerlink\" title=\"Swift4 新特性\"></a>Swift4 新特性</h1><p>参考自：Ray Wenderlich - iOS11 by Tutorials</p>\n<h3 id=\"One-sided-ranges\"><a href=\"#One-sided-ranges\" class=\"headerlink\" title=\"One-sided ranges\"></a>One-sided ranges</h3><p>我们现在可以这样表示一个范围：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"string\">\"通信电子线路\"</span>, <span class=\"string\">\"电磁场与电磁波\"</span>, <span class=\"string\">\"数字信号处理\"</span>, <span class=\"string\">\"通信原理\"</span>, <span class=\"string\">\"计算机网络\"</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(array[...<span class=\"number\">3</span>])</span><br><span class=\"line\">\\\\打印出: [<span class=\"string\">\"通信电子线路\"</span>, <span class=\"string\">\"电磁场与电磁波\"</span>, <span class=\"string\">\"数字信号处理\"</span>, <span class=\"string\">\"通信原理\"</span>]</span><br></pre></td></tr></table></figure>\n<p>也可以这样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array[..&lt;<span class=\"number\">3</span>]</span><br><span class=\"line\">array[<span class=\"number\">2</span>...]</span><br></pre></td></tr></table></figure>\n<p>单边范围也可以用来产生一个无限序列：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uppercase = [<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> asciiCodes = <span class=\"built_in\">zip</span>(<span class=\"number\">65</span>..., uppercase)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">Array</span>(asciiCodes))</span><br><span class=\"line\">\\\\打印出: [(<span class=\"number\">65</span>, <span class=\"string\">\"A\"</span>), (<span class=\"number\">66</span>, <span class=\"string\">\"B\"</span>), (<span class=\"number\">67</span>, <span class=\"string\">\"C\"</span>), (<span class=\"number\">68</span>, <span class=\"string\">\"D\"</span>)]</span><br></pre></td></tr></table></figure>\n<p>这里 <code>zip</code> 是函数式编程中常用的一个函数，就像 map, flatmap 那样。它表示把两个序列“齿合”成一个序列。别忘了 zip 有“拉链”的意思。</p>\n<p>在模式匹配中也可以应用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slet value = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> value &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> ...<span class=\"number\">2</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">3</span>...:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而且并不仅限于整型！Double 型也是支持的。</p>\n<h3 id=\"Strings\"><a href=\"#Strings\" class=\"headerlink\" title=\"Strings\"></a>Strings</h3><p>String 现在回归了集合类型（就像 Swift1 中的那样）。这意味着集合可以做的事情，String 都可以做。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"How are you Indian Mi fans?\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> str &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(char)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">str.<span class=\"built_in\">count</span></span><br><span class=\"line\">str.isEmpty</span><br><span class=\"line\"><span class=\"type\">String</span>(str.reversed())</span><br></pre></td></tr></table></figure>\n<p>这里注意，<code>str.reversed()</code> 返回的是一个 <code>ReversedCollection&lt;String&gt;</code> ，所以必须强制转换成 String。</p>\n<p>String 虽是集合类型，但是 Int 和 Swift3 中一样不能作为其下标。下标必须是一个 <code>String.Index</code> 。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> index = str.index(str.startIndex, offsetBy: <span class=\"number\">4</span>)</span><br><span class=\"line\">str[index...] <span class=\"comment\">//are you Indian Mi fans?</span></span><br></pre></td></tr></table></figure>\n<p>Swift4 还带来了一个新的类型：<strong>Substring</strong></p>\n<p>为什么不继续使用 String 类型，而要构造一个新的 Substring 类型呢？我们知道，为了保证高效率，Swift 大量使用了 copy-on-write 技术。在你提取出一个子串的时候，并不会真的复制出一个新的字符串出来，而是多了一个指向原有字符串其中一部分的指针。就像这样：</p>\n<p><img src=\"/img/Swift4新特性/substring.png\" alt=\"substring\"></p>\n<p>这回使得该字符串的引用计数增加。当你不在使用原有的字符串而转而只用子串时，原有的字符串就无法被自动释放。而如果引入了新的类型 Substring，而大量的 api 要求传入的类型是 String，你就不得不强制将 Substring 转化为 String（Swift 是强类型语言的缘故）。这个被强制转化出来的 String 就与之前的字符串无关了（被 copy 出来），从而避免了内存泄露。</p>\n<p>在上面的例子中就已经出现了 Substring：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sub = str[index...]</span><br><span class=\"line\">type(of: sub) <span class=\"comment\">//Substring.Type</span></span><br></pre></td></tr></table></figure>\n<p>由于 String 和 Substring 都遵守 StringProtocol，所以大多数用法都是一致的。重点需要记住的就是内存中的关系。</p>\n<p>Range&lt;String.Index&gt; 和 NSRange 之间的转化也变得更方便了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"🙈🙉🙊🐵🐒\"</span></span><br><span class=\"line\">str.<span class=\"built_in\">count</span> <span class=\"comment\">//5</span></span><br><span class=\"line\">str.utf16.<span class=\"built_in\">count</span> <span class=\"comment\">//10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> nsRange = <span class=\"type\">NSRange</span>(str.startIndex..., <span class=\"keyword\">in</span>: str) <span class=\"comment\">//&#123;0, 10&#125;</span></span><br></pre></td></tr></table></figure>\n<p>（NSRange 和 UTF-16 是对应的）</p>\n<p>Swift4 还带来了多行字符串，就像 Python 中的那样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">大鹏一日同风起，</span></span><br><span class=\"line\"><span class=\"string\">抟摇直上九万里。</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Dictionary-enhancements\"><a href=\"#Dictionary-enhancements\" class=\"headerlink\" title=\"Dictionary enhancements\"></a>Dictionary enhancements</h3><p>有了新的初始化函数，现在可以使用键值序列来构造字典了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dic = <span class=\"type\">Dictionary</span>(uniqueKeysWithValues: <span class=\"built_in\">zip</span>(<span class=\"number\">1</span>..., [<span class=\"string\">\"1\"</span>,<span class=\"string\">\"2\"</span>,<span class=\"string\">\"3\"</span>]))</span><br><span class=\"line\"><span class=\"comment\">//dic: [2: \"2\", 3: \"3\", 1: \"1\"]</span></span><br></pre></td></tr></table></figure>\n<p>或者用元组的序列也可以：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dic = <span class=\"type\">Dictionary</span>(uniqueKeysWithValues: [(<span class=\"number\">1</span>,<span class=\"string\">\"1\"</span>), (<span class=\"number\">2</span>,<span class=\"string\">\"2\"</span>)])</span><br></pre></td></tr></table></figure>\n<p>并且增加了一个 merge 函数，用来合并两个字典。在闭包中定义遇到冲突时的处理方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaultStyling: [<span class=\"type\">String</span>: <span class=\"type\">UIColor</span>] = [</span><br><span class=\"line\">    <span class=\"string\">\"body\"</span>: .black, <span class=\"string\">\"title\"</span>: .blue, <span class=\"string\">\"byline\"</span>: .green</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">var</span> userStyling: [<span class=\"type\">String</span>: <span class=\"type\">UIColor</span>] = [</span><br><span class=\"line\">    <span class=\"string\">\"body\"</span>: .purple, <span class=\"string\">\"title\"</span>: .blue</span><br><span class=\"line\">]</span><br><span class=\"line\">userStyling.merge(defaultStyling) &#123; (user, <span class=\"number\">_</span>) -&gt; <span class=\"type\">UIColor</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    user</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// [\"body\": .purple, \"title\": .blue, \"byline\": .green]</span></span><br></pre></td></tr></table></figure>\n<p>新的 mapValues 函数可以不改变字典的结构（map 会返回一个数组，而不是字典）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dic = <span class=\"type\">Dictionary</span>(uniqueKeysWithValues: <span class=\"built_in\">zip</span>(<span class=\"number\">1</span>..., [<span class=\"string\">\"1\"</span>,<span class=\"string\">\"2\"</span>,<span class=\"string\">\"3\"</span>]))</span><br><span class=\"line\">dic = dic.mapValues&#123;</span><br><span class=\"line\">    <span class=\"type\">String</span>(<span class=\"type\">Int</span>($<span class=\"number\">0</span>)! + <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字典也可以依据某一个特征来进行分组（Grouping）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = [<span class=\"string\">\"Harry\"</span>, <span class=\"string\">\"ron\"</span>, <span class=\"string\">\"Hermione\"</span>, <span class=\"string\">\"Hannah\"</span>, <span class=\"string\">\"neville\"</span>, <span class=\"string\">\"pansy\"</span>, <span class=\"string\">\"Padma\"</span>].<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span>.capitalized &#125; <span class=\"comment\">//大写</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> nameList = <span class=\"type\">Dictionary</span>(grouping: names) &#123; $<span class=\"number\">0</span>.<span class=\"keyword\">prefix</span>(<span class=\"number\">1</span>) &#125;</span><br><span class=\"line\"><span class=\"comment\">//[\"H\": [\"Harry\", \"Hermione\", \"Hannah\"], \"R\": [\"Ron\"], \"N\": [\"Neville\"], \"P\": [\"Pansy\", \"Padma\"]]</span></span><br></pre></td></tr></table></figure>\n<p>自定义下标可以返回范型了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Grade</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> data: [<span class=\"type\">String</span>: <span class=\"type\">Any</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(data: [<span class=\"type\">String</span>: <span class=\"type\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.data = data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">subscript</span>&lt;<span class=\"type\">T</span>&gt;(key: <span class=\"type\">String</span>) -&gt; <span class=\"type\">T?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[key] <span class=\"keyword\">as</span>? <span class=\"type\">T</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> gradebook = <span class=\"type\">Grade</span>(data: [<span class=\"string\">\"name\"</span>: <span class=\"string\">\"Neil Armstrong\"</span>,</span><br><span class=\"line\">                             <span class=\"string\">\"exam\"</span>: <span class=\"string\">\"LEM Landing\"</span>,</span><br><span class=\"line\">                             <span class=\"string\">\"grade\"</span>: <span class=\"number\">97</span>])</span><br><span class=\"line\"><span class=\"keyword\">let</span> who: <span class=\"type\">String?</span> = gradebook[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> grade: <span class=\"type\">Int?</span>  = gradebook[<span class=\"string\">\"grade\"</span>]</span><br></pre></td></tr></table></figure>\n<p>这样就不必写 as 语句把 Any 类型转化了。但是指明类型仍是必不可少的（即<code>:String？</code>不可缺少）。</p>\n<h3 id=\"还有一些其他的小变化\"><a href=\"#还有一些其他的小变化\" class=\"headerlink\" title=\"还有一些其他的小变化\"></a>还有一些其他的小变化</h3><ul>\n<li>extension 中可以访问到 private 成员变量了。</li>\n<li>出于内存安全性的考虑，一个变量不能被当作两个 <code>inout</code> 参数传入同一个函数，这被称为“排他性”（exclusivity）。所以 Swift3 中的 swap 函数在 Swift4 中就非法了：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">swap</span>(&amp;numbers[<span class=\"number\">1</span>], &amp;numbers[<span class=\"number\">3</span>]) <span class=\"comment\">// illegal in Swift4</span></span><br><span class=\"line\"><span class=\"comment\">//numbers 不能被当作两个 inout 参数传入 swap 函数</span></span><br></pre></td></tr></table></figure>\n<p>​    现在可以用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers.swapAt(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>​    更详细的介绍参看<a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0173-swap-indices.md\">这里</a>。</p>\n<ul>\n<li>Swift4 中对 NSNumber 的桥接做了安全性检测：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"type\">NSNumber</span>(value: <span class=\"number\">603</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> v = n <span class=\"keyword\">as</span>? <span class=\"type\">Int8</span></span><br></pre></td></tr></table></figure>\n<p>​    在 Swift3 中，会出现一个不正确的值。而现在会是 nil 了。也可以用 is 语句来判断是否可以转换。</p>\n<ul>\n<li>可以具体指明一个对象既是某个类型，又遵守某个协议了：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">MySpecialDelegateProtocol</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySpecialView</span>: <span class=\"title\">UIView</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> delegate: (<span class=\"type\">UIView</span> &amp; <span class=\"type\">MySpecialDelegateProtocol</span>)?</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"还有一些参考资料：\"><a href=\"#还有一些参考资料：\" class=\"headerlink\" title=\"还有一些参考资料：\"></a>还有一些参考资料：</h3><p><a href=\"https://github.com/apple/swift-evolution\">https://github.com/apple/swift-evolution</a></p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2017/402/\">https://developer.apple.com/videos/play/wwdc2017/402/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Swift4-新特性\"><a href=\"#Swift4-新特性\" class=\"headerlink\" title=\"Swift4 新特性\"></a>Swift4 新特性</h1><p>参考自：Ray Wenderlich - iOS11 by Tutorials</p>\n<h3 id=\"One-sided-ranges\"><a href=\"#One-sided-ranges\" class=\"headerlink\" title=\"One-sided ranges\"></a>One-sided ranges</h3><p>我们现在可以这样表示一个范围：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"string\">\"通信电子线路\"</span>, <span class=\"string\">\"电磁场与电磁波\"</span>, <span class=\"string\">\"数字信号处理\"</span>, <span class=\"string\">\"通信原理\"</span>, <span class=\"string\">\"计算机网络\"</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(array[...<span class=\"number\">3</span>])</span><br><span class=\"line\">\\\\打印出: [<span class=\"string\">\"通信电子线路\"</span>, <span class=\"string\">\"电磁场与电磁波\"</span>, <span class=\"string\">\"数字信号处理\"</span>, <span class=\"string\">\"通信原理\"</span>]</span><br></pre></td></tr></table></figure>\n<p>也可以这样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">array[..&lt;<span class=\"number\">3</span>]</span><br><span class=\"line\">array[<span class=\"number\">2</span>...]</span><br></pre></td></tr></table></figure>\n<p>单边范围也可以用来产生一个无限序列：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> uppercase = [<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> asciiCodes = <span class=\"built_in\">zip</span>(<span class=\"number\">65</span>..., uppercase)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"type\">Array</span>(asciiCodes))</span><br><span class=\"line\">\\\\打印出: [(<span class=\"number\">65</span>, <span class=\"string\">\"A\"</span>), (<span class=\"number\">66</span>, <span class=\"string\">\"B\"</span>), (<span class=\"number\">67</span>, <span class=\"string\">\"C\"</span>), (<span class=\"number\">68</span>, <span class=\"string\">\"D\"</span>)]</span><br></pre></td></tr></table></figure>\n<p>这里 <code>zip</code> 是函数式编程中常用的一个函数，就像 map, flatmap 那样。它表示把两个序列“齿合”成一个序列。别忘了 zip 有“拉链”的意思。</p>\n<p>在模式匹配中也可以应用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slet value = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">switch</span> value &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> ...<span class=\"number\">2</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">3</span>...:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而且并不仅限于整型！Double 型也是支持的。</p>\n<h3 id=\"Strings\"><a href=\"#Strings\" class=\"headerlink\" title=\"Strings\"></a>Strings</h3><p>String 现在回归了集合类型（就像 Swift1 中的那样）。这意味着集合可以做的事情，String 都可以做。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"How are you Indian Mi fans?\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> str &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(char)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">str.<span class=\"built_in\">count</span></span><br><span class=\"line\">str.isEmpty</span><br><span class=\"line\"><span class=\"type\">String</span>(str.reversed())</span><br></pre></td></tr></table></figure>\n<p>这里注意，<code>str.reversed()</code> 返回的是一个 <code>ReversedCollection&lt;String&gt;</code> ，所以必须强制转换成 String。</p>\n<p>String 虽是集合类型，但是 Int 和 Swift3 中一样不能作为其下标。下标必须是一个 <code>String.Index</code> 。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> index = str.index(str.startIndex, offsetBy: <span class=\"number\">4</span>)</span><br><span class=\"line\">str[index...] <span class=\"comment\">//are you Indian Mi fans?</span></span><br></pre></td></tr></table></figure>\n<p>Swift4 还带来了一个新的类型：<strong>Substring</strong></p>\n<p>为什么不继续使用 String 类型，而要构造一个新的 Substring 类型呢？我们知道，为了保证高效率，Swift 大量使用了 copy-on-write 技术。在你提取出一个子串的时候，并不会真的复制出一个新的字符串出来，而是多了一个指向原有字符串其中一部分的指针。就像这样：</p>\n<p><img src=\"/img/Swift4新特性/substring.png\" alt=\"substring\"></p>\n<p>这回使得该字符串的引用计数增加。当你不在使用原有的字符串而转而只用子串时，原有的字符串就无法被自动释放。而如果引入了新的类型 Substring，而大量的 api 要求传入的类型是 String，你就不得不强制将 Substring 转化为 String（Swift 是强类型语言的缘故）。这个被强制转化出来的 String 就与之前的字符串无关了（被 copy 出来），从而避免了内存泄露。</p>\n<p>在上面的例子中就已经出现了 Substring：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sub = str[index...]</span><br><span class=\"line\">type(of: sub) <span class=\"comment\">//Substring.Type</span></span><br></pre></td></tr></table></figure>\n<p>由于 String 和 Substring 都遵守 StringProtocol，所以大多数用法都是一致的。重点需要记住的就是内存中的关系。</p>\n<p>Range&lt;String.Index&gt; 和 NSRange 之间的转化也变得更方便了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"🙈🙉🙊🐵🐒\"</span></span><br><span class=\"line\">str.<span class=\"built_in\">count</span> <span class=\"comment\">//5</span></span><br><span class=\"line\">str.utf16.<span class=\"built_in\">count</span> <span class=\"comment\">//10</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> nsRange = <span class=\"type\">NSRange</span>(str.startIndex..., <span class=\"keyword\">in</span>: str) <span class=\"comment\">//&#123;0, 10&#125;</span></span><br></pre></td></tr></table></figure>\n<p>（NSRange 和 UTF-16 是对应的）</p>\n<p>Swift4 还带来了多行字符串，就像 Python 中的那样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">大鹏一日同风起，</span></span><br><span class=\"line\"><span class=\"string\">抟摇直上九万里。</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Dictionary-enhancements\"><a href=\"#Dictionary-enhancements\" class=\"headerlink\" title=\"Dictionary enhancements\"></a>Dictionary enhancements</h3><p>有了新的初始化函数，现在可以使用键值序列来构造字典了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dic = <span class=\"type\">Dictionary</span>(uniqueKeysWithValues: <span class=\"built_in\">zip</span>(<span class=\"number\">1</span>..., [<span class=\"string\">\"1\"</span>,<span class=\"string\">\"2\"</span>,<span class=\"string\">\"3\"</span>]))</span><br><span class=\"line\"><span class=\"comment\">//dic: [2: \"2\", 3: \"3\", 1: \"1\"]</span></span><br></pre></td></tr></table></figure>\n<p>或者用元组的序列也可以：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dic = <span class=\"type\">Dictionary</span>(uniqueKeysWithValues: [(<span class=\"number\">1</span>,<span class=\"string\">\"1\"</span>), (<span class=\"number\">2</span>,<span class=\"string\">\"2\"</span>)])</span><br></pre></td></tr></table></figure>\n<p>并且增加了一个 merge 函数，用来合并两个字典。在闭包中定义遇到冲突时的处理方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> defaultStyling: [<span class=\"type\">String</span>: <span class=\"type\">UIColor</span>] = [</span><br><span class=\"line\">    <span class=\"string\">\"body\"</span>: .black, <span class=\"string\">\"title\"</span>: .blue, <span class=\"string\">\"byline\"</span>: .green</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">var</span> userStyling: [<span class=\"type\">String</span>: <span class=\"type\">UIColor</span>] = [</span><br><span class=\"line\">    <span class=\"string\">\"body\"</span>: .purple, <span class=\"string\">\"title\"</span>: .blue</span><br><span class=\"line\">]</span><br><span class=\"line\">userStyling.merge(defaultStyling) &#123; (user, <span class=\"number\">_</span>) -&gt; <span class=\"type\">UIColor</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    user</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// [\"body\": .purple, \"title\": .blue, \"byline\": .green]</span></span><br></pre></td></tr></table></figure>\n<p>新的 mapValues 函数可以不改变字典的结构（map 会返回一个数组，而不是字典）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dic = <span class=\"type\">Dictionary</span>(uniqueKeysWithValues: <span class=\"built_in\">zip</span>(<span class=\"number\">1</span>..., [<span class=\"string\">\"1\"</span>,<span class=\"string\">\"2\"</span>,<span class=\"string\">\"3\"</span>]))</span><br><span class=\"line\">dic = dic.mapValues&#123;</span><br><span class=\"line\">    <span class=\"type\">String</span>(<span class=\"type\">Int</span>($<span class=\"number\">0</span>)! + <span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字典也可以依据某一个特征来进行分组（Grouping）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names = [<span class=\"string\">\"Harry\"</span>, <span class=\"string\">\"ron\"</span>, <span class=\"string\">\"Hermione\"</span>, <span class=\"string\">\"Hannah\"</span>, <span class=\"string\">\"neville\"</span>, <span class=\"string\">\"pansy\"</span>, <span class=\"string\">\"Padma\"</span>].<span class=\"built_in\">map</span> &#123; $<span class=\"number\">0</span>.capitalized &#125; <span class=\"comment\">//大写</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> nameList = <span class=\"type\">Dictionary</span>(grouping: names) &#123; $<span class=\"number\">0</span>.<span class=\"keyword\">prefix</span>(<span class=\"number\">1</span>) &#125;</span><br><span class=\"line\"><span class=\"comment\">//[\"H\": [\"Harry\", \"Hermione\", \"Hannah\"], \"R\": [\"Ron\"], \"N\": [\"Neville\"], \"P\": [\"Pansy\", \"Padma\"]]</span></span><br></pre></td></tr></table></figure>\n<p>自定义下标可以返回范型了：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Grade</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> data: [<span class=\"type\">String</span>: <span class=\"type\">Any</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(data: [<span class=\"type\">String</span>: <span class=\"type\">Any</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.data = data</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">subscript</span>&lt;<span class=\"type\">T</span>&gt;(key: <span class=\"type\">String</span>) -&gt; <span class=\"type\">T?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[key] <span class=\"keyword\">as</span>? <span class=\"type\">T</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> gradebook = <span class=\"type\">Grade</span>(data: [<span class=\"string\">\"name\"</span>: <span class=\"string\">\"Neil Armstrong\"</span>,</span><br><span class=\"line\">                             <span class=\"string\">\"exam\"</span>: <span class=\"string\">\"LEM Landing\"</span>,</span><br><span class=\"line\">                             <span class=\"string\">\"grade\"</span>: <span class=\"number\">97</span>])</span><br><span class=\"line\"><span class=\"keyword\">let</span> who: <span class=\"type\">String?</span> = gradebook[<span class=\"string\">\"name\"</span>]</span><br><span class=\"line\"><span class=\"keyword\">let</span> grade: <span class=\"type\">Int?</span>  = gradebook[<span class=\"string\">\"grade\"</span>]</span><br></pre></td></tr></table></figure>\n<p>这样就不必写 as 语句把 Any 类型转化了。但是指明类型仍是必不可少的（即<code>:String？</code>不可缺少）。</p>\n<h3 id=\"还有一些其他的小变化\"><a href=\"#还有一些其他的小变化\" class=\"headerlink\" title=\"还有一些其他的小变化\"></a>还有一些其他的小变化</h3><ul>\n<li>extension 中可以访问到 private 成员变量了。</li>\n<li>出于内存安全性的考虑，一个变量不能被当作两个 <code>inout</code> 参数传入同一个函数，这被称为“排他性”（exclusivity）。所以 Swift3 中的 swap 函数在 Swift4 中就非法了：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">swap</span>(&amp;numbers[<span class=\"number\">1</span>], &amp;numbers[<span class=\"number\">3</span>]) <span class=\"comment\">// illegal in Swift4</span></span><br><span class=\"line\"><span class=\"comment\">//numbers 不能被当作两个 inout 参数传入 swap 函数</span></span><br></pre></td></tr></table></figure>\n<p>​    现在可以用：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">numbers.swapAt(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<p>​    更详细的介绍参看<a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0173-swap-indices.md\">这里</a>。</p>\n<ul>\n<li>Swift4 中对 NSNumber 的桥接做了安全性检测：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"type\">NSNumber</span>(value: <span class=\"number\">603</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> v = n <span class=\"keyword\">as</span>? <span class=\"type\">Int8</span></span><br></pre></td></tr></table></figure>\n<p>​    在 Swift3 中，会出现一个不正确的值。而现在会是 nil 了。也可以用 is 语句来判断是否可以转换。</p>\n<ul>\n<li>可以具体指明一个对象既是某个类型，又遵守某个协议了：</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">protocol</span> <span class=\"title\">MySpecialDelegateProtocol</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySpecialView</span>: <span class=\"title\">UIView</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyController</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> delegate: (<span class=\"type\">UIView</span> &amp; <span class=\"type\">MySpecialDelegateProtocol</span>)?</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"还有一些参考资料：\"><a href=\"#还有一些参考资料：\" class=\"headerlink\" title=\"还有一些参考资料：\"></a>还有一些参考资料：</h3><p><a href=\"https://github.com/apple/swift-evolution\">https://github.com/apple/swift-evolution</a></p>\n<p><a href=\"https://developer.apple.com/videos/play/wwdc2017/402/\">https://developer.apple.com/videos/play/wwdc2017/402/</a></p>\n"},{"title":"WiFi监听UDP包","date":"2019-04-22T15:56:33.000Z","_content":"\n# Wi-Fi 监听 UDP 包\n\n最近遇到一个需求，一个被远程控制的小车需要在多个网络中无缝漫游。如果按照我们熟悉的方式，搭建一个 Wi-Fi 网络，小车上的树莓派就可能在网络切换时掉线 1 至 2 秒钟。鉴于小车是被实时远程控制的，我们需要网络切换时间极短，而不同 Wi-Fi 之间的切换速度就不符合要求。\n\n我认为，与其想办法加快在不同网络之间切换的速度，不如干脆不接入任何一个网络了——让树莓派嗅探空气中的所有数据包，并解析出自己需要的包来获取控制信息。不接入网络，自然就不存在基站切换的耗时问题。这相当于在以广播的形式通信。\n\n我也考虑了使用其他的通信方式，比如蓝牙、Zigbee 等，最终还是更加倾向于 Wi-Fi。\n\n## 网络架构\n\n多台树莓派充当 AP，通过 UDP 协议广播数据。小车车载树莓派监听所有数据包，并筛选自己需要的数据。这需要车载树莓派进入 monitor mode。普通的 managed mode 下，网卡会过滤掉目的地址不是自身的包。由于我们不希望小车接入网络，所以在这种模式下就收不到包了。monitor mode 不同于 promiscuous mode（混杂模式），它不需要和 AP 建立连接（太好了）。\n\n## 硬件\n\n不是所有的无线网卡都支持 monitor mode。Raspberry Pi 3 B+ 板载网卡就默认不支持，因此需要额外购买合适的网卡。但社区也提供了支持 monitor mode 的布丁 [nexmon](https://github.com/seemoo-lab/nexmon) 。\n\n## 进入 monitor mode\n\n```\n$ sudo ifconfig <your interface> down\n$ sudo iwconfig <your interface> mode monitor\n$ sudo ifconfig <your interface> up\n$ sudo iwconfig <your interface> channel <your channel number>\n```\n\n这里，需要指定网卡工作的频率。虽然 Wi-Fi 信道有重叠，但最好还是要和路由器的工作频率匹配。比如，我就设置路由器（或者其他作为 AP 的树莓派）的工作信道设置成了 channel 5 。当然，如果许多热点在同时工作，则最好工作在不同的频段防止干扰，再不断切换车载 Wi-Fi 频道。虽然 Wi-Fi 有载波监听、冲突避免等机制，但仍会大幅降低传输效率。\n\nWi-Fi 最好不要设置密码——否则数据包会被加密，如何解包又是一个问题。\n\n如果使用 Wireshark 抓包，则要在 Wireshark 里面也勾选上 monitor mode。\n\n## 捕捉 UDP 数据包\n\n和 Wireshark 一样，我们要使用 libpcap 来抓包。libpcap 有一个 python 的封装 [pcapy](https://github.com/helpsystems/pcapy) ，这样编写 python 代码就更方便了。\n\n```python\n#!/usr/bin/env python\n\nimport sys\nimport pcapy\nimport socket\nfrom struct import *\n\ndef parse_packet(packet):\n    wifi_length = 0x32 //【1】\n\n    if len(packet) < wifi_length:\n        return None\n\n    wifi_protocol = packet[0x30 : wifi_length] \n    \n    wifi_protocol = unpack('!h' , wifi_protocol) //【2】\n    wifi_protocol = wifi_protocol[0]\n    \n    # ip protocol\n    if wifi_protocol == 0x0800:\n        ip_header = packet[wifi_length : 20+wifi_length]\n        iph = unpack('!BBHHHBBH4s4s', ip_header)\n        version_ihl = iph[0]\n        version = version_ihl >> 4\n        ihl = version_ihl & 0xF\n\n\n        iph_length = ihl * 4\n\n        protocol = iph[6]\n        s_addr = socket.inet_ntoa(iph[8])\n        d_addr = socket.inet_ntoa(iph[9])\n\n        #udp\n        if protocol == 17:\n            u = iph_length + wifi_length\n            udph_length = 8\n            udp_header = packet[u : u+8]\n\n            udph = unpack('!HHHH' , udp_header)\n            source_port = udph[0]\n            dest_port = udph[1]\n            length = udph[2]\n            checksum = udph[3]\n\n            h_size = wifi_length + iph_length + udph_length\n            data_size = len(packet) - h_size\n\t\t\t\n\t\t\t\t\t\t#get data from the packet\n            data = packet[h_size:]\n\n            print(\"Data: \") + data\n\n          \npcap = pcapy.open_live(\"wlx000f00906ff3\", 65536, 1, 0) //【3】\n\nwhile (1):\n    (header, packet) = pcap.next()\n    parse_packet(packet)\n```\n\n【1】802.11 协议比较复杂，事实上，在 IP 层外不止封装了一层。通过 Wireshark 捕捉 UDP 包可以看到格式，这里我直接把 IPv4 协议上层封装全作为一层处理了。\n\n【2】`unpack` 函数可以把一个字符串（python 里字符数组亦被用来存储原始二进制数据，毕竟一个 char 正好对应一个字节）按照格式解析，并返回一个元组。最前面的感叹号代表网络字节序。网络字节序是大字节序，和我们  x86 上常见的小字节序相反，要特别小心。从大字节序转换成小字节序可以用 `ntohs` 函数，当然也可以自己反转。\n\n【3】wlx000f00906ff3 是我的网卡 interface 的名字。\n\n## 测试\n\n编写一个 shell 脚本来测试程序是否能抓到 UDP 包：\n\n```shell\nfor i in {1..1000}\ndo \n\techo -n \"hello world!\" | ncat -u 192.168.1.255 8080\ndone\n\n```\n\n使用 ncat 来向广播地址发送简单的 UDP 包。当然这里不一定是广播地址，毕竟什么包都能抓到……\n\n我测试时，主机通过以太网连接无线路由器，主机未接入无线局域网，但是程序可以通过无线网卡抓到包。使用另一台树莓派作为 AP 发送 UDP 包，同样可以抓到。\n\n## Alternate Choice\n\n也可以考虑简历一个虚拟网卡，让小车同时接入两个网络。这样在发生切换时，保证另一个网络仍是畅通的。如果 Wi-Fi 网络不加密，建立连接的速度也会比较快。","source":"_posts/WiFi监听UDP包.md","raw":"---\ntitle: WiFi监听UDP包\ndate: 2019-04-22 23:56:33\ntags: network\n---\n\n# Wi-Fi 监听 UDP 包\n\n最近遇到一个需求，一个被远程控制的小车需要在多个网络中无缝漫游。如果按照我们熟悉的方式，搭建一个 Wi-Fi 网络，小车上的树莓派就可能在网络切换时掉线 1 至 2 秒钟。鉴于小车是被实时远程控制的，我们需要网络切换时间极短，而不同 Wi-Fi 之间的切换速度就不符合要求。\n\n我认为，与其想办法加快在不同网络之间切换的速度，不如干脆不接入任何一个网络了——让树莓派嗅探空气中的所有数据包，并解析出自己需要的包来获取控制信息。不接入网络，自然就不存在基站切换的耗时问题。这相当于在以广播的形式通信。\n\n我也考虑了使用其他的通信方式，比如蓝牙、Zigbee 等，最终还是更加倾向于 Wi-Fi。\n\n## 网络架构\n\n多台树莓派充当 AP，通过 UDP 协议广播数据。小车车载树莓派监听所有数据包，并筛选自己需要的数据。这需要车载树莓派进入 monitor mode。普通的 managed mode 下，网卡会过滤掉目的地址不是自身的包。由于我们不希望小车接入网络，所以在这种模式下就收不到包了。monitor mode 不同于 promiscuous mode（混杂模式），它不需要和 AP 建立连接（太好了）。\n\n## 硬件\n\n不是所有的无线网卡都支持 monitor mode。Raspberry Pi 3 B+ 板载网卡就默认不支持，因此需要额外购买合适的网卡。但社区也提供了支持 monitor mode 的布丁 [nexmon](https://github.com/seemoo-lab/nexmon) 。\n\n## 进入 monitor mode\n\n```\n$ sudo ifconfig <your interface> down\n$ sudo iwconfig <your interface> mode monitor\n$ sudo ifconfig <your interface> up\n$ sudo iwconfig <your interface> channel <your channel number>\n```\n\n这里，需要指定网卡工作的频率。虽然 Wi-Fi 信道有重叠，但最好还是要和路由器的工作频率匹配。比如，我就设置路由器（或者其他作为 AP 的树莓派）的工作信道设置成了 channel 5 。当然，如果许多热点在同时工作，则最好工作在不同的频段防止干扰，再不断切换车载 Wi-Fi 频道。虽然 Wi-Fi 有载波监听、冲突避免等机制，但仍会大幅降低传输效率。\n\nWi-Fi 最好不要设置密码——否则数据包会被加密，如何解包又是一个问题。\n\n如果使用 Wireshark 抓包，则要在 Wireshark 里面也勾选上 monitor mode。\n\n## 捕捉 UDP 数据包\n\n和 Wireshark 一样，我们要使用 libpcap 来抓包。libpcap 有一个 python 的封装 [pcapy](https://github.com/helpsystems/pcapy) ，这样编写 python 代码就更方便了。\n\n```python\n#!/usr/bin/env python\n\nimport sys\nimport pcapy\nimport socket\nfrom struct import *\n\ndef parse_packet(packet):\n    wifi_length = 0x32 //【1】\n\n    if len(packet) < wifi_length:\n        return None\n\n    wifi_protocol = packet[0x30 : wifi_length] \n    \n    wifi_protocol = unpack('!h' , wifi_protocol) //【2】\n    wifi_protocol = wifi_protocol[0]\n    \n    # ip protocol\n    if wifi_protocol == 0x0800:\n        ip_header = packet[wifi_length : 20+wifi_length]\n        iph = unpack('!BBHHHBBH4s4s', ip_header)\n        version_ihl = iph[0]\n        version = version_ihl >> 4\n        ihl = version_ihl & 0xF\n\n\n        iph_length = ihl * 4\n\n        protocol = iph[6]\n        s_addr = socket.inet_ntoa(iph[8])\n        d_addr = socket.inet_ntoa(iph[9])\n\n        #udp\n        if protocol == 17:\n            u = iph_length + wifi_length\n            udph_length = 8\n            udp_header = packet[u : u+8]\n\n            udph = unpack('!HHHH' , udp_header)\n            source_port = udph[0]\n            dest_port = udph[1]\n            length = udph[2]\n            checksum = udph[3]\n\n            h_size = wifi_length + iph_length + udph_length\n            data_size = len(packet) - h_size\n\t\t\t\n\t\t\t\t\t\t#get data from the packet\n            data = packet[h_size:]\n\n            print(\"Data: \") + data\n\n          \npcap = pcapy.open_live(\"wlx000f00906ff3\", 65536, 1, 0) //【3】\n\nwhile (1):\n    (header, packet) = pcap.next()\n    parse_packet(packet)\n```\n\n【1】802.11 协议比较复杂，事实上，在 IP 层外不止封装了一层。通过 Wireshark 捕捉 UDP 包可以看到格式，这里我直接把 IPv4 协议上层封装全作为一层处理了。\n\n【2】`unpack` 函数可以把一个字符串（python 里字符数组亦被用来存储原始二进制数据，毕竟一个 char 正好对应一个字节）按照格式解析，并返回一个元组。最前面的感叹号代表网络字节序。网络字节序是大字节序，和我们  x86 上常见的小字节序相反，要特别小心。从大字节序转换成小字节序可以用 `ntohs` 函数，当然也可以自己反转。\n\n【3】wlx000f00906ff3 是我的网卡 interface 的名字。\n\n## 测试\n\n编写一个 shell 脚本来测试程序是否能抓到 UDP 包：\n\n```shell\nfor i in {1..1000}\ndo \n\techo -n \"hello world!\" | ncat -u 192.168.1.255 8080\ndone\n\n```\n\n使用 ncat 来向广播地址发送简单的 UDP 包。当然这里不一定是广播地址，毕竟什么包都能抓到……\n\n我测试时，主机通过以太网连接无线路由器，主机未接入无线局域网，但是程序可以通过无线网卡抓到包。使用另一台树莓派作为 AP 发送 UDP 包，同样可以抓到。\n\n## Alternate Choice\n\n也可以考虑简历一个虚拟网卡，让小车同时接入两个网络。这样在发生切换时，保证另一个网络仍是畅通的。如果 Wi-Fi 网络不加密，建立连接的速度也会比较快。","slug":"WiFi监听UDP包","published":1,"updated":"2020-01-04T08:16:16.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv33000rljc3p7sanu3t","content":"<h1 id=\"Wi-Fi-监听-UDP-包\"><a href=\"#Wi-Fi-监听-UDP-包\" class=\"headerlink\" title=\"Wi-Fi 监听 UDP 包\"></a>Wi-Fi 监听 UDP 包</h1><p>最近遇到一个需求，一个被远程控制的小车需要在多个网络中无缝漫游。如果按照我们熟悉的方式，搭建一个 Wi-Fi 网络，小车上的树莓派就可能在网络切换时掉线 1 至 2 秒钟。鉴于小车是被实时远程控制的，我们需要网络切换时间极短，而不同 Wi-Fi 之间的切换速度就不符合要求。</p>\n<p>我认为，与其想办法加快在不同网络之间切换的速度，不如干脆不接入任何一个网络了——让树莓派嗅探空气中的所有数据包，并解析出自己需要的包来获取控制信息。不接入网络，自然就不存在基站切换的耗时问题。这相当于在以广播的形式通信。</p>\n<p>我也考虑了使用其他的通信方式，比如蓝牙、Zigbee 等，最终还是更加倾向于 Wi-Fi。</p>\n<h2 id=\"网络架构\"><a href=\"#网络架构\" class=\"headerlink\" title=\"网络架构\"></a>网络架构</h2><p>多台树莓派充当 AP，通过 UDP 协议广播数据。小车车载树莓派监听所有数据包，并筛选自己需要的数据。这需要车载树莓派进入 monitor mode。普通的 managed mode 下，网卡会过滤掉目的地址不是自身的包。由于我们不希望小车接入网络，所以在这种模式下就收不到包了。monitor mode 不同于 promiscuous mode（混杂模式），它不需要和 AP 建立连接（太好了）。</p>\n<h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><p>不是所有的无线网卡都支持 monitor mode。Raspberry Pi 3 B+ 板载网卡就默认不支持，因此需要额外购买合适的网卡。但社区也提供了支持 monitor mode 的布丁 <a href=\"https://github.com/seemoo-lab/nexmon\">nexmon</a> 。</p>\n<h2 id=\"进入-monitor-mode\"><a href=\"#进入-monitor-mode\" class=\"headerlink\" title=\"进入 monitor mode\"></a>进入 monitor mode</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo ifconfig &lt;your interface&gt; down</span><br><span class=\"line\">$ sudo iwconfig &lt;your interface&gt; mode monitor</span><br><span class=\"line\">$ sudo ifconfig &lt;your interface&gt; up</span><br><span class=\"line\">$ sudo iwconfig &lt;your interface&gt; channel &lt;your channel number&gt;</span><br></pre></td></tr></table></figure>\n<p>这里，需要指定网卡工作的频率。虽然 Wi-Fi 信道有重叠，但最好还是要和路由器的工作频率匹配。比如，我就设置路由器（或者其他作为 AP 的树莓派）的工作信道设置成了 channel 5 。当然，如果许多热点在同时工作，则最好工作在不同的频段防止干扰，再不断切换车载 Wi-Fi 频道。虽然 Wi-Fi 有载波监听、冲突避免等机制，但仍会大幅降低传输效率。</p>\n<p>Wi-Fi 最好不要设置密码——否则数据包会被加密，如何解包又是一个问题。</p>\n<p>如果使用 Wireshark 抓包，则要在 Wireshark 里面也勾选上 monitor mode。</p>\n<h2 id=\"捕捉-UDP-数据包\"><a href=\"#捕捉-UDP-数据包\" class=\"headerlink\" title=\"捕捉 UDP 数据包\"></a>捕捉 UDP 数据包</h2><p>和 Wireshark 一样，我们要使用 libpcap 来抓包。libpcap 有一个 python 的封装 <a href=\"https://github.com/helpsystems/pcapy\">pcapy</a> ，这样编写 python 代码就更方便了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> pcapy</span><br><span class=\"line\"><span class=\"keyword\">import</span> socket</span><br><span class=\"line\"><span class=\"keyword\">from</span> struct <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_packet</span><span class=\"params\">(packet)</span>:</span></span><br><span class=\"line\">    wifi_length = <span class=\"number\">0x32</span> //【<span class=\"number\">1</span>】</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(packet) &lt; wifi_length:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    wifi_protocol = packet[<span class=\"number\">0x30</span> : wifi_length] </span><br><span class=\"line\">    </span><br><span class=\"line\">    wifi_protocol = unpack(<span class=\"string\">'!h'</span> , wifi_protocol) //【<span class=\"number\">2</span>】</span><br><span class=\"line\">    wifi_protocol = wifi_protocol[<span class=\"number\">0</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># ip protocol</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> wifi_protocol == <span class=\"number\">0x0800</span>:</span><br><span class=\"line\">        ip_header = packet[wifi_length : <span class=\"number\">20</span>+wifi_length]</span><br><span class=\"line\">        iph = unpack(<span class=\"string\">'!BBHHHBBH4s4s'</span>, ip_header)</span><br><span class=\"line\">        version_ihl = iph[<span class=\"number\">0</span>]</span><br><span class=\"line\">        version = version_ihl &gt;&gt; <span class=\"number\">4</span></span><br><span class=\"line\">        ihl = version_ihl &amp; <span class=\"number\">0xF</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        iph_length = ihl * <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\">        protocol = iph[<span class=\"number\">6</span>]</span><br><span class=\"line\">        s_addr = socket.inet_ntoa(iph[<span class=\"number\">8</span>])</span><br><span class=\"line\">        d_addr = socket.inet_ntoa(iph[<span class=\"number\">9</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#udp</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> protocol == <span class=\"number\">17</span>:</span><br><span class=\"line\">            u = iph_length + wifi_length</span><br><span class=\"line\">            udph_length = <span class=\"number\">8</span></span><br><span class=\"line\">            udp_header = packet[u : u+<span class=\"number\">8</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">            udph = unpack(<span class=\"string\">'!HHHH'</span> , udp_header)</span><br><span class=\"line\">            source_port = udph[<span class=\"number\">0</span>]</span><br><span class=\"line\">            dest_port = udph[<span class=\"number\">1</span>]</span><br><span class=\"line\">            length = udph[<span class=\"number\">2</span>]</span><br><span class=\"line\">            checksum = udph[<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">            h_size = wifi_length + iph_length + udph_length</span><br><span class=\"line\">            data_size = len(packet) - h_size</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">#get data from the packet</span></span><br><span class=\"line\">            data = packet[h_size:]</span><br><span class=\"line\"></span><br><span class=\"line\">            print(<span class=\"string\">\"Data: \"</span>) + data</span><br><span class=\"line\"></span><br><span class=\"line\">          </span><br><span class=\"line\">pcap = pcapy.open_live(<span class=\"string\">\"wlx000f00906ff3\"</span>, <span class=\"number\">65536</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>) //【<span class=\"number\">3</span>】</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"number\">1</span>):</span><br><span class=\"line\">    (header, packet) = pcap.next()</span><br><span class=\"line\">    parse_packet(packet)</span><br></pre></td></tr></table></figure>\n<p>【1】802.11 协议比较复杂，事实上，在 IP 层外不止封装了一层。通过 Wireshark 捕捉 UDP 包可以看到格式，这里我直接把 IPv4 协议上层封装全作为一层处理了。</p>\n<p>【2】<code>unpack</code> 函数可以把一个字符串（python 里字符数组亦被用来存储原始二进制数据，毕竟一个 char 正好对应一个字节）按照格式解析，并返回一个元组。最前面的感叹号代表网络字节序。网络字节序是大字节序，和我们  x86 上常见的小字节序相反，要特别小心。从大字节序转换成小字节序可以用 <code>ntohs</code> 函数，当然也可以自己反转。</p>\n<p>【3】wlx000f00906ff3 是我的网卡 interface 的名字。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>编写一个 shell 脚本来测试程序是否能抓到 UDP 包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in &#123;1..1000&#125;</span><br><span class=\"line\">do </span><br><span class=\"line\">\techo -n \"hello world!\" | ncat -u 192.168.1.255 8080</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>使用 ncat 来向广播地址发送简单的 UDP 包。当然这里不一定是广播地址，毕竟什么包都能抓到……</p>\n<p>我测试时，主机通过以太网连接无线路由器，主机未接入无线局域网，但是程序可以通过无线网卡抓到包。使用另一台树莓派作为 AP 发送 UDP 包，同样可以抓到。</p>\n<h2 id=\"Alternate-Choice\"><a href=\"#Alternate-Choice\" class=\"headerlink\" title=\"Alternate Choice\"></a>Alternate Choice</h2><p>也可以考虑简历一个虚拟网卡，让小车同时接入两个网络。这样在发生切换时，保证另一个网络仍是畅通的。如果 Wi-Fi 网络不加密，建立连接的速度也会比较快。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Wi-Fi-监听-UDP-包\"><a href=\"#Wi-Fi-监听-UDP-包\" class=\"headerlink\" title=\"Wi-Fi 监听 UDP 包\"></a>Wi-Fi 监听 UDP 包</h1><p>最近遇到一个需求，一个被远程控制的小车需要在多个网络中无缝漫游。如果按照我们熟悉的方式，搭建一个 Wi-Fi 网络，小车上的树莓派就可能在网络切换时掉线 1 至 2 秒钟。鉴于小车是被实时远程控制的，我们需要网络切换时间极短，而不同 Wi-Fi 之间的切换速度就不符合要求。</p>\n<p>我认为，与其想办法加快在不同网络之间切换的速度，不如干脆不接入任何一个网络了——让树莓派嗅探空气中的所有数据包，并解析出自己需要的包来获取控制信息。不接入网络，自然就不存在基站切换的耗时问题。这相当于在以广播的形式通信。</p>\n<p>我也考虑了使用其他的通信方式，比如蓝牙、Zigbee 等，最终还是更加倾向于 Wi-Fi。</p>\n<h2 id=\"网络架构\"><a href=\"#网络架构\" class=\"headerlink\" title=\"网络架构\"></a>网络架构</h2><p>多台树莓派充当 AP，通过 UDP 协议广播数据。小车车载树莓派监听所有数据包，并筛选自己需要的数据。这需要车载树莓派进入 monitor mode。普通的 managed mode 下，网卡会过滤掉目的地址不是自身的包。由于我们不希望小车接入网络，所以在这种模式下就收不到包了。monitor mode 不同于 promiscuous mode（混杂模式），它不需要和 AP 建立连接（太好了）。</p>\n<h2 id=\"硬件\"><a href=\"#硬件\" class=\"headerlink\" title=\"硬件\"></a>硬件</h2><p>不是所有的无线网卡都支持 monitor mode。Raspberry Pi 3 B+ 板载网卡就默认不支持，因此需要额外购买合适的网卡。但社区也提供了支持 monitor mode 的布丁 <a href=\"https://github.com/seemoo-lab/nexmon\">nexmon</a> 。</p>\n<h2 id=\"进入-monitor-mode\"><a href=\"#进入-monitor-mode\" class=\"headerlink\" title=\"进入 monitor mode\"></a>进入 monitor mode</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo ifconfig &lt;your interface&gt; down</span><br><span class=\"line\">$ sudo iwconfig &lt;your interface&gt; mode monitor</span><br><span class=\"line\">$ sudo ifconfig &lt;your interface&gt; up</span><br><span class=\"line\">$ sudo iwconfig &lt;your interface&gt; channel &lt;your channel number&gt;</span><br></pre></td></tr></table></figure>\n<p>这里，需要指定网卡工作的频率。虽然 Wi-Fi 信道有重叠，但最好还是要和路由器的工作频率匹配。比如，我就设置路由器（或者其他作为 AP 的树莓派）的工作信道设置成了 channel 5 。当然，如果许多热点在同时工作，则最好工作在不同的频段防止干扰，再不断切换车载 Wi-Fi 频道。虽然 Wi-Fi 有载波监听、冲突避免等机制，但仍会大幅降低传输效率。</p>\n<p>Wi-Fi 最好不要设置密码——否则数据包会被加密，如何解包又是一个问题。</p>\n<p>如果使用 Wireshark 抓包，则要在 Wireshark 里面也勾选上 monitor mode。</p>\n<h2 id=\"捕捉-UDP-数据包\"><a href=\"#捕捉-UDP-数据包\" class=\"headerlink\" title=\"捕捉 UDP 数据包\"></a>捕捉 UDP 数据包</h2><p>和 Wireshark 一样，我们要使用 libpcap 来抓包。libpcap 有一个 python 的封装 <a href=\"https://github.com/helpsystems/pcapy\">pcapy</a> ，这样编写 python 代码就更方便了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> pcapy</span><br><span class=\"line\"><span class=\"keyword\">import</span> socket</span><br><span class=\"line\"><span class=\"keyword\">from</span> struct <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">parse_packet</span><span class=\"params\">(packet)</span>:</span></span><br><span class=\"line\">    wifi_length = <span class=\"number\">0x32</span> //【<span class=\"number\">1</span>】</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(packet) &lt; wifi_length:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    wifi_protocol = packet[<span class=\"number\">0x30</span> : wifi_length] </span><br><span class=\"line\">    </span><br><span class=\"line\">    wifi_protocol = unpack(<span class=\"string\">'!h'</span> , wifi_protocol) //【<span class=\"number\">2</span>】</span><br><span class=\"line\">    wifi_protocol = wifi_protocol[<span class=\"number\">0</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># ip protocol</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> wifi_protocol == <span class=\"number\">0x0800</span>:</span><br><span class=\"line\">        ip_header = packet[wifi_length : <span class=\"number\">20</span>+wifi_length]</span><br><span class=\"line\">        iph = unpack(<span class=\"string\">'!BBHHHBBH4s4s'</span>, ip_header)</span><br><span class=\"line\">        version_ihl = iph[<span class=\"number\">0</span>]</span><br><span class=\"line\">        version = version_ihl &gt;&gt; <span class=\"number\">4</span></span><br><span class=\"line\">        ihl = version_ihl &amp; <span class=\"number\">0xF</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        iph_length = ihl * <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\">        protocol = iph[<span class=\"number\">6</span>]</span><br><span class=\"line\">        s_addr = socket.inet_ntoa(iph[<span class=\"number\">8</span>])</span><br><span class=\"line\">        d_addr = socket.inet_ntoa(iph[<span class=\"number\">9</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#udp</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> protocol == <span class=\"number\">17</span>:</span><br><span class=\"line\">            u = iph_length + wifi_length</span><br><span class=\"line\">            udph_length = <span class=\"number\">8</span></span><br><span class=\"line\">            udp_header = packet[u : u+<span class=\"number\">8</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">            udph = unpack(<span class=\"string\">'!HHHH'</span> , udp_header)</span><br><span class=\"line\">            source_port = udph[<span class=\"number\">0</span>]</span><br><span class=\"line\">            dest_port = udph[<span class=\"number\">1</span>]</span><br><span class=\"line\">            length = udph[<span class=\"number\">2</span>]</span><br><span class=\"line\">            checksum = udph[<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">            h_size = wifi_length + iph_length + udph_length</span><br><span class=\"line\">            data_size = len(packet) - h_size</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"comment\">#get data from the packet</span></span><br><span class=\"line\">            data = packet[h_size:]</span><br><span class=\"line\"></span><br><span class=\"line\">            print(<span class=\"string\">\"Data: \"</span>) + data</span><br><span class=\"line\"></span><br><span class=\"line\">          </span><br><span class=\"line\">pcap = pcapy.open_live(<span class=\"string\">\"wlx000f00906ff3\"</span>, <span class=\"number\">65536</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>) //【<span class=\"number\">3</span>】</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"number\">1</span>):</span><br><span class=\"line\">    (header, packet) = pcap.next()</span><br><span class=\"line\">    parse_packet(packet)</span><br></pre></td></tr></table></figure>\n<p>【1】802.11 协议比较复杂，事实上，在 IP 层外不止封装了一层。通过 Wireshark 捕捉 UDP 包可以看到格式，这里我直接把 IPv4 协议上层封装全作为一层处理了。</p>\n<p>【2】<code>unpack</code> 函数可以把一个字符串（python 里字符数组亦被用来存储原始二进制数据，毕竟一个 char 正好对应一个字节）按照格式解析，并返回一个元组。最前面的感叹号代表网络字节序。网络字节序是大字节序，和我们  x86 上常见的小字节序相反，要特别小心。从大字节序转换成小字节序可以用 <code>ntohs</code> 函数，当然也可以自己反转。</p>\n<p>【3】wlx000f00906ff3 是我的网卡 interface 的名字。</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>编写一个 shell 脚本来测试程序是否能抓到 UDP 包：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i in &#123;1..1000&#125;</span><br><span class=\"line\">do </span><br><span class=\"line\">\techo -n \"hello world!\" | ncat -u 192.168.1.255 8080</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure>\n<p>使用 ncat 来向广播地址发送简单的 UDP 包。当然这里不一定是广播地址，毕竟什么包都能抓到……</p>\n<p>我测试时，主机通过以太网连接无线路由器，主机未接入无线局域网，但是程序可以通过无线网卡抓到包。使用另一台树莓派作为 AP 发送 UDP 包，同样可以抓到。</p>\n<h2 id=\"Alternate-Choice\"><a href=\"#Alternate-Choice\" class=\"headerlink\" title=\"Alternate Choice\"></a>Alternate Choice</h2><p>也可以考虑简历一个虚拟网卡，让小车同时接入两个网络。这样在发生切换时，保证另一个网络仍是畅通的。如果 Wi-Fi 网络不加密，建立连接的速度也会比较快。</p>\n"},{"title":"V-REP实现Bubble Rebound算法","date":"2018-11-09T16:51:52.000Z","_content":"\n# V-REP 实现 Bubble Rebound 算法\n\n[V-REP](http://www.coppeliarobotics.com) 是一款较为易用的机器人仿真软件。它拥有 4 个不同的物理引擎，可以较好地进行动力学仿真。\n\n首先，参考官方教程建立 bubbleRob 机器人模型。为了方便实现 Bubble Rebound 算法，还要添加几个额外的接近传感器。\n\n![bb1](/img/bubble_rebound/bb1.png)\n\n模型建立好了之后，就可以开始着手实现 Bubble Rebound 避障算法了。Bubble Rebound 是一个很简单的避障算法，该论文可以在 [IEEE Xplore](https://ieeexplore.ieee.org/document/5524302) 上找到。简单来说，首先对距离传感器进行编号。以上图为例，最左边的传感器为 3 号，向右依次为 2，1，-1，-2，-3 。论文的插图给出了一侧四个传感器的例子：\n\n![bb2](/img/bubble_rebound/bb2.png)\n\n之后，根据文章中给出的公式可以计算出机器人应该旋转的角度。大体思路是，如果左边有障碍物，那么正数部分就会因为距离较小而较小，从而计算得到一个负数的角度。在机器人 z 轴向上的情况下，旋转一个负数的角度即转向没有障碍物的右侧。\n\n但是在 V-REP 中使用内建的 Lua 脚本控制机器人旋转某个角度的实现中，有一点需要注意。旋转某个角度的思路大概如下：在一个循环中，给机器人的两个轮子施加不同的速度，不断对比当前的转角与目标转角，直至达到目标。需要注意的是，如果新建的是非多线程脚本，那么这个循环就会阻塞住仿真线程。仿真过程被阻塞住，也就无法让机器人旋转；机器人不旋转，我们的循环就无法退出，从而造成机器人不转、仿真不进行的尴尬局面。\n\n为了解决这个问题，就要使用多线程脚本。同时，也可以调用 `sim.switchThread()` 提前切换线程来得到更好的性能。进一步地说，Lua 本身并不是使用的多线程来进行的并行操作，而是使用了协程（coroutine）。多个协程在同一个线程中，可在子程序内部中断，去执行其他子程序，再返回，而不是函数调用（函数调用也可以算作协程的一种特殊状态）。因为是在同一个线程中，且由程序自身控制切换（线程、进程的切换由调度器来进行，程序员干预较少），因此效率非常高，没有线程转换的开销；不需要担心资源抢占，无需锁机制。多个子程序协作完成任务（而非抢占），故称为协程（co-routine）。\n\n完整代码可参见我的 GitHub。","source":"_posts/V-REP实现Bubble-Rebound算法.md","raw":"---\ntitle: V-REP实现Bubble Rebound算法\ndate: 2018-11-10 00:51:52\ntags: Robotics\n---\n\n# V-REP 实现 Bubble Rebound 算法\n\n[V-REP](http://www.coppeliarobotics.com) 是一款较为易用的机器人仿真软件。它拥有 4 个不同的物理引擎，可以较好地进行动力学仿真。\n\n首先，参考官方教程建立 bubbleRob 机器人模型。为了方便实现 Bubble Rebound 算法，还要添加几个额外的接近传感器。\n\n![bb1](/img/bubble_rebound/bb1.png)\n\n模型建立好了之后，就可以开始着手实现 Bubble Rebound 避障算法了。Bubble Rebound 是一个很简单的避障算法，该论文可以在 [IEEE Xplore](https://ieeexplore.ieee.org/document/5524302) 上找到。简单来说，首先对距离传感器进行编号。以上图为例，最左边的传感器为 3 号，向右依次为 2，1，-1，-2，-3 。论文的插图给出了一侧四个传感器的例子：\n\n![bb2](/img/bubble_rebound/bb2.png)\n\n之后，根据文章中给出的公式可以计算出机器人应该旋转的角度。大体思路是，如果左边有障碍物，那么正数部分就会因为距离较小而较小，从而计算得到一个负数的角度。在机器人 z 轴向上的情况下，旋转一个负数的角度即转向没有障碍物的右侧。\n\n但是在 V-REP 中使用内建的 Lua 脚本控制机器人旋转某个角度的实现中，有一点需要注意。旋转某个角度的思路大概如下：在一个循环中，给机器人的两个轮子施加不同的速度，不断对比当前的转角与目标转角，直至达到目标。需要注意的是，如果新建的是非多线程脚本，那么这个循环就会阻塞住仿真线程。仿真过程被阻塞住，也就无法让机器人旋转；机器人不旋转，我们的循环就无法退出，从而造成机器人不转、仿真不进行的尴尬局面。\n\n为了解决这个问题，就要使用多线程脚本。同时，也可以调用 `sim.switchThread()` 提前切换线程来得到更好的性能。进一步地说，Lua 本身并不是使用的多线程来进行的并行操作，而是使用了协程（coroutine）。多个协程在同一个线程中，可在子程序内部中断，去执行其他子程序，再返回，而不是函数调用（函数调用也可以算作协程的一种特殊状态）。因为是在同一个线程中，且由程序自身控制切换（线程、进程的切换由调度器来进行，程序员干预较少），因此效率非常高，没有线程转换的开销；不需要担心资源抢占，无需锁机制。多个子程序协作完成任务（而非抢占），故称为协程（co-routine）。\n\n完整代码可参见我的 GitHub。","slug":"V-REP实现Bubble-Rebound算法","published":1,"updated":"2020-01-04T08:16:16.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv34000sljc3m3whcwgb","content":"<h1 id=\"V-REP-实现-Bubble-Rebound-算法\"><a href=\"#V-REP-实现-Bubble-Rebound-算法\" class=\"headerlink\" title=\"V-REP 实现 Bubble Rebound 算法\"></a>V-REP 实现 Bubble Rebound 算法</h1><p><a href=\"http://www.coppeliarobotics.com\">V-REP</a> 是一款较为易用的机器人仿真软件。它拥有 4 个不同的物理引擎，可以较好地进行动力学仿真。</p>\n<p>首先，参考官方教程建立 bubbleRob 机器人模型。为了方便实现 Bubble Rebound 算法，还要添加几个额外的接近传感器。</p>\n<p><img src=\"/img/bubble_rebound/bb1.png\" alt=\"bb1\"></p>\n<p>模型建立好了之后，就可以开始着手实现 Bubble Rebound 避障算法了。Bubble Rebound 是一个很简单的避障算法，该论文可以在 <a href=\"https://ieeexplore.ieee.org/document/5524302\">IEEE Xplore</a> 上找到。简单来说，首先对距离传感器进行编号。以上图为例，最左边的传感器为 3 号，向右依次为 2，1，-1，-2，-3 。论文的插图给出了一侧四个传感器的例子：</p>\n<p><img src=\"/img/bubble_rebound/bb2.png\" alt=\"bb2\"></p>\n<p>之后，根据文章中给出的公式可以计算出机器人应该旋转的角度。大体思路是，如果左边有障碍物，那么正数部分就会因为距离较小而较小，从而计算得到一个负数的角度。在机器人 z 轴向上的情况下，旋转一个负数的角度即转向没有障碍物的右侧。</p>\n<p>但是在 V-REP 中使用内建的 Lua 脚本控制机器人旋转某个角度的实现中，有一点需要注意。旋转某个角度的思路大概如下：在一个循环中，给机器人的两个轮子施加不同的速度，不断对比当前的转角与目标转角，直至达到目标。需要注意的是，如果新建的是非多线程脚本，那么这个循环就会阻塞住仿真线程。仿真过程被阻塞住，也就无法让机器人旋转；机器人不旋转，我们的循环就无法退出，从而造成机器人不转、仿真不进行的尴尬局面。</p>\n<p>为了解决这个问题，就要使用多线程脚本。同时，也可以调用 <code>sim.switchThread()</code> 提前切换线程来得到更好的性能。进一步地说，Lua 本身并不是使用的多线程来进行的并行操作，而是使用了协程（coroutine）。多个协程在同一个线程中，可在子程序内部中断，去执行其他子程序，再返回，而不是函数调用（函数调用也可以算作协程的一种特殊状态）。因为是在同一个线程中，且由程序自身控制切换（线程、进程的切换由调度器来进行，程序员干预较少），因此效率非常高，没有线程转换的开销；不需要担心资源抢占，无需锁机制。多个子程序协作完成任务（而非抢占），故称为协程（co-routine）。</p>\n<p>完整代码可参见我的 GitHub。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"V-REP-实现-Bubble-Rebound-算法\"><a href=\"#V-REP-实现-Bubble-Rebound-算法\" class=\"headerlink\" title=\"V-REP 实现 Bubble Rebound 算法\"></a>V-REP 实现 Bubble Rebound 算法</h1><p><a href=\"http://www.coppeliarobotics.com\">V-REP</a> 是一款较为易用的机器人仿真软件。它拥有 4 个不同的物理引擎，可以较好地进行动力学仿真。</p>\n<p>首先，参考官方教程建立 bubbleRob 机器人模型。为了方便实现 Bubble Rebound 算法，还要添加几个额外的接近传感器。</p>\n<p><img src=\"/img/bubble_rebound/bb1.png\" alt=\"bb1\"></p>\n<p>模型建立好了之后，就可以开始着手实现 Bubble Rebound 避障算法了。Bubble Rebound 是一个很简单的避障算法，该论文可以在 <a href=\"https://ieeexplore.ieee.org/document/5524302\">IEEE Xplore</a> 上找到。简单来说，首先对距离传感器进行编号。以上图为例，最左边的传感器为 3 号，向右依次为 2，1，-1，-2，-3 。论文的插图给出了一侧四个传感器的例子：</p>\n<p><img src=\"/img/bubble_rebound/bb2.png\" alt=\"bb2\"></p>\n<p>之后，根据文章中给出的公式可以计算出机器人应该旋转的角度。大体思路是，如果左边有障碍物，那么正数部分就会因为距离较小而较小，从而计算得到一个负数的角度。在机器人 z 轴向上的情况下，旋转一个负数的角度即转向没有障碍物的右侧。</p>\n<p>但是在 V-REP 中使用内建的 Lua 脚本控制机器人旋转某个角度的实现中，有一点需要注意。旋转某个角度的思路大概如下：在一个循环中，给机器人的两个轮子施加不同的速度，不断对比当前的转角与目标转角，直至达到目标。需要注意的是，如果新建的是非多线程脚本，那么这个循环就会阻塞住仿真线程。仿真过程被阻塞住，也就无法让机器人旋转；机器人不旋转，我们的循环就无法退出，从而造成机器人不转、仿真不进行的尴尬局面。</p>\n<p>为了解决这个问题，就要使用多线程脚本。同时，也可以调用 <code>sim.switchThread()</code> 提前切换线程来得到更好的性能。进一步地说，Lua 本身并不是使用的多线程来进行的并行操作，而是使用了协程（coroutine）。多个协程在同一个线程中，可在子程序内部中断，去执行其他子程序，再返回，而不是函数调用（函数调用也可以算作协程的一种特殊状态）。因为是在同一个线程中，且由程序自身控制切换（线程、进程的切换由调度器来进行，程序员干预较少），因此效率非常高，没有线程转换的开销；不需要担心资源抢占，无需锁机制。多个子程序协作完成任务（而非抢占），故称为协程（co-routine）。</p>\n<p>完整代码可参见我的 GitHub。</p>\n"},{"title":"Swift集成友盟数据统计","date":"2017-12-23T12:04:36.000Z","_content":"\n# Swift 集成友盟数据统计\n\n[友盟](umeng.com)是比较有名的数据统计服务提供商，但其 SDK 是用 OC 写的，开发文档中暂时也没有给出 Swift 的接入教程。不过其实用 Swift 集成友盟还是非常简单的。\n\n### 获取 App Key\n\n注册友盟账号，在 U-App 中创建新应用，就可以获取到 App Key 了。\n\n### 安装 SDK\n\n虽然目前在 iOS 的文档中没有写明，但友盟已经支持使用 CocoaPods 进行安装了。在 Podfile 里添加：\n\n```swift\npod 'UMengAnalytics'\n```\n\n或\n\n```swift\npod 'UMengAnalytics-NO-IDFA'\n```\n\n上面的是标准 SDK，下面的是无 IDFA 版本的。IDFA 是苹果的广告标识符，用于保护用户隐私的同时让商家可以最终广告效果。友盟使用 IDFA 是为了防止今后苹果可能会禁用 open-UDID 而造成数据异常。不过苹果禁止没有广告而获取 IDFA 的应用上架，因此审核期间可能会有风险。这里我选择了不采集 IDFA 的版本。\n\n### 构建桥接文件\n\n由于友盟的 SDK 是用 OC 编写的，因此在 Swift 项目中需要桥接文件来完成混编。好在 Swift 调用 OC 是非常方便的。\n\n1. `Command + N` 呼出新建文件窗口，选择 `Header File`，命名为 `YourAppName-Bridging-Header.h`。（如果你已经引用过 OC 的代码，无视这一步）\n2. 在其中插入你需要的组件的头文件，如 `#import \"UMMobClick/MobClick.h\" `。\n3. 在工程的 Build Settings 中，找到 Swift Compiler - General （如果没有，记得勾选上方的 All，或者直接搜索）。在 Objective-C Bridging Header 项填入刚刚桥接文件的路径。也可以双击该项使它处于可编辑状态，把文件直接从文件树中拖过来，就会自动填充路径。\n\n### 开始使用\n\n桥接文件构建完成，就可以按照官方文档用 Swift 调用友盟的 api 了。在 `AppDelegate.swift`中，找到 `application(_:didFinishLaunchingWithOptions:)` 函数，开始配置。\n\n```swift\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { \n    let UMConfig = UMAnalyticsConfig()\n    UMConfig.appKey = \"Your App Key\"\n    UMConfig.channelId = \"App Store\"\n    MobClick.start(withConfigure: UMConfig)\n    return true\n}\n```\n\n现在，在真机或模拟器中启动程序，如果你在友盟的统计页面中看到相应的信息，就说明已经配置成功了！\n\n如果不想污染数据，可以使用友盟的集成调试功能。具体的内容可以参考开发文档。","source":"_posts/Swift集成友盟数据统计.md","raw":"---\ntitle: Swift集成友盟数据统计\ndate: 2017-12-23 20:04:36\ntags:\n---\n\n# Swift 集成友盟数据统计\n\n[友盟](umeng.com)是比较有名的数据统计服务提供商，但其 SDK 是用 OC 写的，开发文档中暂时也没有给出 Swift 的接入教程。不过其实用 Swift 集成友盟还是非常简单的。\n\n### 获取 App Key\n\n注册友盟账号，在 U-App 中创建新应用，就可以获取到 App Key 了。\n\n### 安装 SDK\n\n虽然目前在 iOS 的文档中没有写明，但友盟已经支持使用 CocoaPods 进行安装了。在 Podfile 里添加：\n\n```swift\npod 'UMengAnalytics'\n```\n\n或\n\n```swift\npod 'UMengAnalytics-NO-IDFA'\n```\n\n上面的是标准 SDK，下面的是无 IDFA 版本的。IDFA 是苹果的广告标识符，用于保护用户隐私的同时让商家可以最终广告效果。友盟使用 IDFA 是为了防止今后苹果可能会禁用 open-UDID 而造成数据异常。不过苹果禁止没有广告而获取 IDFA 的应用上架，因此审核期间可能会有风险。这里我选择了不采集 IDFA 的版本。\n\n### 构建桥接文件\n\n由于友盟的 SDK 是用 OC 编写的，因此在 Swift 项目中需要桥接文件来完成混编。好在 Swift 调用 OC 是非常方便的。\n\n1. `Command + N` 呼出新建文件窗口，选择 `Header File`，命名为 `YourAppName-Bridging-Header.h`。（如果你已经引用过 OC 的代码，无视这一步）\n2. 在其中插入你需要的组件的头文件，如 `#import \"UMMobClick/MobClick.h\" `。\n3. 在工程的 Build Settings 中，找到 Swift Compiler - General （如果没有，记得勾选上方的 All，或者直接搜索）。在 Objective-C Bridging Header 项填入刚刚桥接文件的路径。也可以双击该项使它处于可编辑状态，把文件直接从文件树中拖过来，就会自动填充路径。\n\n### 开始使用\n\n桥接文件构建完成，就可以按照官方文档用 Swift 调用友盟的 api 了。在 `AppDelegate.swift`中，找到 `application(_:didFinishLaunchingWithOptions:)` 函数，开始配置。\n\n```swift\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -> Bool { \n    let UMConfig = UMAnalyticsConfig()\n    UMConfig.appKey = \"Your App Key\"\n    UMConfig.channelId = \"App Store\"\n    MobClick.start(withConfigure: UMConfig)\n    return true\n}\n```\n\n现在，在真机或模拟器中启动程序，如果你在友盟的统计页面中看到相应的信息，就说明已经配置成功了！\n\n如果不想污染数据，可以使用友盟的集成调试功能。具体的内容可以参考开发文档。","slug":"Swift集成友盟数据统计","published":1,"updated":"2020-01-04T08:16:16.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv35000uljc34k8q1f6z","content":"<h1 id=\"Swift-集成友盟数据统计\"><a href=\"#Swift-集成友盟数据统计\" class=\"headerlink\" title=\"Swift 集成友盟数据统计\"></a>Swift 集成友盟数据统计</h1><p><a href=\"umeng.com\">友盟</a>是比较有名的数据统计服务提供商，但其 SDK 是用 OC 写的，开发文档中暂时也没有给出 Swift 的接入教程。不过其实用 Swift 集成友盟还是非常简单的。</p>\n<h3 id=\"获取-App-Key\"><a href=\"#获取-App-Key\" class=\"headerlink\" title=\"获取 App Key\"></a>获取 App Key</h3><p>注册友盟账号，在 U-App 中创建新应用，就可以获取到 App Key 了。</p>\n<h3 id=\"安装-SDK\"><a href=\"#安装-SDK\" class=\"headerlink\" title=\"安装 SDK\"></a>安装 SDK</h3><p>虽然目前在 iOS 的文档中没有写明，但友盟已经支持使用 CocoaPods 进行安装了。在 Podfile 里添加：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod '<span class=\"type\">UMengAnalytics'</span></span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod '<span class=\"type\">UMengAnalytics</span>-<span class=\"type\">NO</span>-<span class=\"type\">IDFA'</span></span><br></pre></td></tr></table></figure>\n<p>上面的是标准 SDK，下面的是无 IDFA 版本的。IDFA 是苹果的广告标识符，用于保护用户隐私的同时让商家可以最终广告效果。友盟使用 IDFA 是为了防止今后苹果可能会禁用 open-UDID 而造成数据异常。不过苹果禁止没有广告而获取 IDFA 的应用上架，因此审核期间可能会有风险。这里我选择了不采集 IDFA 的版本。</p>\n<h3 id=\"构建桥接文件\"><a href=\"#构建桥接文件\" class=\"headerlink\" title=\"构建桥接文件\"></a>构建桥接文件</h3><p>由于友盟的 SDK 是用 OC 编写的，因此在 Swift 项目中需要桥接文件来完成混编。好在 Swift 调用 OC 是非常方便的。</p>\n<ol>\n<li><code>Command + N</code> 呼出新建文件窗口，选择 <code>Header File</code>，命名为 <code>YourAppName-Bridging-Header.h</code>。（如果你已经引用过 OC 的代码，无视这一步）</li>\n<li>在其中插入你需要的组件的头文件，如 <code>#import &quot;UMMobClick/MobClick.h&quot;</code>。</li>\n<li>在工程的 Build Settings 中，找到 Swift Compiler - General （如果没有，记得勾选上方的 All，或者直接搜索）。在 Objective-C Bridging Header 项填入刚刚桥接文件的路径。也可以双击该项使它处于可编辑状态，把文件直接从文件树中拖过来，就会自动填充路径。</li>\n</ol>\n<h3 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h3><p>桥接文件构建完成，就可以按照官方文档用 Swift 调用友盟的 api 了。在 <code>AppDelegate.swift</code>中，找到 <code>application(_:didFinishLaunchingWithOptions:)</code> 函数，开始配置。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class=\"keyword\">Any</span>]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"type\">UMConfig</span> = <span class=\"type\">UMAnalyticsConfig</span>()</span><br><span class=\"line\">    <span class=\"type\">UMConfig</span>.appKey = <span class=\"string\">\"Your App Key\"</span></span><br><span class=\"line\">    <span class=\"type\">UMConfig</span>.channelId = <span class=\"string\">\"App Store\"</span></span><br><span class=\"line\">    <span class=\"type\">MobClick</span>.start(withConfigure: <span class=\"type\">UMConfig</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，在真机或模拟器中启动程序，如果你在友盟的统计页面中看到相应的信息，就说明已经配置成功了！</p>\n<p>如果不想污染数据，可以使用友盟的集成调试功能。具体的内容可以参考开发文档。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Swift-集成友盟数据统计\"><a href=\"#Swift-集成友盟数据统计\" class=\"headerlink\" title=\"Swift 集成友盟数据统计\"></a>Swift 集成友盟数据统计</h1><p><a href=\"umeng.com\">友盟</a>是比较有名的数据统计服务提供商，但其 SDK 是用 OC 写的，开发文档中暂时也没有给出 Swift 的接入教程。不过其实用 Swift 集成友盟还是非常简单的。</p>\n<h3 id=\"获取-App-Key\"><a href=\"#获取-App-Key\" class=\"headerlink\" title=\"获取 App Key\"></a>获取 App Key</h3><p>注册友盟账号，在 U-App 中创建新应用，就可以获取到 App Key 了。</p>\n<h3 id=\"安装-SDK\"><a href=\"#安装-SDK\" class=\"headerlink\" title=\"安装 SDK\"></a>安装 SDK</h3><p>虽然目前在 iOS 的文档中没有写明，但友盟已经支持使用 CocoaPods 进行安装了。在 Podfile 里添加：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod '<span class=\"type\">UMengAnalytics'</span></span><br></pre></td></tr></table></figure>\n<p>或</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pod '<span class=\"type\">UMengAnalytics</span>-<span class=\"type\">NO</span>-<span class=\"type\">IDFA'</span></span><br></pre></td></tr></table></figure>\n<p>上面的是标准 SDK，下面的是无 IDFA 版本的。IDFA 是苹果的广告标识符，用于保护用户隐私的同时让商家可以最终广告效果。友盟使用 IDFA 是为了防止今后苹果可能会禁用 open-UDID 而造成数据异常。不过苹果禁止没有广告而获取 IDFA 的应用上架，因此审核期间可能会有风险。这里我选择了不采集 IDFA 的版本。</p>\n<h3 id=\"构建桥接文件\"><a href=\"#构建桥接文件\" class=\"headerlink\" title=\"构建桥接文件\"></a>构建桥接文件</h3><p>由于友盟的 SDK 是用 OC 编写的，因此在 Swift 项目中需要桥接文件来完成混编。好在 Swift 调用 OC 是非常方便的。</p>\n<ol>\n<li><code>Command + N</code> 呼出新建文件窗口，选择 <code>Header File</code>，命名为 <code>YourAppName-Bridging-Header.h</code>。（如果你已经引用过 OC 的代码，无视这一步）</li>\n<li>在其中插入你需要的组件的头文件，如 <code>#import &quot;UMMobClick/MobClick.h&quot;</code>。</li>\n<li>在工程的 Build Settings 中，找到 Swift Compiler - General （如果没有，记得勾选上方的 All，或者直接搜索）。在 Objective-C Bridging Header 项填入刚刚桥接文件的路径。也可以双击该项使它处于可编辑状态，把文件直接从文件树中拖过来，就会自动填充路径。</li>\n</ol>\n<h3 id=\"开始使用\"><a href=\"#开始使用\" class=\"headerlink\" title=\"开始使用\"></a>开始使用</h3><p>桥接文件构建完成，就可以按照官方文档用 Swift 调用友盟的 api 了。在 <code>AppDelegate.swift</code>中，找到 <code>application(_:didFinishLaunchingWithOptions:)</code> 函数，开始配置。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">application</span><span class=\"params\">(<span class=\"number\">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class=\"keyword\">Any</span>]?)</span></span> -&gt; <span class=\"type\">Bool</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"type\">UMConfig</span> = <span class=\"type\">UMAnalyticsConfig</span>()</span><br><span class=\"line\">    <span class=\"type\">UMConfig</span>.appKey = <span class=\"string\">\"Your App Key\"</span></span><br><span class=\"line\">    <span class=\"type\">UMConfig</span>.channelId = <span class=\"string\">\"App Store\"</span></span><br><span class=\"line\">    <span class=\"type\">MobClick</span>.start(withConfigure: <span class=\"type\">UMConfig</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，在真机或模拟器中启动程序，如果你在友盟的统计页面中看到相应的信息，就说明已经配置成功了！</p>\n<p>如果不想污染数据，可以使用友盟的集成调试功能。具体的内容可以参考开发文档。</p>\n"},{"title":"iOS 为 TableView 左滑删除添加图片","date":"2017-11-17T16:11:26.000Z","_content":"\n# iOS 为 TableView 左滑删除添加图片\n\n**本文适用于 iOS11**\n\n### 起因\n\n最近做的项目中，PM 和设计想把 TableView 左滑删除、分享等按钮的文字替换成图片。我想既然 iOS11 自带的邮件应用中就是这样的，那实现起来应该很容易，就一口答应了。\n\n<img src=\"/img/左滑删除图片/leftswipe.PNG\" style=\"zoom:40%\"/>\n\n开始开发的时候，我信心满满地在 Xcode 中敲下了配置左滑编辑功能的代理方法：\n\n```swift\nfunc tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {\n    let stickAction = UITableViewRowAction(style: .default, title: \"置顶\") { (_, _) in\n        //\n    }\n    stickAction.//???\n    return [stickAction]\n        \n}\n```\n\n然后在自动补全中只看到了孤零零的 backgroundColor……什么！竟然没有配置图片的 API ！\n\n### 寻找解决方案\n\n要知道，左滑弹出的这些按钮无非也就是一些 Button，只要能拿到 Button，设置图片就很容易了。打开 Debug View Hierarchy，可以看到视图层级是这样的：\n\n<img src=\"/img/左滑删除图片/hierarchy.png\" style=\"zoom:40%\"/>\n\n我们要找的按钮不就是这个 UISwipeActionStandardButton 类型的 Button 吗！只要拿到它就可以了。它的父视图是 UISwipeActionPullView 类型的 View，再往上一层就是我们的 UITableView 了。于是我到 Documents 上查了一下，想说看有没有调用的相关 API，发现竟然没有！震惊！看来又是私有属性！\n\n### 强行拿到 Button\n\n我们已知视图的类型和层级关系，拿到它也不困难。只要遍历 TableView 的子视图，找到 UISwipeActionPullView 类型的视图就可以了。注意这个类型是私有的，所以只能通过名字反射（抱歉这里借用了 Java 中反射的概念）进去：\n\n```swift\nfor each in self.tableView.subviews {\n    if each.isKind(of: NSClassFromString(\"UISwipeActionPullView\")!) {\n        print(dump(each))\n        let btn = each.subviews.first! as! UIButton\n        btn.setImage(UIImage(named: \"test\"), for: .normal)\n    }\n}\n```\n\n离大功告成还剩最后一步！\n\n### 在合适的时机调用\n\n要想让代码成功执行，必须等待 TableView 已经配置好侧滑按钮。否则 UISwipeActionPullView 还没被实例化出来，肯定是找不到这个类型的变量的（我因为这个问题纠结了一个多小时，反应过来的时候想掐死自己）。\n\n```swift\nfunc tableView(_ tableView: UITableView, willBeginEditingRowAt indexPath: IndexPath) {\n    for each in self.tableView.subviews {\n        if each.isKind(of: NSClassFromString(\"UISwipeActionPullView\")!) {\n            print(dump(each))\n            let btn = each.subviews.first! as! UIButton\n            btn.setImage(UIImage(named: \"test\"), for: .normal)\n        }\n    }\n}\n```\n\n大功告成！\n\n![finish](/img/左滑删除图片/finish.png)\n\n### 写在最后\n\n首先，调用私有 API 是一件非常有风险的事情。有可能在审核的时候被苹果拒绝不说（这里应该还好），这些 API 和属性都是非常不稳定的。比如，在 iOS10 中表现会不一样。想兼容 iOS10 的话就要编写额外的代码，很麻烦。而且随着系统更新，这些方法可能会被苹果更改从而不再有效。\n\n我不知道为什么这些很基本的东西苹果不愿意开放给开发者（类似的还有 UIAlertController，想自定义必须用 KVC 在运行时动态更改，而文档中明确写出不要继承它），但苹果自己却在使用。感觉很麻烦啊！唉。\n\n","source":"_posts/iOS-为TableView左滑删除添加图片.md","raw":"---\ntitle: iOS 为 TableView 左滑删除添加图片\ndate: 2017-11-18 00:11:26\ntags: UITableView\n---\n\n# iOS 为 TableView 左滑删除添加图片\n\n**本文适用于 iOS11**\n\n### 起因\n\n最近做的项目中，PM 和设计想把 TableView 左滑删除、分享等按钮的文字替换成图片。我想既然 iOS11 自带的邮件应用中就是这样的，那实现起来应该很容易，就一口答应了。\n\n<img src=\"/img/左滑删除图片/leftswipe.PNG\" style=\"zoom:40%\"/>\n\n开始开发的时候，我信心满满地在 Xcode 中敲下了配置左滑编辑功能的代理方法：\n\n```swift\nfunc tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -> [UITableViewRowAction]? {\n    let stickAction = UITableViewRowAction(style: .default, title: \"置顶\") { (_, _) in\n        //\n    }\n    stickAction.//???\n    return [stickAction]\n        \n}\n```\n\n然后在自动补全中只看到了孤零零的 backgroundColor……什么！竟然没有配置图片的 API ！\n\n### 寻找解决方案\n\n要知道，左滑弹出的这些按钮无非也就是一些 Button，只要能拿到 Button，设置图片就很容易了。打开 Debug View Hierarchy，可以看到视图层级是这样的：\n\n<img src=\"/img/左滑删除图片/hierarchy.png\" style=\"zoom:40%\"/>\n\n我们要找的按钮不就是这个 UISwipeActionStandardButton 类型的 Button 吗！只要拿到它就可以了。它的父视图是 UISwipeActionPullView 类型的 View，再往上一层就是我们的 UITableView 了。于是我到 Documents 上查了一下，想说看有没有调用的相关 API，发现竟然没有！震惊！看来又是私有属性！\n\n### 强行拿到 Button\n\n我们已知视图的类型和层级关系，拿到它也不困难。只要遍历 TableView 的子视图，找到 UISwipeActionPullView 类型的视图就可以了。注意这个类型是私有的，所以只能通过名字反射（抱歉这里借用了 Java 中反射的概念）进去：\n\n```swift\nfor each in self.tableView.subviews {\n    if each.isKind(of: NSClassFromString(\"UISwipeActionPullView\")!) {\n        print(dump(each))\n        let btn = each.subviews.first! as! UIButton\n        btn.setImage(UIImage(named: \"test\"), for: .normal)\n    }\n}\n```\n\n离大功告成还剩最后一步！\n\n### 在合适的时机调用\n\n要想让代码成功执行，必须等待 TableView 已经配置好侧滑按钮。否则 UISwipeActionPullView 还没被实例化出来，肯定是找不到这个类型的变量的（我因为这个问题纠结了一个多小时，反应过来的时候想掐死自己）。\n\n```swift\nfunc tableView(_ tableView: UITableView, willBeginEditingRowAt indexPath: IndexPath) {\n    for each in self.tableView.subviews {\n        if each.isKind(of: NSClassFromString(\"UISwipeActionPullView\")!) {\n            print(dump(each))\n            let btn = each.subviews.first! as! UIButton\n            btn.setImage(UIImage(named: \"test\"), for: .normal)\n        }\n    }\n}\n```\n\n大功告成！\n\n![finish](/img/左滑删除图片/finish.png)\n\n### 写在最后\n\n首先，调用私有 API 是一件非常有风险的事情。有可能在审核的时候被苹果拒绝不说（这里应该还好），这些 API 和属性都是非常不稳定的。比如，在 iOS10 中表现会不一样。想兼容 iOS10 的话就要编写额外的代码，很麻烦。而且随着系统更新，这些方法可能会被苹果更改从而不再有效。\n\n我不知道为什么这些很基本的东西苹果不愿意开放给开发者（类似的还有 UIAlertController，想自定义必须用 KVC 在运行时动态更改，而文档中明确写出不要继承它），但苹果自己却在使用。感觉很麻烦啊！唉。\n\n","slug":"iOS-为TableView左滑删除添加图片","published":1,"updated":"2020-01-04T08:16:16.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv36000wljc3ok92srtw","content":"<h1 id=\"iOS-为-TableView-左滑删除添加图片\"><a href=\"#iOS-为-TableView-左滑删除添加图片\" class=\"headerlink\" title=\"iOS 为 TableView 左滑删除添加图片\"></a>iOS 为 TableView 左滑删除添加图片</h1><p><strong>本文适用于 iOS11</strong></p>\n<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>最近做的项目中，PM 和设计想把 TableView 左滑删除、分享等按钮的文字替换成图片。我想既然 iOS11 自带的邮件应用中就是这样的，那实现起来应该很容易，就一口答应了。</p>\n<p><img src=\"/img/左滑删除图片/leftswipe.PNG\" style=\"zoom:40%\"/></p>\n<p>开始开发的时候，我信心满满地在 Xcode 中敲下了配置左滑编辑功能的代理方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, editActionsForRowAt indexPath: IndexPath)</span></span> -&gt; [<span class=\"type\">UITableViewRowAction</span>]? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stickAction = <span class=\"type\">UITableViewRowAction</span>(style: .<span class=\"keyword\">default</span>, title: <span class=\"string\">\"置顶\"</span>) &#123; (<span class=\"number\">_</span>, <span class=\"number\">_</span>) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stickAction.<span class=\"comment\">//???</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [stickAction]</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在自动补全中只看到了孤零零的 backgroundColor……什么！竟然没有配置图片的 API ！</p>\n<h3 id=\"寻找解决方案\"><a href=\"#寻找解决方案\" class=\"headerlink\" title=\"寻找解决方案\"></a>寻找解决方案</h3><p>要知道，左滑弹出的这些按钮无非也就是一些 Button，只要能拿到 Button，设置图片就很容易了。打开 Debug View Hierarchy，可以看到视图层级是这样的：</p>\n<p><img src=\"/img/左滑删除图片/hierarchy.png\" style=\"zoom:40%\"/></p>\n<p>我们要找的按钮不就是这个 UISwipeActionStandardButton 类型的 Button 吗！只要拿到它就可以了。它的父视图是 UISwipeActionPullView 类型的 View，再往上一层就是我们的 UITableView 了。于是我到 Documents 上查了一下，想说看有没有调用的相关 API，发现竟然没有！震惊！看来又是私有属性！</p>\n<h3 id=\"强行拿到-Button\"><a href=\"#强行拿到-Button\" class=\"headerlink\" title=\"强行拿到 Button\"></a>强行拿到 Button</h3><p>我们已知视图的类型和层级关系，拿到它也不困难。只要遍历 TableView 的子视图，找到 UISwipeActionPullView 类型的视图就可以了。注意这个类型是私有的，所以只能通过名字反射（抱歉这里借用了 Java 中反射的概念）进去：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.tableView.subviews &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> each.isKind(of: <span class=\"type\">NSClassFromString</span>(<span class=\"string\">\"UISwipeActionPullView\"</span>)!) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">dump</span>(each))</span><br><span class=\"line\">        <span class=\"keyword\">let</span> btn = each.subviews.first! <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        btn.setImage(<span class=\"type\">UIImage</span>(named: <span class=\"string\">\"test\"</span>), <span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>离大功告成还剩最后一步！</p>\n<h3 id=\"在合适的时机调用\"><a href=\"#在合适的时机调用\" class=\"headerlink\" title=\"在合适的时机调用\"></a>在合适的时机调用</h3><p>要想让代码成功执行，必须等待 TableView 已经配置好侧滑按钮。否则 UISwipeActionPullView 还没被实例化出来，肯定是找不到这个类型的变量的（我因为这个问题纠结了一个多小时，反应过来的时候想掐死自己）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, willBeginEditingRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.tableView.subviews &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> each.isKind(of: <span class=\"type\">NSClassFromString</span>(<span class=\"string\">\"UISwipeActionPullView\"</span>)!) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"built_in\">dump</span>(each))</span><br><span class=\"line\">            <span class=\"keyword\">let</span> btn = each.subviews.first! <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">            btn.setImage(<span class=\"type\">UIImage</span>(named: <span class=\"string\">\"test\"</span>), <span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大功告成！</p>\n<p><img src=\"/img/左滑删除图片/finish.png\" alt=\"finish\"></p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>首先，调用私有 API 是一件非常有风险的事情。有可能在审核的时候被苹果拒绝不说（这里应该还好），这些 API 和属性都是非常不稳定的。比如，在 iOS10 中表现会不一样。想兼容 iOS10 的话就要编写额外的代码，很麻烦。而且随着系统更新，这些方法可能会被苹果更改从而不再有效。</p>\n<p>我不知道为什么这些很基本的东西苹果不愿意开放给开发者（类似的还有 UIAlertController，想自定义必须用 KVC 在运行时动态更改，而文档中明确写出不要继承它），但苹果自己却在使用。感觉很麻烦啊！唉。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-为-TableView-左滑删除添加图片\"><a href=\"#iOS-为-TableView-左滑删除添加图片\" class=\"headerlink\" title=\"iOS 为 TableView 左滑删除添加图片\"></a>iOS 为 TableView 左滑删除添加图片</h1><p><strong>本文适用于 iOS11</strong></p>\n<h3 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h3><p>最近做的项目中，PM 和设计想把 TableView 左滑删除、分享等按钮的文字替换成图片。我想既然 iOS11 自带的邮件应用中就是这样的，那实现起来应该很容易，就一口答应了。</p>\n<p><img src=\"/img/左滑删除图片/leftswipe.PNG\" style=\"zoom:40%\"/></p>\n<p>开始开发的时候，我信心满满地在 Xcode 中敲下了配置左滑编辑功能的代理方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, editActionsForRowAt indexPath: IndexPath)</span></span> -&gt; [<span class=\"type\">UITableViewRowAction</span>]? &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> stickAction = <span class=\"type\">UITableViewRowAction</span>(style: .<span class=\"keyword\">default</span>, title: <span class=\"string\">\"置顶\"</span>) &#123; (<span class=\"number\">_</span>, <span class=\"number\">_</span>) <span class=\"keyword\">in</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stickAction.<span class=\"comment\">//???</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [stickAction]</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后在自动补全中只看到了孤零零的 backgroundColor……什么！竟然没有配置图片的 API ！</p>\n<h3 id=\"寻找解决方案\"><a href=\"#寻找解决方案\" class=\"headerlink\" title=\"寻找解决方案\"></a>寻找解决方案</h3><p>要知道，左滑弹出的这些按钮无非也就是一些 Button，只要能拿到 Button，设置图片就很容易了。打开 Debug View Hierarchy，可以看到视图层级是这样的：</p>\n<p><img src=\"/img/左滑删除图片/hierarchy.png\" style=\"zoom:40%\"/></p>\n<p>我们要找的按钮不就是这个 UISwipeActionStandardButton 类型的 Button 吗！只要拿到它就可以了。它的父视图是 UISwipeActionPullView 类型的 View，再往上一层就是我们的 UITableView 了。于是我到 Documents 上查了一下，想说看有没有调用的相关 API，发现竟然没有！震惊！看来又是私有属性！</p>\n<h3 id=\"强行拿到-Button\"><a href=\"#强行拿到-Button\" class=\"headerlink\" title=\"强行拿到 Button\"></a>强行拿到 Button</h3><p>我们已知视图的类型和层级关系，拿到它也不困难。只要遍历 TableView 的子视图，找到 UISwipeActionPullView 类型的视图就可以了。注意这个类型是私有的，所以只能通过名字反射（抱歉这里借用了 Java 中反射的概念）进去：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.tableView.subviews &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> each.isKind(of: <span class=\"type\">NSClassFromString</span>(<span class=\"string\">\"UISwipeActionPullView\"</span>)!) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">dump</span>(each))</span><br><span class=\"line\">        <span class=\"keyword\">let</span> btn = each.subviews.first! <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">        btn.setImage(<span class=\"type\">UIImage</span>(named: <span class=\"string\">\"test\"</span>), <span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>离大功告成还剩最后一步！</p>\n<h3 id=\"在合适的时机调用\"><a href=\"#在合适的时机调用\" class=\"headerlink\" title=\"在合适的时机调用\"></a>在合适的时机调用</h3><p>要想让代码成功执行，必须等待 TableView 已经配置好侧滑按钮。否则 UISwipeActionPullView 还没被实例化出来，肯定是找不到这个类型的变量的（我因为这个问题纠结了一个多小时，反应过来的时候想掐死自己）。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">tableView</span><span class=\"params\">(<span class=\"number\">_</span> tableView: UITableView, willBeginEditingRowAt indexPath: IndexPath)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> <span class=\"keyword\">self</span>.tableView.subviews &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> each.isKind(of: <span class=\"type\">NSClassFromString</span>(<span class=\"string\">\"UISwipeActionPullView\"</span>)!) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"built_in\">dump</span>(each))</span><br><span class=\"line\">            <span class=\"keyword\">let</span> btn = each.subviews.first! <span class=\"keyword\">as</span>! <span class=\"type\">UIButton</span></span><br><span class=\"line\">            btn.setImage(<span class=\"type\">UIImage</span>(named: <span class=\"string\">\"test\"</span>), <span class=\"keyword\">for</span>: .normal)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大功告成！</p>\n<p><img src=\"/img/左滑删除图片/finish.png\" alt=\"finish\"></p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>首先，调用私有 API 是一件非常有风险的事情。有可能在审核的时候被苹果拒绝不说（这里应该还好），这些 API 和属性都是非常不稳定的。比如，在 iOS10 中表现会不一样。想兼容 iOS10 的话就要编写额外的代码，很麻烦。而且随着系统更新，这些方法可能会被苹果更改从而不再有效。</p>\n<p>我不知道为什么这些很基本的东西苹果不愿意开放给开发者（类似的还有 UIAlertController，想自定义必须用 KVC 在运行时动态更改，而文档中明确写出不要继承它），但苹果自己却在使用。感觉很麻烦啊！唉。</p>\n"},{"title":"iOS 核心动画","date":"2017-06-03T16:05:55.000Z","comments":1,"_content":"\n# iOS Core-Animation 动画\n\n### 熟悉 Core-Animation 框架\n\nCore-Animation ，中文译为“核心动画”，是 iOS 和 macOS 上一组非常强大的 API 。它的最底层是 GPU ，上层是 OpenGL ／ OpenGL ES 和 CoreGraphics ，这两个框架提供了一些接口来访问 GPU 。最上层 CoreAnimation 提供了大量封装好的 API 来实现简单或复杂的动画。程序员只需要编写很少的代码，比如修改几个参数，或者设置起始、终止状态，就可以制作出很精美的动画。\n\nCore-Animation 是基于 Layer 的，而非 UIView 。利用 GPU 来计算，所以速度快、效率高，且不会拖累 CPU 造成程序卡顿。所有的动画都是在后台执行的，不会阻塞主线程。\n\n### 基本动画的使用\n\n#### 1. CABasicAnimation\n\n**Demo** - 模仿 iOS9 锁屏界面的“滑动以解锁”动画（在 iOS10 中这个动画已经被”按下主屏幕按钮以解锁“取代）\n\n![滑动解锁演示](https://ooo.0o0.ooo/2017/06/03/59319180d3293.gif)\n\n```swift\nlet gradientLayer = CAGradientLayer() //创建一个\"梯度\"层\ngradientLayer.frame = CGRect(x: 0, y: 0, width: 200, height: 60)\n//设置起始位置和终止位置，由于是水平的，所以 0.5 也可以改成任何其他的值，没有其他影响\ngradientLayer.startPoint = CGPoint(x: 0, y: 0.5)\ngradientLayer.endPoint = CGPoint(x: 1, y: 0.5)\n//黑-白-黑的颜色渐变\ngradientLayer.colors = [UIColor.black.cgColor,UIColor.white.cgColor,UIColor.black.cgColor]\n\ngradientLayer.locations = [0,0.5,1] //每个颜色处于的位置，即白色在正中间，只要让这里动起来就可以了\n        \nlet myview = UIView(frame: CGRect(x: 120, y: 200, width: 200, height: 60))\nmyview.layer.addSublayer(gradientLayer) //把梯度层加入\nview.addSubview(myview)\n        \n// CABasicAnimation 部分\nlet gradient = CABasicAnimation(keyPath: \"locations\")\ngradient.fromValue = [0,0,0.25]\ngradient.toValue = [0.75,1,1]\ngradient.duration = 3\ngradient.repeatCount = Float.infinity //无限循环\n\ngradientLayer.add(gradient, forKey: nil) //添加动画\n        \nlet text:NSString = \"滑动以解锁\"\n\n//下面把文字转化为图片\nlet textAttributes:[String:Any] = {\n\tlet style = NSMutableParagraphStyle()\n    style.alignment = .center\n    return [NSFontAttributeName: UIFont.systemFont(ofSize: 25),NSParagraphStyleAttributeName: style]\n}()\n        \nlet image = UIGraphicsImageRenderer(size: CGSize(width: 200, height: 60)).image(actions: {\n\t_ in\n   \ttext.draw(in: CGRect(x: 0, y: 0, width: 200, height: 60), withAttributes: textAttributes)\n})\n\nlet masklayer = CALayer() //遮罩层\nmasklayer.frame = CGRect(x: 0, y: 0, width: 200, height: 60)\nmasklayer.backgroundColor = UIColor.clear.cgColor\nmasklayer.contents = image.cgImage\nmyview.layer.mask = masklayer //myview 其实是黑色的方块（带有动画），只露出来文字的形状\n```\n\n#### 2. CAKeyFrameAnimation\n\n所谓的“关键帧动画”。与 BasicAnimation 的区别是： CABasicAnimation 只能设置起始和终止值，而 CAKeyFrameAnimation 可以用一个数组保存中间值，即记录下来“关键帧”的信息。\n\n这里可以设置 path（其实 CABasicAnimation 也可以设置 path ），让动画沿着轨迹运动。但是设置 path 之后，value 值将被忽略。\n\n**Demo** - 沿路径运动（ UIBeizerPath ）\n\n![沿路径运动动画](https://ooo.0o0.ooo/2017/06/03/5932b0c3731fd.gif)\n\n```swift\nlet move = CAKeyframeAnimation(keyPath: \"position\")\nmove.path = UIBezierPath(rect: CGRect(x: 120+25, y: 200+25, width: 100, \theight: 100)).cgPath\nmove.duration = 3\nmove.repeatCount = .infinity\n        \nmyview.layer.add(move, forKey: nil)\n```\n\n这里似乎不能直接设置反向运动。想要反向运动需要自己绘制一个反向的矩形。\n\n**Demo** - 圆形进度条（ CAShapeLayer ）\n\n![圆形进度条](https://ooo.0o0.ooo/2017/06/03/5932b5ef6a311.gif)\n\n```swift\nlet shape = CAShapeLayer()\nshape.frame = myview.bounds\nshape.path = UIBezierPath(ovalIn: shape.frame).cgPath\nshape.fillColor = UIColor.clear.cgColor\nshape.lineWidth = 5\nshape.strokeColor = UIColor.red.cgColor\n        \nmyview.layer.addSublayer(shape)\n        \nlet anim = CAKeyframeAnimation(keyPath: \"strokeEnd\") //strokeEnd 也是可以动的参数\nanim.values = [0,1]\nanim.keyTimes = [0,1]\nanim.duration = 3\nanim.autoreverses = true\nanim.repeatCount = .infinity\n        \nshape.add(anim, forKey: nil)\n```\n\n#### 3. CATransition\n\n**Demo** - 简单的转场动画（渐变效果）\n\n![转场动画](https://ooo.0o0.ooo/2017/06/03/5932c324448aa.gif)\n\n```swift\nimport UIKit\nimport PlaygroundSupport\n\nclass ViewController: UIViewController, UIViewControllerTransitioningDelegate {\n    \n    let button = UIButton(frame: CGRect(x: 100, y: 100, width: 50, height: 50))\n    \n    override func viewDidLoad() {\n        view.backgroundColor = UIColor.white\n        view.addSubview(button)\n        button.backgroundColor = UIColor.red\n        button.addTarget(self, action: #selector(ViewController.onClick), for: .touchUpInside)\n    }\n    \n    func onClick() {\n        let vc = YellowViewController()\n        vc.transitioningDelegate = self\n        present(vc, animated: true, completion: nil)\n    }\n    \n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return Animator()\n    }\n    \n    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return nil\n    }\n}\n\nclass YellowViewController: UIViewController, UIViewControllerTransitioningDelegate {\n    override func viewDidLoad() {\n        view.backgroundColor = UIColor.yellow\n    }\n}\n\nclass Animator: NSObject, UIViewControllerAnimatedTransitioning {\n    \n    let duration = 2.0\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {\n        return duration\n    }\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n        let containerView = transitionContext.containerView\n        let toView = transitionContext.view(forKey: .to)!\n        containerView.addSubview(toView)\n        toView.alpha = 0\n        UIView.animate(withDuration: duration, animations: {\n            toView.alpha = 1\n        })\n    }\n}\n\nPlaygroundPage.current.liveView = ViewController()\n```\n\n### 问题\n\n#### 1. CoreAnimation 的工作机制\n\nCoreAnimation 是基于 layer 的动画，通过 GPU 来渲染。而基于 view 的动画是通过调用 drawRect 方法使用新参数不断的重绘内容，使用 CPU 来不断的计算，因而效率很低。\n\n#### 2. 为什么动画结束后返回原状态？为什么动画在移动过程中我们不能进行操作？\n\n因为在动画运行时，我们看到的并不是该控件本身，而是一个假的“躯壳”，即 presentation layer 。真实的控件会被隐藏，而只有视觉层在做动画，所以移动的过程中不能做任何操作。一旦动画结束， presentation layer 就会被移除，真实的控件又会显示出来，这就是为什么动画结束后会返回到原状态：因为动画并没有修改控件本身的属性，结束后又回到了 model layer 的值。有时候会为了不让动画结束后跳回原状态而设置 fillMode 参数，但是这也这是让 presentation layer 停留在最后的位置。如果你的控件是可以操作的，那就不可以这么做。","source":"_posts/iOS-核心动画.md","raw":"---\ntitle: iOS 核心动画\ndate: 2017-06-04 00:05:55\ntags: CoreAnimation\ncomments: true\n---\n\n# iOS Core-Animation 动画\n\n### 熟悉 Core-Animation 框架\n\nCore-Animation ，中文译为“核心动画”，是 iOS 和 macOS 上一组非常强大的 API 。它的最底层是 GPU ，上层是 OpenGL ／ OpenGL ES 和 CoreGraphics ，这两个框架提供了一些接口来访问 GPU 。最上层 CoreAnimation 提供了大量封装好的 API 来实现简单或复杂的动画。程序员只需要编写很少的代码，比如修改几个参数，或者设置起始、终止状态，就可以制作出很精美的动画。\n\nCore-Animation 是基于 Layer 的，而非 UIView 。利用 GPU 来计算，所以速度快、效率高，且不会拖累 CPU 造成程序卡顿。所有的动画都是在后台执行的，不会阻塞主线程。\n\n### 基本动画的使用\n\n#### 1. CABasicAnimation\n\n**Demo** - 模仿 iOS9 锁屏界面的“滑动以解锁”动画（在 iOS10 中这个动画已经被”按下主屏幕按钮以解锁“取代）\n\n![滑动解锁演示](https://ooo.0o0.ooo/2017/06/03/59319180d3293.gif)\n\n```swift\nlet gradientLayer = CAGradientLayer() //创建一个\"梯度\"层\ngradientLayer.frame = CGRect(x: 0, y: 0, width: 200, height: 60)\n//设置起始位置和终止位置，由于是水平的，所以 0.5 也可以改成任何其他的值，没有其他影响\ngradientLayer.startPoint = CGPoint(x: 0, y: 0.5)\ngradientLayer.endPoint = CGPoint(x: 1, y: 0.5)\n//黑-白-黑的颜色渐变\ngradientLayer.colors = [UIColor.black.cgColor,UIColor.white.cgColor,UIColor.black.cgColor]\n\ngradientLayer.locations = [0,0.5,1] //每个颜色处于的位置，即白色在正中间，只要让这里动起来就可以了\n        \nlet myview = UIView(frame: CGRect(x: 120, y: 200, width: 200, height: 60))\nmyview.layer.addSublayer(gradientLayer) //把梯度层加入\nview.addSubview(myview)\n        \n// CABasicAnimation 部分\nlet gradient = CABasicAnimation(keyPath: \"locations\")\ngradient.fromValue = [0,0,0.25]\ngradient.toValue = [0.75,1,1]\ngradient.duration = 3\ngradient.repeatCount = Float.infinity //无限循环\n\ngradientLayer.add(gradient, forKey: nil) //添加动画\n        \nlet text:NSString = \"滑动以解锁\"\n\n//下面把文字转化为图片\nlet textAttributes:[String:Any] = {\n\tlet style = NSMutableParagraphStyle()\n    style.alignment = .center\n    return [NSFontAttributeName: UIFont.systemFont(ofSize: 25),NSParagraphStyleAttributeName: style]\n}()\n        \nlet image = UIGraphicsImageRenderer(size: CGSize(width: 200, height: 60)).image(actions: {\n\t_ in\n   \ttext.draw(in: CGRect(x: 0, y: 0, width: 200, height: 60), withAttributes: textAttributes)\n})\n\nlet masklayer = CALayer() //遮罩层\nmasklayer.frame = CGRect(x: 0, y: 0, width: 200, height: 60)\nmasklayer.backgroundColor = UIColor.clear.cgColor\nmasklayer.contents = image.cgImage\nmyview.layer.mask = masklayer //myview 其实是黑色的方块（带有动画），只露出来文字的形状\n```\n\n#### 2. CAKeyFrameAnimation\n\n所谓的“关键帧动画”。与 BasicAnimation 的区别是： CABasicAnimation 只能设置起始和终止值，而 CAKeyFrameAnimation 可以用一个数组保存中间值，即记录下来“关键帧”的信息。\n\n这里可以设置 path（其实 CABasicAnimation 也可以设置 path ），让动画沿着轨迹运动。但是设置 path 之后，value 值将被忽略。\n\n**Demo** - 沿路径运动（ UIBeizerPath ）\n\n![沿路径运动动画](https://ooo.0o0.ooo/2017/06/03/5932b0c3731fd.gif)\n\n```swift\nlet move = CAKeyframeAnimation(keyPath: \"position\")\nmove.path = UIBezierPath(rect: CGRect(x: 120+25, y: 200+25, width: 100, \theight: 100)).cgPath\nmove.duration = 3\nmove.repeatCount = .infinity\n        \nmyview.layer.add(move, forKey: nil)\n```\n\n这里似乎不能直接设置反向运动。想要反向运动需要自己绘制一个反向的矩形。\n\n**Demo** - 圆形进度条（ CAShapeLayer ）\n\n![圆形进度条](https://ooo.0o0.ooo/2017/06/03/5932b5ef6a311.gif)\n\n```swift\nlet shape = CAShapeLayer()\nshape.frame = myview.bounds\nshape.path = UIBezierPath(ovalIn: shape.frame).cgPath\nshape.fillColor = UIColor.clear.cgColor\nshape.lineWidth = 5\nshape.strokeColor = UIColor.red.cgColor\n        \nmyview.layer.addSublayer(shape)\n        \nlet anim = CAKeyframeAnimation(keyPath: \"strokeEnd\") //strokeEnd 也是可以动的参数\nanim.values = [0,1]\nanim.keyTimes = [0,1]\nanim.duration = 3\nanim.autoreverses = true\nanim.repeatCount = .infinity\n        \nshape.add(anim, forKey: nil)\n```\n\n#### 3. CATransition\n\n**Demo** - 简单的转场动画（渐变效果）\n\n![转场动画](https://ooo.0o0.ooo/2017/06/03/5932c324448aa.gif)\n\n```swift\nimport UIKit\nimport PlaygroundSupport\n\nclass ViewController: UIViewController, UIViewControllerTransitioningDelegate {\n    \n    let button = UIButton(frame: CGRect(x: 100, y: 100, width: 50, height: 50))\n    \n    override func viewDidLoad() {\n        view.backgroundColor = UIColor.white\n        view.addSubview(button)\n        button.backgroundColor = UIColor.red\n        button.addTarget(self, action: #selector(ViewController.onClick), for: .touchUpInside)\n    }\n    \n    func onClick() {\n        let vc = YellowViewController()\n        vc.transitioningDelegate = self\n        present(vc, animated: true, completion: nil)\n    }\n    \n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return Animator()\n    }\n    \n    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        return nil\n    }\n}\n\nclass YellowViewController: UIViewController, UIViewControllerTransitioningDelegate {\n    override func viewDidLoad() {\n        view.backgroundColor = UIColor.yellow\n    }\n}\n\nclass Animator: NSObject, UIViewControllerAnimatedTransitioning {\n    \n    let duration = 2.0\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {\n        return duration\n    }\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n        let containerView = transitionContext.containerView\n        let toView = transitionContext.view(forKey: .to)!\n        containerView.addSubview(toView)\n        toView.alpha = 0\n        UIView.animate(withDuration: duration, animations: {\n            toView.alpha = 1\n        })\n    }\n}\n\nPlaygroundPage.current.liveView = ViewController()\n```\n\n### 问题\n\n#### 1. CoreAnimation 的工作机制\n\nCoreAnimation 是基于 layer 的动画，通过 GPU 来渲染。而基于 view 的动画是通过调用 drawRect 方法使用新参数不断的重绘内容，使用 CPU 来不断的计算，因而效率很低。\n\n#### 2. 为什么动画结束后返回原状态？为什么动画在移动过程中我们不能进行操作？\n\n因为在动画运行时，我们看到的并不是该控件本身，而是一个假的“躯壳”，即 presentation layer 。真实的控件会被隐藏，而只有视觉层在做动画，所以移动的过程中不能做任何操作。一旦动画结束， presentation layer 就会被移除，真实的控件又会显示出来，这就是为什么动画结束后会返回到原状态：因为动画并没有修改控件本身的属性，结束后又回到了 model layer 的值。有时候会为了不让动画结束后跳回原状态而设置 fillMode 参数，但是这也这是让 presentation layer 停留在最后的位置。如果你的控件是可以操作的，那就不可以这么做。","slug":"iOS-核心动画","published":1,"updated":"2020-01-04T08:16:16.918Z","layout":"post","photos":[],"link":"","_id":"ck4zcnv37000yljc3ls69hg45","content":"<h1 id=\"iOS-Core-Animation-动画\"><a href=\"#iOS-Core-Animation-动画\" class=\"headerlink\" title=\"iOS Core-Animation 动画\"></a>iOS Core-Animation 动画</h1><h3 id=\"熟悉-Core-Animation-框架\"><a href=\"#熟悉-Core-Animation-框架\" class=\"headerlink\" title=\"熟悉 Core-Animation 框架\"></a>熟悉 Core-Animation 框架</h3><p>Core-Animation ，中文译为“核心动画”，是 iOS 和 macOS 上一组非常强大的 API 。它的最底层是 GPU ，上层是 OpenGL ／ OpenGL ES 和 CoreGraphics ，这两个框架提供了一些接口来访问 GPU 。最上层 CoreAnimation 提供了大量封装好的 API 来实现简单或复杂的动画。程序员只需要编写很少的代码，比如修改几个参数，或者设置起始、终止状态，就可以制作出很精美的动画。</p>\n<p>Core-Animation 是基于 Layer 的，而非 UIView 。利用 GPU 来计算，所以速度快、效率高，且不会拖累 CPU 造成程序卡顿。所有的动画都是在后台执行的，不会阻塞主线程。</p>\n<h3 id=\"基本动画的使用\"><a href=\"#基本动画的使用\" class=\"headerlink\" title=\"基本动画的使用\"></a>基本动画的使用</h3><h4 id=\"1-CABasicAnimation\"><a href=\"#1-CABasicAnimation\" class=\"headerlink\" title=\"1. CABasicAnimation\"></a>1. CABasicAnimation</h4><p><strong>Demo</strong> - 模仿 iOS9 锁屏界面的“滑动以解锁”动画（在 iOS10 中这个动画已经被”按下主屏幕按钮以解锁“取代）</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/03/59319180d3293.gif\" alt=\"滑动解锁演示\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gradientLayer = <span class=\"type\">CAGradientLayer</span>() <span class=\"comment\">//创建一个\"梯度\"层</span></span><br><span class=\"line\">gradientLayer.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">200</span>, height: <span class=\"number\">60</span>)</span><br><span class=\"line\"><span class=\"comment\">//设置起始位置和终止位置，由于是水平的，所以 0.5 也可以改成任何其他的值，没有其他影响</span></span><br><span class=\"line\">gradientLayer.startPoint = <span class=\"type\">CGPoint</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0.5</span>)</span><br><span class=\"line\">gradientLayer.endPoint = <span class=\"type\">CGPoint</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">0.5</span>)</span><br><span class=\"line\"><span class=\"comment\">//黑-白-黑的颜色渐变</span></span><br><span class=\"line\">gradientLayer.colors = [<span class=\"type\">UIColor</span>.black.cgColor,<span class=\"type\">UIColor</span>.white.cgColor,<span class=\"type\">UIColor</span>.black.cgColor]</span><br><span class=\"line\"></span><br><span class=\"line\">gradientLayer.locations = [<span class=\"number\">0</span>,<span class=\"number\">0.5</span>,<span class=\"number\">1</span>] <span class=\"comment\">//每个颜色处于的位置，即白色在正中间，只要让这里动起来就可以了</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> myview = <span class=\"type\">UIView</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">120</span>, y: <span class=\"number\">200</span>, width: <span class=\"number\">200</span>, height: <span class=\"number\">60</span>))</span><br><span class=\"line\">myview.layer.addSublayer(gradientLayer) <span class=\"comment\">//把梯度层加入</span></span><br><span class=\"line\">view.addSubview(myview)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">// CABasicAnimation 部分</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> gradient = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"locations\"</span>)</span><br><span class=\"line\">gradient.fromValue = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.25</span>]</span><br><span class=\"line\">gradient.toValue = [<span class=\"number\">0.75</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">gradient.duration = <span class=\"number\">3</span></span><br><span class=\"line\">gradient.repeatCount = <span class=\"type\">Float</span>.infinity <span class=\"comment\">//无限循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">gradientLayer.add(gradient, forKey: <span class=\"literal\">nil</span>) <span class=\"comment\">//添加动画</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> text:<span class=\"type\">NSString</span> = <span class=\"string\">\"滑动以解锁\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下面把文字转化为图片</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> textAttributes:[<span class=\"type\">String</span>:<span class=\"type\">Any</span>] = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> style = <span class=\"type\">NSMutableParagraphStyle</span>()</span><br><span class=\"line\">    style.alignment = .center</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"type\">NSFontAttributeName</span>: <span class=\"type\">UIFont</span>.systemFont(ofSize: <span class=\"number\">25</span>),<span class=\"type\">NSParagraphStyleAttributeName</span>: style]</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> image = <span class=\"type\">UIGraphicsImageRenderer</span>(size: <span class=\"type\">CGSize</span>(width: <span class=\"number\">200</span>, height: <span class=\"number\">60</span>)).image(actions: &#123;</span><br><span class=\"line\">\t<span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">   \ttext.draw(<span class=\"keyword\">in</span>: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">200</span>, height: <span class=\"number\">60</span>), withAttributes: textAttributes)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> masklayer = <span class=\"type\">CALayer</span>() <span class=\"comment\">//遮罩层</span></span><br><span class=\"line\">masklayer.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">200</span>, height: <span class=\"number\">60</span>)</span><br><span class=\"line\">masklayer.backgroundColor = <span class=\"type\">UIColor</span>.clear.cgColor</span><br><span class=\"line\">masklayer.contents = image.cgImage</span><br><span class=\"line\">myview.layer.mask = masklayer <span class=\"comment\">//myview 其实是黑色的方块（带有动画），只露出来文字的形状</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-CAKeyFrameAnimation\"><a href=\"#2-CAKeyFrameAnimation\" class=\"headerlink\" title=\"2. CAKeyFrameAnimation\"></a>2. CAKeyFrameAnimation</h4><p>所谓的“关键帧动画”。与 BasicAnimation 的区别是： CABasicAnimation 只能设置起始和终止值，而 CAKeyFrameAnimation 可以用一个数组保存中间值，即记录下来“关键帧”的信息。</p>\n<p>这里可以设置 path（其实 CABasicAnimation 也可以设置 path ），让动画沿着轨迹运动。但是设置 path 之后，value 值将被忽略。</p>\n<p><strong>Demo</strong> - 沿路径运动（ UIBeizerPath ）</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/03/5932b0c3731fd.gif\" alt=\"沿路径运动动画\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> move = <span class=\"type\">CAKeyframeAnimation</span>(keyPath: <span class=\"string\">\"position\"</span>)</span><br><span class=\"line\">move.path = <span class=\"type\">UIBezierPath</span>(rect: <span class=\"type\">CGRect</span>(x: <span class=\"number\">120</span>+<span class=\"number\">25</span>, y: <span class=\"number\">200</span>+<span class=\"number\">25</span>, width: <span class=\"number\">100</span>, \theight: <span class=\"number\">100</span>)).cgPath</span><br><span class=\"line\">move.duration = <span class=\"number\">3</span></span><br><span class=\"line\">move.repeatCount = .infinity</span><br><span class=\"line\">        </span><br><span class=\"line\">myview.layer.add(move, forKey: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>这里似乎不能直接设置反向运动。想要反向运动需要自己绘制一个反向的矩形。</p>\n<p><strong>Demo</strong> - 圆形进度条（ CAShapeLayer ）</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/03/5932b5ef6a311.gif\" alt=\"圆形进度条\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> shape = <span class=\"type\">CAShapeLayer</span>()</span><br><span class=\"line\">shape.frame = myview.bounds</span><br><span class=\"line\">shape.path = <span class=\"type\">UIBezierPath</span>(ovalIn: shape.frame).cgPath</span><br><span class=\"line\">shape.fillColor = <span class=\"type\">UIColor</span>.clear.cgColor</span><br><span class=\"line\">shape.lineWidth = <span class=\"number\">5</span></span><br><span class=\"line\">shape.strokeColor = <span class=\"type\">UIColor</span>.red.cgColor</span><br><span class=\"line\">        </span><br><span class=\"line\">myview.layer.addSublayer(shape)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> anim = <span class=\"type\">CAKeyframeAnimation</span>(keyPath: <span class=\"string\">\"strokeEnd\"</span>) <span class=\"comment\">//strokeEnd 也是可以动的参数</span></span><br><span class=\"line\">anim.values = [<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">anim.keyTimes = [<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">anim.duration = <span class=\"number\">3</span></span><br><span class=\"line\">anim.autoreverses = <span class=\"literal\">true</span></span><br><span class=\"line\">anim.repeatCount = .infinity</span><br><span class=\"line\">        </span><br><span class=\"line\">shape.add(anim, forKey: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-CATransition\"><a href=\"#3-CATransition\" class=\"headerlink\" title=\"3. CATransition\"></a>3. CATransition</h4><p><strong>Demo</strong> - 简单的转场动画（渐变效果）</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/03/5932c324448aa.gif\" alt=\"转场动画\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = <span class=\"type\">UIButton</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">100</span>, y: <span class=\"number\">100</span>, width: <span class=\"number\">50</span>, height: <span class=\"number\">50</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.white</span><br><span class=\"line\">        view.addSubview(button)</span><br><span class=\"line\">        button.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        button.addTarget(<span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">ViewController</span>.onClick), <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClick</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> vc = <span class=\"type\">YellowViewController</span>()</span><br><span class=\"line\">        vc.transitioningDelegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">        present(vc, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Animator</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YellowViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.yellow</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animator</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> duration = <span class=\"number\">2.0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transitionDuration</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class=\"type\">TimeInterval</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> duration</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animateTransition</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> containerView = transitionContext.containerView</span><br><span class=\"line\">        <span class=\"keyword\">let</span> toView = transitionContext.view(forKey: .to)!</span><br><span class=\"line\">        containerView.addSubview(toView)</span><br><span class=\"line\">        toView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class=\"line\">            toView.alpha = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">ViewController</span>()</span><br></pre></td></tr></table></figure>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><h4 id=\"1-CoreAnimation-的工作机制\"><a href=\"#1-CoreAnimation-的工作机制\" class=\"headerlink\" title=\"1. CoreAnimation 的工作机制\"></a>1. CoreAnimation 的工作机制</h4><p>CoreAnimation 是基于 layer 的动画，通过 GPU 来渲染。而基于 view 的动画是通过调用 drawRect 方法使用新参数不断的重绘内容，使用 CPU 来不断的计算，因而效率很低。</p>\n<h4 id=\"2-为什么动画结束后返回原状态？为什么动画在移动过程中我们不能进行操作？\"><a href=\"#2-为什么动画结束后返回原状态？为什么动画在移动过程中我们不能进行操作？\" class=\"headerlink\" title=\"2. 为什么动画结束后返回原状态？为什么动画在移动过程中我们不能进行操作？\"></a>2. 为什么动画结束后返回原状态？为什么动画在移动过程中我们不能进行操作？</h4><p>因为在动画运行时，我们看到的并不是该控件本身，而是一个假的“躯壳”，即 presentation layer 。真实的控件会被隐藏，而只有视觉层在做动画，所以移动的过程中不能做任何操作。一旦动画结束， presentation layer 就会被移除，真实的控件又会显示出来，这就是为什么动画结束后会返回到原状态：因为动画并没有修改控件本身的属性，结束后又回到了 model layer 的值。有时候会为了不让动画结束后跳回原状态而设置 fillMode 参数，但是这也这是让 presentation layer 停留在最后的位置。如果你的控件是可以操作的，那就不可以这么做。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-Core-Animation-动画\"><a href=\"#iOS-Core-Animation-动画\" class=\"headerlink\" title=\"iOS Core-Animation 动画\"></a>iOS Core-Animation 动画</h1><h3 id=\"熟悉-Core-Animation-框架\"><a href=\"#熟悉-Core-Animation-框架\" class=\"headerlink\" title=\"熟悉 Core-Animation 框架\"></a>熟悉 Core-Animation 框架</h3><p>Core-Animation ，中文译为“核心动画”，是 iOS 和 macOS 上一组非常强大的 API 。它的最底层是 GPU ，上层是 OpenGL ／ OpenGL ES 和 CoreGraphics ，这两个框架提供了一些接口来访问 GPU 。最上层 CoreAnimation 提供了大量封装好的 API 来实现简单或复杂的动画。程序员只需要编写很少的代码，比如修改几个参数，或者设置起始、终止状态，就可以制作出很精美的动画。</p>\n<p>Core-Animation 是基于 Layer 的，而非 UIView 。利用 GPU 来计算，所以速度快、效率高，且不会拖累 CPU 造成程序卡顿。所有的动画都是在后台执行的，不会阻塞主线程。</p>\n<h3 id=\"基本动画的使用\"><a href=\"#基本动画的使用\" class=\"headerlink\" title=\"基本动画的使用\"></a>基本动画的使用</h3><h4 id=\"1-CABasicAnimation\"><a href=\"#1-CABasicAnimation\" class=\"headerlink\" title=\"1. CABasicAnimation\"></a>1. CABasicAnimation</h4><p><strong>Demo</strong> - 模仿 iOS9 锁屏界面的“滑动以解锁”动画（在 iOS10 中这个动画已经被”按下主屏幕按钮以解锁“取代）</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/03/59319180d3293.gif\" alt=\"滑动解锁演示\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> gradientLayer = <span class=\"type\">CAGradientLayer</span>() <span class=\"comment\">//创建一个\"梯度\"层</span></span><br><span class=\"line\">gradientLayer.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">200</span>, height: <span class=\"number\">60</span>)</span><br><span class=\"line\"><span class=\"comment\">//设置起始位置和终止位置，由于是水平的，所以 0.5 也可以改成任何其他的值，没有其他影响</span></span><br><span class=\"line\">gradientLayer.startPoint = <span class=\"type\">CGPoint</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0.5</span>)</span><br><span class=\"line\">gradientLayer.endPoint = <span class=\"type\">CGPoint</span>(x: <span class=\"number\">1</span>, y: <span class=\"number\">0.5</span>)</span><br><span class=\"line\"><span class=\"comment\">//黑-白-黑的颜色渐变</span></span><br><span class=\"line\">gradientLayer.colors = [<span class=\"type\">UIColor</span>.black.cgColor,<span class=\"type\">UIColor</span>.white.cgColor,<span class=\"type\">UIColor</span>.black.cgColor]</span><br><span class=\"line\"></span><br><span class=\"line\">gradientLayer.locations = [<span class=\"number\">0</span>,<span class=\"number\">0.5</span>,<span class=\"number\">1</span>] <span class=\"comment\">//每个颜色处于的位置，即白色在正中间，只要让这里动起来就可以了</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> myview = <span class=\"type\">UIView</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">120</span>, y: <span class=\"number\">200</span>, width: <span class=\"number\">200</span>, height: <span class=\"number\">60</span>))</span><br><span class=\"line\">myview.layer.addSublayer(gradientLayer) <span class=\"comment\">//把梯度层加入</span></span><br><span class=\"line\">view.addSubview(myview)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"comment\">// CABasicAnimation 部分</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> gradient = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"locations\"</span>)</span><br><span class=\"line\">gradient.fromValue = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0.25</span>]</span><br><span class=\"line\">gradient.toValue = [<span class=\"number\">0.75</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">gradient.duration = <span class=\"number\">3</span></span><br><span class=\"line\">gradient.repeatCount = <span class=\"type\">Float</span>.infinity <span class=\"comment\">//无限循环</span></span><br><span class=\"line\"></span><br><span class=\"line\">gradientLayer.add(gradient, forKey: <span class=\"literal\">nil</span>) <span class=\"comment\">//添加动画</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> text:<span class=\"type\">NSString</span> = <span class=\"string\">\"滑动以解锁\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下面把文字转化为图片</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> textAttributes:[<span class=\"type\">String</span>:<span class=\"type\">Any</span>] = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> style = <span class=\"type\">NSMutableParagraphStyle</span>()</span><br><span class=\"line\">    style.alignment = .center</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"type\">NSFontAttributeName</span>: <span class=\"type\">UIFont</span>.systemFont(ofSize: <span class=\"number\">25</span>),<span class=\"type\">NSParagraphStyleAttributeName</span>: style]</span><br><span class=\"line\">&#125;()</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> image = <span class=\"type\">UIGraphicsImageRenderer</span>(size: <span class=\"type\">CGSize</span>(width: <span class=\"number\">200</span>, height: <span class=\"number\">60</span>)).image(actions: &#123;</span><br><span class=\"line\">\t<span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">   \ttext.draw(<span class=\"keyword\">in</span>: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">200</span>, height: <span class=\"number\">60</span>), withAttributes: textAttributes)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> masklayer = <span class=\"type\">CALayer</span>() <span class=\"comment\">//遮罩层</span></span><br><span class=\"line\">masklayer.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">200</span>, height: <span class=\"number\">60</span>)</span><br><span class=\"line\">masklayer.backgroundColor = <span class=\"type\">UIColor</span>.clear.cgColor</span><br><span class=\"line\">masklayer.contents = image.cgImage</span><br><span class=\"line\">myview.layer.mask = masklayer <span class=\"comment\">//myview 其实是黑色的方块（带有动画），只露出来文字的形状</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-CAKeyFrameAnimation\"><a href=\"#2-CAKeyFrameAnimation\" class=\"headerlink\" title=\"2. CAKeyFrameAnimation\"></a>2. CAKeyFrameAnimation</h4><p>所谓的“关键帧动画”。与 BasicAnimation 的区别是： CABasicAnimation 只能设置起始和终止值，而 CAKeyFrameAnimation 可以用一个数组保存中间值，即记录下来“关键帧”的信息。</p>\n<p>这里可以设置 path（其实 CABasicAnimation 也可以设置 path ），让动画沿着轨迹运动。但是设置 path 之后，value 值将被忽略。</p>\n<p><strong>Demo</strong> - 沿路径运动（ UIBeizerPath ）</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/03/5932b0c3731fd.gif\" alt=\"沿路径运动动画\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> move = <span class=\"type\">CAKeyframeAnimation</span>(keyPath: <span class=\"string\">\"position\"</span>)</span><br><span class=\"line\">move.path = <span class=\"type\">UIBezierPath</span>(rect: <span class=\"type\">CGRect</span>(x: <span class=\"number\">120</span>+<span class=\"number\">25</span>, y: <span class=\"number\">200</span>+<span class=\"number\">25</span>, width: <span class=\"number\">100</span>, \theight: <span class=\"number\">100</span>)).cgPath</span><br><span class=\"line\">move.duration = <span class=\"number\">3</span></span><br><span class=\"line\">move.repeatCount = .infinity</span><br><span class=\"line\">        </span><br><span class=\"line\">myview.layer.add(move, forKey: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>这里似乎不能直接设置反向运动。想要反向运动需要自己绘制一个反向的矩形。</p>\n<p><strong>Demo</strong> - 圆形进度条（ CAShapeLayer ）</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/03/5932b5ef6a311.gif\" alt=\"圆形进度条\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> shape = <span class=\"type\">CAShapeLayer</span>()</span><br><span class=\"line\">shape.frame = myview.bounds</span><br><span class=\"line\">shape.path = <span class=\"type\">UIBezierPath</span>(ovalIn: shape.frame).cgPath</span><br><span class=\"line\">shape.fillColor = <span class=\"type\">UIColor</span>.clear.cgColor</span><br><span class=\"line\">shape.lineWidth = <span class=\"number\">5</span></span><br><span class=\"line\">shape.strokeColor = <span class=\"type\">UIColor</span>.red.cgColor</span><br><span class=\"line\">        </span><br><span class=\"line\">myview.layer.addSublayer(shape)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> anim = <span class=\"type\">CAKeyframeAnimation</span>(keyPath: <span class=\"string\">\"strokeEnd\"</span>) <span class=\"comment\">//strokeEnd 也是可以动的参数</span></span><br><span class=\"line\">anim.values = [<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">anim.keyTimes = [<span class=\"number\">0</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">anim.duration = <span class=\"number\">3</span></span><br><span class=\"line\">anim.autoreverses = <span class=\"literal\">true</span></span><br><span class=\"line\">anim.repeatCount = .infinity</span><br><span class=\"line\">        </span><br><span class=\"line\">shape.add(anim, forKey: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-CATransition\"><a href=\"#3-CATransition\" class=\"headerlink\" title=\"3. CATransition\"></a>3. CATransition</h4><p><strong>Demo</strong> - 简单的转场动画（渐变效果）</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/06/03/5932c324448aa.gif\" alt=\"转场动画\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> button = <span class=\"type\">UIButton</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">100</span>, y: <span class=\"number\">100</span>, width: <span class=\"number\">50</span>, height: <span class=\"number\">50</span>))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.white</span><br><span class=\"line\">        view.addSubview(button)</span><br><span class=\"line\">        button.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        button.addTarget(<span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">ViewController</span>.onClick), <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClick</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> vc = <span class=\"type\">YellowViewController</span>()</span><br><span class=\"line\">        vc.transitioningDelegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">        present(vc, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Animator</span>()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">YellowViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.yellow</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animator</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> duration = <span class=\"number\">2.0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transitionDuration</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class=\"type\">TimeInterval</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> duration</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animateTransition</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> containerView = transitionContext.containerView</span><br><span class=\"line\">        <span class=\"keyword\">let</span> toView = transitionContext.view(forKey: .to)!</span><br><span class=\"line\">        containerView.addSubview(toView)</span><br><span class=\"line\">        toView.alpha = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class=\"line\">            toView.alpha = <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">ViewController</span>()</span><br></pre></td></tr></table></figure>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><h4 id=\"1-CoreAnimation-的工作机制\"><a href=\"#1-CoreAnimation-的工作机制\" class=\"headerlink\" title=\"1. CoreAnimation 的工作机制\"></a>1. CoreAnimation 的工作机制</h4><p>CoreAnimation 是基于 layer 的动画，通过 GPU 来渲染。而基于 view 的动画是通过调用 drawRect 方法使用新参数不断的重绘内容，使用 CPU 来不断的计算，因而效率很低。</p>\n<h4 id=\"2-为什么动画结束后返回原状态？为什么动画在移动过程中我们不能进行操作？\"><a href=\"#2-为什么动画结束后返回原状态？为什么动画在移动过程中我们不能进行操作？\" class=\"headerlink\" title=\"2. 为什么动画结束后返回原状态？为什么动画在移动过程中我们不能进行操作？\"></a>2. 为什么动画结束后返回原状态？为什么动画在移动过程中我们不能进行操作？</h4><p>因为在动画运行时，我们看到的并不是该控件本身，而是一个假的“躯壳”，即 presentation layer 。真实的控件会被隐藏，而只有视觉层在做动画，所以移动的过程中不能做任何操作。一旦动画结束， presentation layer 就会被移除，真实的控件又会显示出来，这就是为什么动画结束后会返回到原状态：因为动画并没有修改控件本身的属性，结束后又回到了 model layer 的值。有时候会为了不让动画结束后跳回原状态而设置 fillMode 参数，但是这也这是让 presentation layer 停留在最后的位置。如果你的控件是可以操作的，那就不可以这么做。</p>\n"},{"title":"iOS 自定义TabBar的正确姿势","date":"2017-09-02T05:45:10.000Z","_content":"\n# iOS 自定义TabBar的正确姿势\n\n看默认风格的 TabBar 久了未免会觉得有些审美疲劳，于是就想自定义 TabBar，加一些小动画。自定义 TabBar 并不困难，无非就是写一个 UITabBarController 的子类，然后在 storyboard 中设置一下嘛。事实上，我之前也写过这样的一个小 demo，放在了 gitlab 上：[TabBarAnimation](https://git.bingyan.net/BeBeBerr/TabBarAnimation) 。这次想在自己的小项目上应用一下，美滋滋地直接把代码拷贝过来，却出现了不少问题。经过一番周折，终于发现了自定义 TabBar 的正确姿势。\n\n### 在 Demo 中的实现思路\n\n```swift\nclass CSTabBarController: UITabBarController {\n    var imageViews = [UIImageView]()\n    let mainView = UIView()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        mainView.frame = self.tabBar.bounds\n        self.view.addSubview(mainView)\n        //balabal......\n        self.tabBar.removeFromSuperview()\n    }\n \n    func onClickTabBarButton(sender:UIButton) {\n        //balabala......\n    }\n}\n```\n\n思路很简单。既然是自定义 TabBar，而且没办法在原来的 BarItem 上修改，那我就把原来的 TabBar 移除，然后在 view 上新建一个 view 冒充 TabBar 嘛！只要把原来 Item 的位置上放上按钮，就足以以假乱真了。而且在 demo 中，这个方法的确奏效。\n\n### 出现的问题 & 前期解决方案\n\n在 demo 中，我只做了 TabBar 的小动画，比较简单，所以没有暴露出来这些隐藏的问题。而放在一个实际的项目中，这些问题就变得不可容忍了，主要的问题有：\n\n- TabBar 丢失了半透明、模糊效果。\n- 顶部缺少了一条浅灰色的分界线。\n- 即使设置了 hideBottomBarOnPush，TabBar 也不会隐藏。\n\n作为一个优秀的开发者（大雾），这些小小的问题怎么能难倒我呢？既然丢失了模糊效果，那我就自己加一个 blurEffect layer 上去。缺少分界线，就自己画一条上去。不能隐藏这个问题比较麻烦，那就在每一个 viewWillAppear 中自己手动设置 isHide 嘛。虽然烦琐了点，但又不是不能用。\n\n手动做完这些之后，本以为就没什么问题了。但显然我还是太天真了。前两个问题还好，第三个手动隐藏缺暴露了更多的问题，而且难以容忍：\n\n- 隐藏和显示是突然出现的，而系统默认的是有一个向左滑动的动画效果，显得太过突兀。\n- 进入下一级页面时（添加上去的自定义 view 刚刚隐藏），默认版本的 TabBar 突然出现了一下，即使已经把默认的 TabBar 从 superView 中移除了。虽然很细节，但如果用户仔细观察还是可以发现。\n- 默认状态下，右滑回到上一级的过程中，TabBar 是跟随上一级的视图一起滑动的，而在这里就直接出现了。\n- 如果在上面的状态下，用户一边滑动一边突然点按 TabBar 上的按钮，切换到另外的视图，那么 TabBar 就消失了。除非关闭程序再进入，否则就没有办法切换试图。虽然可能很少有用户这么做，但这对体验的影响非常大。\n\n### 正确的姿势\n\n其实解决方案非常简单，就是不要直接添加到 view 中，而是添加到 TabBar 中。这样无论是模糊效果、分界线还是自动隐藏，都与默认的逻辑一样了。这里特别需要注意的是，如果添加完了没有任何效果，检查一下是不是在设置 frame 的时候，不小心设置成了 TabBar 的 frame。因为是添加到 TabBar 上面，所以应该设置为 TabBar 的 bounds（而如果项之前那样添加到 view 上，就需要用 frame）。单这样还不够，会出现和默认的 TabBar 重叠在一起的情况。所以需要在 viewWillAppear 中移除所有的子控件，再重新添加。\n\n完整的代码（点击后有弹性放大效果、无提示文字）：\n\n```swift\nclass CSTabBarController: UITabBarController {\n\n    var imageViews = [UIImageView]()\n    let mainView = UIView()\n   \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        mainView.frame = self.tabBar.bounds\n    \n        mainView.backgroundColor = UIColor.clear\n        \n        let itemWidth = mainView.frame.width / CGFloat(viewControllers!.count)\n        \n        for i in 0..<viewControllers!.count {\n            \n            let button = UIButton(frame: CGRect(x: itemWidth * CGFloat(i), y: 0, width: itemWidth, height: mainView.frame.height))\n            button.backgroundColor = UIColor.clear\n            button.tag = i\n            button.addTarget(self, action: #selector(CSTabBarController.onClickTabBarButton(sender:)), for: .touchUpInside)\n            mainView.addSubview(button)\n            \n            var imageView = UIImageView()\n            switch i {\n            case 0:\n                imageView = UIImageView(image: UIImage(named: \"home\")?.withRenderingMode(.alwaysTemplate))\n            case 1:\n                imageView = UIImageView(image: UIImage(named: \"schedule\")?.withRenderingMode(.alwaysTemplate))\n            case 2:\n                imageView = UIImageView(image: UIImage(named: \"setting\")?.withRenderingMode(.alwaysTemplate))\n            default:\n                break\n            }\n            if i > 0 {\n                imageView.tintColor = UIColor.gray\n            } else {\n                imageView.tintColor = UIColor.flatGreen\n            }\n            \n            imageView.frame = CGRect(x: button.frame.midX - 11, y: button.frame.midY - 11, width: 22, height: 22)\n            mainView.addSubview(imageView)\n            imageViews.append(imageView)\n        }\n    }\n    \n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        let _ = tabBar.subviews.map({$0.removeFromSuperview()})\n        tabBar.addSubview(mainView)\n    }\n    \n    func onClickTabBarButton(sender:UIButton) {\n        if self.selectedIndex == sender.tag {\n            return\n        }\n        \n        for imageView in imageViews {\n            imageView.tintColor = UIColor.gray\n        }\n        \n        self.selectedIndex = sender.tag\n        \n        UIView.animate(withDuration: 1, animations: {\n            self.imageViews[sender.tag].tintColor = UIColor.flatGreen\n        })\n        \n        let bigger = CABasicAnimation(keyPath: \"transform.scale\")\n        bigger.fromValue = 1\n        bigger.toValue = 1.3\n        bigger.duration = 0.1\n        \n        let zoom = CASpringAnimation(keyPath: \"transform.scale\")\n        zoom.fromValue = 1.3\n        zoom.toValue = 1\n        zoom.duration = 0.5\n        zoom.damping = 5\n   \n        imageViews[sender.tag].layer.add(bigger, forKey: nil)\n        zoom.beginTime = CACurrentMediaTime() + 0.1\n        imageViews[sender.tag].layer.add(zoom, forKey: nil)\n        \n    }\n}\n```","source":"_posts/iOS-自定义TabBar的正确姿势.md","raw":"---\ntitle: iOS 自定义TabBar的正确姿势\ndate: 2017-09-02 13:45:10\ntags:\n---\n\n# iOS 自定义TabBar的正确姿势\n\n看默认风格的 TabBar 久了未免会觉得有些审美疲劳，于是就想自定义 TabBar，加一些小动画。自定义 TabBar 并不困难，无非就是写一个 UITabBarController 的子类，然后在 storyboard 中设置一下嘛。事实上，我之前也写过这样的一个小 demo，放在了 gitlab 上：[TabBarAnimation](https://git.bingyan.net/BeBeBerr/TabBarAnimation) 。这次想在自己的小项目上应用一下，美滋滋地直接把代码拷贝过来，却出现了不少问题。经过一番周折，终于发现了自定义 TabBar 的正确姿势。\n\n### 在 Demo 中的实现思路\n\n```swift\nclass CSTabBarController: UITabBarController {\n    var imageViews = [UIImageView]()\n    let mainView = UIView()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        mainView.frame = self.tabBar.bounds\n        self.view.addSubview(mainView)\n        //balabal......\n        self.tabBar.removeFromSuperview()\n    }\n \n    func onClickTabBarButton(sender:UIButton) {\n        //balabala......\n    }\n}\n```\n\n思路很简单。既然是自定义 TabBar，而且没办法在原来的 BarItem 上修改，那我就把原来的 TabBar 移除，然后在 view 上新建一个 view 冒充 TabBar 嘛！只要把原来 Item 的位置上放上按钮，就足以以假乱真了。而且在 demo 中，这个方法的确奏效。\n\n### 出现的问题 & 前期解决方案\n\n在 demo 中，我只做了 TabBar 的小动画，比较简单，所以没有暴露出来这些隐藏的问题。而放在一个实际的项目中，这些问题就变得不可容忍了，主要的问题有：\n\n- TabBar 丢失了半透明、模糊效果。\n- 顶部缺少了一条浅灰色的分界线。\n- 即使设置了 hideBottomBarOnPush，TabBar 也不会隐藏。\n\n作为一个优秀的开发者（大雾），这些小小的问题怎么能难倒我呢？既然丢失了模糊效果，那我就自己加一个 blurEffect layer 上去。缺少分界线，就自己画一条上去。不能隐藏这个问题比较麻烦，那就在每一个 viewWillAppear 中自己手动设置 isHide 嘛。虽然烦琐了点，但又不是不能用。\n\n手动做完这些之后，本以为就没什么问题了。但显然我还是太天真了。前两个问题还好，第三个手动隐藏缺暴露了更多的问题，而且难以容忍：\n\n- 隐藏和显示是突然出现的，而系统默认的是有一个向左滑动的动画效果，显得太过突兀。\n- 进入下一级页面时（添加上去的自定义 view 刚刚隐藏），默认版本的 TabBar 突然出现了一下，即使已经把默认的 TabBar 从 superView 中移除了。虽然很细节，但如果用户仔细观察还是可以发现。\n- 默认状态下，右滑回到上一级的过程中，TabBar 是跟随上一级的视图一起滑动的，而在这里就直接出现了。\n- 如果在上面的状态下，用户一边滑动一边突然点按 TabBar 上的按钮，切换到另外的视图，那么 TabBar 就消失了。除非关闭程序再进入，否则就没有办法切换试图。虽然可能很少有用户这么做，但这对体验的影响非常大。\n\n### 正确的姿势\n\n其实解决方案非常简单，就是不要直接添加到 view 中，而是添加到 TabBar 中。这样无论是模糊效果、分界线还是自动隐藏，都与默认的逻辑一样了。这里特别需要注意的是，如果添加完了没有任何效果，检查一下是不是在设置 frame 的时候，不小心设置成了 TabBar 的 frame。因为是添加到 TabBar 上面，所以应该设置为 TabBar 的 bounds（而如果项之前那样添加到 view 上，就需要用 frame）。单这样还不够，会出现和默认的 TabBar 重叠在一起的情况。所以需要在 viewWillAppear 中移除所有的子控件，再重新添加。\n\n完整的代码（点击后有弹性放大效果、无提示文字）：\n\n```swift\nclass CSTabBarController: UITabBarController {\n\n    var imageViews = [UIImageView]()\n    let mainView = UIView()\n   \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        mainView.frame = self.tabBar.bounds\n    \n        mainView.backgroundColor = UIColor.clear\n        \n        let itemWidth = mainView.frame.width / CGFloat(viewControllers!.count)\n        \n        for i in 0..<viewControllers!.count {\n            \n            let button = UIButton(frame: CGRect(x: itemWidth * CGFloat(i), y: 0, width: itemWidth, height: mainView.frame.height))\n            button.backgroundColor = UIColor.clear\n            button.tag = i\n            button.addTarget(self, action: #selector(CSTabBarController.onClickTabBarButton(sender:)), for: .touchUpInside)\n            mainView.addSubview(button)\n            \n            var imageView = UIImageView()\n            switch i {\n            case 0:\n                imageView = UIImageView(image: UIImage(named: \"home\")?.withRenderingMode(.alwaysTemplate))\n            case 1:\n                imageView = UIImageView(image: UIImage(named: \"schedule\")?.withRenderingMode(.alwaysTemplate))\n            case 2:\n                imageView = UIImageView(image: UIImage(named: \"setting\")?.withRenderingMode(.alwaysTemplate))\n            default:\n                break\n            }\n            if i > 0 {\n                imageView.tintColor = UIColor.gray\n            } else {\n                imageView.tintColor = UIColor.flatGreen\n            }\n            \n            imageView.frame = CGRect(x: button.frame.midX - 11, y: button.frame.midY - 11, width: 22, height: 22)\n            mainView.addSubview(imageView)\n            imageViews.append(imageView)\n        }\n    }\n    \n    override func viewWillAppear(_ animated: Bool) {\n        super.viewWillAppear(animated)\n        let _ = tabBar.subviews.map({$0.removeFromSuperview()})\n        tabBar.addSubview(mainView)\n    }\n    \n    func onClickTabBarButton(sender:UIButton) {\n        if self.selectedIndex == sender.tag {\n            return\n        }\n        \n        for imageView in imageViews {\n            imageView.tintColor = UIColor.gray\n        }\n        \n        self.selectedIndex = sender.tag\n        \n        UIView.animate(withDuration: 1, animations: {\n            self.imageViews[sender.tag].tintColor = UIColor.flatGreen\n        })\n        \n        let bigger = CABasicAnimation(keyPath: \"transform.scale\")\n        bigger.fromValue = 1\n        bigger.toValue = 1.3\n        bigger.duration = 0.1\n        \n        let zoom = CASpringAnimation(keyPath: \"transform.scale\")\n        zoom.fromValue = 1.3\n        zoom.toValue = 1\n        zoom.duration = 0.5\n        zoom.damping = 5\n   \n        imageViews[sender.tag].layer.add(bigger, forKey: nil)\n        zoom.beginTime = CACurrentMediaTime() + 0.1\n        imageViews[sender.tag].layer.add(zoom, forKey: nil)\n        \n    }\n}\n```","slug":"iOS-自定义TabBar的正确姿势","published":1,"updated":"2020-01-04T08:16:16.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv380010ljc37elewzb6","content":"<h1 id=\"iOS-自定义TabBar的正确姿势\"><a href=\"#iOS-自定义TabBar的正确姿势\" class=\"headerlink\" title=\"iOS 自定义TabBar的正确姿势\"></a>iOS 自定义TabBar的正确姿势</h1><p>看默认风格的 TabBar 久了未免会觉得有些审美疲劳，于是就想自定义 TabBar，加一些小动画。自定义 TabBar 并不困难，无非就是写一个 UITabBarController 的子类，然后在 storyboard 中设置一下嘛。事实上，我之前也写过这样的一个小 demo，放在了 gitlab 上：<a href=\"https://git.bingyan.net/BeBeBerr/TabBarAnimation\">TabBarAnimation</a> 。这次想在自己的小项目上应用一下，美滋滋地直接把代码拷贝过来，却出现了不少问题。经过一番周折，终于发现了自定义 TabBar 的正确姿势。</p>\n<h3 id=\"在-Demo-中的实现思路\"><a href=\"#在-Demo-中的实现思路\" class=\"headerlink\" title=\"在 Demo 中的实现思路\"></a>在 Demo 中的实现思路</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CSTabBarController</span>: <span class=\"title\">UITabBarController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> imageViews = [<span class=\"type\">UIImageView</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mainView = <span class=\"type\">UIView</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        mainView.frame = <span class=\"keyword\">self</span>.tabBar.bounds</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.view.addSubview(mainView)</span><br><span class=\"line\">        <span class=\"comment\">//balabal......</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tabBar.removeFromSuperview()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClickTabBarButton</span><span class=\"params\">(sender:UIButton)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//balabala......</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思路很简单。既然是自定义 TabBar，而且没办法在原来的 BarItem 上修改，那我就把原来的 TabBar 移除，然后在 view 上新建一个 view 冒充 TabBar 嘛！只要把原来 Item 的位置上放上按钮，就足以以假乱真了。而且在 demo 中，这个方法的确奏效。</p>\n<h3 id=\"出现的问题-amp-前期解决方案\"><a href=\"#出现的问题-amp-前期解决方案\" class=\"headerlink\" title=\"出现的问题 &amp; 前期解决方案\"></a>出现的问题 &amp; 前期解决方案</h3><p>在 demo 中，我只做了 TabBar 的小动画，比较简单，所以没有暴露出来这些隐藏的问题。而放在一个实际的项目中，这些问题就变得不可容忍了，主要的问题有：</p>\n<ul>\n<li>TabBar 丢失了半透明、模糊效果。</li>\n<li>顶部缺少了一条浅灰色的分界线。</li>\n<li>即使设置了 hideBottomBarOnPush，TabBar 也不会隐藏。</li>\n</ul>\n<p>作为一个优秀的开发者（大雾），这些小小的问题怎么能难倒我呢？既然丢失了模糊效果，那我就自己加一个 blurEffect layer 上去。缺少分界线，就自己画一条上去。不能隐藏这个问题比较麻烦，那就在每一个 viewWillAppear 中自己手动设置 isHide 嘛。虽然烦琐了点，但又不是不能用。</p>\n<p>手动做完这些之后，本以为就没什么问题了。但显然我还是太天真了。前两个问题还好，第三个手动隐藏缺暴露了更多的问题，而且难以容忍：</p>\n<ul>\n<li>隐藏和显示是突然出现的，而系统默认的是有一个向左滑动的动画效果，显得太过突兀。</li>\n<li>进入下一级页面时（添加上去的自定义 view 刚刚隐藏），默认版本的 TabBar 突然出现了一下，即使已经把默认的 TabBar 从 superView 中移除了。虽然很细节，但如果用户仔细观察还是可以发现。</li>\n<li>默认状态下，右滑回到上一级的过程中，TabBar 是跟随上一级的视图一起滑动的，而在这里就直接出现了。</li>\n<li>如果在上面的状态下，用户一边滑动一边突然点按 TabBar 上的按钮，切换到另外的视图，那么 TabBar 就消失了。除非关闭程序再进入，否则就没有办法切换试图。虽然可能很少有用户这么做，但这对体验的影响非常大。</li>\n</ul>\n<h3 id=\"正确的姿势\"><a href=\"#正确的姿势\" class=\"headerlink\" title=\"正确的姿势\"></a>正确的姿势</h3><p>其实解决方案非常简单，就是不要直接添加到 view 中，而是添加到 TabBar 中。这样无论是模糊效果、分界线还是自动隐藏，都与默认的逻辑一样了。这里特别需要注意的是，如果添加完了没有任何效果，检查一下是不是在设置 frame 的时候，不小心设置成了 TabBar 的 frame。因为是添加到 TabBar 上面，所以应该设置为 TabBar 的 bounds（而如果项之前那样添加到 view 上，就需要用 frame）。单这样还不够，会出现和默认的 TabBar 重叠在一起的情况。所以需要在 viewWillAppear 中移除所有的子控件，再重新添加。</p>\n<p>完整的代码（点击后有弹性放大效果、无提示文字）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CSTabBarController</span>: <span class=\"title\">UITabBarController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> imageViews = [<span class=\"type\">UIImageView</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mainView = <span class=\"type\">UIView</span>()</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        mainView.frame = <span class=\"keyword\">self</span>.tabBar.bounds</span><br><span class=\"line\">    </span><br><span class=\"line\">        mainView.backgroundColor = <span class=\"type\">UIColor</span>.clear</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> itemWidth = mainView.frame.width / <span class=\"type\">CGFloat</span>(viewControllers!.<span class=\"built_in\">count</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;viewControllers!.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">let</span> button = <span class=\"type\">UIButton</span>(frame: <span class=\"type\">CGRect</span>(x: itemWidth * <span class=\"type\">CGFloat</span>(i), y: <span class=\"number\">0</span>, width: itemWidth, height: mainView.frame.height))</span><br><span class=\"line\">            button.backgroundColor = <span class=\"type\">UIColor</span>.clear</span><br><span class=\"line\">            button.tag = i</span><br><span class=\"line\">            button.addTarget(<span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">CSTabBarController</span>.onClickTabBarButton(sender:)), <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">            mainView.addSubview(button)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">var</span> imageView = <span class=\"type\">UIImageView</span>()</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> i &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                imageView = <span class=\"type\">UIImageView</span>(image: <span class=\"type\">UIImage</span>(named: <span class=\"string\">\"home\"</span>)?.withRenderingMode(.alwaysTemplate))</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                imageView = <span class=\"type\">UIImageView</span>(image: <span class=\"type\">UIImage</span>(named: <span class=\"string\">\"schedule\"</span>)?.withRenderingMode(.alwaysTemplate))</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                imageView = <span class=\"type\">UIImageView</span>(image: <span class=\"type\">UIImage</span>(named: <span class=\"string\">\"setting\"</span>)?.withRenderingMode(.alwaysTemplate))</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                imageView.tintColor = <span class=\"type\">UIColor</span>.gray</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                imageView.tintColor = <span class=\"type\">UIColor</span>.flatGreen</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            imageView.frame = <span class=\"type\">CGRect</span>(x: button.frame.midX - <span class=\"number\">11</span>, y: button.frame.midY - <span class=\"number\">11</span>, width: <span class=\"number\">22</span>, height: <span class=\"number\">22</span>)</span><br><span class=\"line\">            mainView.addSubview(imageView)</span><br><span class=\"line\">            imageViews.append(imageView)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewWillAppear</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewWillAppear(animated)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"number\">_</span> = tabBar.subviews.<span class=\"built_in\">map</span>(&#123;$<span class=\"number\">0</span>.removeFromSuperview()&#125;)</span><br><span class=\"line\">        tabBar.addSubview(mainView)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClickTabBarButton</span><span class=\"params\">(sender:UIButton)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.selectedIndex == sender.tag &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> imageView <span class=\"keyword\">in</span> imageViews &#123;</span><br><span class=\"line\">            imageView.tintColor = <span class=\"type\">UIColor</span>.gray</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">self</span>.selectedIndex = sender.tag</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">1</span>, animations: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.imageViews[sender.tag].tintColor = <span class=\"type\">UIColor</span>.flatGreen</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> bigger = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"transform.scale\"</span>)</span><br><span class=\"line\">        bigger.fromValue = <span class=\"number\">1</span></span><br><span class=\"line\">        bigger.toValue = <span class=\"number\">1.3</span></span><br><span class=\"line\">        bigger.duration = <span class=\"number\">0.1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> zoom = <span class=\"type\">CASpringAnimation</span>(keyPath: <span class=\"string\">\"transform.scale\"</span>)</span><br><span class=\"line\">        zoom.fromValue = <span class=\"number\">1.3</span></span><br><span class=\"line\">        zoom.toValue = <span class=\"number\">1</span></span><br><span class=\"line\">        zoom.duration = <span class=\"number\">0.5</span></span><br><span class=\"line\">        zoom.damping = <span class=\"number\">5</span></span><br><span class=\"line\">   </span><br><span class=\"line\">        imageViews[sender.tag].layer.add(bigger, forKey: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        zoom.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">0.1</span></span><br><span class=\"line\">        imageViews[sender.tag].layer.add(zoom, forKey: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-自定义TabBar的正确姿势\"><a href=\"#iOS-自定义TabBar的正确姿势\" class=\"headerlink\" title=\"iOS 自定义TabBar的正确姿势\"></a>iOS 自定义TabBar的正确姿势</h1><p>看默认风格的 TabBar 久了未免会觉得有些审美疲劳，于是就想自定义 TabBar，加一些小动画。自定义 TabBar 并不困难，无非就是写一个 UITabBarController 的子类，然后在 storyboard 中设置一下嘛。事实上，我之前也写过这样的一个小 demo，放在了 gitlab 上：<a href=\"https://git.bingyan.net/BeBeBerr/TabBarAnimation\">TabBarAnimation</a> 。这次想在自己的小项目上应用一下，美滋滋地直接把代码拷贝过来，却出现了不少问题。经过一番周折，终于发现了自定义 TabBar 的正确姿势。</p>\n<h3 id=\"在-Demo-中的实现思路\"><a href=\"#在-Demo-中的实现思路\" class=\"headerlink\" title=\"在 Demo 中的实现思路\"></a>在 Demo 中的实现思路</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CSTabBarController</span>: <span class=\"title\">UITabBarController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> imageViews = [<span class=\"type\">UIImageView</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mainView = <span class=\"type\">UIView</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        mainView.frame = <span class=\"keyword\">self</span>.tabBar.bounds</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.view.addSubview(mainView)</span><br><span class=\"line\">        <span class=\"comment\">//balabal......</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.tabBar.removeFromSuperview()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClickTabBarButton</span><span class=\"params\">(sender:UIButton)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//balabala......</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思路很简单。既然是自定义 TabBar，而且没办法在原来的 BarItem 上修改，那我就把原来的 TabBar 移除，然后在 view 上新建一个 view 冒充 TabBar 嘛！只要把原来 Item 的位置上放上按钮，就足以以假乱真了。而且在 demo 中，这个方法的确奏效。</p>\n<h3 id=\"出现的问题-amp-前期解决方案\"><a href=\"#出现的问题-amp-前期解决方案\" class=\"headerlink\" title=\"出现的问题 &amp; 前期解决方案\"></a>出现的问题 &amp; 前期解决方案</h3><p>在 demo 中，我只做了 TabBar 的小动画，比较简单，所以没有暴露出来这些隐藏的问题。而放在一个实际的项目中，这些问题就变得不可容忍了，主要的问题有：</p>\n<ul>\n<li>TabBar 丢失了半透明、模糊效果。</li>\n<li>顶部缺少了一条浅灰色的分界线。</li>\n<li>即使设置了 hideBottomBarOnPush，TabBar 也不会隐藏。</li>\n</ul>\n<p>作为一个优秀的开发者（大雾），这些小小的问题怎么能难倒我呢？既然丢失了模糊效果，那我就自己加一个 blurEffect layer 上去。缺少分界线，就自己画一条上去。不能隐藏这个问题比较麻烦，那就在每一个 viewWillAppear 中自己手动设置 isHide 嘛。虽然烦琐了点，但又不是不能用。</p>\n<p>手动做完这些之后，本以为就没什么问题了。但显然我还是太天真了。前两个问题还好，第三个手动隐藏缺暴露了更多的问题，而且难以容忍：</p>\n<ul>\n<li>隐藏和显示是突然出现的，而系统默认的是有一个向左滑动的动画效果，显得太过突兀。</li>\n<li>进入下一级页面时（添加上去的自定义 view 刚刚隐藏），默认版本的 TabBar 突然出现了一下，即使已经把默认的 TabBar 从 superView 中移除了。虽然很细节，但如果用户仔细观察还是可以发现。</li>\n<li>默认状态下，右滑回到上一级的过程中，TabBar 是跟随上一级的视图一起滑动的，而在这里就直接出现了。</li>\n<li>如果在上面的状态下，用户一边滑动一边突然点按 TabBar 上的按钮，切换到另外的视图，那么 TabBar 就消失了。除非关闭程序再进入，否则就没有办法切换试图。虽然可能很少有用户这么做，但这对体验的影响非常大。</li>\n</ul>\n<h3 id=\"正确的姿势\"><a href=\"#正确的姿势\" class=\"headerlink\" title=\"正确的姿势\"></a>正确的姿势</h3><p>其实解决方案非常简单，就是不要直接添加到 view 中，而是添加到 TabBar 中。这样无论是模糊效果、分界线还是自动隐藏，都与默认的逻辑一样了。这里特别需要注意的是，如果添加完了没有任何效果，检查一下是不是在设置 frame 的时候，不小心设置成了 TabBar 的 frame。因为是添加到 TabBar 上面，所以应该设置为 TabBar 的 bounds（而如果项之前那样添加到 view 上，就需要用 frame）。单这样还不够，会出现和默认的 TabBar 重叠在一起的情况。所以需要在 viewWillAppear 中移除所有的子控件，再重新添加。</p>\n<p>完整的代码（点击后有弹性放大效果、无提示文字）：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CSTabBarController</span>: <span class=\"title\">UITabBarController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> imageViews = [<span class=\"type\">UIImageView</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mainView = <span class=\"type\">UIView</span>()</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        mainView.frame = <span class=\"keyword\">self</span>.tabBar.bounds</span><br><span class=\"line\">    </span><br><span class=\"line\">        mainView.backgroundColor = <span class=\"type\">UIColor</span>.clear</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> itemWidth = mainView.frame.width / <span class=\"type\">CGFloat</span>(viewControllers!.<span class=\"built_in\">count</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;viewControllers!.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">let</span> button = <span class=\"type\">UIButton</span>(frame: <span class=\"type\">CGRect</span>(x: itemWidth * <span class=\"type\">CGFloat</span>(i), y: <span class=\"number\">0</span>, width: itemWidth, height: mainView.frame.height))</span><br><span class=\"line\">            button.backgroundColor = <span class=\"type\">UIColor</span>.clear</span><br><span class=\"line\">            button.tag = i</span><br><span class=\"line\">            button.addTarget(<span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">CSTabBarController</span>.onClickTabBarButton(sender:)), <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">            mainView.addSubview(button)</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">var</span> imageView = <span class=\"type\">UIImageView</span>()</span><br><span class=\"line\">            <span class=\"keyword\">switch</span> i &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                imageView = <span class=\"type\">UIImageView</span>(image: <span class=\"type\">UIImage</span>(named: <span class=\"string\">\"home\"</span>)?.withRenderingMode(.alwaysTemplate))</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                imageView = <span class=\"type\">UIImageView</span>(image: <span class=\"type\">UIImage</span>(named: <span class=\"string\">\"schedule\"</span>)?.withRenderingMode(.alwaysTemplate))</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                imageView = <span class=\"type\">UIImageView</span>(image: <span class=\"type\">UIImage</span>(named: <span class=\"string\">\"setting\"</span>)?.withRenderingMode(.alwaysTemplate))</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">                imageView.tintColor = <span class=\"type\">UIColor</span>.gray</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                imageView.tintColor = <span class=\"type\">UIColor</span>.flatGreen</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            imageView.frame = <span class=\"type\">CGRect</span>(x: button.frame.midX - <span class=\"number\">11</span>, y: button.frame.midY - <span class=\"number\">11</span>, width: <span class=\"number\">22</span>, height: <span class=\"number\">22</span>)</span><br><span class=\"line\">            mainView.addSubview(imageView)</span><br><span class=\"line\">            imageViews.append(imageView)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewWillAppear</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewWillAppear(animated)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> <span class=\"number\">_</span> = tabBar.subviews.<span class=\"built_in\">map</span>(&#123;$<span class=\"number\">0</span>.removeFromSuperview()&#125;)</span><br><span class=\"line\">        tabBar.addSubview(mainView)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClickTabBarButton</span><span class=\"params\">(sender:UIButton)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.selectedIndex == sender.tag &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> imageView <span class=\"keyword\">in</span> imageViews &#123;</span><br><span class=\"line\">            imageView.tintColor = <span class=\"type\">UIColor</span>.gray</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">self</span>.selectedIndex = sender.tag</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: <span class=\"number\">1</span>, animations: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.imageViews[sender.tag].tintColor = <span class=\"type\">UIColor</span>.flatGreen</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> bigger = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"transform.scale\"</span>)</span><br><span class=\"line\">        bigger.fromValue = <span class=\"number\">1</span></span><br><span class=\"line\">        bigger.toValue = <span class=\"number\">1.3</span></span><br><span class=\"line\">        bigger.duration = <span class=\"number\">0.1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> zoom = <span class=\"type\">CASpringAnimation</span>(keyPath: <span class=\"string\">\"transform.scale\"</span>)</span><br><span class=\"line\">        zoom.fromValue = <span class=\"number\">1.3</span></span><br><span class=\"line\">        zoom.toValue = <span class=\"number\">1</span></span><br><span class=\"line\">        zoom.duration = <span class=\"number\">0.5</span></span><br><span class=\"line\">        zoom.damping = <span class=\"number\">5</span></span><br><span class=\"line\">   </span><br><span class=\"line\">        imageViews[sender.tag].layer.add(bigger, forKey: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        zoom.beginTime = <span class=\"type\">CACurrentMediaTime</span>() + <span class=\"number\">0.1</span></span><br><span class=\"line\">        imageViews[sender.tag].layer.add(zoom, forKey: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"iOS限制UIScrollView允许滑动角度","date":"2017-11-13T15:13:09.000Z","_content":"\n# iOS 限定 UIScrollView 允许滑动角度\n\n本文主要解决 UIScrollView 中自己添加的滑动手势与它本身自带的滑动手势冲突的问题。\n\n最近做的项目中，有一个需求是在一个 UITextView 中，把手指滑动过程中覆盖的文字标记为红色（以备后续使用）。而由于文本可能很长，上下滚动 UITextView 的功能要保留，就像下面这样：\n\n![scroll](/img/限定ScrollView允许滑动角度/scroll.gif)\n\n滑动把文本标记为红色比较简单。只需要在 UITextView 上添加一个 UIPanGestureRecognizer ，手指移动的时候找出坐标对应的文字就好了。要命的是，这会带来手势冲突：所有的滑动事件都被自己添加的这个手势捕获了，UITextView 没有办法上下滚动。一个直观的想法就是，我们可以给 UITextView 限定一个允许滚动的角度，比如，用户以 80～90 度的方向（非常竖直的方向）滑动时，认为是在滚动视图；而以一个较为水平的方向滑动时，认为在标记文字。\n\n但是怎么去判定方向呢？我们固然可以在自己添加的手势中根据坐标算出来角度，但是这样没有办法限制住 UITextView 的滚动。UIScrollView 的代理方法也做不到限制它滚动。所以只能另辟蹊径了！\n\n首先，我们要覆盖掉 UITextView 自己判断是否执行手势的方法，借此来控制手势的成功与失败：\n\n```swift\nclass TextView: UITextView {\n    override func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {\n        if gestureRecognizer == self.panGestureRecognizer {\n            let point = (gestureRecognizer as! UIPanGestureRecognizer).translation(in: self)\n            if fabs(point.y) / fabs(point.x) < 1 {\n                return false\n            }\n        }\n        return super.gestureRecognizerShouldBegin(gestureRecognizer)\n    }\n}\n```\n\n这里我们用自己的 TextView 来继承了 UITextView。当 x 与 y 成一定比值时（这里是大于 45 度，因为 arctan(1) = 45度）返回 false 令手势失败。\n\n然后，在自己的 ViewController 中，设置自己添加的手势必须要在 UITextView 自己的滑动手势失败后（即角度比较水平的时候）才开始识别。\n\n```swift\nfunc gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool {\n    if gestureRecognizer == textView.panGestureRecognizer {\n        return false\n    } else {\n        return true\n    }\n}\n```\n\n大功告成！\n\n但是程序一运行，发现不对劲了。每次滑动一段时间之后，文字才开始变红，这个体验就很不好了。仔细一想，原来是因为自己的手势必须要等待滑动手势失败之后才能开始识别。而这需要时间。所以我们只好把逻辑反过来，竖直滑动的时候让自己的手势失败；再让 UITextView 的手势等待我们自己的手势失败后再开始识别。\n\n最终的代码：\n\n```swift\nclass TextReciteViewController: UIViewController, UITextViewDelegate, UIGestureRecognizerDelegate {\n\n    let textView = TextView() //要用自己的 TextView 而不是 UITextView 了\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n      \t//......\n   \t\ttextView.delegate = self\n        let panGesture = UIPanGestureRecognizer(target: self, action: #selector(TextReciteViewController.panToSelectText(gesture:)))\n        panGesture.delegate = self\n        textView.addGestureRecognizer(panGesture)\n      \t//......\n    }\n\n    @objc func panToSelectText(gesture: UIPanGestureRecognizer) {\n      \t//把文字标记为红色\n        let location = gesture.location(in: textView)\n        //......\n    }\n  \n    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool {\n        if otherGestureRecognizer == textView.panGestureRecognizer {\n            return true\n        } else {\n            return false\n        }\n    }\n}\n\nclass TextView: UITextView {\n    override func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {\n        if gestureRecognizer is UIPanGestureRecognizer && gestureRecognizer != self.panGestureRecognizer {\n            let point = (gestureRecognizer as! UIPanGestureRecognizer).translation(in: self)\n            if fabs(point.y) / fabs(point.x) > 0.15 {\n                return false\n            }\n        }\n        return super.gestureRecognizerShouldBegin(gestureRecognizer)\n    }\n}\n```\n\n最终就能实现一开始的动图啦！","source":"_posts/iOS限制UIScrollView允许滑动角度.md","raw":"---\ntitle: iOS限制UIScrollView允许滑动角度\ndate: 2017-11-13 23:13:09\ntags: 手势冲突\n---\n\n# iOS 限定 UIScrollView 允许滑动角度\n\n本文主要解决 UIScrollView 中自己添加的滑动手势与它本身自带的滑动手势冲突的问题。\n\n最近做的项目中，有一个需求是在一个 UITextView 中，把手指滑动过程中覆盖的文字标记为红色（以备后续使用）。而由于文本可能很长，上下滚动 UITextView 的功能要保留，就像下面这样：\n\n![scroll](/img/限定ScrollView允许滑动角度/scroll.gif)\n\n滑动把文本标记为红色比较简单。只需要在 UITextView 上添加一个 UIPanGestureRecognizer ，手指移动的时候找出坐标对应的文字就好了。要命的是，这会带来手势冲突：所有的滑动事件都被自己添加的这个手势捕获了，UITextView 没有办法上下滚动。一个直观的想法就是，我们可以给 UITextView 限定一个允许滚动的角度，比如，用户以 80～90 度的方向（非常竖直的方向）滑动时，认为是在滚动视图；而以一个较为水平的方向滑动时，认为在标记文字。\n\n但是怎么去判定方向呢？我们固然可以在自己添加的手势中根据坐标算出来角度，但是这样没有办法限制住 UITextView 的滚动。UIScrollView 的代理方法也做不到限制它滚动。所以只能另辟蹊径了！\n\n首先，我们要覆盖掉 UITextView 自己判断是否执行手势的方法，借此来控制手势的成功与失败：\n\n```swift\nclass TextView: UITextView {\n    override func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {\n        if gestureRecognizer == self.panGestureRecognizer {\n            let point = (gestureRecognizer as! UIPanGestureRecognizer).translation(in: self)\n            if fabs(point.y) / fabs(point.x) < 1 {\n                return false\n            }\n        }\n        return super.gestureRecognizerShouldBegin(gestureRecognizer)\n    }\n}\n```\n\n这里我们用自己的 TextView 来继承了 UITextView。当 x 与 y 成一定比值时（这里是大于 45 度，因为 arctan(1) = 45度）返回 false 令手势失败。\n\n然后，在自己的 ViewController 中，设置自己添加的手势必须要在 UITextView 自己的滑动手势失败后（即角度比较水平的时候）才开始识别。\n\n```swift\nfunc gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool {\n    if gestureRecognizer == textView.panGestureRecognizer {\n        return false\n    } else {\n        return true\n    }\n}\n```\n\n大功告成！\n\n但是程序一运行，发现不对劲了。每次滑动一段时间之后，文字才开始变红，这个体验就很不好了。仔细一想，原来是因为自己的手势必须要等待滑动手势失败之后才能开始识别。而这需要时间。所以我们只好把逻辑反过来，竖直滑动的时候让自己的手势失败；再让 UITextView 的手势等待我们自己的手势失败后再开始识别。\n\n最终的代码：\n\n```swift\nclass TextReciteViewController: UIViewController, UITextViewDelegate, UIGestureRecognizerDelegate {\n\n    let textView = TextView() //要用自己的 TextView 而不是 UITextView 了\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n      \t//......\n   \t\ttextView.delegate = self\n        let panGesture = UIPanGestureRecognizer(target: self, action: #selector(TextReciteViewController.panToSelectText(gesture:)))\n        panGesture.delegate = self\n        textView.addGestureRecognizer(panGesture)\n      \t//......\n    }\n\n    @objc func panToSelectText(gesture: UIPanGestureRecognizer) {\n      \t//把文字标记为红色\n        let location = gesture.location(in: textView)\n        //......\n    }\n  \n    func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool {\n        if otherGestureRecognizer == textView.panGestureRecognizer {\n            return true\n        } else {\n            return false\n        }\n    }\n}\n\nclass TextView: UITextView {\n    override func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool {\n        if gestureRecognizer is UIPanGestureRecognizer && gestureRecognizer != self.panGestureRecognizer {\n            let point = (gestureRecognizer as! UIPanGestureRecognizer).translation(in: self)\n            if fabs(point.y) / fabs(point.x) > 0.15 {\n                return false\n            }\n        }\n        return super.gestureRecognizerShouldBegin(gestureRecognizer)\n    }\n}\n```\n\n最终就能实现一开始的动图啦！","slug":"iOS限制UIScrollView允许滑动角度","published":1,"updated":"2020-01-04T08:16:16.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv390012ljc39qe9hfv7","content":"<h1 id=\"iOS-限定-UIScrollView-允许滑动角度\"><a href=\"#iOS-限定-UIScrollView-允许滑动角度\" class=\"headerlink\" title=\"iOS 限定 UIScrollView 允许滑动角度\"></a>iOS 限定 UIScrollView 允许滑动角度</h1><p>本文主要解决 UIScrollView 中自己添加的滑动手势与它本身自带的滑动手势冲突的问题。</p>\n<p>最近做的项目中，有一个需求是在一个 UITextView 中，把手指滑动过程中覆盖的文字标记为红色（以备后续使用）。而由于文本可能很长，上下滚动 UITextView 的功能要保留，就像下面这样：</p>\n<p><img src=\"/img/限定ScrollView允许滑动角度/scroll.gif\" alt=\"scroll\"></p>\n<p>滑动把文本标记为红色比较简单。只需要在 UITextView 上添加一个 UIPanGestureRecognizer ，手指移动的时候找出坐标对应的文字就好了。要命的是，这会带来手势冲突：所有的滑动事件都被自己添加的这个手势捕获了，UITextView 没有办法上下滚动。一个直观的想法就是，我们可以给 UITextView 限定一个允许滚动的角度，比如，用户以 80～90 度的方向（非常竖直的方向）滑动时，认为是在滚动视图；而以一个较为水平的方向滑动时，认为在标记文字。</p>\n<p>但是怎么去判定方向呢？我们固然可以在自己添加的手势中根据坐标算出来角度，但是这样没有办法限制住 UITextView 的滚动。UIScrollView 的代理方法也做不到限制它滚动。所以只能另辟蹊径了！</p>\n<p>首先，我们要覆盖掉 UITextView 自己判断是否执行手势的方法，借此来控制手势的成功与失败：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span>: <span class=\"title\">UITextView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizerShouldBegin</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> gestureRecognizer == <span class=\"keyword\">self</span>.panGestureRecognizer &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> point = (gestureRecognizer <span class=\"keyword\">as</span>! <span class=\"type\">UIPanGestureRecognizer</span>).translation(<span class=\"keyword\">in</span>: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> fabs(point.y) / fabs(point.x) &lt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.gestureRecognizerShouldBegin(gestureRecognizer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们用自己的 TextView 来继承了 UITextView。当 x 与 y 成一定比值时（这里是大于 45 度，因为 arctan(1) = 45度）返回 false 令手势失败。</p>\n<p>然后，在自己的 ViewController 中，设置自己添加的手势必须要在 UITextView 自己的滑动手势失败后（即角度比较水平的时候）才开始识别。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> gestureRecognizer == textView.panGestureRecognizer &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大功告成！</p>\n<p>但是程序一运行，发现不对劲了。每次滑动一段时间之后，文字才开始变红，这个体验就很不好了。仔细一想，原来是因为自己的手势必须要等待滑动手势失败之后才能开始识别。而这需要时间。所以我们只好把逻辑反过来，竖直滑动的时候让自己的手势失败；再让 UITextView 的手势等待我们自己的手势失败后再开始识别。</p>\n<p>最终的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextReciteViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UITextViewDelegate</span>, <span class=\"title\">UIGestureRecognizerDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> textView = <span class=\"type\">TextView</span>() <span class=\"comment\">//要用自己的 TextView 而不是 UITextView 了</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">      \t<span class=\"comment\">//......</span></span><br><span class=\"line\">   \t\ttextView.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> panGesture = <span class=\"type\">UIPanGestureRecognizer</span>(target: <span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">TextReciteViewController</span>.panToSelectText(gesture:)))</span><br><span class=\"line\">        panGesture.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">        textView.addGestureRecognizer(panGesture)</span><br><span class=\"line\">      \t<span class=\"comment\">//......</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">panToSelectText</span><span class=\"params\">(gesture: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">//把文字标记为红色</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> location = gesture.location(<span class=\"keyword\">in</span>: textView)</span><br><span class=\"line\">        <span class=\"comment\">//......</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> otherGestureRecognizer == textView.panGestureRecognizer &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span>: <span class=\"title\">UITextView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizerShouldBegin</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> gestureRecognizer <span class=\"keyword\">is</span> <span class=\"type\">UIPanGestureRecognizer</span> &amp;&amp; gestureRecognizer != <span class=\"keyword\">self</span>.panGestureRecognizer &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> point = (gestureRecognizer <span class=\"keyword\">as</span>! <span class=\"type\">UIPanGestureRecognizer</span>).translation(<span class=\"keyword\">in</span>: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> fabs(point.y) / fabs(point.x) &gt; <span class=\"number\">0.15</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.gestureRecognizerShouldBegin(gestureRecognizer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终就能实现一开始的动图啦！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-限定-UIScrollView-允许滑动角度\"><a href=\"#iOS-限定-UIScrollView-允许滑动角度\" class=\"headerlink\" title=\"iOS 限定 UIScrollView 允许滑动角度\"></a>iOS 限定 UIScrollView 允许滑动角度</h1><p>本文主要解决 UIScrollView 中自己添加的滑动手势与它本身自带的滑动手势冲突的问题。</p>\n<p>最近做的项目中，有一个需求是在一个 UITextView 中，把手指滑动过程中覆盖的文字标记为红色（以备后续使用）。而由于文本可能很长，上下滚动 UITextView 的功能要保留，就像下面这样：</p>\n<p><img src=\"/img/限定ScrollView允许滑动角度/scroll.gif\" alt=\"scroll\"></p>\n<p>滑动把文本标记为红色比较简单。只需要在 UITextView 上添加一个 UIPanGestureRecognizer ，手指移动的时候找出坐标对应的文字就好了。要命的是，这会带来手势冲突：所有的滑动事件都被自己添加的这个手势捕获了，UITextView 没有办法上下滚动。一个直观的想法就是，我们可以给 UITextView 限定一个允许滚动的角度，比如，用户以 80～90 度的方向（非常竖直的方向）滑动时，认为是在滚动视图；而以一个较为水平的方向滑动时，认为在标记文字。</p>\n<p>但是怎么去判定方向呢？我们固然可以在自己添加的手势中根据坐标算出来角度，但是这样没有办法限制住 UITextView 的滚动。UIScrollView 的代理方法也做不到限制它滚动。所以只能另辟蹊径了！</p>\n<p>首先，我们要覆盖掉 UITextView 自己判断是否执行手势的方法，借此来控制手势的成功与失败：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span>: <span class=\"title\">UITextView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizerShouldBegin</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> gestureRecognizer == <span class=\"keyword\">self</span>.panGestureRecognizer &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> point = (gestureRecognizer <span class=\"keyword\">as</span>! <span class=\"type\">UIPanGestureRecognizer</span>).translation(<span class=\"keyword\">in</span>: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> fabs(point.y) / fabs(point.x) &lt; <span class=\"number\">1</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.gestureRecognizerShouldBegin(gestureRecognizer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们用自己的 TextView 来继承了 UITextView。当 x 与 y 成一定比值时（这里是大于 45 度，因为 arctan(1) = 45度）返回 false 令手势失败。</p>\n<p>然后，在自己的 ViewController 中，设置自己添加的手势必须要在 UITextView 自己的滑动手势失败后（即角度比较水平的时候）才开始识别。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> gestureRecognizer == textView.panGestureRecognizer &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>大功告成！</p>\n<p>但是程序一运行，发现不对劲了。每次滑动一段时间之后，文字才开始变红，这个体验就很不好了。仔细一想，原来是因为自己的手势必须要等待滑动手势失败之后才能开始识别。而这需要时间。所以我们只好把逻辑反过来，竖直滑动的时候让自己的手势失败；再让 UITextView 的手势等待我们自己的手势失败后再开始识别。</p>\n<p>最终的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextReciteViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UITextViewDelegate</span>, <span class=\"title\">UIGestureRecognizerDelegate</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> textView = <span class=\"type\">TextView</span>() <span class=\"comment\">//要用自己的 TextView 而不是 UITextView 了</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">      \t<span class=\"comment\">//......</span></span><br><span class=\"line\">   \t\ttextView.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> panGesture = <span class=\"type\">UIPanGestureRecognizer</span>(target: <span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">TextReciteViewController</span>.panToSelectText(gesture:)))</span><br><span class=\"line\">        panGesture.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">        textView.addGestureRecognizer(panGesture)</span><br><span class=\"line\">      \t<span class=\"comment\">//......</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">panToSelectText</span><span class=\"params\">(gesture: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">//把文字标记为红色</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> location = gesture.location(<span class=\"keyword\">in</span>: textView)</span><br><span class=\"line\">        <span class=\"comment\">//......</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> otherGestureRecognizer == textView.panGestureRecognizer &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextView</span>: <span class=\"title\">UITextView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizerShouldBegin</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> gestureRecognizer <span class=\"keyword\">is</span> <span class=\"type\">UIPanGestureRecognizer</span> &amp;&amp; gestureRecognizer != <span class=\"keyword\">self</span>.panGestureRecognizer &#123;</span><br><span class=\"line\">            <span class=\"keyword\">let</span> point = (gestureRecognizer <span class=\"keyword\">as</span>! <span class=\"type\">UIPanGestureRecognizer</span>).translation(<span class=\"keyword\">in</span>: <span class=\"keyword\">self</span>)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> fabs(point.y) / fabs(point.x) &gt; <span class=\"number\">0.15</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.gestureRecognizerShouldBegin(gestureRecognizer)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终就能实现一开始的动图啦！</p>\n"},{"title":"iOS蓝牙开发-超声波测距仪","date":"2017-07-30T12:14:14.000Z","_content":"\n# iOS 蓝牙开发——超声波测距仪\n\n**写在前面：**本来的计划是做一个 pm2.5 测量仪的，毕竟北京的空气有时很糟糕。去网上找粉尘传感器，发现有 200 多的，有 20 多的。看了眼支付宝余额……默默选择了 20 块钱的。结果到手之后发现精度实在太低了，而且线头又短又软，适合焊接而不是插到面包板上🤦‍♂️只好先改成了超声波测距仪。 Pm2.5 测量……就以后再说吧……\n\n### 硬件电路\n\n这里用了 Arduino 单片机 + 蓝牙 4.0 模块 + 超声波测距模块构成硬件电路，结构比较简单。\n\n![原理图](/img/蓝牙测距/原理图.png)\n\n![photo](/img/蓝牙测距/photo.jpg)\n\n蓝牙和超声波模块 Vcc 接 Arduino 5V 输出。特别要注意超声波模块的工作电压，如果模块本身的工作电压是 5V 却只给 3.3V 的话，会工作异常。二者 GND 接 Arduino GND。\n\n蓝牙模块的 Tx 和 Rx 分别接 Arduino 的 Rx 和 Tx。超声波模块的 Echo 和 Trig 分别接两个 Arduino 的数字输入／输出引脚。\n\n### 超声波测距仪工作原理\n\n超声波具有定向性好的特点，因此可以用来测距。此超声波测距模块需要给予 Trig 脚最少 10 微秒的高电平作为触发信号，之后便会自动发射超声波，并接收反射波。一旦接受到反射回来的声波，便会在 Echo 脚输出一段时间的高电平。该高电平持续时间就是声波的传播时间。因此，测量出超声波的传播时间，再结合已知的声音在空气中的传播速度，就可以算出距离。\n\n此超声波测距模块的工作范围是 4 厘米到 4.5 米，且精度很高，达到毫米级。两次测量最好间隔 60 毫秒以上。\n\n### Arduino 编程\n\n```c\nint trigPin = 7;\nint echoPin = 8;\nunsigned long startTime = 0;\nunsigned long endTime = 0; //时间可能会溢出\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(trigPin, OUTPUT);\n  pinMode(echoPin, INPUT);\n}\n\nvoid loop() {\n  \n  digitalWrite(trigPin, HIGH);\n  delayMicroseconds(15); //至少给trig引脚10us的高电平\n  digitalWrite(trigPin, LOW);\n\n  while(digitalRead(echoPin) == LOW); //等待echo引脚返回高电平\n\n  startTime = micros();\n  while(digitalRead(echoPin) == HIGH);\n  endTime = micros();\n\n  if(startTime > endTime) {\n    //溢出，此次结果作废\n    return;\n  }\n\n  double deltaTime = endTime - startTime;\n  double distance = (deltaTime / 1000000.0 * 340.0) / 2.0; //unit: m\n\n  Serial.println(distance * 100); //unit: cm\n\n  delay(1000);\n  \n}\n```\n\n需要注意的一点是，Arduino 的时间值是从上电到当前的累积，用 long 型保存。因此上电时间过长的话，会产生溢出。虽然这种情况要等待很久才会发生，但最好还是做一个判断。\n\n测量出高电平持续的时间，算出距离后直接写到串口上，蓝牙模块就会自动发送数据了。\n\n### iOS 客户端\n\n源代码已经放在了 [GitLab](https://git.bingyan.net/BeBeBerr/DistanceDetector) 上。\n\n![screenshot1](/img/蓝牙测距/screenshot1.PNG)\n\n上面是测量的过程中，用物体遮挡一段时间的结果。\n\n![screenshot2](/img/蓝牙测距/screenshot2.PNG)\n\n上面是让障碍物先远离，再靠近，最后释放的结果。\n\n每接受到一次新的数据，就会让图标重绘一次，就形成了图表不断变化的效果。\n\n### 附：近期总结\n\n转眼间七月就要过去了，暑假已经过去一大半了。本来计划是 8 月前把算法什么的搞完，8 月能自在些。结果最近突然要学车，再加上又双叒叕生病了……没办法只能往后拖拖了……祝明天科目二考试顺利吧，赶紧学完车能歇歇了。","source":"_posts/iOS蓝牙开发-超声波测距仪.md","raw":"---\ntitle: iOS蓝牙开发-超声波测距仪\ndate: 2017-07-30 20:14:14\ntags: CoreBluetooth\n---\n\n# iOS 蓝牙开发——超声波测距仪\n\n**写在前面：**本来的计划是做一个 pm2.5 测量仪的，毕竟北京的空气有时很糟糕。去网上找粉尘传感器，发现有 200 多的，有 20 多的。看了眼支付宝余额……默默选择了 20 块钱的。结果到手之后发现精度实在太低了，而且线头又短又软，适合焊接而不是插到面包板上🤦‍♂️只好先改成了超声波测距仪。 Pm2.5 测量……就以后再说吧……\n\n### 硬件电路\n\n这里用了 Arduino 单片机 + 蓝牙 4.0 模块 + 超声波测距模块构成硬件电路，结构比较简单。\n\n![原理图](/img/蓝牙测距/原理图.png)\n\n![photo](/img/蓝牙测距/photo.jpg)\n\n蓝牙和超声波模块 Vcc 接 Arduino 5V 输出。特别要注意超声波模块的工作电压，如果模块本身的工作电压是 5V 却只给 3.3V 的话，会工作异常。二者 GND 接 Arduino GND。\n\n蓝牙模块的 Tx 和 Rx 分别接 Arduino 的 Rx 和 Tx。超声波模块的 Echo 和 Trig 分别接两个 Arduino 的数字输入／输出引脚。\n\n### 超声波测距仪工作原理\n\n超声波具有定向性好的特点，因此可以用来测距。此超声波测距模块需要给予 Trig 脚最少 10 微秒的高电平作为触发信号，之后便会自动发射超声波，并接收反射波。一旦接受到反射回来的声波，便会在 Echo 脚输出一段时间的高电平。该高电平持续时间就是声波的传播时间。因此，测量出超声波的传播时间，再结合已知的声音在空气中的传播速度，就可以算出距离。\n\n此超声波测距模块的工作范围是 4 厘米到 4.5 米，且精度很高，达到毫米级。两次测量最好间隔 60 毫秒以上。\n\n### Arduino 编程\n\n```c\nint trigPin = 7;\nint echoPin = 8;\nunsigned long startTime = 0;\nunsigned long endTime = 0; //时间可能会溢出\n\nvoid setup() {\n  Serial.begin(9600);\n  pinMode(trigPin, OUTPUT);\n  pinMode(echoPin, INPUT);\n}\n\nvoid loop() {\n  \n  digitalWrite(trigPin, HIGH);\n  delayMicroseconds(15); //至少给trig引脚10us的高电平\n  digitalWrite(trigPin, LOW);\n\n  while(digitalRead(echoPin) == LOW); //等待echo引脚返回高电平\n\n  startTime = micros();\n  while(digitalRead(echoPin) == HIGH);\n  endTime = micros();\n\n  if(startTime > endTime) {\n    //溢出，此次结果作废\n    return;\n  }\n\n  double deltaTime = endTime - startTime;\n  double distance = (deltaTime / 1000000.0 * 340.0) / 2.0; //unit: m\n\n  Serial.println(distance * 100); //unit: cm\n\n  delay(1000);\n  \n}\n```\n\n需要注意的一点是，Arduino 的时间值是从上电到当前的累积，用 long 型保存。因此上电时间过长的话，会产生溢出。虽然这种情况要等待很久才会发生，但最好还是做一个判断。\n\n测量出高电平持续的时间，算出距离后直接写到串口上，蓝牙模块就会自动发送数据了。\n\n### iOS 客户端\n\n源代码已经放在了 [GitLab](https://git.bingyan.net/BeBeBerr/DistanceDetector) 上。\n\n![screenshot1](/img/蓝牙测距/screenshot1.PNG)\n\n上面是测量的过程中，用物体遮挡一段时间的结果。\n\n![screenshot2](/img/蓝牙测距/screenshot2.PNG)\n\n上面是让障碍物先远离，再靠近，最后释放的结果。\n\n每接受到一次新的数据，就会让图标重绘一次，就形成了图表不断变化的效果。\n\n### 附：近期总结\n\n转眼间七月就要过去了，暑假已经过去一大半了。本来计划是 8 月前把算法什么的搞完，8 月能自在些。结果最近突然要学车，再加上又双叒叕生病了……没办法只能往后拖拖了……祝明天科目二考试顺利吧，赶紧学完车能歇歇了。","slug":"iOS蓝牙开发-超声波测距仪","published":1,"updated":"2020-01-04T08:16:16.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv390014ljc3pf008bm0","content":"<h1 id=\"iOS-蓝牙开发——超声波测距仪\"><a href=\"#iOS-蓝牙开发——超声波测距仪\" class=\"headerlink\" title=\"iOS 蓝牙开发——超声波测距仪\"></a>iOS 蓝牙开发——超声波测距仪</h1><p><strong>写在前面：</strong>本来的计划是做一个 pm2.5 测量仪的，毕竟北京的空气有时很糟糕。去网上找粉尘传感器，发现有 200 多的，有 20 多的。看了眼支付宝余额……默默选择了 20 块钱的。结果到手之后发现精度实在太低了，而且线头又短又软，适合焊接而不是插到面包板上🤦‍♂️只好先改成了超声波测距仪。 Pm2.5 测量……就以后再说吧……</p>\n<h3 id=\"硬件电路\"><a href=\"#硬件电路\" class=\"headerlink\" title=\"硬件电路\"></a>硬件电路</h3><p>这里用了 Arduino 单片机 + 蓝牙 4.0 模块 + 超声波测距模块构成硬件电路，结构比较简单。</p>\n<p><img src=\"/img/蓝牙测距/原理图.png\" alt=\"原理图\"></p>\n<p><img src=\"/img/蓝牙测距/photo.jpg\" alt=\"photo\"></p>\n<p>蓝牙和超声波模块 Vcc 接 Arduino 5V 输出。特别要注意超声波模块的工作电压，如果模块本身的工作电压是 5V 却只给 3.3V 的话，会工作异常。二者 GND 接 Arduino GND。</p>\n<p>蓝牙模块的 Tx 和 Rx 分别接 Arduino 的 Rx 和 Tx。超声波模块的 Echo 和 Trig 分别接两个 Arduino 的数字输入／输出引脚。</p>\n<h3 id=\"超声波测距仪工作原理\"><a href=\"#超声波测距仪工作原理\" class=\"headerlink\" title=\"超声波测距仪工作原理\"></a>超声波测距仪工作原理</h3><p>超声波具有定向性好的特点，因此可以用来测距。此超声波测距模块需要给予 Trig 脚最少 10 微秒的高电平作为触发信号，之后便会自动发射超声波，并接收反射波。一旦接受到反射回来的声波，便会在 Echo 脚输出一段时间的高电平。该高电平持续时间就是声波的传播时间。因此，测量出超声波的传播时间，再结合已知的声音在空气中的传播速度，就可以算出距离。</p>\n<p>此超声波测距模块的工作范围是 4 厘米到 4.5 米，且精度很高，达到毫米级。两次测量最好间隔 60 毫秒以上。</p>\n<h3 id=\"Arduino-编程\"><a href=\"#Arduino-编程\" class=\"headerlink\" title=\"Arduino 编程\"></a>Arduino 编程</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> trigPin = <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> echoPin = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> startTime = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> endTime = <span class=\"number\">0</span>; <span class=\"comment\">//时间可能会溢出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Serial.begin(<span class=\"number\">9600</span>);</span><br><span class=\"line\">  pinMode(trigPin, OUTPUT);</span><br><span class=\"line\">  pinMode(echoPin, INPUT);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  digitalWrite(trigPin, HIGH);</span><br><span class=\"line\">  delayMicroseconds(<span class=\"number\">15</span>); <span class=\"comment\">//至少给trig引脚10us的高电平</span></span><br><span class=\"line\">  digitalWrite(trigPin, LOW);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(digitalRead(echoPin) == LOW); <span class=\"comment\">//等待echo引脚返回高电平</span></span><br><span class=\"line\"></span><br><span class=\"line\">  startTime = micros();</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(digitalRead(echoPin) == HIGH);</span><br><span class=\"line\">  endTime = micros();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(startTime &gt; endTime) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//溢出，此次结果作废</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">double</span> deltaTime = endTime - startTime;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> distance = (deltaTime / <span class=\"number\">1000000.0</span> * <span class=\"number\">340.0</span>) / <span class=\"number\">2.0</span>; <span class=\"comment\">//unit: m</span></span><br><span class=\"line\"></span><br><span class=\"line\">  Serial.println(distance * <span class=\"number\">100</span>); <span class=\"comment\">//unit: cm</span></span><br><span class=\"line\"></span><br><span class=\"line\">  delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的一点是，Arduino 的时间值是从上电到当前的累积，用 long 型保存。因此上电时间过长的话，会产生溢出。虽然这种情况要等待很久才会发生，但最好还是做一个判断。</p>\n<p>测量出高电平持续的时间，算出距离后直接写到串口上，蓝牙模块就会自动发送数据了。</p>\n<h3 id=\"iOS-客户端\"><a href=\"#iOS-客户端\" class=\"headerlink\" title=\"iOS 客户端\"></a>iOS 客户端</h3><p>源代码已经放在了 <a href=\"https://git.bingyan.net/BeBeBerr/DistanceDetector\">GitLab</a> 上。</p>\n<p><img src=\"/img/蓝牙测距/screenshot1.PNG\" alt=\"screenshot1\"></p>\n<p>上面是测量的过程中，用物体遮挡一段时间的结果。</p>\n<p><img src=\"/img/蓝牙测距/screenshot2.PNG\" alt=\"screenshot2\"></p>\n<p>上面是让障碍物先远离，再靠近，最后释放的结果。</p>\n<p>每接受到一次新的数据，就会让图标重绘一次，就形成了图表不断变化的效果。</p>\n<h3 id=\"附：近期总结\"><a href=\"#附：近期总结\" class=\"headerlink\" title=\"附：近期总结\"></a>附：近期总结</h3><p>转眼间七月就要过去了，暑假已经过去一大半了。本来计划是 8 月前把算法什么的搞完，8 月能自在些。结果最近突然要学车，再加上又双叒叕生病了……没办法只能往后拖拖了……祝明天科目二考试顺利吧，赶紧学完车能歇歇了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-蓝牙开发——超声波测距仪\"><a href=\"#iOS-蓝牙开发——超声波测距仪\" class=\"headerlink\" title=\"iOS 蓝牙开发——超声波测距仪\"></a>iOS 蓝牙开发——超声波测距仪</h1><p><strong>写在前面：</strong>本来的计划是做一个 pm2.5 测量仪的，毕竟北京的空气有时很糟糕。去网上找粉尘传感器，发现有 200 多的，有 20 多的。看了眼支付宝余额……默默选择了 20 块钱的。结果到手之后发现精度实在太低了，而且线头又短又软，适合焊接而不是插到面包板上🤦‍♂️只好先改成了超声波测距仪。 Pm2.5 测量……就以后再说吧……</p>\n<h3 id=\"硬件电路\"><a href=\"#硬件电路\" class=\"headerlink\" title=\"硬件电路\"></a>硬件电路</h3><p>这里用了 Arduino 单片机 + 蓝牙 4.0 模块 + 超声波测距模块构成硬件电路，结构比较简单。</p>\n<p><img src=\"/img/蓝牙测距/原理图.png\" alt=\"原理图\"></p>\n<p><img src=\"/img/蓝牙测距/photo.jpg\" alt=\"photo\"></p>\n<p>蓝牙和超声波模块 Vcc 接 Arduino 5V 输出。特别要注意超声波模块的工作电压，如果模块本身的工作电压是 5V 却只给 3.3V 的话，会工作异常。二者 GND 接 Arduino GND。</p>\n<p>蓝牙模块的 Tx 和 Rx 分别接 Arduino 的 Rx 和 Tx。超声波模块的 Echo 和 Trig 分别接两个 Arduino 的数字输入／输出引脚。</p>\n<h3 id=\"超声波测距仪工作原理\"><a href=\"#超声波测距仪工作原理\" class=\"headerlink\" title=\"超声波测距仪工作原理\"></a>超声波测距仪工作原理</h3><p>超声波具有定向性好的特点，因此可以用来测距。此超声波测距模块需要给予 Trig 脚最少 10 微秒的高电平作为触发信号，之后便会自动发射超声波，并接收反射波。一旦接受到反射回来的声波，便会在 Echo 脚输出一段时间的高电平。该高电平持续时间就是声波的传播时间。因此，测量出超声波的传播时间，再结合已知的声音在空气中的传播速度，就可以算出距离。</p>\n<p>此超声波测距模块的工作范围是 4 厘米到 4.5 米，且精度很高，达到毫米级。两次测量最好间隔 60 毫秒以上。</p>\n<h3 id=\"Arduino-编程\"><a href=\"#Arduino-编程\" class=\"headerlink\" title=\"Arduino 编程\"></a>Arduino 编程</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> trigPin = <span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> echoPin = <span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> startTime = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> endTime = <span class=\"number\">0</span>; <span class=\"comment\">//时间可能会溢出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Serial.begin(<span class=\"number\">9600</span>);</span><br><span class=\"line\">  pinMode(trigPin, OUTPUT);</span><br><span class=\"line\">  pinMode(echoPin, INPUT);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  digitalWrite(trigPin, HIGH);</span><br><span class=\"line\">  delayMicroseconds(<span class=\"number\">15</span>); <span class=\"comment\">//至少给trig引脚10us的高电平</span></span><br><span class=\"line\">  digitalWrite(trigPin, LOW);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span>(digitalRead(echoPin) == LOW); <span class=\"comment\">//等待echo引脚返回高电平</span></span><br><span class=\"line\"></span><br><span class=\"line\">  startTime = micros();</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(digitalRead(echoPin) == HIGH);</span><br><span class=\"line\">  endTime = micros();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(startTime &gt; endTime) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//溢出，此次结果作废</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">double</span> deltaTime = endTime - startTime;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> distance = (deltaTime / <span class=\"number\">1000000.0</span> * <span class=\"number\">340.0</span>) / <span class=\"number\">2.0</span>; <span class=\"comment\">//unit: m</span></span><br><span class=\"line\"></span><br><span class=\"line\">  Serial.println(distance * <span class=\"number\">100</span>); <span class=\"comment\">//unit: cm</span></span><br><span class=\"line\"></span><br><span class=\"line\">  delay(<span class=\"number\">1000</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的一点是，Arduino 的时间值是从上电到当前的累积，用 long 型保存。因此上电时间过长的话，会产生溢出。虽然这种情况要等待很久才会发生，但最好还是做一个判断。</p>\n<p>测量出高电平持续的时间，算出距离后直接写到串口上，蓝牙模块就会自动发送数据了。</p>\n<h3 id=\"iOS-客户端\"><a href=\"#iOS-客户端\" class=\"headerlink\" title=\"iOS 客户端\"></a>iOS 客户端</h3><p>源代码已经放在了 <a href=\"https://git.bingyan.net/BeBeBerr/DistanceDetector\">GitLab</a> 上。</p>\n<p><img src=\"/img/蓝牙测距/screenshot1.PNG\" alt=\"screenshot1\"></p>\n<p>上面是测量的过程中，用物体遮挡一段时间的结果。</p>\n<p><img src=\"/img/蓝牙测距/screenshot2.PNG\" alt=\"screenshot2\"></p>\n<p>上面是让障碍物先远离，再靠近，最后释放的结果。</p>\n<p>每接受到一次新的数据，就会让图标重绘一次，就形成了图表不断变化的效果。</p>\n<h3 id=\"附：近期总结\"><a href=\"#附：近期总结\" class=\"headerlink\" title=\"附：近期总结\"></a>附：近期总结</h3><p>转眼间七月就要过去了，暑假已经过去一大半了。本来计划是 8 月前把算法什么的搞完，8 月能自在些。结果最近突然要学车，再加上又双叒叕生病了……没办法只能往后拖拖了……祝明天科目二考试顺利吧，赶紧学完车能歇歇了。</p>\n"},{"title":"iOS静默推送","date":"2018-08-08T10:29:06.000Z","_content":"\n# iOS 静默推送\n\n静默推送，更准确地说，后台更新通知（Background Update Notification）是苹果在 iOS7 开始支持的新功能。简单来说，它让我们拥有了在用户毫无察觉的情况下，唤起应用并执行代码的能力，赋予了极大的想象空间。\n\n## 能力\n\n苹果在设计静默推送的时候，是希望开发者可以定时唤醒应用，下载最新的内容。这样，用户隔一段时间后打开应用，也能立刻看到最新的内容（比如当天的新闻等），而不用打开应用后再等待刷新。不过我们当然可以利用这个能力来做一些奇怪的事情 : )\n\n静默推送可以在不弹出横幅等通知的情况下（用户无感），将应用唤醒。经过测试，如果应用是处于挂起，或是被系统终止的情况下，都是可以唤醒的。也就是说，只要用户没有手动将程序从后台关闭就可以。苹果在官方文档上说，最长可以执行 30s 的代码，不过可以通过设置来讲后台执行代码的时间稍作延长。在实际使用中，我发现这并不是说每次都给你 30s 的时间随便执行代码，到时间就终止，而似乎是主线程一旦空闲，程序就会被终止掉（这点存疑）。也就是，如果你在子线程上执行诸如网络请求等代码，可能很快程序就被系统终止了，再也收不到回调。\n\n与普通推送相比，静默推送不仅是无感，我们更关心的是它可以唤醒已经死掉的程序。\n\n## 调试与配置\n\n走 APNS 推送显然是需要后台来做的。但是，借助工具，iOS 程序员也可以自行调试。比如，可以在 GitHub 上下载 [Knuff](https://github.com/KnuffApp/Knuff) 应用来调试。\n\n![knuff](/img/静默推送/knuff.png)\n\n配置好后，只要点击 push 按钮，手机上就会收到一条推送了！\n\n在 Knuff 界面上，可以看到需要配置的一些字段。Identity 是要选择推送证书，在应用最终上线时，服务端也是需要这个证书来进行验证的。可以在苹果开发者账号管理页面生成 p12 证书，生成证书时，记得选好类型，是 sandbox 还是 production。\n\n![p12](/img/静默推送/p12.png)\n\nToken 是设备的编号，否则，苹果的服务器怎么知道向哪台设备推送呢？当程序调用了 `registerForRemoteNotifications ` 向苹果注册了推送后，在\n\n```objc\n- (void)application:(UIApplication *)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken\n```\n\n方法中可以拿到 token。注意，一定要在 Capability 中勾选上 Remote notification，并使用真机调试。这个 token 并不是一成不变的，有可能会发生变动。\n\nPayload 中就是要传给苹果的内容，其中 `content-available` 字段设置为 1 表示静默推送。\n\n## 接收推送\n\n收到推送通知后，会调用 AppDelegate 中的 \n\n```objc\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler\n```\n\n方法。如果程序是被唤醒的，当然会先走启动逻辑，再来调用这个方法。在这里就可以开始书写自己的逻辑了。\n\n## 延长执行时间\n\n在实际测试中，我发现往往程序执行还不到 30s，就被干掉了，因此怀疑是主线程一旦空闲，系统就不管子线程的死活了（不确定）。但是可能我在后台正在执行网络请求，这个时候就需要延长执行时间。\n\n可以通过 background task 来获得更长的执行时间：\n\n```objc\nself.backgroundTaskId = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{\n        NSLog(@\"end\"); \n}];\n```\n\n系统即将要终止应用时，会调用这个回调方法。但是建议在系统强制终止程序前，通过\n\n```objc\n[[UIApplication sharedApplication] endBackgroundTask:self.backgroundTaskId];\n```\n\n手动通知系统任务完成。\n\n## 后台传输\n\n很多情况下，在程序被唤醒后都要去下载/上传一个比较大的文件。即使通过上述方法延长了执行时间，可能也不足以等到文件传输完毕。好在苹果也提供了后台传输的方法，通过此方法，上传/下载任务会被交给操作系统执行，即使程序被 kill 掉，也可以继续完成传输任务。\n\n通过 AFNetworking，可以这样开启后台传输：\n\n```objc\nNSURLSessionConfiguration *config = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@\"your.identifier\"];\nself.manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:config];\nNSMutableURLRequest *request = [AFHTTPRequestSerializer.serializer requestWithMethod:@\"PUT\" URLString:@\"https://your.url\" parameters:nil error:nil];\nrequest.timeoutInterval = 60.0;\n[[self.manager uploadTaskWithRequest:request fromData:nil progress:nil completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {\n        //\n}] resume];\n```\n\n当后台传输完毕后，系统会调用\n\n```objc\n- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)(void))completionHandler\n```\n\n再次唤醒程序，并执行我们的代码。","source":"_posts/iOS静默推送.md","raw":"---\ntitle: iOS静默推送\ndate: 2018-08-08 18:29:06\ntags: Push\n---\n\n# iOS 静默推送\n\n静默推送，更准确地说，后台更新通知（Background Update Notification）是苹果在 iOS7 开始支持的新功能。简单来说，它让我们拥有了在用户毫无察觉的情况下，唤起应用并执行代码的能力，赋予了极大的想象空间。\n\n## 能力\n\n苹果在设计静默推送的时候，是希望开发者可以定时唤醒应用，下载最新的内容。这样，用户隔一段时间后打开应用，也能立刻看到最新的内容（比如当天的新闻等），而不用打开应用后再等待刷新。不过我们当然可以利用这个能力来做一些奇怪的事情 : )\n\n静默推送可以在不弹出横幅等通知的情况下（用户无感），将应用唤醒。经过测试，如果应用是处于挂起，或是被系统终止的情况下，都是可以唤醒的。也就是说，只要用户没有手动将程序从后台关闭就可以。苹果在官方文档上说，最长可以执行 30s 的代码，不过可以通过设置来讲后台执行代码的时间稍作延长。在实际使用中，我发现这并不是说每次都给你 30s 的时间随便执行代码，到时间就终止，而似乎是主线程一旦空闲，程序就会被终止掉（这点存疑）。也就是，如果你在子线程上执行诸如网络请求等代码，可能很快程序就被系统终止了，再也收不到回调。\n\n与普通推送相比，静默推送不仅是无感，我们更关心的是它可以唤醒已经死掉的程序。\n\n## 调试与配置\n\n走 APNS 推送显然是需要后台来做的。但是，借助工具，iOS 程序员也可以自行调试。比如，可以在 GitHub 上下载 [Knuff](https://github.com/KnuffApp/Knuff) 应用来调试。\n\n![knuff](/img/静默推送/knuff.png)\n\n配置好后，只要点击 push 按钮，手机上就会收到一条推送了！\n\n在 Knuff 界面上，可以看到需要配置的一些字段。Identity 是要选择推送证书，在应用最终上线时，服务端也是需要这个证书来进行验证的。可以在苹果开发者账号管理页面生成 p12 证书，生成证书时，记得选好类型，是 sandbox 还是 production。\n\n![p12](/img/静默推送/p12.png)\n\nToken 是设备的编号，否则，苹果的服务器怎么知道向哪台设备推送呢？当程序调用了 `registerForRemoteNotifications ` 向苹果注册了推送后，在\n\n```objc\n- (void)application:(UIApplication *)app didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken\n```\n\n方法中可以拿到 token。注意，一定要在 Capability 中勾选上 Remote notification，并使用真机调试。这个 token 并不是一成不变的，有可能会发生变动。\n\nPayload 中就是要传给苹果的内容，其中 `content-available` 字段设置为 1 表示静默推送。\n\n## 接收推送\n\n收到推送通知后，会调用 AppDelegate 中的 \n\n```objc\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler\n```\n\n方法。如果程序是被唤醒的，当然会先走启动逻辑，再来调用这个方法。在这里就可以开始书写自己的逻辑了。\n\n## 延长执行时间\n\n在实际测试中，我发现往往程序执行还不到 30s，就被干掉了，因此怀疑是主线程一旦空闲，系统就不管子线程的死活了（不确定）。但是可能我在后台正在执行网络请求，这个时候就需要延长执行时间。\n\n可以通过 background task 来获得更长的执行时间：\n\n```objc\nself.backgroundTaskId = [[UIApplication sharedApplication] beginBackgroundTaskWithExpirationHandler:^{\n        NSLog(@\"end\"); \n}];\n```\n\n系统即将要终止应用时，会调用这个回调方法。但是建议在系统强制终止程序前，通过\n\n```objc\n[[UIApplication sharedApplication] endBackgroundTask:self.backgroundTaskId];\n```\n\n手动通知系统任务完成。\n\n## 后台传输\n\n很多情况下，在程序被唤醒后都要去下载/上传一个比较大的文件。即使通过上述方法延长了执行时间，可能也不足以等到文件传输完毕。好在苹果也提供了后台传输的方法，通过此方法，上传/下载任务会被交给操作系统执行，即使程序被 kill 掉，也可以继续完成传输任务。\n\n通过 AFNetworking，可以这样开启后台传输：\n\n```objc\nNSURLSessionConfiguration *config = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@\"your.identifier\"];\nself.manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:config];\nNSMutableURLRequest *request = [AFHTTPRequestSerializer.serializer requestWithMethod:@\"PUT\" URLString:@\"https://your.url\" parameters:nil error:nil];\nrequest.timeoutInterval = 60.0;\n[[self.manager uploadTaskWithRequest:request fromData:nil progress:nil completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {\n        //\n}] resume];\n```\n\n当后台传输完毕后，系统会调用\n\n```objc\n- (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)(void))completionHandler\n```\n\n再次唤醒程序，并执行我们的代码。","slug":"iOS静默推送","published":1,"updated":"2020-01-04T08:16:16.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3a0016ljc31ckeorgj","content":"<h1 id=\"iOS-静默推送\"><a href=\"#iOS-静默推送\" class=\"headerlink\" title=\"iOS 静默推送\"></a>iOS 静默推送</h1><p>静默推送，更准确地说，后台更新通知（Background Update Notification）是苹果在 iOS7 开始支持的新功能。简单来说，它让我们拥有了在用户毫无察觉的情况下，唤起应用并执行代码的能力，赋予了极大的想象空间。</p>\n<h2 id=\"能力\"><a href=\"#能力\" class=\"headerlink\" title=\"能力\"></a>能力</h2><p>苹果在设计静默推送的时候，是希望开发者可以定时唤醒应用，下载最新的内容。这样，用户隔一段时间后打开应用，也能立刻看到最新的内容（比如当天的新闻等），而不用打开应用后再等待刷新。不过我们当然可以利用这个能力来做一些奇怪的事情 : )</p>\n<p>静默推送可以在不弹出横幅等通知的情况下（用户无感），将应用唤醒。经过测试，如果应用是处于挂起，或是被系统终止的情况下，都是可以唤醒的。也就是说，只要用户没有手动将程序从后台关闭就可以。苹果在官方文档上说，最长可以执行 30s 的代码，不过可以通过设置来讲后台执行代码的时间稍作延长。在实际使用中，我发现这并不是说每次都给你 30s 的时间随便执行代码，到时间就终止，而似乎是主线程一旦空闲，程序就会被终止掉（这点存疑）。也就是，如果你在子线程上执行诸如网络请求等代码，可能很快程序就被系统终止了，再也收不到回调。</p>\n<p>与普通推送相比，静默推送不仅是无感，我们更关心的是它可以唤醒已经死掉的程序。</p>\n<h2 id=\"调试与配置\"><a href=\"#调试与配置\" class=\"headerlink\" title=\"调试与配置\"></a>调试与配置</h2><p>走 APNS 推送显然是需要后台来做的。但是，借助工具，iOS 程序员也可以自行调试。比如，可以在 GitHub 上下载 <a href=\"https://github.com/KnuffApp/Knuff\">Knuff</a> 应用来调试。</p>\n<p><img src=\"/img/静默推送/knuff.png\" alt=\"knuff\"></p>\n<p>配置好后，只要点击 push 按钮，手机上就会收到一条推送了！</p>\n<p>在 Knuff 界面上，可以看到需要配置的一些字段。Identity 是要选择推送证书，在应用最终上线时，服务端也是需要这个证书来进行验证的。可以在苹果开发者账号管理页面生成 p12 证书，生成证书时，记得选好类型，是 sandbox 还是 production。</p>\n<p><img src=\"/img/静默推送/p12.png\" alt=\"p12\"></p>\n<p>Token 是设备的编号，否则，苹果的服务器怎么知道向哪台设备推送呢？当程序调用了 <code>registerForRemoteNotifications</code> 向苹果注册了推送后，在</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)app didRegisterForRemoteNotificationsWithDeviceToken:(<span class=\"built_in\">NSData</span> *)deviceToken</span><br></pre></td></tr></table></figure>\n<p>方法中可以拿到 token。注意，一定要在 Capability 中勾选上 Remote notification，并使用真机调试。这个 token 并不是一成不变的，有可能会发生变动。</p>\n<p>Payload 中就是要传给苹果的内容，其中 <code>content-available</code> 字段设置为 1 表示静默推送。</p>\n<h2 id=\"接收推送\"><a href=\"#接收推送\" class=\"headerlink\" title=\"接收推送\"></a>接收推送</h2><p>收到推送通知后，会调用 AppDelegate 中的 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didReceiveRemoteNotification:(<span class=\"built_in\">NSDictionary</span> *)userInfo fetchCompletionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">UIBackgroundFetchResult</span> result))completionHandler</span><br></pre></td></tr></table></figure>\n<p>方法。如果程序是被唤醒的，当然会先走启动逻辑，再来调用这个方法。在这里就可以开始书写自己的逻辑了。</p>\n<h2 id=\"延长执行时间\"><a href=\"#延长执行时间\" class=\"headerlink\" title=\"延长执行时间\"></a>延长执行时间</h2><p>在实际测试中，我发现往往程序执行还不到 30s，就被干掉了，因此怀疑是主线程一旦空闲，系统就不管子线程的死活了（不确定）。但是可能我在后台正在执行网络请求，这个时候就需要延长执行时间。</p>\n<p>可以通过 background task 来获得更长的执行时间：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.backgroundTaskId = [[<span class=\"built_in\">UIApplication</span> sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end\"</span>); </span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>系统即将要终止应用时，会调用这个回调方法。但是建议在系统强制终止程序前，通过</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">UIApplication</span> sharedApplication] endBackgroundTask:<span class=\"keyword\">self</span>.backgroundTaskId];</span><br></pre></td></tr></table></figure>\n<p>手动通知系统任务完成。</p>\n<h2 id=\"后台传输\"><a href=\"#后台传输\" class=\"headerlink\" title=\"后台传输\"></a>后台传输</h2><p>很多情况下，在程序被唤醒后都要去下载/上传一个比较大的文件。即使通过上述方法延长了执行时间，可能也不足以等到文件传输完毕。好在苹果也提供了后台传输的方法，通过此方法，上传/下载任务会被交给操作系统执行，即使程序被 kill 掉，也可以继续完成传输任务。</p>\n<p>通过 AFNetworking，可以这样开启后台传输：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURLSessionConfiguration</span> *config = [<span class=\"built_in\">NSURLSessionConfiguration</span> backgroundSessionConfigurationWithIdentifier:<span class=\"string\">@\"your.identifier\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:config];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> *request = [AFHTTPRequestSerializer.serializer requestWithMethod:<span class=\"string\">@\"PUT\"</span> URLString:<span class=\"string\">@\"https://your.url\"</span> parameters:<span class=\"literal\">nil</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">request.timeoutInterval = <span class=\"number\">60.0</span>;</span><br><span class=\"line\">[[<span class=\"keyword\">self</span>.manager uploadTaskWithRequest:request fromData:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span> completionHandler:^(<span class=\"built_in\">NSURLResponse</span> * _Nonnull response, <span class=\"keyword\">id</span>  _Nullable responseObject, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;] resume];</span><br></pre></td></tr></table></figure>\n<p>当后台传输完毕后，系统会调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)application handleEventsForBackgroundURLSession:(<span class=\"built_in\">NSString</span> *)identifier completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">void</span>))completionHandler</span><br></pre></td></tr></table></figure>\n<p>再次唤醒程序，并执行我们的代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-静默推送\"><a href=\"#iOS-静默推送\" class=\"headerlink\" title=\"iOS 静默推送\"></a>iOS 静默推送</h1><p>静默推送，更准确地说，后台更新通知（Background Update Notification）是苹果在 iOS7 开始支持的新功能。简单来说，它让我们拥有了在用户毫无察觉的情况下，唤起应用并执行代码的能力，赋予了极大的想象空间。</p>\n<h2 id=\"能力\"><a href=\"#能力\" class=\"headerlink\" title=\"能力\"></a>能力</h2><p>苹果在设计静默推送的时候，是希望开发者可以定时唤醒应用，下载最新的内容。这样，用户隔一段时间后打开应用，也能立刻看到最新的内容（比如当天的新闻等），而不用打开应用后再等待刷新。不过我们当然可以利用这个能力来做一些奇怪的事情 : )</p>\n<p>静默推送可以在不弹出横幅等通知的情况下（用户无感），将应用唤醒。经过测试，如果应用是处于挂起，或是被系统终止的情况下，都是可以唤醒的。也就是说，只要用户没有手动将程序从后台关闭就可以。苹果在官方文档上说，最长可以执行 30s 的代码，不过可以通过设置来讲后台执行代码的时间稍作延长。在实际使用中，我发现这并不是说每次都给你 30s 的时间随便执行代码，到时间就终止，而似乎是主线程一旦空闲，程序就会被终止掉（这点存疑）。也就是，如果你在子线程上执行诸如网络请求等代码，可能很快程序就被系统终止了，再也收不到回调。</p>\n<p>与普通推送相比，静默推送不仅是无感，我们更关心的是它可以唤醒已经死掉的程序。</p>\n<h2 id=\"调试与配置\"><a href=\"#调试与配置\" class=\"headerlink\" title=\"调试与配置\"></a>调试与配置</h2><p>走 APNS 推送显然是需要后台来做的。但是，借助工具，iOS 程序员也可以自行调试。比如，可以在 GitHub 上下载 <a href=\"https://github.com/KnuffApp/Knuff\">Knuff</a> 应用来调试。</p>\n<p><img src=\"/img/静默推送/knuff.png\" alt=\"knuff\"></p>\n<p>配置好后，只要点击 push 按钮，手机上就会收到一条推送了！</p>\n<p>在 Knuff 界面上，可以看到需要配置的一些字段。Identity 是要选择推送证书，在应用最终上线时，服务端也是需要这个证书来进行验证的。可以在苹果开发者账号管理页面生成 p12 证书，生成证书时，记得选好类型，是 sandbox 还是 production。</p>\n<p><img src=\"/img/静默推送/p12.png\" alt=\"p12\"></p>\n<p>Token 是设备的编号，否则，苹果的服务器怎么知道向哪台设备推送呢？当程序调用了 <code>registerForRemoteNotifications</code> 向苹果注册了推送后，在</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)app didRegisterForRemoteNotificationsWithDeviceToken:(<span class=\"built_in\">NSData</span> *)deviceToken</span><br></pre></td></tr></table></figure>\n<p>方法中可以拿到 token。注意，一定要在 Capability 中勾选上 Remote notification，并使用真机调试。这个 token 并不是一成不变的，有可能会发生变动。</p>\n<p>Payload 中就是要传给苹果的内容，其中 <code>content-available</code> 字段设置为 1 表示静默推送。</p>\n<h2 id=\"接收推送\"><a href=\"#接收推送\" class=\"headerlink\" title=\"接收推送\"></a>接收推送</h2><p>收到推送通知后，会调用 AppDelegate 中的 </p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)application didReceiveRemoteNotification:(<span class=\"built_in\">NSDictionary</span> *)userInfo fetchCompletionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"built_in\">UIBackgroundFetchResult</span> result))completionHandler</span><br></pre></td></tr></table></figure>\n<p>方法。如果程序是被唤醒的，当然会先走启动逻辑，再来调用这个方法。在这里就可以开始书写自己的逻辑了。</p>\n<h2 id=\"延长执行时间\"><a href=\"#延长执行时间\" class=\"headerlink\" title=\"延长执行时间\"></a>延长执行时间</h2><p>在实际测试中，我发现往往程序执行还不到 30s，就被干掉了，因此怀疑是主线程一旦空闲，系统就不管子线程的死活了（不确定）。但是可能我在后台正在执行网络请求，这个时候就需要延长执行时间。</p>\n<p>可以通过 background task 来获得更长的执行时间：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.backgroundTaskId = [[<span class=\"built_in\">UIApplication</span> sharedApplication] beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"end\"</span>); </span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<p>系统即将要终止应用时，会调用这个回调方法。但是建议在系统强制终止程序前，通过</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[<span class=\"built_in\">UIApplication</span> sharedApplication] endBackgroundTask:<span class=\"keyword\">self</span>.backgroundTaskId];</span><br></pre></td></tr></table></figure>\n<p>手动通知系统任务完成。</p>\n<h2 id=\"后台传输\"><a href=\"#后台传输\" class=\"headerlink\" title=\"后台传输\"></a>后台传输</h2><p>很多情况下，在程序被唤醒后都要去下载/上传一个比较大的文件。即使通过上述方法延长了执行时间，可能也不足以等到文件传输完毕。好在苹果也提供了后台传输的方法，通过此方法，上传/下载任务会被交给操作系统执行，即使程序被 kill 掉，也可以继续完成传输任务。</p>\n<p>通过 AFNetworking，可以这样开启后台传输：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSURLSessionConfiguration</span> *config = [<span class=\"built_in\">NSURLSessionConfiguration</span> backgroundSessionConfigurationWithIdentifier:<span class=\"string\">@\"your.identifier\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">self</span>.manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:config];</span><br><span class=\"line\"><span class=\"built_in\">NSMutableURLRequest</span> *request = [AFHTTPRequestSerializer.serializer requestWithMethod:<span class=\"string\">@\"PUT\"</span> URLString:<span class=\"string\">@\"https://your.url\"</span> parameters:<span class=\"literal\">nil</span> error:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">request.timeoutInterval = <span class=\"number\">60.0</span>;</span><br><span class=\"line\">[[<span class=\"keyword\">self</span>.manager uploadTaskWithRequest:request fromData:<span class=\"literal\">nil</span> progress:<span class=\"literal\">nil</span> completionHandler:^(<span class=\"built_in\">NSURLResponse</span> * _Nonnull response, <span class=\"keyword\">id</span>  _Nullable responseObject, <span class=\"built_in\">NSError</span> * _Nullable error) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;] resume];</span><br></pre></td></tr></table></figure>\n<p>当后台传输完毕后，系统会调用</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"keyword\">void</span>)application:(<span class=\"built_in\">UIApplication</span> *)application handleEventsForBackgroundURLSession:(<span class=\"built_in\">NSString</span> *)identifier completionHandler:(<span class=\"keyword\">void</span> (^)(<span class=\"keyword\">void</span>))completionHandler</span><br></pre></td></tr></table></figure>\n<p>再次唤醒程序，并执行我们的代码。</p>\n"},{"title":"What are Dynamic Libraries ?","date":"2019-09-18T02:35:57.000Z","_content":"\n# What are Dynamic Libraries ?\n\nRef: [Overview of Dynamic Libraries](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html)\n\n动态库会在使用时动态地加载到内存中。在 Linux 上，动态库以 `.so` 结尾，在 macOS 上是 `.dylib`，而在 Windows 上是 `.dll`。\n\n## Usage\n\n以 macOS 为例，首先新建两个文件 `lib.c` 和 `lib.h`。\n\n```c\n//lib.h\nvoid lib_print();\n```\n\n```c\n//lib.c\n#include <stdio.h>\nvoid lib_print() {\n    printf(\"Hello World from lib!\");\n}\n```\n\n然后编译出 `.dylib` 文件：\n\n`gcc -dynamiclib lib.c -o libtest.dylib`\n\n编写 `main.c` 文件来验证一下：\n\n```c\n#include \"lib.h\"\nint main() {\n    lib_print();\n    return 0;\n}\n```\n\n编译的时候指定要链接的动态库：\n\n`gcc main.c -L. -ltest -o main`\n\n标准的动态库都以 `lib` 开头，如这里的 `libtest.dylib` 。如果不以 lib 开头，linker 就找不到它。\n\n## Load on Runtime\n\n在编译时制定要链接的动态库，这种用法看起来和静态库差不多。但动态库之所以动态的一个原因正是它可以在运行时动态地加载。\n\n修改 `main.c` 文件：\n\n```c\n#include <dlfcn.h>\n#include \"lib.h\"\n\ntypedef void(*Func)();\n\nint main() {\n    void *lib_handle = dlopen(\"libtest.dylib\", RTLD_LAZY);\n    Func lib_func = dlsym(lib_handle, \"lib_print\");\n    lib_func();\n    return 0;\n}\n```\n\n其中，`dlopen` 用于装载和链接一个动态库，而 `dlsym` 会返回 symbol 的地址。\n\n## .dylib vs .a\n\n- 动态链接会降低包体积\n- 将静态的事情放在动态来做，会拖慢程序的运行速度。但是 Apple 提供了 shared library cache 来做缓存。\n- 即使有缓存，仍需要查找 Procedure Linkage Table (PLT) 表。这个表记录了之前已经调用过的函数的地址。\n\n## Function Interposing\n\n`dyld` 提供了一般的 loader 没有的功能：函数拦截。这样我们可以轻松地 Hook 其他动态库中的函数（比如系统调用）。而在 Linux 中，Hook 系统调用就麻烦些。\n\n出自 *Mac OS X and iOS Internals: To the Apple's Core* 中的替换掉 `malloc` 和 `free` 的例子在互联网上已经泛滥，这里就不再赘述。在这个例子中，我们 Hook 掉之前 `lib.c` 重的 `lib_print` 函数。\n\n新建一个 `libhook.c` 文件。\n\n```c\n//libhook.c\n#include <stdio.h>\n#include \"lib.h\"\n\n#define DYLD_INTERPOSE(_replacment,_replacee) \\\n   __attribute__((used)) static struct{ const void* replacment; const void* replacee; } _interpose_##_replacee \\\n            __attribute__ ((section (\"__DATA,__interpose\"))) = { (const void*)(unsigned long)&_replacment, (const void*)(unsigned long)&_replacee };\n\nvoid another_print() {\n    printf(\"www.wangluyuan.cc\");\n}\n\nDYLD_INTERPOSE(another_print, lib_print)\n```\n\n中间的宏定义来源于 `/include/mach-o/dyld-interposing.h` 中。我们把它编译成一个动态库：\n\n`gcc -dynamiclib libhook.c -o libhook.dylib -L. -ltest`\n\n然后，通过 dyld 的环境变量，将这个动态库强制插入已经编译好的 main 程序中：\n\n`DYLD_INSERT_LIBRARIES=libhook.dylib ./main`\n\n```c\n//main.c\n#include \"lib.h\"\nint main() {\n    lib_print();\n    return 0;\n}\n```\n\n我们会发现 `lib_print` 的实现已经被替换了，而 main 对此毫不知情，表示很无辜。","source":"_posts/what-are-dynamic-libraries.md","raw":"---\ntitle: What are Dynamic Libraries ?\ndate: 2019-09-18 10:35:57\ntags: dyld\n---\n\n# What are Dynamic Libraries ?\n\nRef: [Overview of Dynamic Libraries](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html)\n\n动态库会在使用时动态地加载到内存中。在 Linux 上，动态库以 `.so` 结尾，在 macOS 上是 `.dylib`，而在 Windows 上是 `.dll`。\n\n## Usage\n\n以 macOS 为例，首先新建两个文件 `lib.c` 和 `lib.h`。\n\n```c\n//lib.h\nvoid lib_print();\n```\n\n```c\n//lib.c\n#include <stdio.h>\nvoid lib_print() {\n    printf(\"Hello World from lib!\");\n}\n```\n\n然后编译出 `.dylib` 文件：\n\n`gcc -dynamiclib lib.c -o libtest.dylib`\n\n编写 `main.c` 文件来验证一下：\n\n```c\n#include \"lib.h\"\nint main() {\n    lib_print();\n    return 0;\n}\n```\n\n编译的时候指定要链接的动态库：\n\n`gcc main.c -L. -ltest -o main`\n\n标准的动态库都以 `lib` 开头，如这里的 `libtest.dylib` 。如果不以 lib 开头，linker 就找不到它。\n\n## Load on Runtime\n\n在编译时制定要链接的动态库，这种用法看起来和静态库差不多。但动态库之所以动态的一个原因正是它可以在运行时动态地加载。\n\n修改 `main.c` 文件：\n\n```c\n#include <dlfcn.h>\n#include \"lib.h\"\n\ntypedef void(*Func)();\n\nint main() {\n    void *lib_handle = dlopen(\"libtest.dylib\", RTLD_LAZY);\n    Func lib_func = dlsym(lib_handle, \"lib_print\");\n    lib_func();\n    return 0;\n}\n```\n\n其中，`dlopen` 用于装载和链接一个动态库，而 `dlsym` 会返回 symbol 的地址。\n\n## .dylib vs .a\n\n- 动态链接会降低包体积\n- 将静态的事情放在动态来做，会拖慢程序的运行速度。但是 Apple 提供了 shared library cache 来做缓存。\n- 即使有缓存，仍需要查找 Procedure Linkage Table (PLT) 表。这个表记录了之前已经调用过的函数的地址。\n\n## Function Interposing\n\n`dyld` 提供了一般的 loader 没有的功能：函数拦截。这样我们可以轻松地 Hook 其他动态库中的函数（比如系统调用）。而在 Linux 中，Hook 系统调用就麻烦些。\n\n出自 *Mac OS X and iOS Internals: To the Apple's Core* 中的替换掉 `malloc` 和 `free` 的例子在互联网上已经泛滥，这里就不再赘述。在这个例子中，我们 Hook 掉之前 `lib.c` 重的 `lib_print` 函数。\n\n新建一个 `libhook.c` 文件。\n\n```c\n//libhook.c\n#include <stdio.h>\n#include \"lib.h\"\n\n#define DYLD_INTERPOSE(_replacment,_replacee) \\\n   __attribute__((used)) static struct{ const void* replacment; const void* replacee; } _interpose_##_replacee \\\n            __attribute__ ((section (\"__DATA,__interpose\"))) = { (const void*)(unsigned long)&_replacment, (const void*)(unsigned long)&_replacee };\n\nvoid another_print() {\n    printf(\"www.wangluyuan.cc\");\n}\n\nDYLD_INTERPOSE(another_print, lib_print)\n```\n\n中间的宏定义来源于 `/include/mach-o/dyld-interposing.h` 中。我们把它编译成一个动态库：\n\n`gcc -dynamiclib libhook.c -o libhook.dylib -L. -ltest`\n\n然后，通过 dyld 的环境变量，将这个动态库强制插入已经编译好的 main 程序中：\n\n`DYLD_INSERT_LIBRARIES=libhook.dylib ./main`\n\n```c\n//main.c\n#include \"lib.h\"\nint main() {\n    lib_print();\n    return 0;\n}\n```\n\n我们会发现 `lib_print` 的实现已经被替换了，而 main 对此毫不知情，表示很无辜。","slug":"what-are-dynamic-libraries","published":1,"updated":"2020-01-04T08:16:16.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3b0018ljc3fqt4lne9","content":"<h1 id=\"What-are-Dynamic-Libraries\"><a href=\"#What-are-Dynamic-Libraries\" class=\"headerlink\" title=\"What are Dynamic Libraries ?\"></a>What are Dynamic Libraries ?</h1><p>Ref: <a href=\"https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html\">Overview of Dynamic Libraries</a></p>\n<p>动态库会在使用时动态地加载到内存中。在 Linux 上，动态库以 <code>.so</code> 结尾，在 macOS 上是 <code>.dylib</code>，而在 Windows 上是 <code>.dll</code>。</p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>以 macOS 为例，首先新建两个文件 <code>lib.c</code> 和 <code>lib.h</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//lib.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lib_print</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//lib.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lib_print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World from lib!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后编译出 <code>.dylib</code> 文件：</p>\n<p><code>gcc -dynamiclib lib.c -o libtest.dylib</code></p>\n<p>编写 <code>main.c</code> 文件来验证一下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"lib.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lib_print();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译的时候指定要链接的动态库：</p>\n<p><code>gcc main.c -L. -ltest -o main</code></p>\n<p>标准的动态库都以 <code>lib</code> 开头，如这里的 <code>libtest.dylib</code> 。如果不以 lib 开头，linker 就找不到它。</p>\n<h2 id=\"Load-on-Runtime\"><a href=\"#Load-on-Runtime\" class=\"headerlink\" title=\"Load on Runtime\"></a>Load on Runtime</h2><p>在编译时制定要链接的动态库，这种用法看起来和静态库差不多。但动态库之所以动态的一个原因正是它可以在运行时动态地加载。</p>\n<p>修改 <code>main.c</code> 文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;dlfcn.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"lib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*Func)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *lib_handle = dlopen(<span class=\"string\">\"libtest.dylib\"</span>, RTLD_LAZY);</span><br><span class=\"line\">    Func lib_func = dlsym(lib_handle, <span class=\"string\">\"lib_print\"</span>);</span><br><span class=\"line\">    lib_func();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，<code>dlopen</code> 用于装载和链接一个动态库，而 <code>dlsym</code> 会返回 symbol 的地址。</p>\n<h2 id=\"dylib-vs-a\"><a href=\"#dylib-vs-a\" class=\"headerlink\" title=\".dylib vs .a\"></a>.dylib vs .a</h2><ul>\n<li>动态链接会降低包体积</li>\n<li>将静态的事情放在动态来做，会拖慢程序的运行速度。但是 Apple 提供了 shared library cache 来做缓存。</li>\n<li>即使有缓存，仍需要查找 Procedure Linkage Table (PLT) 表。这个表记录了之前已经调用过的函数的地址。</li>\n</ul>\n<h2 id=\"Function-Interposing\"><a href=\"#Function-Interposing\" class=\"headerlink\" title=\"Function Interposing\"></a>Function Interposing</h2><p><code>dyld</code> 提供了一般的 loader 没有的功能：函数拦截。这样我们可以轻松地 Hook 其他动态库中的函数（比如系统调用）。而在 Linux 中，Hook 系统调用就麻烦些。</p>\n<p>出自 <em>Mac OS X and iOS Internals: To the Apple’s Core</em> 中的替换掉 <code>malloc</code> 和 <code>free</code> 的例子在互联网上已经泛滥，这里就不再赘述。在这个例子中，我们 Hook 掉之前 <code>lib.c</code> 重的 <code>lib_print</code> 函数。</p>\n<p>新建一个 <code>libhook.c</code> 文件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//libhook.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"lib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DYLD_INTERPOSE(_replacment,_replacee) \\</span></span><br><span class=\"line\">   __attribute__((used)) <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span> <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* replacment; <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* replacee; &#125; _interpose_##_replacee \\</span><br><span class=\"line\">            __attribute__ ((section (<span class=\"string\">\"__DATA,__interpose\"</span>))) = &#123; (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>*)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;_replacment, (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>*)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;_replacee &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">another_print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"www.wangluyuan.cc\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DYLD_INTERPOSE(another_print, lib_print)</span><br></pre></td></tr></table></figure>\n<p>中间的宏定义来源于 <code>/include/mach-o/dyld-interposing.h</code> 中。我们把它编译成一个动态库：</p>\n<p><code>gcc -dynamiclib libhook.c -o libhook.dylib -L. -ltest</code></p>\n<p>然后，通过 dyld 的环境变量，将这个动态库强制插入已经编译好的 main 程序中：</p>\n<p><code>DYLD_INSERT_LIBRARIES=libhook.dylib ./main</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"lib.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lib_print();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们会发现 <code>lib_print</code> 的实现已经被替换了，而 main 对此毫不知情，表示很无辜。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"What-are-Dynamic-Libraries\"><a href=\"#What-are-Dynamic-Libraries\" class=\"headerlink\" title=\"What are Dynamic Libraries ?\"></a>What are Dynamic Libraries ?</h1><p>Ref: <a href=\"https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html\">Overview of Dynamic Libraries</a></p>\n<p>动态库会在使用时动态地加载到内存中。在 Linux 上，动态库以 <code>.so</code> 结尾，在 macOS 上是 <code>.dylib</code>，而在 Windows 上是 <code>.dll</code>。</p>\n<h2 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h2><p>以 macOS 为例，首先新建两个文件 <code>lib.c</code> 和 <code>lib.h</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//lib.h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lib_print</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//lib.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">lib_print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello World from lib!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后编译出 <code>.dylib</code> 文件：</p>\n<p><code>gcc -dynamiclib lib.c -o libtest.dylib</code></p>\n<p>编写 <code>main.c</code> 文件来验证一下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"lib.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lib_print();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译的时候指定要链接的动态库：</p>\n<p><code>gcc main.c -L. -ltest -o main</code></p>\n<p>标准的动态库都以 <code>lib</code> 开头，如这里的 <code>libtest.dylib</code> 。如果不以 lib 开头，linker 就找不到它。</p>\n<h2 id=\"Load-on-Runtime\"><a href=\"#Load-on-Runtime\" class=\"headerlink\" title=\"Load on Runtime\"></a>Load on Runtime</h2><p>在编译时制定要链接的动态库，这种用法看起来和静态库差不多。但动态库之所以动态的一个原因正是它可以在运行时动态地加载。</p>\n<p>修改 <code>main.c</code> 文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;dlfcn.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"lib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*Func)</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *lib_handle = dlopen(<span class=\"string\">\"libtest.dylib\"</span>, RTLD_LAZY);</span><br><span class=\"line\">    Func lib_func = dlsym(lib_handle, <span class=\"string\">\"lib_print\"</span>);</span><br><span class=\"line\">    lib_func();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中，<code>dlopen</code> 用于装载和链接一个动态库，而 <code>dlsym</code> 会返回 symbol 的地址。</p>\n<h2 id=\"dylib-vs-a\"><a href=\"#dylib-vs-a\" class=\"headerlink\" title=\".dylib vs .a\"></a>.dylib vs .a</h2><ul>\n<li>动态链接会降低包体积</li>\n<li>将静态的事情放在动态来做，会拖慢程序的运行速度。但是 Apple 提供了 shared library cache 来做缓存。</li>\n<li>即使有缓存，仍需要查找 Procedure Linkage Table (PLT) 表。这个表记录了之前已经调用过的函数的地址。</li>\n</ul>\n<h2 id=\"Function-Interposing\"><a href=\"#Function-Interposing\" class=\"headerlink\" title=\"Function Interposing\"></a>Function Interposing</h2><p><code>dyld</code> 提供了一般的 loader 没有的功能：函数拦截。这样我们可以轻松地 Hook 其他动态库中的函数（比如系统调用）。而在 Linux 中，Hook 系统调用就麻烦些。</p>\n<p>出自 <em>Mac OS X and iOS Internals: To the Apple’s Core</em> 中的替换掉 <code>malloc</code> 和 <code>free</code> 的例子在互联网上已经泛滥，这里就不再赘述。在这个例子中，我们 Hook 掉之前 <code>lib.c</code> 重的 <code>lib_print</code> 函数。</p>\n<p>新建一个 <code>libhook.c</code> 文件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//libhook.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"lib.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> DYLD_INTERPOSE(_replacment,_replacee) \\</span></span><br><span class=\"line\">   __attribute__((used)) <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span> <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* replacment; <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* replacee; &#125; _interpose_##_replacee \\</span><br><span class=\"line\">            __attribute__ ((section (<span class=\"string\">\"__DATA,__interpose\"</span>))) = &#123; (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>*)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;_replacment, (<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>*)(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>)&amp;_replacee &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">another_print</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"www.wangluyuan.cc\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">DYLD_INTERPOSE(another_print, lib_print)</span><br></pre></td></tr></table></figure>\n<p>中间的宏定义来源于 <code>/include/mach-o/dyld-interposing.h</code> 中。我们把它编译成一个动态库：</p>\n<p><code>gcc -dynamiclib libhook.c -o libhook.dylib -L. -ltest</code></p>\n<p>然后，通过 dyld 的环境变量，将这个动态库强制插入已经编译好的 main 程序中：</p>\n<p><code>DYLD_INSERT_LIBRARIES=libhook.dylib ./main</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"lib.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    lib_print();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们会发现 <code>lib_print</code> 的实现已经被替换了，而 main 对此毫不知情，表示很无辜。</p>\n"},{"title":"macOS上唤起其他程序并获取实时输出","date":"2018-05-25T08:50:08.000Z","_content":"\n# macOS 上唤起其他程序并获得实时输出\n\n在开发桌面端程序时，我们偶尔需要调用其他语言写的程序。桥接或者混编当然是比较好的方法，但会比较麻烦。如果可以，让我们自己的程序直接唤起另外一个程序 / 脚本，也是一种不错的选择。这个时候我们就需要两个进程之间互相通信。\n\n两个进程间通信，可以通过一个进程向控制台 print，另外一个从控制台 read 来完成。如果是用 Java 等语言实现，其实比较简单。这里我们谈的是使用 Swift / OC 开发原生应用时，如何实时地获取输出。\n\n### 场景\n\n在这个例子中，我使用 Swift 开发 macOS 的原生应用，它需要调用一个 Python 脚本来跑一些算法。Python 脚本会经常 print 一些值，我们需要时时读取它们。\n\n### 调用 Python 脚本\n\n在工程文件夹新建一个 Python 文件 `/Scripts/main.py` ，在这里编写算法。这样我们可以通过 Bundle 来获取到这个文件。\n\n在 NSViewController 的 ViewDidLoad 方法中，通过 Process 类来执行其他程序：\n\n```swift\nlet task = Process()\ntask.launchPath = \"/usr/bin/python\"\ntask.arguments = [Bundle.main.path(forResource: \"main\", ofType: \"py\")!]\ntask.launch()\n```\n\n注意以下几点：\n\n- NSTask 已经被弃用，应使用 Process。\n- launchPath 是你在 terminal 中调用的命令（比如，运行 main.py 需要在 terminal 中键入 `python main.py`，python 是命令，main.py 是参数）。但这里需要绝对路径，python 命令一般在 `/usr/bin/` 中，这取决于你具体的环境。\n- arguments 是参数。我们通过 Bundle 来获取脚本的绝对路径。\n- 调用 task.launch 启动任务。\n\n现在运行程序，可以看到 Python 脚本启动了，且在 Xcode 的控制台中源源不断地 print 信息。\n\n### 实时获取输出\n\n网上的大多数教程只会提及如何获取输出。当然，多数情况我们调用的程序都会很快执行完毕，我们只要获得最后的结果就好了。但是现在，我们的 Python 脚本会一直运行，我们要实时获取输出。\n\n通过 Pipe 来为两个 process 建立一个单工的通信信道：\n\n```swift\nlet outputPipe = Pipe()\ntask.standardOutput = outputPipe\n```\n\n现在，Python 脚本的 print 已经被转到了 pipe 中，在控制台看不到了。\n\n使用 FileHandle 来处理 Pipe 的输出。先在 NSViewController 类中添加一个新的变量：\n\n```swift\nvar outFile = FileHandle()\n```\n\n之后：\n\n```swift\noutFile = outputPipe.fileHandleForReading\n```\n\n此时已经可以直接获取 outFile 的 data 了。但是我们要的是实时，所以每次 outFile 有数据，都要发送通知：\n\n```swift\nNotificationCenter.default.addObserver(self, selector: #selector(onScriptOutputChanged), name: NSNotification.Name.NSFileHandleDataAvailable, object: outFile)\noutFile.waitForDataInBackgroundAndNotify()\n```\n\n在 onScriptOutputChanged 函数中：\n\n```swift\n@objc func onScriptOutputChanged() {\n    let data = outFile.availableData\n    let str = String(data: data, encoding: .utf8)\n    if let str = str {\n        print(str)\n    }\n    outFile.waitForDataInBackgroundAndNotify()\n}\n```\n\n注意，每次接收到通知都要再告诉 outFile 等待并通知一次，否则将只发送一次通知就结束了。\n\n现在运行程序，就可以实时拿到 Python 脚本的输出了。","source":"_posts/macOS上运行其他程序并获取实时输出.md","raw":"---\ntitle: macOS上唤起其他程序并获取实时输出\ndate: 2018-05-25 16:50:08\ntags: macOS\n---\n\n# macOS 上唤起其他程序并获得实时输出\n\n在开发桌面端程序时，我们偶尔需要调用其他语言写的程序。桥接或者混编当然是比较好的方法，但会比较麻烦。如果可以，让我们自己的程序直接唤起另外一个程序 / 脚本，也是一种不错的选择。这个时候我们就需要两个进程之间互相通信。\n\n两个进程间通信，可以通过一个进程向控制台 print，另外一个从控制台 read 来完成。如果是用 Java 等语言实现，其实比较简单。这里我们谈的是使用 Swift / OC 开发原生应用时，如何实时地获取输出。\n\n### 场景\n\n在这个例子中，我使用 Swift 开发 macOS 的原生应用，它需要调用一个 Python 脚本来跑一些算法。Python 脚本会经常 print 一些值，我们需要时时读取它们。\n\n### 调用 Python 脚本\n\n在工程文件夹新建一个 Python 文件 `/Scripts/main.py` ，在这里编写算法。这样我们可以通过 Bundle 来获取到这个文件。\n\n在 NSViewController 的 ViewDidLoad 方法中，通过 Process 类来执行其他程序：\n\n```swift\nlet task = Process()\ntask.launchPath = \"/usr/bin/python\"\ntask.arguments = [Bundle.main.path(forResource: \"main\", ofType: \"py\")!]\ntask.launch()\n```\n\n注意以下几点：\n\n- NSTask 已经被弃用，应使用 Process。\n- launchPath 是你在 terminal 中调用的命令（比如，运行 main.py 需要在 terminal 中键入 `python main.py`，python 是命令，main.py 是参数）。但这里需要绝对路径，python 命令一般在 `/usr/bin/` 中，这取决于你具体的环境。\n- arguments 是参数。我们通过 Bundle 来获取脚本的绝对路径。\n- 调用 task.launch 启动任务。\n\n现在运行程序，可以看到 Python 脚本启动了，且在 Xcode 的控制台中源源不断地 print 信息。\n\n### 实时获取输出\n\n网上的大多数教程只会提及如何获取输出。当然，多数情况我们调用的程序都会很快执行完毕，我们只要获得最后的结果就好了。但是现在，我们的 Python 脚本会一直运行，我们要实时获取输出。\n\n通过 Pipe 来为两个 process 建立一个单工的通信信道：\n\n```swift\nlet outputPipe = Pipe()\ntask.standardOutput = outputPipe\n```\n\n现在，Python 脚本的 print 已经被转到了 pipe 中，在控制台看不到了。\n\n使用 FileHandle 来处理 Pipe 的输出。先在 NSViewController 类中添加一个新的变量：\n\n```swift\nvar outFile = FileHandle()\n```\n\n之后：\n\n```swift\noutFile = outputPipe.fileHandleForReading\n```\n\n此时已经可以直接获取 outFile 的 data 了。但是我们要的是实时，所以每次 outFile 有数据，都要发送通知：\n\n```swift\nNotificationCenter.default.addObserver(self, selector: #selector(onScriptOutputChanged), name: NSNotification.Name.NSFileHandleDataAvailable, object: outFile)\noutFile.waitForDataInBackgroundAndNotify()\n```\n\n在 onScriptOutputChanged 函数中：\n\n```swift\n@objc func onScriptOutputChanged() {\n    let data = outFile.availableData\n    let str = String(data: data, encoding: .utf8)\n    if let str = str {\n        print(str)\n    }\n    outFile.waitForDataInBackgroundAndNotify()\n}\n```\n\n注意，每次接收到通知都要再告诉 outFile 等待并通知一次，否则将只发送一次通知就结束了。\n\n现在运行程序，就可以实时拿到 Python 脚本的输出了。","slug":"macOS上运行其他程序并获取实时输出","published":1,"updated":"2020-01-04T08:16:16.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3c001aljc39nl3taf3","content":"<h1 id=\"macOS-上唤起其他程序并获得实时输出\"><a href=\"#macOS-上唤起其他程序并获得实时输出\" class=\"headerlink\" title=\"macOS 上唤起其他程序并获得实时输出\"></a>macOS 上唤起其他程序并获得实时输出</h1><p>在开发桌面端程序时，我们偶尔需要调用其他语言写的程序。桥接或者混编当然是比较好的方法，但会比较麻烦。如果可以，让我们自己的程序直接唤起另外一个程序 / 脚本，也是一种不错的选择。这个时候我们就需要两个进程之间互相通信。</p>\n<p>两个进程间通信，可以通过一个进程向控制台 print，另外一个从控制台 read 来完成。如果是用 Java 等语言实现，其实比较简单。这里我们谈的是使用 Swift / OC 开发原生应用时，如何实时地获取输出。</p>\n<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><p>在这个例子中，我使用 Swift 开发 macOS 的原生应用，它需要调用一个 Python 脚本来跑一些算法。Python 脚本会经常 print 一些值，我们需要时时读取它们。</p>\n<h3 id=\"调用-Python-脚本\"><a href=\"#调用-Python-脚本\" class=\"headerlink\" title=\"调用 Python 脚本\"></a>调用 Python 脚本</h3><p>在工程文件夹新建一个 Python 文件 <code>/Scripts/main.py</code> ，在这里编写算法。这样我们可以通过 Bundle 来获取到这个文件。</p>\n<p>在 NSViewController 的 ViewDidLoad 方法中，通过 Process 类来执行其他程序：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> task = <span class=\"type\">Process</span>()</span><br><span class=\"line\">task.launchPath = <span class=\"string\">\"/usr/bin/python\"</span></span><br><span class=\"line\">task.arguments = [<span class=\"type\">Bundle</span>.main.path(forResource: <span class=\"string\">\"main\"</span>, ofType: <span class=\"string\">\"py\"</span>)!]</span><br><span class=\"line\">task.launch()</span><br></pre></td></tr></table></figure>\n<p>注意以下几点：</p>\n<ul>\n<li>NSTask 已经被弃用，应使用 Process。</li>\n<li>launchPath 是你在 terminal 中调用的命令（比如，运行 main.py 需要在 terminal 中键入 <code>python main.py</code>，python 是命令，main.py 是参数）。但这里需要绝对路径，python 命令一般在 <code>/usr/bin/</code> 中，这取决于你具体的环境。</li>\n<li>arguments 是参数。我们通过 Bundle 来获取脚本的绝对路径。</li>\n<li>调用 task.launch 启动任务。</li>\n</ul>\n<p>现在运行程序，可以看到 Python 脚本启动了，且在 Xcode 的控制台中源源不断地 print 信息。</p>\n<h3 id=\"实时获取输出\"><a href=\"#实时获取输出\" class=\"headerlink\" title=\"实时获取输出\"></a>实时获取输出</h3><p>网上的大多数教程只会提及如何获取输出。当然，多数情况我们调用的程序都会很快执行完毕，我们只要获得最后的结果就好了。但是现在，我们的 Python 脚本会一直运行，我们要实时获取输出。</p>\n<p>通过 Pipe 来为两个 process 建立一个单工的通信信道：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> outputPipe = <span class=\"type\">Pipe</span>()</span><br><span class=\"line\">task.standardOutput = outputPipe</span><br></pre></td></tr></table></figure>\n<p>现在，Python 脚本的 print 已经被转到了 pipe 中，在控制台看不到了。</p>\n<p>使用 FileHandle 来处理 Pipe 的输出。先在 NSViewController 类中添加一个新的变量：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outFile = <span class=\"type\">FileHandle</span>()</span><br></pre></td></tr></table></figure>\n<p>之后：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">outFile = outputPipe.fileHandleForReading</span><br></pre></td></tr></table></figure>\n<p>此时已经可以直接获取 outFile 的 data 了。但是我们要的是实时，所以每次 outFile 有数据，都要发送通知：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(onScriptOutputChanged), name: <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"type\">NSFileHandleDataAvailable</span>, object: outFile)</span><br><span class=\"line\">outFile.waitForDataInBackgroundAndNotify()</span><br></pre></td></tr></table></figure>\n<p>在 onScriptOutputChanged 函数中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onScriptOutputChanged</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = outFile.availableData</span><br><span class=\"line\">    <span class=\"keyword\">let</span> str = <span class=\"type\">String</span>(data: data, encoding: .utf8)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> str = str &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(str)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    outFile.waitForDataInBackgroundAndNotify()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，每次接收到通知都要再告诉 outFile 等待并通知一次，否则将只发送一次通知就结束了。</p>\n<p>现在运行程序，就可以实时拿到 Python 脚本的输出了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"macOS-上唤起其他程序并获得实时输出\"><a href=\"#macOS-上唤起其他程序并获得实时输出\" class=\"headerlink\" title=\"macOS 上唤起其他程序并获得实时输出\"></a>macOS 上唤起其他程序并获得实时输出</h1><p>在开发桌面端程序时，我们偶尔需要调用其他语言写的程序。桥接或者混编当然是比较好的方法，但会比较麻烦。如果可以，让我们自己的程序直接唤起另外一个程序 / 脚本，也是一种不错的选择。这个时候我们就需要两个进程之间互相通信。</p>\n<p>两个进程间通信，可以通过一个进程向控制台 print，另外一个从控制台 read 来完成。如果是用 Java 等语言实现，其实比较简单。这里我们谈的是使用 Swift / OC 开发原生应用时，如何实时地获取输出。</p>\n<h3 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h3><p>在这个例子中，我使用 Swift 开发 macOS 的原生应用，它需要调用一个 Python 脚本来跑一些算法。Python 脚本会经常 print 一些值，我们需要时时读取它们。</p>\n<h3 id=\"调用-Python-脚本\"><a href=\"#调用-Python-脚本\" class=\"headerlink\" title=\"调用 Python 脚本\"></a>调用 Python 脚本</h3><p>在工程文件夹新建一个 Python 文件 <code>/Scripts/main.py</code> ，在这里编写算法。这样我们可以通过 Bundle 来获取到这个文件。</p>\n<p>在 NSViewController 的 ViewDidLoad 方法中，通过 Process 类来执行其他程序：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> task = <span class=\"type\">Process</span>()</span><br><span class=\"line\">task.launchPath = <span class=\"string\">\"/usr/bin/python\"</span></span><br><span class=\"line\">task.arguments = [<span class=\"type\">Bundle</span>.main.path(forResource: <span class=\"string\">\"main\"</span>, ofType: <span class=\"string\">\"py\"</span>)!]</span><br><span class=\"line\">task.launch()</span><br></pre></td></tr></table></figure>\n<p>注意以下几点：</p>\n<ul>\n<li>NSTask 已经被弃用，应使用 Process。</li>\n<li>launchPath 是你在 terminal 中调用的命令（比如，运行 main.py 需要在 terminal 中键入 <code>python main.py</code>，python 是命令，main.py 是参数）。但这里需要绝对路径，python 命令一般在 <code>/usr/bin/</code> 中，这取决于你具体的环境。</li>\n<li>arguments 是参数。我们通过 Bundle 来获取脚本的绝对路径。</li>\n<li>调用 task.launch 启动任务。</li>\n</ul>\n<p>现在运行程序，可以看到 Python 脚本启动了，且在 Xcode 的控制台中源源不断地 print 信息。</p>\n<h3 id=\"实时获取输出\"><a href=\"#实时获取输出\" class=\"headerlink\" title=\"实时获取输出\"></a>实时获取输出</h3><p>网上的大多数教程只会提及如何获取输出。当然，多数情况我们调用的程序都会很快执行完毕，我们只要获得最后的结果就好了。但是现在，我们的 Python 脚本会一直运行，我们要实时获取输出。</p>\n<p>通过 Pipe 来为两个 process 建立一个单工的通信信道：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> outputPipe = <span class=\"type\">Pipe</span>()</span><br><span class=\"line\">task.standardOutput = outputPipe</span><br></pre></td></tr></table></figure>\n<p>现在，Python 脚本的 print 已经被转到了 pipe 中，在控制台看不到了。</p>\n<p>使用 FileHandle 来处理 Pipe 的输出。先在 NSViewController 类中添加一个新的变量：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> outFile = <span class=\"type\">FileHandle</span>()</span><br></pre></td></tr></table></figure>\n<p>之后：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">outFile = outputPipe.fileHandleForReading</span><br></pre></td></tr></table></figure>\n<p>此时已经可以直接获取 outFile 的 data 了。但是我们要的是实时，所以每次 outFile 有数据，都要发送通知：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NotificationCenter</span>.<span class=\"keyword\">default</span>.addObserver(<span class=\"keyword\">self</span>, selector: #selector(onScriptOutputChanged), name: <span class=\"type\">NSNotification</span>.<span class=\"type\">Name</span>.<span class=\"type\">NSFileHandleDataAvailable</span>, object: outFile)</span><br><span class=\"line\">outFile.waitForDataInBackgroundAndNotify()</span><br></pre></td></tr></table></figure>\n<p>在 onScriptOutputChanged 函数中：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onScriptOutputChanged</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = outFile.availableData</span><br><span class=\"line\">    <span class=\"keyword\">let</span> str = <span class=\"type\">String</span>(data: data, encoding: .utf8)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> str = str &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(str)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    outFile.waitForDataInBackgroundAndNotify()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意，每次接收到通知都要再告诉 outFile 等待并通知一次，否则将只发送一次通知就结束了。</p>\n<p>现在运行程序，就可以实时拿到 Python 脚本的输出了。</p>\n"},{"title":"动态规划法","date":"2018-03-25T05:27:28.000Z","_content":"\n# 动态规划法\n\n### 最长公共子序列\n\n**题目：**\n\n求两个字符串 X 和 Y 的最长公共子序列长度。例如：\"abcbdab\" 和 \"bdcaba\" 的最长公共子序列之一为 \"bcba\"，故应输出 4。\n\n**思路：**\n\n利用动态规划法，在二维数组 c\\[m+1][n+1] 中保存 $X_i$ 与 $Y_j$ 的最长公共子序列（LCS）的长度，其中 m 和 n 分别代表 X 和 Y 的长度。求解 c 的规则如下：\n\n- 如果 X[i] == Y[j]，那么 c\\[i][j] = c\\[i-1][j-1] + 1。试想：abcd 和 abcEd，因为 d == d，我们又知道 abc 和 abcE 的 LCS 长度为 3，所以这两个字符串的 LCS 长度应为 3+1=4。\n- 如果不等，则 c\\[i][j] = MAX(c\\[i-1][j], c\\[i][j-1])。当前的字符不相等，故为上一次计算结果中较大的那个。\n- i == 0 或 j == 0 时，为 0。\n\n**Java 实现：**\n\n```java\nint getLongestCommonSubsequenceLength(String X, String Y) {\n    int m = X.length();\n    int n = Y.length();\n    X = \" \" + X; //在字符串前插入空格\n    Y = \" \" + Y;\n    int c[][] = new int[m+1][n+1];\n    for(int i=1; i<=m; i++) {\n        c[i][0] = 0;\n    }\n    for(int i=1; i<=n; i++) {\n        c[0][i] = 0;\n    }\n    for(int i=1; i<=m; i++) {\n        for(int j=1; j<=n; j++) {\n            if(X.charAt(i) == Y.charAt(j)) {\n                c[i][j] = c[i-1][j-1] + 1;\n            } else {\n                c[i][j] = c[i-1][j] > c[i][j-1] ? c[i-1][j] : c[i][j-1];\n            }\n        }\n    }\n    return c[m][n];\n}\n```\n\n为什么要在字符串前插入一个无意义的空格，并把数组长度设为 m+1，n+1 呢？因为 0 列和 0 行被我们全部置零用于满足第三条条件了，所以需要多一行、一列的存储空间。当然不存，手动判断也是可以的。\n\n### 硬币问题\n\n**题目：**\n\n现有面值为 c1, c2, c3, … , cm 元的 m 种硬币，求支付 n 元时所需硬币的最少枚数。各面值的硬币可任意使用 n 次。\n\n**思路：**\n\n我们用 C[i] 表示第 i 种硬币的面值。用 T\\[i][j] 表示使用第 0 至第 i 种硬币支付 j 元时的最少硬币数。\n\n那么，给定某个需要支付的金额 j，求解 T\\[i][j] 时有两个选择，一时选用第 i 种硬币，二是不用第 i 种硬币，我们选这两者之间较小的方案即可。也就是 `T[i][j] = min(T[i-1][j], T[i][j-C[i]] + 1)` 。\n\n其中，`T[i-1][j]` 表示不使用，而 `T[i][j-C[i]]` 表示使用，所以还要多加上使用的这枚硬币。\n\n但是我们没必要给每种面值都记录一个最优枚数，只需要记录最小的就可以了。因此可化简为 `T[j] = min(T[j], T[j-C[i]]+1)` 。\n\n**Java 实现：**\n\n```java\nstatic int getMinNumOfCoin(int[] C, int amout) {\n    int[] T = new int[amout+1];\n    for(int i=0; i<T.length; i++) {\n        T[i] = Integer.MAX_VALUE;\n    }\n    T[0] = 0;\n    for(int i=0; i<C.length; i++) {\n        //外层循环遍历了使用第i种硬币 / 不使用第i种硬币的可能 我们只记录最小的情况\n        for(int j=C[i]; j<=amout; j++) {\n            T[j] = Integer.min(T[j], T[j-C[i]]+1);\n        }\n    }\n    return T[amout];\n}\n```\n\n### 背包问题\n\n**题目：**\n\n现有价值分别为 $v_i$, 重量分别为 $w_i$ 的 N 块宝石。作为珠宝大盗的你，最多能背动总重量为 W 的背包。请问你这次盗窃的总收益最多为多少？\n\n**思路：**\n\n这道问题是每个物品选或不选的组合，因此被称为 0-1 背包问题。我们用 `C[i][w]` 表示前 i 个物品装入容量为 w 的背包时的总价值的最大值，递增背包容量 w 至最大值来求解。求出 `C[i][w]` 的值为以下二者中较大的一个：\n\n- `C[i-1][w - 物品i的重量] + 物品i的价值`\n- `C[i-1][w]` \n\n第一种即选择 i 的情况，第二种为不选择 i 的情况。\n\n**Java 实现：**\n\n```java\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n\n        Item[] items = new Item[5];\n        items[1] = new Item(4,2);\n        items[2] = new Item(5,2);\n        items[3] = new Item(2,1);\n        items[4] = new Item(8,3);\n\n        System.out.println(getMaxValue(items, 5));\n    }\n\n    static int getMaxValue(Item[] items, int weight) {\n        int[][] C = new int[items.length][weight+1];\n        for(int i=0; i<C.length; i++) {\n            for(int j=0; j<C[i].length; j++) {\n                C[i][j] = 0;\n            }\n        }\n        for(int i=1; i<items.length; i++) {\n            for(int j=1; j<=weight; j++) {\n                if(items[i].weight > j) {\n                    //不可能选择\n                } else {\n                    C[i][j] = Integer.max(C[i-1][j], C[i-1][j-items[i].weight] + items[i].value);\n                }\n            }\n        }\n        return C[items.length-1][weight];\n    }\n}\n\nclass Item {\n    public int value;\n    public int weight;\n\n    public Item(int value, int weight) {\n        this.value = value;\n        this.weight = weight;\n    }\n}\n```","source":"_posts/动态规划法.md","raw":"---\ntitle: 动态规划法\ndate: 2018-03-25 13:27:28\ntags: Algorithm\n---\n\n# 动态规划法\n\n### 最长公共子序列\n\n**题目：**\n\n求两个字符串 X 和 Y 的最长公共子序列长度。例如：\"abcbdab\" 和 \"bdcaba\" 的最长公共子序列之一为 \"bcba\"，故应输出 4。\n\n**思路：**\n\n利用动态规划法，在二维数组 c\\[m+1][n+1] 中保存 $X_i$ 与 $Y_j$ 的最长公共子序列（LCS）的长度，其中 m 和 n 分别代表 X 和 Y 的长度。求解 c 的规则如下：\n\n- 如果 X[i] == Y[j]，那么 c\\[i][j] = c\\[i-1][j-1] + 1。试想：abcd 和 abcEd，因为 d == d，我们又知道 abc 和 abcE 的 LCS 长度为 3，所以这两个字符串的 LCS 长度应为 3+1=4。\n- 如果不等，则 c\\[i][j] = MAX(c\\[i-1][j], c\\[i][j-1])。当前的字符不相等，故为上一次计算结果中较大的那个。\n- i == 0 或 j == 0 时，为 0。\n\n**Java 实现：**\n\n```java\nint getLongestCommonSubsequenceLength(String X, String Y) {\n    int m = X.length();\n    int n = Y.length();\n    X = \" \" + X; //在字符串前插入空格\n    Y = \" \" + Y;\n    int c[][] = new int[m+1][n+1];\n    for(int i=1; i<=m; i++) {\n        c[i][0] = 0;\n    }\n    for(int i=1; i<=n; i++) {\n        c[0][i] = 0;\n    }\n    for(int i=1; i<=m; i++) {\n        for(int j=1; j<=n; j++) {\n            if(X.charAt(i) == Y.charAt(j)) {\n                c[i][j] = c[i-1][j-1] + 1;\n            } else {\n                c[i][j] = c[i-1][j] > c[i][j-1] ? c[i-1][j] : c[i][j-1];\n            }\n        }\n    }\n    return c[m][n];\n}\n```\n\n为什么要在字符串前插入一个无意义的空格，并把数组长度设为 m+1，n+1 呢？因为 0 列和 0 行被我们全部置零用于满足第三条条件了，所以需要多一行、一列的存储空间。当然不存，手动判断也是可以的。\n\n### 硬币问题\n\n**题目：**\n\n现有面值为 c1, c2, c3, … , cm 元的 m 种硬币，求支付 n 元时所需硬币的最少枚数。各面值的硬币可任意使用 n 次。\n\n**思路：**\n\n我们用 C[i] 表示第 i 种硬币的面值。用 T\\[i][j] 表示使用第 0 至第 i 种硬币支付 j 元时的最少硬币数。\n\n那么，给定某个需要支付的金额 j，求解 T\\[i][j] 时有两个选择，一时选用第 i 种硬币，二是不用第 i 种硬币，我们选这两者之间较小的方案即可。也就是 `T[i][j] = min(T[i-1][j], T[i][j-C[i]] + 1)` 。\n\n其中，`T[i-1][j]` 表示不使用，而 `T[i][j-C[i]]` 表示使用，所以还要多加上使用的这枚硬币。\n\n但是我们没必要给每种面值都记录一个最优枚数，只需要记录最小的就可以了。因此可化简为 `T[j] = min(T[j], T[j-C[i]]+1)` 。\n\n**Java 实现：**\n\n```java\nstatic int getMinNumOfCoin(int[] C, int amout) {\n    int[] T = new int[amout+1];\n    for(int i=0; i<T.length; i++) {\n        T[i] = Integer.MAX_VALUE;\n    }\n    T[0] = 0;\n    for(int i=0; i<C.length; i++) {\n        //外层循环遍历了使用第i种硬币 / 不使用第i种硬币的可能 我们只记录最小的情况\n        for(int j=C[i]; j<=amout; j++) {\n            T[j] = Integer.min(T[j], T[j-C[i]]+1);\n        }\n    }\n    return T[amout];\n}\n```\n\n### 背包问题\n\n**题目：**\n\n现有价值分别为 $v_i$, 重量分别为 $w_i$ 的 N 块宝石。作为珠宝大盗的你，最多能背动总重量为 W 的背包。请问你这次盗窃的总收益最多为多少？\n\n**思路：**\n\n这道问题是每个物品选或不选的组合，因此被称为 0-1 背包问题。我们用 `C[i][w]` 表示前 i 个物品装入容量为 w 的背包时的总价值的最大值，递增背包容量 w 至最大值来求解。求出 `C[i][w]` 的值为以下二者中较大的一个：\n\n- `C[i-1][w - 物品i的重量] + 物品i的价值`\n- `C[i-1][w]` \n\n第一种即选择 i 的情况，第二种为不选择 i 的情况。\n\n**Java 实现：**\n\n```java\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n\n        Item[] items = new Item[5];\n        items[1] = new Item(4,2);\n        items[2] = new Item(5,2);\n        items[3] = new Item(2,1);\n        items[4] = new Item(8,3);\n\n        System.out.println(getMaxValue(items, 5));\n    }\n\n    static int getMaxValue(Item[] items, int weight) {\n        int[][] C = new int[items.length][weight+1];\n        for(int i=0; i<C.length; i++) {\n            for(int j=0; j<C[i].length; j++) {\n                C[i][j] = 0;\n            }\n        }\n        for(int i=1; i<items.length; i++) {\n            for(int j=1; j<=weight; j++) {\n                if(items[i].weight > j) {\n                    //不可能选择\n                } else {\n                    C[i][j] = Integer.max(C[i-1][j], C[i-1][j-items[i].weight] + items[i].value);\n                }\n            }\n        }\n        return C[items.length-1][weight];\n    }\n}\n\nclass Item {\n    public int value;\n    public int weight;\n\n    public Item(int value, int weight) {\n        this.value = value;\n        this.weight = weight;\n    }\n}\n```","slug":"动态规划法","published":1,"updated":"2020-01-04T08:16:16.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3c001cljc3l1yuruxz","content":"<h1 id=\"动态规划法\"><a href=\"#动态规划法\" class=\"headerlink\" title=\"动态规划法\"></a>动态规划法</h1><h3 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h3><p><strong>题目：</strong></p>\n<p>求两个字符串 X 和 Y 的最长公共子序列长度。例如：”abcbdab” 和 “bdcaba” 的最长公共子序列之一为 “bcba”，故应输出 4。</p>\n<p><strong>思路：</strong></p>\n<p>利用动态规划法，在二维数组 c[m+1][n+1] 中保存 $X_i$ 与 $Y_j$ 的最长公共子序列（LCS）的长度，其中 m 和 n 分别代表 X 和 Y 的长度。求解 c 的规则如下：</p>\n<ul>\n<li>如果 X[i] == Y[j]，那么 c[i][j] = c[i-1][j-1] + 1。试想：abcd 和 abcEd，因为 d == d，我们又知道 abc 和 abcE 的 LCS 长度为 3，所以这两个字符串的 LCS 长度应为 3+1=4。</li>\n<li>如果不等，则 c[i][j] = MAX(c[i-1][j], c[i][j-1])。当前的字符不相等，故为上一次计算结果中较大的那个。</li>\n<li>i == 0 或 j == 0 时，为 0。</li>\n</ul>\n<p><strong>Java 实现：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLongestCommonSubsequenceLength</span><span class=\"params\">(String X, String Y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = X.length();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = Y.length();</span><br><span class=\"line\">    X = <span class=\"string\">\" \"</span> + X; <span class=\"comment\">//在字符串前插入空格</span></span><br><span class=\"line\">    Y = <span class=\"string\">\" \"</span> + Y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c[][] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m+<span class=\"number\">1</span>][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; i++) &#123;</span><br><span class=\"line\">        c[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++) &#123;</span><br><span class=\"line\">        c[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;=n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(X.charAt(i) == Y.charAt(j)) &#123;</span><br><span class=\"line\">                c[i][j] = c[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                c[i][j] = c[i-<span class=\"number\">1</span>][j] &gt; c[i][j-<span class=\"number\">1</span>] ? c[i-<span class=\"number\">1</span>][j] : c[i][j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c[m][n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为什么要在字符串前插入一个无意义的空格，并把数组长度设为 m+1，n+1 呢？因为 0 列和 0 行被我们全部置零用于满足第三条条件了，所以需要多一行、一列的存储空间。当然不存，手动判断也是可以的。</p>\n<h3 id=\"硬币问题\"><a href=\"#硬币问题\" class=\"headerlink\" title=\"硬币问题\"></a>硬币问题</h3><p><strong>题目：</strong></p>\n<p>现有面值为 c1, c2, c3, … , cm 元的 m 种硬币，求支付 n 元时所需硬币的最少枚数。各面值的硬币可任意使用 n 次。</p>\n<p><strong>思路：</strong></p>\n<p>我们用 C[i] 表示第 i 种硬币的面值。用 T[i][j] 表示使用第 0 至第 i 种硬币支付 j 元时的最少硬币数。</p>\n<p>那么，给定某个需要支付的金额 j，求解 T[i][j] 时有两个选择，一时选用第 i 种硬币，二是不用第 i 种硬币，我们选这两者之间较小的方案即可。也就是 <code>T[i][j] = min(T[i-1][j], T[i][j-C[i]] + 1)</code> 。</p>\n<p>其中，<code>T[i-1][j]</code> 表示不使用，而 <code>T[i][j-C[i]]</code> 表示使用，所以还要多加上使用的这枚硬币。</p>\n<p>但是我们没必要给每种面值都记录一个最优枚数，只需要记录最小的就可以了。因此可化简为 <code>T[j] = min(T[j], T[j-C[i]]+1)</code> 。</p>\n<p><strong>Java 实现：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getMinNumOfCoin</span><span class=\"params\">(<span class=\"keyword\">int</span>[] C, <span class=\"keyword\">int</span> amout)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] T = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[amout+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;T.length; i++) &#123;</span><br><span class=\"line\">        T[i] = Integer.MAX_VALUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    T[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;C.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//外层循环遍历了使用第i种硬币 / 不使用第i种硬币的可能 我们只记录最小的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=C[i]; j&lt;=amout; j++) &#123;</span><br><span class=\"line\">            T[j] = Integer.min(T[j], T[j-C[i]]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> T[amout];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h3><p><strong>题目：</strong></p>\n<p>现有价值分别为 $v_i$, 重量分别为 $w_i$ 的 N 块宝石。作为珠宝大盗的你，最多能背动总重量为 W 的背包。请问你这次盗窃的总收益最多为多少？</p>\n<p><strong>思路：</strong></p>\n<p>这道问题是每个物品选或不选的组合，因此被称为 0-1 背包问题。我们用 <code>C[i][w]</code> 表示前 i 个物品装入容量为 w 的背包时的总价值的最大值，递增背包容量 w 至最大值来求解。求出 <code>C[i][w]</code> 的值为以下二者中较大的一个：</p>\n<ul>\n<li><code>C[i-1][w - 物品i的重量] + 物品i的价值</code></li>\n<li><code>C[i-1][w]</code> </li>\n</ul>\n<p>第一种即选择 i 的情况，第二种为不选择 i 的情况。</p>\n<p><strong>Java 实现：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Item[] items = <span class=\"keyword\">new</span> Item[<span class=\"number\">5</span>];</span><br><span class=\"line\">        items[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> Item(<span class=\"number\">4</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">        items[<span class=\"number\">2</span>] = <span class=\"keyword\">new</span> Item(<span class=\"number\">5</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">        items[<span class=\"number\">3</span>] = <span class=\"keyword\">new</span> Item(<span class=\"number\">2</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        items[<span class=\"number\">4</span>] = <span class=\"keyword\">new</span> Item(<span class=\"number\">8</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(getMaxValue(items, <span class=\"number\">5</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getMaxValue</span><span class=\"params\">(Item[] items, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] C = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[items.length][weight+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;C.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;C[i].length; j++) &#123;</span><br><span class=\"line\">                C[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;items.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;=weight; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(items[i].weight &gt; j) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//不可能选择</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    C[i][j] = Integer.max(C[i-<span class=\"number\">1</span>][j], C[i-<span class=\"number\">1</span>][j-items[i].weight] + items[i].value);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> C[items.length-<span class=\"number\">1</span>][weight];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Item</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Item</span><span class=\"params\">(<span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"动态规划法\"><a href=\"#动态规划法\" class=\"headerlink\" title=\"动态规划法\"></a>动态规划法</h1><h3 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h3><p><strong>题目：</strong></p>\n<p>求两个字符串 X 和 Y 的最长公共子序列长度。例如：”abcbdab” 和 “bdcaba” 的最长公共子序列之一为 “bcba”，故应输出 4。</p>\n<p><strong>思路：</strong></p>\n<p>利用动态规划法，在二维数组 c[m+1][n+1] 中保存 $X_i$ 与 $Y_j$ 的最长公共子序列（LCS）的长度，其中 m 和 n 分别代表 X 和 Y 的长度。求解 c 的规则如下：</p>\n<ul>\n<li>如果 X[i] == Y[j]，那么 c[i][j] = c[i-1][j-1] + 1。试想：abcd 和 abcEd，因为 d == d，我们又知道 abc 和 abcE 的 LCS 长度为 3，所以这两个字符串的 LCS 长度应为 3+1=4。</li>\n<li>如果不等，则 c[i][j] = MAX(c[i-1][j], c[i][j-1])。当前的字符不相等，故为上一次计算结果中较大的那个。</li>\n<li>i == 0 或 j == 0 时，为 0。</li>\n</ul>\n<p><strong>Java 实现：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getLongestCommonSubsequenceLength</span><span class=\"params\">(String X, String Y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = X.length();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = Y.length();</span><br><span class=\"line\">    X = <span class=\"string\">\" \"</span> + X; <span class=\"comment\">//在字符串前插入空格</span></span><br><span class=\"line\">    Y = <span class=\"string\">\" \"</span> + Y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c[][] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[m+<span class=\"number\">1</span>][n+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; i++) &#123;</span><br><span class=\"line\">        c[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=n; i++) &#123;</span><br><span class=\"line\">        c[<span class=\"number\">0</span>][i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=m; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;=n; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(X.charAt(i) == Y.charAt(j)) &#123;</span><br><span class=\"line\">                c[i][j] = c[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                c[i][j] = c[i-<span class=\"number\">1</span>][j] &gt; c[i][j-<span class=\"number\">1</span>] ? c[i-<span class=\"number\">1</span>][j] : c[i][j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> c[m][n];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为什么要在字符串前插入一个无意义的空格，并把数组长度设为 m+1，n+1 呢？因为 0 列和 0 行被我们全部置零用于满足第三条条件了，所以需要多一行、一列的存储空间。当然不存，手动判断也是可以的。</p>\n<h3 id=\"硬币问题\"><a href=\"#硬币问题\" class=\"headerlink\" title=\"硬币问题\"></a>硬币问题</h3><p><strong>题目：</strong></p>\n<p>现有面值为 c1, c2, c3, … , cm 元的 m 种硬币，求支付 n 元时所需硬币的最少枚数。各面值的硬币可任意使用 n 次。</p>\n<p><strong>思路：</strong></p>\n<p>我们用 C[i] 表示第 i 种硬币的面值。用 T[i][j] 表示使用第 0 至第 i 种硬币支付 j 元时的最少硬币数。</p>\n<p>那么，给定某个需要支付的金额 j，求解 T[i][j] 时有两个选择，一时选用第 i 种硬币，二是不用第 i 种硬币，我们选这两者之间较小的方案即可。也就是 <code>T[i][j] = min(T[i-1][j], T[i][j-C[i]] + 1)</code> 。</p>\n<p>其中，<code>T[i-1][j]</code> 表示不使用，而 <code>T[i][j-C[i]]</code> 表示使用，所以还要多加上使用的这枚硬币。</p>\n<p>但是我们没必要给每种面值都记录一个最优枚数，只需要记录最小的就可以了。因此可化简为 <code>T[j] = min(T[j], T[j-C[i]]+1)</code> 。</p>\n<p><strong>Java 实现：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getMinNumOfCoin</span><span class=\"params\">(<span class=\"keyword\">int</span>[] C, <span class=\"keyword\">int</span> amout)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] T = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[amout+<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;T.length; i++) &#123;</span><br><span class=\"line\">        T[i] = Integer.MAX_VALUE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    T[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;C.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//外层循环遍历了使用第i种硬币 / 不使用第i种硬币的可能 我们只记录最小的情况</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=C[i]; j&lt;=amout; j++) &#123;</span><br><span class=\"line\">            T[j] = Integer.min(T[j], T[j-C[i]]+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> T[amout];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"背包问题\"><a href=\"#背包问题\" class=\"headerlink\" title=\"背包问题\"></a>背包问题</h3><p><strong>题目：</strong></p>\n<p>现有价值分别为 $v_i$, 重量分别为 $w_i$ 的 N 块宝石。作为珠宝大盗的你，最多能背动总重量为 W 的背包。请问你这次盗窃的总收益最多为多少？</p>\n<p><strong>思路：</strong></p>\n<p>这道问题是每个物品选或不选的组合，因此被称为 0-1 背包问题。我们用 <code>C[i][w]</code> 表示前 i 个物品装入容量为 w 的背包时的总价值的最大值，递增背包容量 w 至最大值来求解。求出 <code>C[i][w]</code> 的值为以下二者中较大的一个：</p>\n<ul>\n<li><code>C[i-1][w - 物品i的重量] + 物品i的价值</code></li>\n<li><code>C[i-1][w]</code> </li>\n</ul>\n<p>第一种即选择 i 的情况，第二种为不选择 i 的情况。</p>\n<p><strong>Java 实现：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Item[] items = <span class=\"keyword\">new</span> Item[<span class=\"number\">5</span>];</span><br><span class=\"line\">        items[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> Item(<span class=\"number\">4</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">        items[<span class=\"number\">2</span>] = <span class=\"keyword\">new</span> Item(<span class=\"number\">5</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">        items[<span class=\"number\">3</span>] = <span class=\"keyword\">new</span> Item(<span class=\"number\">2</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\">        items[<span class=\"number\">4</span>] = <span class=\"keyword\">new</span> Item(<span class=\"number\">8</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(getMaxValue(items, <span class=\"number\">5</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getMaxValue</span><span class=\"params\">(Item[] items, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] C = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[items.length][weight+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;C.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;C[i].length; j++) &#123;</span><br><span class=\"line\">                C[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;items.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;=weight; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(items[i].weight &gt; j) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//不可能选择</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    C[i][j] = Integer.max(C[i-<span class=\"number\">1</span>][j], C[i-<span class=\"number\">1</span>][j-items[i].weight] + items[i].value);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> C[items.length-<span class=\"number\">1</span>][weight];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Item</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> weight;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Item</span><span class=\"params\">(<span class=\"keyword\">int</span> value, <span class=\"keyword\">int</span> weight)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.weight = weight;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"在macOS下安装gem5模拟器","date":"2019-03-03T13:51:09.000Z","_content":"\n# 在 macOS 下安装 gem5 模拟器\n\nGem5 是一款 CPU 模拟器，一般用于计算机体系架构的研究工作。Gem5 可以用来模拟多种 CPU 架构，如 Alpha，ARM，SPARC，MIPS，当然还有x86。它同时支持 Linux / macOS 系统。\n\n## 依赖\n\n以下为必要的依赖：\n\n- g++\n- Python 2.7\n- SCons 这是一个 build 管理工具，类似于 make\n- zlib 这是一个数据压缩库。如果已经安装了 Xcode 命令行工具就已经包含了。如果没有，运行 `xcode-select --install ` 安装 Xcode 命令行工具。\n- GNU m4 宏处理器\n\n以下为推荐安装的依赖：\n\n- protobuf\n- pydot\n\n在 Mac 下，使用 homebrew 安装这些依赖较为简单。基本上 `brew install <name>` 就可以搞定了。\n\n## 下载源代码\n\nGem5 模拟器开放了源代码，且需要我们自己编译。通过 Git 把源码下载下来：\n\n```shell\ngit clone https://gem5.googlesource.com/public/gem5\n```\n\n当然也可以使用其他的版本控制工具下载。\n\n## 编译\n\nGem5 使用 SCons 作为 build 管理工具。用法是 `build/<config>/<binary>` 。Gem5 提供了多种版本，比如：\n\n- debug\n- opt\n- prof\n- perf\n- fast\n\n一般常用的是 opt 版本，这是带 debugging 和优化的版本。prof 和 perf 版本提供了性能分析支持，不过一般不常用。而且，编译 prof 版本可以成功，但是运行时会抛出 `__dyld section not supported` 异常。这是因为新版的 LLVM 已经不再支持 dyld 了。所以还是建议使用 opt 版本。如果我们需要 x86 架构的话：\n\n```shell\nscons build/X86/gem5.opt\n```\n\n编译耗时还是比较久的，需要耐心等待，可以去健个身之类的。\n\n## 运行\n\n最后可以跑一下自带的 hello world 程序，来验证 gem5 是否可用：\n\n```shell\nbuild/X86/gem5.opt configs/example/se.py -c tests/test-progs/hello/bin/x86/linux/hello\n```\n\n如果屏幕上成功打印出 `Hello world!` 就代表可以正常使用 gem5 模拟器了。","source":"_posts/在macOS下安装gem5模拟器.md","raw":"---\ntitle: 在macOS下安装gem5模拟器\ndate: 2019-03-03 21:51:09\ntags: gem5\n---\n\n# 在 macOS 下安装 gem5 模拟器\n\nGem5 是一款 CPU 模拟器，一般用于计算机体系架构的研究工作。Gem5 可以用来模拟多种 CPU 架构，如 Alpha，ARM，SPARC，MIPS，当然还有x86。它同时支持 Linux / macOS 系统。\n\n## 依赖\n\n以下为必要的依赖：\n\n- g++\n- Python 2.7\n- SCons 这是一个 build 管理工具，类似于 make\n- zlib 这是一个数据压缩库。如果已经安装了 Xcode 命令行工具就已经包含了。如果没有，运行 `xcode-select --install ` 安装 Xcode 命令行工具。\n- GNU m4 宏处理器\n\n以下为推荐安装的依赖：\n\n- protobuf\n- pydot\n\n在 Mac 下，使用 homebrew 安装这些依赖较为简单。基本上 `brew install <name>` 就可以搞定了。\n\n## 下载源代码\n\nGem5 模拟器开放了源代码，且需要我们自己编译。通过 Git 把源码下载下来：\n\n```shell\ngit clone https://gem5.googlesource.com/public/gem5\n```\n\n当然也可以使用其他的版本控制工具下载。\n\n## 编译\n\nGem5 使用 SCons 作为 build 管理工具。用法是 `build/<config>/<binary>` 。Gem5 提供了多种版本，比如：\n\n- debug\n- opt\n- prof\n- perf\n- fast\n\n一般常用的是 opt 版本，这是带 debugging 和优化的版本。prof 和 perf 版本提供了性能分析支持，不过一般不常用。而且，编译 prof 版本可以成功，但是运行时会抛出 `__dyld section not supported` 异常。这是因为新版的 LLVM 已经不再支持 dyld 了。所以还是建议使用 opt 版本。如果我们需要 x86 架构的话：\n\n```shell\nscons build/X86/gem5.opt\n```\n\n编译耗时还是比较久的，需要耐心等待，可以去健个身之类的。\n\n## 运行\n\n最后可以跑一下自带的 hello world 程序，来验证 gem5 是否可用：\n\n```shell\nbuild/X86/gem5.opt configs/example/se.py -c tests/test-progs/hello/bin/x86/linux/hello\n```\n\n如果屏幕上成功打印出 `Hello world!` 就代表可以正常使用 gem5 模拟器了。","slug":"在macOS下安装gem5模拟器","published":1,"updated":"2020-01-04T08:16:16.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3d001eljc3mf9qkmob","content":"<h1 id=\"在-macOS-下安装-gem5-模拟器\"><a href=\"#在-macOS-下安装-gem5-模拟器\" class=\"headerlink\" title=\"在 macOS 下安装 gem5 模拟器\"></a>在 macOS 下安装 gem5 模拟器</h1><p>Gem5 是一款 CPU 模拟器，一般用于计算机体系架构的研究工作。Gem5 可以用来模拟多种 CPU 架构，如 Alpha，ARM，SPARC，MIPS，当然还有x86。它同时支持 Linux / macOS 系统。</p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>以下为必要的依赖：</p>\n<ul>\n<li>g++</li>\n<li>Python 2.7</li>\n<li>SCons 这是一个 build 管理工具，类似于 make</li>\n<li>zlib 这是一个数据压缩库。如果已经安装了 Xcode 命令行工具就已经包含了。如果没有，运行 <code>xcode-select --install</code> 安装 Xcode 命令行工具。</li>\n<li>GNU m4 宏处理器</li>\n</ul>\n<p>以下为推荐安装的依赖：</p>\n<ul>\n<li>protobuf</li>\n<li>pydot</li>\n</ul>\n<p>在 Mac 下，使用 homebrew 安装这些依赖较为简单。基本上 <code>brew install &lt;name&gt;</code> 就可以搞定了。</p>\n<h2 id=\"下载源代码\"><a href=\"#下载源代码\" class=\"headerlink\" title=\"下载源代码\"></a>下载源代码</h2><p>Gem5 模拟器开放了源代码，且需要我们自己编译。通过 Git 把源码下载下来：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://gem5.googlesource.com/public/gem5</span><br></pre></td></tr></table></figure>\n<p>当然也可以使用其他的版本控制工具下载。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>Gem5 使用 SCons 作为 build 管理工具。用法是 <code>build/&lt;config&gt;/&lt;binary&gt;</code> 。Gem5 提供了多种版本，比如：</p>\n<ul>\n<li>debug</li>\n<li>opt</li>\n<li>prof</li>\n<li>perf</li>\n<li>fast</li>\n</ul>\n<p>一般常用的是 opt 版本，这是带 debugging 和优化的版本。prof 和 perf 版本提供了性能分析支持，不过一般不常用。而且，编译 prof 版本可以成功，但是运行时会抛出 <code>__dyld section not supported</code> 异常。这是因为新版的 LLVM 已经不再支持 dyld 了。所以还是建议使用 opt 版本。如果我们需要 x86 架构的话：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scons build/X86/gem5.opt</span><br></pre></td></tr></table></figure>\n<p>编译耗时还是比较久的，需要耐心等待，可以去健个身之类的。</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>最后可以跑一下自带的 hello world 程序，来验证 gem5 是否可用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/X86/gem5.opt configs/example/se.py -c tests/test-progs/hello/bin/x86/linux/hello</span><br></pre></td></tr></table></figure>\n<p>如果屏幕上成功打印出 <code>Hello world!</code> 就代表可以正常使用 gem5 模拟器了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"在-macOS-下安装-gem5-模拟器\"><a href=\"#在-macOS-下安装-gem5-模拟器\" class=\"headerlink\" title=\"在 macOS 下安装 gem5 模拟器\"></a>在 macOS 下安装 gem5 模拟器</h1><p>Gem5 是一款 CPU 模拟器，一般用于计算机体系架构的研究工作。Gem5 可以用来模拟多种 CPU 架构，如 Alpha，ARM，SPARC，MIPS，当然还有x86。它同时支持 Linux / macOS 系统。</p>\n<h2 id=\"依赖\"><a href=\"#依赖\" class=\"headerlink\" title=\"依赖\"></a>依赖</h2><p>以下为必要的依赖：</p>\n<ul>\n<li>g++</li>\n<li>Python 2.7</li>\n<li>SCons 这是一个 build 管理工具，类似于 make</li>\n<li>zlib 这是一个数据压缩库。如果已经安装了 Xcode 命令行工具就已经包含了。如果没有，运行 <code>xcode-select --install</code> 安装 Xcode 命令行工具。</li>\n<li>GNU m4 宏处理器</li>\n</ul>\n<p>以下为推荐安装的依赖：</p>\n<ul>\n<li>protobuf</li>\n<li>pydot</li>\n</ul>\n<p>在 Mac 下，使用 homebrew 安装这些依赖较为简单。基本上 <code>brew install &lt;name&gt;</code> 就可以搞定了。</p>\n<h2 id=\"下载源代码\"><a href=\"#下载源代码\" class=\"headerlink\" title=\"下载源代码\"></a>下载源代码</h2><p>Gem5 模拟器开放了源代码，且需要我们自己编译。通过 Git 把源码下载下来：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://gem5.googlesource.com/public/gem5</span><br></pre></td></tr></table></figure>\n<p>当然也可以使用其他的版本控制工具下载。</p>\n<h2 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h2><p>Gem5 使用 SCons 作为 build 管理工具。用法是 <code>build/&lt;config&gt;/&lt;binary&gt;</code> 。Gem5 提供了多种版本，比如：</p>\n<ul>\n<li>debug</li>\n<li>opt</li>\n<li>prof</li>\n<li>perf</li>\n<li>fast</li>\n</ul>\n<p>一般常用的是 opt 版本，这是带 debugging 和优化的版本。prof 和 perf 版本提供了性能分析支持，不过一般不常用。而且，编译 prof 版本可以成功，但是运行时会抛出 <code>__dyld section not supported</code> 异常。这是因为新版的 LLVM 已经不再支持 dyld 了。所以还是建议使用 opt 版本。如果我们需要 x86 架构的话：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scons build/X86/gem5.opt</span><br></pre></td></tr></table></figure>\n<p>编译耗时还是比较久的，需要耐心等待，可以去健个身之类的。</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>最后可以跑一下自带的 hello world 程序，来验证 gem5 是否可用：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/X86/gem5.opt configs/example/se.py -c tests/test-progs/hello/bin/x86/linux/hello</span><br></pre></td></tr></table></figure>\n<p>如果屏幕上成功打印出 <code>Hello world!</code> 就代表可以正常使用 gem5 模拟器了。</p>\n"},{"title":"用Swift写算法-初等排序","date":"2017-07-11T11:58:59.000Z","_content":"\n# 用 Swift 写算法——初等排序\n\n### 插入排序法\n\n**简介：**\n\n就像打扑克时整理牌的顺序一样，将牌一张张地抽出来，再插入到已经排列好的牌的适当位置中。重复这个动作直到插入最后一张牌。\n\n**Swift 实现：**\n\n```swift\nfunc insertionSort(array: inout [Int]) {\n    for i in 1..<array.count {\n        let v = array[i]\n        var j = i - 1\n        while j >= 0 && array[j] > v {\n            array[j + 1] = array[j]\n            j -= 1\n        }\n        array[j + 1] = v\n    }\n}\n```\n\n**分析：**\n\n我们从第二个元素开始，往后遍历数组。这个元素左边的序列是已排序的；右边是未排序的。我们在已排序的部分中，从大的元素向小的元素滑动，直到遇到小于当前元素的位置。也就是说，这个位置左边（含这个位置）的元素都小于当前元素；右边都大于当前元素。在滑动的过程中，所有遇到的元素都往后挪动一位以腾出插入的空间（第一次滑动当前元素就被覆盖掉了）。\n\n在插入排序中，不相邻的元素不会交换位置，因此是稳定的。在最坏的情况下，每 i 个循环都需要移动数组元素 i 次，总共需要：\n$$\n1+2+3+\\cdots+(N-1) = \\frac{N\\times(N-1)}{2}\n$$\n故时间复杂度是 $O(n^2)$。\n\n如果输入已经是升序排列，那么插入排序法只需要比较而不用移动，故可以快速地完成相对有序数列的排序。\n\n### 冒泡排序法\n\n**简介：**\n\n冒泡排序法让数组元素像水中的气泡一样逐渐上浮，而达到排序的目的。有些人也把冒泡排序法称为”沉底排序法“。\n\n**Swift 实现：**\n\n```swift\nfunc bubbleSort(array: inout [Int]) {\n    var flag = true\n    while flag {\n        flag = false\n        var i = array.count - 1\n        while i > 0 {\n            if array[i - 1] > array[i] {\n                let temp = array[i]\n                array[i] = array[i - 1]\n                array[i - 1] = temp\n                flag = true\n            }\n            i -= 1\n        }\n    }\n}\n```\n\n**分析：**\n\n每次循环中，都从右往左遍历，遇到顺序相反的元素就交换二者的位置。这样，每次都把最小的泡泡推到最左边。重复这个操作知道所有的元素都符合要求为止。可以看到，这样在数组左边就形成了一个有序的子列，每次循环有序子列的元素个数就增加一个，且没有比这个子列里的元素更小的元素。因此我们可以利用这一点，去减少循环的次数（循环到有序子列尾就可以直接进行下次循环），这也被称为“改进的冒泡排序法”。\n\n冒泡排序法只对相邻的两个反序元素进行交换，因此也是稳定的。需要注意，如果把判断条件改为“大于等于（小于等于）”，则算法会失去稳定性。\n\n在最坏的情况下，冒泡排序法会对相邻的元素（未排序部分）进行以下次比较：\n$$\n(N-1)+(N-2)+\\cdots+1=\\frac{N^2-N}{2}\n$$\n因此时间复杂度是 $O(n^2)$。\n\n### 选择排序法\n\n**简介：**\n\n选择排序法在每个计算步骤中，选择出最小的数放到前面，进而完成排序。\n\n**Swift 实现：**\n\n```swift\nfunc selectionSort(array: inout [Int]) {\n    for i in 0..<array.count {\n        var minj = i\n        for j in i..<array.count {\n            if array[j] < array[minj] {\n                minj = j\n            }\n        }\n        let temp = array[i]\n        array[i] = array[minj]\n        array[minj] = temp\n    }\n}\n```\n\n**分析：**\n\n在循环的过程中，minj 的值会不断地被后面的（更小时元素的下标）覆盖，这样在每次排序中，不相邻的元素会被交换，因此是不稳定的算法。\n\n选择排序法需要经过以下次比较：\n$$\n(N-1)+(N-2)+\\cdots+1=\\frac{N^2-N}{2}\n$$\n因此时间复杂度是 $O(n^2)$。\n\n### 希尔排序法\n\n**简介：**\n\n希尔排序法循环地调用间隔为 g 的插入排序法，每次缩小 g 的范围进而完成排序。\n\n**Swift 实现**\n\n```swift\nfunc shellSort(array: inout [Int]) {\n    let G = [4,3,1]\n    for each in G {\n        insertionSort(array: &array, g: each)\n    }\n}\n\nfunc insertionSort(array: inout [Int], g: Int) {\n    for i in g..<array.count {\n        var v = array[i]\n        var j = i - g\n        while j >= 0 && array[j] > v {\n            array[j + g] = array[j]\n            j = j - g\n        }\n        array[j + g] = v\n    }\n}\n```\n\n**分析：**\n\n前面已经分析过，插入排序法能较为快速地对比较有序的数组进行排序。希尔排序法就是发挥了插入排序法的优势，让数组一步步地变得越来越有序。不断地缩小插入排序法的间隔（间隔越大，插入排序法所需要交互的次数就越小，也就越快完成）直到间隔为 1。间隔为 1 时（退化成普通的插入排序法），数组已经基本有序了，因此效率较高。\n\n每次的间隔 g 的取值对希尔排序法的效率至关重要。对于如何选择 G，人们已经进行了许多研究。例如：当 $g = 1,4,13,40,121\\cdots$ 时，即 $g_{n+1} = 3g_n+1$ 时，算法的复杂度基本维持在 $O(n^{1.25})$。","source":"_posts/用Swift写算法-初等排序.md","raw":"---\ntitle: 用Swift写算法-初等排序\ndate: 2017-07-11 19:58:59\ntags: Algorithm\n---\n\n# 用 Swift 写算法——初等排序\n\n### 插入排序法\n\n**简介：**\n\n就像打扑克时整理牌的顺序一样，将牌一张张地抽出来，再插入到已经排列好的牌的适当位置中。重复这个动作直到插入最后一张牌。\n\n**Swift 实现：**\n\n```swift\nfunc insertionSort(array: inout [Int]) {\n    for i in 1..<array.count {\n        let v = array[i]\n        var j = i - 1\n        while j >= 0 && array[j] > v {\n            array[j + 1] = array[j]\n            j -= 1\n        }\n        array[j + 1] = v\n    }\n}\n```\n\n**分析：**\n\n我们从第二个元素开始，往后遍历数组。这个元素左边的序列是已排序的；右边是未排序的。我们在已排序的部分中，从大的元素向小的元素滑动，直到遇到小于当前元素的位置。也就是说，这个位置左边（含这个位置）的元素都小于当前元素；右边都大于当前元素。在滑动的过程中，所有遇到的元素都往后挪动一位以腾出插入的空间（第一次滑动当前元素就被覆盖掉了）。\n\n在插入排序中，不相邻的元素不会交换位置，因此是稳定的。在最坏的情况下，每 i 个循环都需要移动数组元素 i 次，总共需要：\n$$\n1+2+3+\\cdots+(N-1) = \\frac{N\\times(N-1)}{2}\n$$\n故时间复杂度是 $O(n^2)$。\n\n如果输入已经是升序排列，那么插入排序法只需要比较而不用移动，故可以快速地完成相对有序数列的排序。\n\n### 冒泡排序法\n\n**简介：**\n\n冒泡排序法让数组元素像水中的气泡一样逐渐上浮，而达到排序的目的。有些人也把冒泡排序法称为”沉底排序法“。\n\n**Swift 实现：**\n\n```swift\nfunc bubbleSort(array: inout [Int]) {\n    var flag = true\n    while flag {\n        flag = false\n        var i = array.count - 1\n        while i > 0 {\n            if array[i - 1] > array[i] {\n                let temp = array[i]\n                array[i] = array[i - 1]\n                array[i - 1] = temp\n                flag = true\n            }\n            i -= 1\n        }\n    }\n}\n```\n\n**分析：**\n\n每次循环中，都从右往左遍历，遇到顺序相反的元素就交换二者的位置。这样，每次都把最小的泡泡推到最左边。重复这个操作知道所有的元素都符合要求为止。可以看到，这样在数组左边就形成了一个有序的子列，每次循环有序子列的元素个数就增加一个，且没有比这个子列里的元素更小的元素。因此我们可以利用这一点，去减少循环的次数（循环到有序子列尾就可以直接进行下次循环），这也被称为“改进的冒泡排序法”。\n\n冒泡排序法只对相邻的两个反序元素进行交换，因此也是稳定的。需要注意，如果把判断条件改为“大于等于（小于等于）”，则算法会失去稳定性。\n\n在最坏的情况下，冒泡排序法会对相邻的元素（未排序部分）进行以下次比较：\n$$\n(N-1)+(N-2)+\\cdots+1=\\frac{N^2-N}{2}\n$$\n因此时间复杂度是 $O(n^2)$。\n\n### 选择排序法\n\n**简介：**\n\n选择排序法在每个计算步骤中，选择出最小的数放到前面，进而完成排序。\n\n**Swift 实现：**\n\n```swift\nfunc selectionSort(array: inout [Int]) {\n    for i in 0..<array.count {\n        var minj = i\n        for j in i..<array.count {\n            if array[j] < array[minj] {\n                minj = j\n            }\n        }\n        let temp = array[i]\n        array[i] = array[minj]\n        array[minj] = temp\n    }\n}\n```\n\n**分析：**\n\n在循环的过程中，minj 的值会不断地被后面的（更小时元素的下标）覆盖，这样在每次排序中，不相邻的元素会被交换，因此是不稳定的算法。\n\n选择排序法需要经过以下次比较：\n$$\n(N-1)+(N-2)+\\cdots+1=\\frac{N^2-N}{2}\n$$\n因此时间复杂度是 $O(n^2)$。\n\n### 希尔排序法\n\n**简介：**\n\n希尔排序法循环地调用间隔为 g 的插入排序法，每次缩小 g 的范围进而完成排序。\n\n**Swift 实现**\n\n```swift\nfunc shellSort(array: inout [Int]) {\n    let G = [4,3,1]\n    for each in G {\n        insertionSort(array: &array, g: each)\n    }\n}\n\nfunc insertionSort(array: inout [Int], g: Int) {\n    for i in g..<array.count {\n        var v = array[i]\n        var j = i - g\n        while j >= 0 && array[j] > v {\n            array[j + g] = array[j]\n            j = j - g\n        }\n        array[j + g] = v\n    }\n}\n```\n\n**分析：**\n\n前面已经分析过，插入排序法能较为快速地对比较有序的数组进行排序。希尔排序法就是发挥了插入排序法的优势，让数组一步步地变得越来越有序。不断地缩小插入排序法的间隔（间隔越大，插入排序法所需要交互的次数就越小，也就越快完成）直到间隔为 1。间隔为 1 时（退化成普通的插入排序法），数组已经基本有序了，因此效率较高。\n\n每次的间隔 g 的取值对希尔排序法的效率至关重要。对于如何选择 G，人们已经进行了许多研究。例如：当 $g = 1,4,13,40,121\\cdots$ 时，即 $g_{n+1} = 3g_n+1$ 时，算法的复杂度基本维持在 $O(n^{1.25})$。","slug":"用Swift写算法-初等排序","published":1,"updated":"2020-01-04T08:16:16.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3e001gljc3mq92yz3i","content":"<h1 id=\"用-Swift-写算法——初等排序\"><a href=\"#用-Swift-写算法——初等排序\" class=\"headerlink\" title=\"用 Swift 写算法——初等排序\"></a>用 Swift 写算法——初等排序</h1><h3 id=\"插入排序法\"><a href=\"#插入排序法\" class=\"headerlink\" title=\"插入排序法\"></a>插入排序法</h3><p><strong>简介：</strong></p>\n<p>就像打扑克时整理牌的顺序一样，将牌一张张地抽出来，再插入到已经排列好的牌的适当位置中。重复这个动作直到插入最后一张牌。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertionSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..&lt;array.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> v = array[i]</span><br><span class=\"line\">        <span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span> &amp;&amp; array[j] &gt; v &#123;</span><br><span class=\"line\">            array[j + <span class=\"number\">1</span>] = array[j]</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[j + <span class=\"number\">1</span>] = v</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>我们从第二个元素开始，往后遍历数组。这个元素左边的序列是已排序的；右边是未排序的。我们在已排序的部分中，从大的元素向小的元素滑动，直到遇到小于当前元素的位置。也就是说，这个位置左边（含这个位置）的元素都小于当前元素；右边都大于当前元素。在滑动的过程中，所有遇到的元素都往后挪动一位以腾出插入的空间（第一次滑动当前元素就被覆盖掉了）。</p>\n<p>在插入排序中，不相邻的元素不会交换位置，因此是稳定的。在最坏的情况下，每 i 个循环都需要移动数组元素 i 次，总共需要：<br>$$<br>1+2+3+\\cdots+(N-1) = \\frac{N\\times(N-1)}{2}<br>$$<br>故时间复杂度是 $O(n^2)$。</p>\n<p>如果输入已经是升序排列，那么插入排序法只需要比较而不用移动，故可以快速地完成相对有序数列的排序。</p>\n<h3 id=\"冒泡排序法\"><a href=\"#冒泡排序法\" class=\"headerlink\" title=\"冒泡排序法\"></a>冒泡排序法</h3><p><strong>简介：</strong></p>\n<p>冒泡排序法让数组元素像水中的气泡一样逐渐上浮，而达到排序的目的。有些人也把冒泡排序法称为”沉底排序法“。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> flag = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> flag &#123;</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = array.<span class=\"built_in\">count</span> - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> array[i - <span class=\"number\">1</span>] &gt; array[i] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> temp = array[i]</span><br><span class=\"line\">                array[i] = array[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">                array[i - <span class=\"number\">1</span>] = temp</span><br><span class=\"line\">                flag = <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i -= <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>每次循环中，都从右往左遍历，遇到顺序相反的元素就交换二者的位置。这样，每次都把最小的泡泡推到最左边。重复这个操作知道所有的元素都符合要求为止。可以看到，这样在数组左边就形成了一个有序的子列，每次循环有序子列的元素个数就增加一个，且没有比这个子列里的元素更小的元素。因此我们可以利用这一点，去减少循环的次数（循环到有序子列尾就可以直接进行下次循环），这也被称为“改进的冒泡排序法”。</p>\n<p>冒泡排序法只对相邻的两个反序元素进行交换，因此也是稳定的。需要注意，如果把判断条件改为“大于等于（小于等于）”，则算法会失去稳定性。</p>\n<p>在最坏的情况下，冒泡排序法会对相邻的元素（未排序部分）进行以下次比较：<br>$$<br>(N-1)+(N-2)+\\cdots+1=\\frac{N^2-N}{2}<br>$$<br>因此时间复杂度是 $O(n^2)$。</p>\n<h3 id=\"选择排序法\"><a href=\"#选择排序法\" class=\"headerlink\" title=\"选择排序法\"></a>选择排序法</h3><p><strong>简介：</strong></p>\n<p>选择排序法在每个计算步骤中，选择出最小的数放到前面，进而完成排序。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">selectionSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;array.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> minj = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> i..&lt;array.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> array[j] &lt; array[minj] &#123;</span><br><span class=\"line\">                minj = j</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> temp = array[i]</span><br><span class=\"line\">        array[i] = array[minj]</span><br><span class=\"line\">        array[minj] = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>在循环的过程中，minj 的值会不断地被后面的（更小时元素的下标）覆盖，这样在每次排序中，不相邻的元素会被交换，因此是不稳定的算法。</p>\n<p>选择排序法需要经过以下次比较：<br>$$<br>(N-1)+(N-2)+\\cdots+1=\\frac{N^2-N}{2}<br>$$<br>因此时间复杂度是 $O(n^2)$。</p>\n<h3 id=\"希尔排序法\"><a href=\"#希尔排序法\" class=\"headerlink\" title=\"希尔排序法\"></a>希尔排序法</h3><p><strong>简介：</strong></p>\n<p>希尔排序法循环地调用间隔为 g 的插入排序法，每次缩小 g 的范围进而完成排序。</p>\n<p><strong>Swift 实现</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shellSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"type\">G</span> = [<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> <span class=\"type\">G</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">insertionSort</span>(array: &amp;array, g: each)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertionSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int], g: Int)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> g..&lt;array.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> v = array[i]</span><br><span class=\"line\">        <span class=\"keyword\">var</span> j = i - g</span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span> &amp;&amp; array[j] &gt; v &#123;</span><br><span class=\"line\">            array[j + g] = array[j]</span><br><span class=\"line\">            j = j - g</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[j + g] = v</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>前面已经分析过，插入排序法能较为快速地对比较有序的数组进行排序。希尔排序法就是发挥了插入排序法的优势，让数组一步步地变得越来越有序。不断地缩小插入排序法的间隔（间隔越大，插入排序法所需要交互的次数就越小，也就越快完成）直到间隔为 1。间隔为 1 时（退化成普通的插入排序法），数组已经基本有序了，因此效率较高。</p>\n<p>每次的间隔 g 的取值对希尔排序法的效率至关重要。对于如何选择 G，人们已经进行了许多研究。例如：当 $g = 1,4,13,40,121\\cdots$ 时，即 $g_{n+1} = 3g_n+1$ 时，算法的复杂度基本维持在 $O(n^{1.25})$。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"用-Swift-写算法——初等排序\"><a href=\"#用-Swift-写算法——初等排序\" class=\"headerlink\" title=\"用 Swift 写算法——初等排序\"></a>用 Swift 写算法——初等排序</h1><h3 id=\"插入排序法\"><a href=\"#插入排序法\" class=\"headerlink\" title=\"插入排序法\"></a>插入排序法</h3><p><strong>简介：</strong></p>\n<p>就像打扑克时整理牌的顺序一样，将牌一张张地抽出来，再插入到已经排列好的牌的适当位置中。重复这个动作直到插入最后一张牌。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertionSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">1</span>..&lt;array.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> v = array[i]</span><br><span class=\"line\">        <span class=\"keyword\">var</span> j = i - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span> &amp;&amp; array[j] &gt; v &#123;</span><br><span class=\"line\">            array[j + <span class=\"number\">1</span>] = array[j]</span><br><span class=\"line\">            j -= <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[j + <span class=\"number\">1</span>] = v</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>我们从第二个元素开始，往后遍历数组。这个元素左边的序列是已排序的；右边是未排序的。我们在已排序的部分中，从大的元素向小的元素滑动，直到遇到小于当前元素的位置。也就是说，这个位置左边（含这个位置）的元素都小于当前元素；右边都大于当前元素。在滑动的过程中，所有遇到的元素都往后挪动一位以腾出插入的空间（第一次滑动当前元素就被覆盖掉了）。</p>\n<p>在插入排序中，不相邻的元素不会交换位置，因此是稳定的。在最坏的情况下，每 i 个循环都需要移动数组元素 i 次，总共需要：<br>$$<br>1+2+3+\\cdots+(N-1) = \\frac{N\\times(N-1)}{2}<br>$$<br>故时间复杂度是 $O(n^2)$。</p>\n<p>如果输入已经是升序排列，那么插入排序法只需要比较而不用移动，故可以快速地完成相对有序数列的排序。</p>\n<h3 id=\"冒泡排序法\"><a href=\"#冒泡排序法\" class=\"headerlink\" title=\"冒泡排序法\"></a>冒泡排序法</h3><p><strong>简介：</strong></p>\n<p>冒泡排序法让数组元素像水中的气泡一样逐渐上浮，而达到排序的目的。有些人也把冒泡排序法称为”沉底排序法“。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> flag = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> flag &#123;</span><br><span class=\"line\">        flag = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> i = array.<span class=\"built_in\">count</span> - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> array[i - <span class=\"number\">1</span>] &gt; array[i] &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> temp = array[i]</span><br><span class=\"line\">                array[i] = array[i - <span class=\"number\">1</span>]</span><br><span class=\"line\">                array[i - <span class=\"number\">1</span>] = temp</span><br><span class=\"line\">                flag = <span class=\"literal\">true</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i -= <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>每次循环中，都从右往左遍历，遇到顺序相反的元素就交换二者的位置。这样，每次都把最小的泡泡推到最左边。重复这个操作知道所有的元素都符合要求为止。可以看到，这样在数组左边就形成了一个有序的子列，每次循环有序子列的元素个数就增加一个，且没有比这个子列里的元素更小的元素。因此我们可以利用这一点，去减少循环的次数（循环到有序子列尾就可以直接进行下次循环），这也被称为“改进的冒泡排序法”。</p>\n<p>冒泡排序法只对相邻的两个反序元素进行交换，因此也是稳定的。需要注意，如果把判断条件改为“大于等于（小于等于）”，则算法会失去稳定性。</p>\n<p>在最坏的情况下，冒泡排序法会对相邻的元素（未排序部分）进行以下次比较：<br>$$<br>(N-1)+(N-2)+\\cdots+1=\\frac{N^2-N}{2}<br>$$<br>因此时间复杂度是 $O(n^2)$。</p>\n<h3 id=\"选择排序法\"><a href=\"#选择排序法\" class=\"headerlink\" title=\"选择排序法\"></a>选择排序法</h3><p><strong>简介：</strong></p>\n<p>选择排序法在每个计算步骤中，选择出最小的数放到前面，进而完成排序。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">selectionSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;array.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> minj = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> i..&lt;array.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> array[j] &lt; array[minj] &#123;</span><br><span class=\"line\">                minj = j</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> temp = array[i]</span><br><span class=\"line\">        array[i] = array[minj]</span><br><span class=\"line\">        array[minj] = temp</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>在循环的过程中，minj 的值会不断地被后面的（更小时元素的下标）覆盖，这样在每次排序中，不相邻的元素会被交换，因此是不稳定的算法。</p>\n<p>选择排序法需要经过以下次比较：<br>$$<br>(N-1)+(N-2)+\\cdots+1=\\frac{N^2-N}{2}<br>$$<br>因此时间复杂度是 $O(n^2)$。</p>\n<h3 id=\"希尔排序法\"><a href=\"#希尔排序法\" class=\"headerlink\" title=\"希尔排序法\"></a>希尔排序法</h3><p><strong>简介：</strong></p>\n<p>希尔排序法循环地调用间隔为 g 的插入排序法，每次缩小 g 的范围进而完成排序。</p>\n<p><strong>Swift 实现</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">shellSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int])</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"type\">G</span> = [<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> <span class=\"type\">G</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">insertionSort</span>(array: &amp;array, g: each)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">insertionSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int], g: Int)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> g..&lt;array.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> v = array[i]</span><br><span class=\"line\">        <span class=\"keyword\">var</span> j = i - g</span><br><span class=\"line\">        <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span> &amp;&amp; array[j] &gt; v &#123;</span><br><span class=\"line\">            array[j + g] = array[j]</span><br><span class=\"line\">            j = j - g</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        array[j + g] = v</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>前面已经分析过，插入排序法能较为快速地对比较有序的数组进行排序。希尔排序法就是发挥了插入排序法的优势，让数组一步步地变得越来越有序。不断地缩小插入排序法的间隔（间隔越大，插入排序法所需要交互的次数就越小，也就越快完成）直到间隔为 1。间隔为 1 时（退化成普通的插入排序法），数组已经基本有序了，因此效率较高。</p>\n<p>每次的间隔 g 的取值对希尔排序法的效率至关重要。对于如何选择 G，人们已经进行了许多研究。例如：当 $g = 1,4,13,40,121\\cdots$ 时，即 $g_{n+1} = 3g_n+1$ 时，算法的复杂度基本维持在 $O(n^{1.25})$。</p>\n"},{"title":"用Swift写算法-高等排序","date":"2017-08-01T06:04:22.000Z","_content":"\n# 用 Swift 写算法——高等排序\n\n面对大量的数据，使用复杂度为 $O(n^2)$ 的初等排序法将失去实用价值，为此我们必须引入速度更快的高等排序算法。\n\n### 归并排序\n\n**Swift 实现：**\n\n```swift\nfunc mergeSort(array: inout [Int], left: Int, right: Int) {\n    if left + 1 < right {\n        let mid = (left + right) / 2\n        mergeSort(array: &array, left: left, right: mid)\n        mergeSort(array: &array, left: mid, right: right)\n        merge(array: &array, left: left, mid: mid, right: right)\n    }\n}\n\nfunc merge(array: inout [Int], left: Int, mid: Int, right: Int) {\n    let n1 = mid - left\n    let n2 = right - mid\n    var L = [Int]()\n    var R = [Int]()\n    for i in 0..<n1 {\n        L.append(array[left + i])\n    }\n    for i in 0..<n2 {\n        R.append(array[mid + i])\n    }\n    L.append(Int.max)\n    R.append(Int.max)\n    var i = 0\n    var j = 0\n    for k in left..<right {\n        if L[i] <= R[j] {\n            array[k] = L[i]\n            i += 1\n        } else {\n            array[k] = R[j]\n            j += 1\n        }\n    }\n}\n```\n\n**分析：**\n\n借助分治法的思路，我们将解决问题的方案分为以下步骤：\n\n- 分割：将数组对半分成两个部分\n- 求解：对两个局部数组分别执行归并排序\n- 整合：将排序完毕的局部数组整合成一个数组\n\n函数 `merge()` 是算法的基础。它的作用是将两个分别有序的数组，合并成一个整体有序的数组。为了方便实现，在两个数组末端各插入一个“无穷大”的数。由于两个小数组都已经有序，所以合并只需要分别依次比较大小，然后先行往大数组中插入较小的数就可以了。复杂度为 $O(n1+n2)$ 。\n\n在归并排序法中，我们递归地对数组进行分割，直到仅剩下一个元素。此时，只一个元素的数组是有序的。在一个元素的状态下，由于不满足条件，函数开始返回。返回时，调用了 `merge()` ，对有序的数组进行拼接。这样，经过不断的拼接，最终整体有序。\n\n一般来讲，n 个数需要递归 $O(logn)$ 层，每层执行归并又需要线性的复杂度，因此归并排序的时间复杂度为 $O(nlogn)$。\n\n归并排序法不会交换两个不相邻的元素位置，在合并时，只需要保证前半部分的优先级高于后半部分，就能保持稳定。\n\n归并排序高速、稳定，但是在递归的过程中需要占用递归所需的内存空间。\n\ntips：把控递归的过程，一个重要的方法是画出递归的层次图。画图时，牢牢记住同样层次的递归画在同样的深度下就可以了。\n\n### 快速排序\n\n**Swift 实现：**\n\n```swift\nfunc quickSort(array: inout [Int], p: Int, r: Int) {\n    if p < r {\n        let q = partition(array: &array, p: p, r: r)\n        quickSort(array: &array, p: p, r: q-1)\n        quickSort(array: &array, p: q+1, r: r)\n    }\n}\n\nfunc partition(array: inout [Int], p: Int, r: Int) -> Int {\n    let x = array[r]\n    var i = p - 1\n    for j in p..<r {\n        if array[j] <= x {\n            i += 1\n            let temp = array[j]\n            array[j] = array[i]\n            array[i] = temp\n        }\n    }\n    let temp = array[r]\n    array[r] = array[i+1]\n    array[i+1] = temp\n    return i+1\n}\n```\n\n**分析：**\n\n快速排序的核心是 `partition()` 函数，它的作用是将数组 `array[p...r]` 进行分割。使得前半部分的元素均小于等于某个元素 `array[q]` ，后半部分的元素均大于 `array[q]` ，并返回下标 q。\n\n在快速排序法中，通过分割函数讲数组一分为二，之后分别对前后两部分再次进行分割。不断地分割下去，最终数组会趋于有序。\n\n如果快速排序在分割的过程中恰好能选择到中间值，那么效率将达到最高。一般而言快速排序的平局复杂度为 $O(nlogn)$ ，是多数情况下最高效的排序算法。在这个实现中，分割寒暑选择的基准数是一个固定的值，所以在有些情况下效率会很低（比如数组已经有序）。我们可以将其改为随机选择，或者抽样平均。\n\n快速排序在分割的过程中会交换不相邻的元素，因此是不稳定的排序算法。但是它除了占用递归的内存，不需要开辟额外的存储空间，因此是一种内部排序（原地排序）算法。\n\n### 计数排序（桶排序）\n\n**Swift 实现：**\n\n```swift\nfunc countingSort(A: [Int], k: Int) -> [Int] {\n    var C = [Int]()\n    for i in 0..<k {\n        C.append(0)\n    }\n    \n    for j in 0..<A.count {\n        C[A[j]] += 1\n    }\n    \n    for i in 0..<k {\n        if i > 0 {\n            C[i] += C[i-1]\n        }\n    }\n    \n    var B = A\n    \n    var j = A.count - 1\n    while j >= 0 {\n        B[C[A[j]] - 1] = A[j]\n        C[A[j]] -= 1\n        j -= 1\n    }\n    \n    return B\n}\n```\n\n**分析：**\n\n计数排序的特点是使用了一个计数数组 C（桶）。它统计各元素出现的次数，然后再求出各元素的累积和。因此 C[x] 的值代表 A 中小于等于 x 的元素个数，借此我们就得到了排序后各元素应出现的位置。\n\n从末尾开始选择，计数排序就是稳定的。计数排序的时间复杂度仅为 $O(n+k)$ ，线性。但是它不仅需要额外的内存空间，也需要保证 A 中元素非负，要求比较高。","source":"_posts/用Swift写算法-高等排序.md","raw":"---\ntitle: 用Swift写算法-高等排序\ndate: 2017-08-01 14:04:22\ntags: Algorithm\n---\n\n# 用 Swift 写算法——高等排序\n\n面对大量的数据，使用复杂度为 $O(n^2)$ 的初等排序法将失去实用价值，为此我们必须引入速度更快的高等排序算法。\n\n### 归并排序\n\n**Swift 实现：**\n\n```swift\nfunc mergeSort(array: inout [Int], left: Int, right: Int) {\n    if left + 1 < right {\n        let mid = (left + right) / 2\n        mergeSort(array: &array, left: left, right: mid)\n        mergeSort(array: &array, left: mid, right: right)\n        merge(array: &array, left: left, mid: mid, right: right)\n    }\n}\n\nfunc merge(array: inout [Int], left: Int, mid: Int, right: Int) {\n    let n1 = mid - left\n    let n2 = right - mid\n    var L = [Int]()\n    var R = [Int]()\n    for i in 0..<n1 {\n        L.append(array[left + i])\n    }\n    for i in 0..<n2 {\n        R.append(array[mid + i])\n    }\n    L.append(Int.max)\n    R.append(Int.max)\n    var i = 0\n    var j = 0\n    for k in left..<right {\n        if L[i] <= R[j] {\n            array[k] = L[i]\n            i += 1\n        } else {\n            array[k] = R[j]\n            j += 1\n        }\n    }\n}\n```\n\n**分析：**\n\n借助分治法的思路，我们将解决问题的方案分为以下步骤：\n\n- 分割：将数组对半分成两个部分\n- 求解：对两个局部数组分别执行归并排序\n- 整合：将排序完毕的局部数组整合成一个数组\n\n函数 `merge()` 是算法的基础。它的作用是将两个分别有序的数组，合并成一个整体有序的数组。为了方便实现，在两个数组末端各插入一个“无穷大”的数。由于两个小数组都已经有序，所以合并只需要分别依次比较大小，然后先行往大数组中插入较小的数就可以了。复杂度为 $O(n1+n2)$ 。\n\n在归并排序法中，我们递归地对数组进行分割，直到仅剩下一个元素。此时，只一个元素的数组是有序的。在一个元素的状态下，由于不满足条件，函数开始返回。返回时，调用了 `merge()` ，对有序的数组进行拼接。这样，经过不断的拼接，最终整体有序。\n\n一般来讲，n 个数需要递归 $O(logn)$ 层，每层执行归并又需要线性的复杂度，因此归并排序的时间复杂度为 $O(nlogn)$。\n\n归并排序法不会交换两个不相邻的元素位置，在合并时，只需要保证前半部分的优先级高于后半部分，就能保持稳定。\n\n归并排序高速、稳定，但是在递归的过程中需要占用递归所需的内存空间。\n\ntips：把控递归的过程，一个重要的方法是画出递归的层次图。画图时，牢牢记住同样层次的递归画在同样的深度下就可以了。\n\n### 快速排序\n\n**Swift 实现：**\n\n```swift\nfunc quickSort(array: inout [Int], p: Int, r: Int) {\n    if p < r {\n        let q = partition(array: &array, p: p, r: r)\n        quickSort(array: &array, p: p, r: q-1)\n        quickSort(array: &array, p: q+1, r: r)\n    }\n}\n\nfunc partition(array: inout [Int], p: Int, r: Int) -> Int {\n    let x = array[r]\n    var i = p - 1\n    for j in p..<r {\n        if array[j] <= x {\n            i += 1\n            let temp = array[j]\n            array[j] = array[i]\n            array[i] = temp\n        }\n    }\n    let temp = array[r]\n    array[r] = array[i+1]\n    array[i+1] = temp\n    return i+1\n}\n```\n\n**分析：**\n\n快速排序的核心是 `partition()` 函数，它的作用是将数组 `array[p...r]` 进行分割。使得前半部分的元素均小于等于某个元素 `array[q]` ，后半部分的元素均大于 `array[q]` ，并返回下标 q。\n\n在快速排序法中，通过分割函数讲数组一分为二，之后分别对前后两部分再次进行分割。不断地分割下去，最终数组会趋于有序。\n\n如果快速排序在分割的过程中恰好能选择到中间值，那么效率将达到最高。一般而言快速排序的平局复杂度为 $O(nlogn)$ ，是多数情况下最高效的排序算法。在这个实现中，分割寒暑选择的基准数是一个固定的值，所以在有些情况下效率会很低（比如数组已经有序）。我们可以将其改为随机选择，或者抽样平均。\n\n快速排序在分割的过程中会交换不相邻的元素，因此是不稳定的排序算法。但是它除了占用递归的内存，不需要开辟额外的存储空间，因此是一种内部排序（原地排序）算法。\n\n### 计数排序（桶排序）\n\n**Swift 实现：**\n\n```swift\nfunc countingSort(A: [Int], k: Int) -> [Int] {\n    var C = [Int]()\n    for i in 0..<k {\n        C.append(0)\n    }\n    \n    for j in 0..<A.count {\n        C[A[j]] += 1\n    }\n    \n    for i in 0..<k {\n        if i > 0 {\n            C[i] += C[i-1]\n        }\n    }\n    \n    var B = A\n    \n    var j = A.count - 1\n    while j >= 0 {\n        B[C[A[j]] - 1] = A[j]\n        C[A[j]] -= 1\n        j -= 1\n    }\n    \n    return B\n}\n```\n\n**分析：**\n\n计数排序的特点是使用了一个计数数组 C（桶）。它统计各元素出现的次数，然后再求出各元素的累积和。因此 C[x] 的值代表 A 中小于等于 x 的元素个数，借此我们就得到了排序后各元素应出现的位置。\n\n从末尾开始选择，计数排序就是稳定的。计数排序的时间复杂度仅为 $O(n+k)$ ，线性。但是它不仅需要额外的内存空间，也需要保证 A 中元素非负，要求比较高。","slug":"用Swift写算法-高等排序","published":1,"updated":"2020-01-04T08:16:16.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3f001hljc36udx8y9n","content":"<h1 id=\"用-Swift-写算法——高等排序\"><a href=\"#用-Swift-写算法——高等排序\" class=\"headerlink\" title=\"用 Swift 写算法——高等排序\"></a>用 Swift 写算法——高等排序</h1><p>面对大量的数据，使用复杂度为 $O(n^2)$ 的初等排序法将失去实用价值，为此我们必须引入速度更快的高等排序算法。</p>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mergeSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int], <span class=\"keyword\">left</span>: Int, <span class=\"keyword\">right</span>: Int)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">left</span> + <span class=\"number\">1</span> &lt; <span class=\"keyword\">right</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> mid = (<span class=\"keyword\">left</span> + <span class=\"keyword\">right</span>) / <span class=\"number\">2</span></span><br><span class=\"line\">        mergeSort(array: &amp;array, <span class=\"keyword\">left</span>: <span class=\"keyword\">left</span>, <span class=\"keyword\">right</span>: mid)</span><br><span class=\"line\">        mergeSort(array: &amp;array, <span class=\"keyword\">left</span>: mid, <span class=\"keyword\">right</span>: <span class=\"keyword\">right</span>)</span><br><span class=\"line\">        merge(array: &amp;array, <span class=\"keyword\">left</span>: <span class=\"keyword\">left</span>, mid: mid, <span class=\"keyword\">right</span>: <span class=\"keyword\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int], <span class=\"keyword\">left</span>: Int, mid: Int, <span class=\"keyword\">right</span>: Int)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n1 = mid - <span class=\"keyword\">left</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> n2 = <span class=\"keyword\">right</span> - mid</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"type\">L</span> = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"type\">R</span> = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;n1 &#123;</span><br><span class=\"line\">        <span class=\"type\">L</span>.append(array[<span class=\"keyword\">left</span> + i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;n2 &#123;</span><br><span class=\"line\">        <span class=\"type\">R</span>.append(array[mid + i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">L</span>.append(<span class=\"type\">Int</span>.<span class=\"built_in\">max</span>)</span><br><span class=\"line\">    <span class=\"type\">R</span>.append(<span class=\"type\">Int</span>.<span class=\"built_in\">max</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> j = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"keyword\">left</span>..&lt;<span class=\"keyword\">right</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"type\">L</span>[i] &lt;= <span class=\"type\">R</span>[j] &#123;</span><br><span class=\"line\">            array[k] = <span class=\"type\">L</span>[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            array[k] = <span class=\"type\">R</span>[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>借助分治法的思路，我们将解决问题的方案分为以下步骤：</p>\n<ul>\n<li>分割：将数组对半分成两个部分</li>\n<li>求解：对两个局部数组分别执行归并排序</li>\n<li>整合：将排序完毕的局部数组整合成一个数组</li>\n</ul>\n<p>函数 <code>merge()</code> 是算法的基础。它的作用是将两个分别有序的数组，合并成一个整体有序的数组。为了方便实现，在两个数组末端各插入一个“无穷大”的数。由于两个小数组都已经有序，所以合并只需要分别依次比较大小，然后先行往大数组中插入较小的数就可以了。复杂度为 $O(n1+n2)$ 。</p>\n<p>在归并排序法中，我们递归地对数组进行分割，直到仅剩下一个元素。此时，只一个元素的数组是有序的。在一个元素的状态下，由于不满足条件，函数开始返回。返回时，调用了 <code>merge()</code> ，对有序的数组进行拼接。这样，经过不断的拼接，最终整体有序。</p>\n<p>一般来讲，n 个数需要递归 $O(logn)$ 层，每层执行归并又需要线性的复杂度，因此归并排序的时间复杂度为 $O(nlogn)$。</p>\n<p>归并排序法不会交换两个不相邻的元素位置，在合并时，只需要保证前半部分的优先级高于后半部分，就能保持稳定。</p>\n<p>归并排序高速、稳定，但是在递归的过程中需要占用递归所需的内存空间。</p>\n<p>tips：把控递归的过程，一个重要的方法是画出递归的层次图。画图时，牢牢记住同样层次的递归画在同样的深度下就可以了。</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">quickSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int], p: Int, r: Int)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p &lt; r &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> q = <span class=\"built_in\">partition</span>(array: &amp;array, p: p, r: r)</span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(array: &amp;array, p: p, r: q-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(array: &amp;array, p: q+<span class=\"number\">1</span>, r: r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">partition</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int], p: Int, r: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = array[r]</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = p - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> p..&lt;r &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> array[j] &lt;= x &#123;</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> temp = array[j]</span><br><span class=\"line\">            array[j] = array[i]</span><br><span class=\"line\">            array[i] = temp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = array[r]</span><br><span class=\"line\">    array[r] = array[i+<span class=\"number\">1</span>]</span><br><span class=\"line\">    array[i+<span class=\"number\">1</span>] = temp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i+<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>快速排序的核心是 <code>partition()</code> 函数，它的作用是将数组 <code>array[p...r]</code> 进行分割。使得前半部分的元素均小于等于某个元素 <code>array[q]</code> ，后半部分的元素均大于 <code>array[q]</code> ，并返回下标 q。</p>\n<p>在快速排序法中，通过分割函数讲数组一分为二，之后分别对前后两部分再次进行分割。不断地分割下去，最终数组会趋于有序。</p>\n<p>如果快速排序在分割的过程中恰好能选择到中间值，那么效率将达到最高。一般而言快速排序的平局复杂度为 $O(nlogn)$ ，是多数情况下最高效的排序算法。在这个实现中，分割寒暑选择的基准数是一个固定的值，所以在有些情况下效率会很低（比如数组已经有序）。我们可以将其改为随机选择，或者抽样平均。</p>\n<p>快速排序在分割的过程中会交换不相邻的元素，因此是不稳定的排序算法。但是它除了占用递归的内存，不需要开辟额外的存储空间，因此是一种内部排序（原地排序）算法。</p>\n<h3 id=\"计数排序（桶排序）\"><a href=\"#计数排序（桶排序）\" class=\"headerlink\" title=\"计数排序（桶排序）\"></a>计数排序（桶排序）</h3><p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countingSort</span><span class=\"params\">(A: [Int], k: Int)</span></span> -&gt; [<span class=\"type\">Int</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"type\">C</span> = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;k &#123;</span><br><span class=\"line\">        <span class=\"type\">C</span>.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"type\">A</span>.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">C</span>[<span class=\"type\">A</span>[j]] += <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;k &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">C</span>[i] += <span class=\"type\">C</span>[i-<span class=\"number\">1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"type\">B</span> = <span class=\"type\">A</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> j = <span class=\"type\">A</span>.<span class=\"built_in\">count</span> - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">B</span>[<span class=\"type\">C</span>[<span class=\"type\">A</span>[j]] - <span class=\"number\">1</span>] = <span class=\"type\">A</span>[j]</span><br><span class=\"line\">        <span class=\"type\">C</span>[<span class=\"type\">A</span>[j]] -= <span class=\"number\">1</span></span><br><span class=\"line\">        j -= <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">B</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>计数排序的特点是使用了一个计数数组 C（桶）。它统计各元素出现的次数，然后再求出各元素的累积和。因此 C[x] 的值代表 A 中小于等于 x 的元素个数，借此我们就得到了排序后各元素应出现的位置。</p>\n<p>从末尾开始选择，计数排序就是稳定的。计数排序的时间复杂度仅为 $O(n+k)$ ，线性。但是它不仅需要额外的内存空间，也需要保证 A 中元素非负，要求比较高。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"用-Swift-写算法——高等排序\"><a href=\"#用-Swift-写算法——高等排序\" class=\"headerlink\" title=\"用 Swift 写算法——高等排序\"></a>用 Swift 写算法——高等排序</h1><p>面对大量的数据，使用复杂度为 $O(n^2)$ 的初等排序法将失去实用价值，为此我们必须引入速度更快的高等排序算法。</p>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">mergeSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int], <span class=\"keyword\">left</span>: Int, <span class=\"keyword\">right</span>: Int)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">left</span> + <span class=\"number\">1</span> &lt; <span class=\"keyword\">right</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> mid = (<span class=\"keyword\">left</span> + <span class=\"keyword\">right</span>) / <span class=\"number\">2</span></span><br><span class=\"line\">        mergeSort(array: &amp;array, <span class=\"keyword\">left</span>: <span class=\"keyword\">left</span>, <span class=\"keyword\">right</span>: mid)</span><br><span class=\"line\">        mergeSort(array: &amp;array, <span class=\"keyword\">left</span>: mid, <span class=\"keyword\">right</span>: <span class=\"keyword\">right</span>)</span><br><span class=\"line\">        merge(array: &amp;array, <span class=\"keyword\">left</span>: <span class=\"keyword\">left</span>, mid: mid, <span class=\"keyword\">right</span>: <span class=\"keyword\">right</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">merge</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int], <span class=\"keyword\">left</span>: Int, mid: Int, <span class=\"keyword\">right</span>: Int)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> n1 = mid - <span class=\"keyword\">left</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> n2 = <span class=\"keyword\">right</span> - mid</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"type\">L</span> = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"type\">R</span> = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;n1 &#123;</span><br><span class=\"line\">        <span class=\"type\">L</span>.append(array[<span class=\"keyword\">left</span> + i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;n2 &#123;</span><br><span class=\"line\">        <span class=\"type\">R</span>.append(array[mid + i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">L</span>.append(<span class=\"type\">Int</span>.<span class=\"built_in\">max</span>)</span><br><span class=\"line\">    <span class=\"type\">R</span>.append(<span class=\"type\">Int</span>.<span class=\"built_in\">max</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> j = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> <span class=\"keyword\">left</span>..&lt;<span class=\"keyword\">right</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"type\">L</span>[i] &lt;= <span class=\"type\">R</span>[j] &#123;</span><br><span class=\"line\">            array[k] = <span class=\"type\">L</span>[i]</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            array[k] = <span class=\"type\">R</span>[j]</span><br><span class=\"line\">            j += <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>借助分治法的思路，我们将解决问题的方案分为以下步骤：</p>\n<ul>\n<li>分割：将数组对半分成两个部分</li>\n<li>求解：对两个局部数组分别执行归并排序</li>\n<li>整合：将排序完毕的局部数组整合成一个数组</li>\n</ul>\n<p>函数 <code>merge()</code> 是算法的基础。它的作用是将两个分别有序的数组，合并成一个整体有序的数组。为了方便实现，在两个数组末端各插入一个“无穷大”的数。由于两个小数组都已经有序，所以合并只需要分别依次比较大小，然后先行往大数组中插入较小的数就可以了。复杂度为 $O(n1+n2)$ 。</p>\n<p>在归并排序法中，我们递归地对数组进行分割，直到仅剩下一个元素。此时，只一个元素的数组是有序的。在一个元素的状态下，由于不满足条件，函数开始返回。返回时，调用了 <code>merge()</code> ，对有序的数组进行拼接。这样，经过不断的拼接，最终整体有序。</p>\n<p>一般来讲，n 个数需要递归 $O(logn)$ 层，每层执行归并又需要线性的复杂度，因此归并排序的时间复杂度为 $O(nlogn)$。</p>\n<p>归并排序法不会交换两个不相邻的元素位置，在合并时，只需要保证前半部分的优先级高于后半部分，就能保持稳定。</p>\n<p>归并排序高速、稳定，但是在递归的过程中需要占用递归所需的内存空间。</p>\n<p>tips：把控递归的过程，一个重要的方法是画出递归的层次图。画图时，牢牢记住同样层次的递归画在同样的深度下就可以了。</p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">quickSort</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int], p: Int, r: Int)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> p &lt; r &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> q = <span class=\"built_in\">partition</span>(array: &amp;array, p: p, r: r)</span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(array: &amp;array, p: p, r: q-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">quickSort</span>(array: &amp;array, p: q+<span class=\"number\">1</span>, r: r)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">partition</span><span class=\"params\">(array: <span class=\"keyword\">inout</span> [Int], p: Int, r: Int)</span></span> -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = array[r]</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = p - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> p..&lt;r &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> array[j] &lt;= x &#123;</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> temp = array[j]</span><br><span class=\"line\">            array[j] = array[i]</span><br><span class=\"line\">            array[i] = temp</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> temp = array[r]</span><br><span class=\"line\">    array[r] = array[i+<span class=\"number\">1</span>]</span><br><span class=\"line\">    array[i+<span class=\"number\">1</span>] = temp</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i+<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>快速排序的核心是 <code>partition()</code> 函数，它的作用是将数组 <code>array[p...r]</code> 进行分割。使得前半部分的元素均小于等于某个元素 <code>array[q]</code> ，后半部分的元素均大于 <code>array[q]</code> ，并返回下标 q。</p>\n<p>在快速排序法中，通过分割函数讲数组一分为二，之后分别对前后两部分再次进行分割。不断地分割下去，最终数组会趋于有序。</p>\n<p>如果快速排序在分割的过程中恰好能选择到中间值，那么效率将达到最高。一般而言快速排序的平局复杂度为 $O(nlogn)$ ，是多数情况下最高效的排序算法。在这个实现中，分割寒暑选择的基准数是一个固定的值，所以在有些情况下效率会很低（比如数组已经有序）。我们可以将其改为随机选择，或者抽样平均。</p>\n<p>快速排序在分割的过程中会交换不相邻的元素，因此是不稳定的排序算法。但是它除了占用递归的内存，不需要开辟额外的存储空间，因此是一种内部排序（原地排序）算法。</p>\n<h3 id=\"计数排序（桶排序）\"><a href=\"#计数排序（桶排序）\" class=\"headerlink\" title=\"计数排序（桶排序）\"></a>计数排序（桶排序）</h3><p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">countingSort</span><span class=\"params\">(A: [Int], k: Int)</span></span> -&gt; [<span class=\"type\">Int</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"type\">C</span> = [<span class=\"type\">Int</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;k &#123;</span><br><span class=\"line\">        <span class=\"type\">C</span>.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"type\">A</span>.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">C</span>[<span class=\"type\">A</span>[j]] += <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;k &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">C</span>[i] += <span class=\"type\">C</span>[i-<span class=\"number\">1</span>]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"type\">B</span> = <span class=\"type\">A</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> j = <span class=\"type\">A</span>.<span class=\"built_in\">count</span> - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> j &gt;= <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">B</span>[<span class=\"type\">C</span>[<span class=\"type\">A</span>[j]] - <span class=\"number\">1</span>] = <span class=\"type\">A</span>[j]</span><br><span class=\"line\">        <span class=\"type\">C</span>[<span class=\"type\">A</span>[j]] -= <span class=\"number\">1</span></span><br><span class=\"line\">        j -= <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"type\">B</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>计数排序的特点是使用了一个计数数组 C（桶）。它统计各元素出现的次数，然后再求出各元素的累积和。因此 C[x] 的值代表 A 中小于等于 x 的元素个数，借此我们就得到了排序后各元素应出现的位置。</p>\n<p>从末尾开始选择，计数排序就是稳定的。计数排序的时间复杂度仅为 $O(n+k)$ ，线性。但是它不仅需要额外的内存空间，也需要保证 A 中元素非负，要求比较高。</p>\n"},{"title":"用Swift写算法-搜索","date":"2017-07-12T03:40:43.000Z","_content":"\n# 用 Swift 写算法——搜索\n\n### 线性搜索\n\n**简介：**\n\n线性搜索是从数组的头开始顺次访问各元素，检查该元素值是否与目标值相等。一旦相等就返回该元素位置并结束搜索。线性搜索算法的效率很低，但适用于任何形式的数据。\n\n**Swift 实现：**\n\n```swift\nfunc linearSearch(array: [Int], key: Int) -> Int? {\n    for (i, each) in array.enumerated() {\n        if each == key {\n            return i\n        }\n    }\n    return nil\n}\n```\n\n**分析：**\n\n线性搜索的时间复杂度为 $O(n)$ 。\n\n### 二分搜索\n\n**简介：**\n\n二分搜索可以利用数据的大小进行高速搜索。每执行一次，搜索的范围都会减半，因此可以在极短的时间内完成搜索，不过需要数据有序。\n\n**Swift 实现：**\n\n```swift\nfunc binarySearch(array: [Int], key: Int) -> Int? {\n    var leftIndex = 0\n    var rightIndex = array.count - 1\n    while leftIndex <= rightIndex {\n        let midIndex = (rightIndex + leftIndex) / 2\n        if array[midIndex] > key {\n            rightIndex = midIndex - 1\n        } else if array[midIndex] < key {\n            leftIndex = midIndex + 1\n        } else {\n            return midIndex\n        }\n    }\n    return nil\n}\n```\n\n**分析：**\n\n二分查找法每次搜索范围都会减半，在最坏的情况下大概需要 $log_2n$ 次，时间复杂度为 $O(logn)$ 。\n\n在最坏的情况下，对比线性搜索和二分搜索：\n\n|   元素数   | 线性搜索次数  | 二分搜索次数 |\n| :-----: | :-----: | :----: |\n|   100   |   100   |   7    |\n|  10000  |  10000  |   14   |\n| 1000000 | 1000000 |   20   |\n\n这里默认传入的数组有序。在一般情况下，可以考虑先对数组排序，然后进行二分搜索。不过，考虑到数据的体积，一般需要使用高等排序法。\n\n### 散列法\n\n**简介：**\n\n在散列法中，各元素存储的位置由散列函数决定。这种算法只需要将元素的关键字代入散列函数，就可以计算出它的位置。对特定形式的数据有极高的搜索效率。\n\n**分析：**\n\n散列法的要点在于散列函数的选取和冲突时的处理方法。如果忽略冲突的情况，时间复杂度仅为 $O(1)$。","source":"_posts/用Swift写算法-搜索.md","raw":"---\ntitle: 用Swift写算法-搜索\ndate: 2017-07-12 11:40:43\ntags: Algorithm\n---\n\n# 用 Swift 写算法——搜索\n\n### 线性搜索\n\n**简介：**\n\n线性搜索是从数组的头开始顺次访问各元素，检查该元素值是否与目标值相等。一旦相等就返回该元素位置并结束搜索。线性搜索算法的效率很低，但适用于任何形式的数据。\n\n**Swift 实现：**\n\n```swift\nfunc linearSearch(array: [Int], key: Int) -> Int? {\n    for (i, each) in array.enumerated() {\n        if each == key {\n            return i\n        }\n    }\n    return nil\n}\n```\n\n**分析：**\n\n线性搜索的时间复杂度为 $O(n)$ 。\n\n### 二分搜索\n\n**简介：**\n\n二分搜索可以利用数据的大小进行高速搜索。每执行一次，搜索的范围都会减半，因此可以在极短的时间内完成搜索，不过需要数据有序。\n\n**Swift 实现：**\n\n```swift\nfunc binarySearch(array: [Int], key: Int) -> Int? {\n    var leftIndex = 0\n    var rightIndex = array.count - 1\n    while leftIndex <= rightIndex {\n        let midIndex = (rightIndex + leftIndex) / 2\n        if array[midIndex] > key {\n            rightIndex = midIndex - 1\n        } else if array[midIndex] < key {\n            leftIndex = midIndex + 1\n        } else {\n            return midIndex\n        }\n    }\n    return nil\n}\n```\n\n**分析：**\n\n二分查找法每次搜索范围都会减半，在最坏的情况下大概需要 $log_2n$ 次，时间复杂度为 $O(logn)$ 。\n\n在最坏的情况下，对比线性搜索和二分搜索：\n\n|   元素数   | 线性搜索次数  | 二分搜索次数 |\n| :-----: | :-----: | :----: |\n|   100   |   100   |   7    |\n|  10000  |  10000  |   14   |\n| 1000000 | 1000000 |   20   |\n\n这里默认传入的数组有序。在一般情况下，可以考虑先对数组排序，然后进行二分搜索。不过，考虑到数据的体积，一般需要使用高等排序法。\n\n### 散列法\n\n**简介：**\n\n在散列法中，各元素存储的位置由散列函数决定。这种算法只需要将元素的关键字代入散列函数，就可以计算出它的位置。对特定形式的数据有极高的搜索效率。\n\n**分析：**\n\n散列法的要点在于散列函数的选取和冲突时的处理方法。如果忽略冲突的情况，时间复杂度仅为 $O(1)$。","slug":"用Swift写算法-搜索","published":1,"updated":"2020-01-04T08:16:16.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3g001kljc3ylm40aid","content":"<h1 id=\"用-Swift-写算法——搜索\"><a href=\"#用-Swift-写算法——搜索\" class=\"headerlink\" title=\"用 Swift 写算法——搜索\"></a>用 Swift 写算法——搜索</h1><h3 id=\"线性搜索\"><a href=\"#线性搜索\" class=\"headerlink\" title=\"线性搜索\"></a>线性搜索</h3><p><strong>简介：</strong></p>\n<p>线性搜索是从数组的头开始顺次访问各元素，检查该元素值是否与目标值相等。一旦相等就返回该元素位置并结束搜索。线性搜索算法的效率很低，但适用于任何形式的数据。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">linearSearch</span><span class=\"params\">(array: [Int], key: Int)</span></span> -&gt; <span class=\"type\">Int?</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i, each) <span class=\"keyword\">in</span> array.enumerated() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> each == key &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>线性搜索的时间复杂度为 $O(n)$ 。</p>\n<h3 id=\"二分搜索\"><a href=\"#二分搜索\" class=\"headerlink\" title=\"二分搜索\"></a>二分搜索</h3><p><strong>简介：</strong></p>\n<p>二分搜索可以利用数据的大小进行高速搜索。每执行一次，搜索的范围都会减半，因此可以在极短的时间内完成搜索，不过需要数据有序。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">binarySearch</span><span class=\"params\">(array: [Int], key: Int)</span></span> -&gt; <span class=\"type\">Int?</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> leftIndex = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> rightIndex = array.<span class=\"built_in\">count</span> - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> leftIndex &lt;= rightIndex &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> midIndex = (rightIndex + leftIndex) / <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> array[midIndex] &gt; key &#123;</span><br><span class=\"line\">            rightIndex = midIndex - <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> array[midIndex] &lt; key &#123;</span><br><span class=\"line\">            leftIndex = midIndex + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> midIndex</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>二分查找法每次搜索范围都会减半，在最坏的情况下大概需要 $log_2n$ 次，时间复杂度为 $O(logn)$ 。</p>\n<p>在最坏的情况下，对比线性搜索和二分搜索：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">元素数</th>\n<th style=\"text-align:center\">线性搜索次数</th>\n<th style=\"text-align:center\">二分搜索次数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">7</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10000</td>\n<td style=\"text-align:center\">10000</td>\n<td style=\"text-align:center\">14</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1000000</td>\n<td style=\"text-align:center\">1000000</td>\n<td style=\"text-align:center\">20</td>\n</tr>\n</tbody>\n</table>\n<p>这里默认传入的数组有序。在一般情况下，可以考虑先对数组排序，然后进行二分搜索。不过，考虑到数据的体积，一般需要使用高等排序法。</p>\n<h3 id=\"散列法\"><a href=\"#散列法\" class=\"headerlink\" title=\"散列法\"></a>散列法</h3><p><strong>简介：</strong></p>\n<p>在散列法中，各元素存储的位置由散列函数决定。这种算法只需要将元素的关键字代入散列函数，就可以计算出它的位置。对特定形式的数据有极高的搜索效率。</p>\n<p><strong>分析：</strong></p>\n<p>散列法的要点在于散列函数的选取和冲突时的处理方法。如果忽略冲突的情况，时间复杂度仅为 $O(1)$。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"用-Swift-写算法——搜索\"><a href=\"#用-Swift-写算法——搜索\" class=\"headerlink\" title=\"用 Swift 写算法——搜索\"></a>用 Swift 写算法——搜索</h1><h3 id=\"线性搜索\"><a href=\"#线性搜索\" class=\"headerlink\" title=\"线性搜索\"></a>线性搜索</h3><p><strong>简介：</strong></p>\n<p>线性搜索是从数组的头开始顺次访问各元素，检查该元素值是否与目标值相等。一旦相等就返回该元素位置并结束搜索。线性搜索算法的效率很低，但适用于任何形式的数据。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">linearSearch</span><span class=\"params\">(array: [Int], key: Int)</span></span> -&gt; <span class=\"type\">Int?</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i, each) <span class=\"keyword\">in</span> array.enumerated() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> each == key &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>线性搜索的时间复杂度为 $O(n)$ 。</p>\n<h3 id=\"二分搜索\"><a href=\"#二分搜索\" class=\"headerlink\" title=\"二分搜索\"></a>二分搜索</h3><p><strong>简介：</strong></p>\n<p>二分搜索可以利用数据的大小进行高速搜索。每执行一次，搜索的范围都会减半，因此可以在极短的时间内完成搜索，不过需要数据有序。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">binarySearch</span><span class=\"params\">(array: [Int], key: Int)</span></span> -&gt; <span class=\"type\">Int?</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> leftIndex = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> rightIndex = array.<span class=\"built_in\">count</span> - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> leftIndex &lt;= rightIndex &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> midIndex = (rightIndex + leftIndex) / <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> array[midIndex] &gt; key &#123;</span><br><span class=\"line\">            rightIndex = midIndex - <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> array[midIndex] &lt; key &#123;</span><br><span class=\"line\">            leftIndex = midIndex + <span class=\"number\">1</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> midIndex</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>二分查找法每次搜索范围都会减半，在最坏的情况下大概需要 $log_2n$ 次，时间复杂度为 $O(logn)$ 。</p>\n<p>在最坏的情况下，对比线性搜索和二分搜索：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">元素数</th>\n<th style=\"text-align:center\">线性搜索次数</th>\n<th style=\"text-align:center\">二分搜索次数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">7</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">10000</td>\n<td style=\"text-align:center\">10000</td>\n<td style=\"text-align:center\">14</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">1000000</td>\n<td style=\"text-align:center\">1000000</td>\n<td style=\"text-align:center\">20</td>\n</tr>\n</tbody>\n</table>\n<p>这里默认传入的数组有序。在一般情况下，可以考虑先对数组排序，然后进行二分搜索。不过，考虑到数据的体积，一般需要使用高等排序法。</p>\n<h3 id=\"散列法\"><a href=\"#散列法\" class=\"headerlink\" title=\"散列法\"></a>散列法</h3><p><strong>简介：</strong></p>\n<p>在散列法中，各元素存储的位置由散列函数决定。这种算法只需要将元素的关键字代入散列函数，就可以计算出它的位置。对特定形式的数据有极高的搜索效率。</p>\n<p><strong>分析：</strong></p>\n<p>散列法的要点在于散列函数的选取和冲突时的处理方法。如果忽略冲突的情况，时间复杂度仅为 $O(1)$。</p>\n"},{"title":"解决Leak分析闪退问题","date":"2018-04-27T15:46:15.000Z","_content":"\n# 解决内存泄露分析导致的App闪退\n\n我们在解决应用内存泄露的问题时，常常要用到 Instruments 调试工具的 Leak Check 工具。然而，有时打开 Leak Check，应用就闪退了，导致无法调试。\n\n这似乎是 Xcode 的一个 bug。解决方法很简单：打开 Allocations 分析工具（而不是 Leaks）、点击右上角 + 按钮添加 Leaks 工具就可以了。","source":"_posts/解决Leak分析闪退问题.md","raw":"---\ntitle: 解决Leak分析闪退问题\ndate: 2018-04-27 23:46:15\ntags: Instruments\n---\n\n# 解决内存泄露分析导致的App闪退\n\n我们在解决应用内存泄露的问题时，常常要用到 Instruments 调试工具的 Leak Check 工具。然而，有时打开 Leak Check，应用就闪退了，导致无法调试。\n\n这似乎是 Xcode 的一个 bug。解决方法很简单：打开 Allocations 分析工具（而不是 Leaks）、点击右上角 + 按钮添加 Leaks 工具就可以了。","slug":"解决Leak分析闪退问题","published":1,"updated":"2020-01-04T08:16:16.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3g001lljc3qn4o2zof","content":"<h1 id=\"解决内存泄露分析导致的App闪退\"><a href=\"#解决内存泄露分析导致的App闪退\" class=\"headerlink\" title=\"解决内存泄露分析导致的App闪退\"></a>解决内存泄露分析导致的App闪退</h1><p>我们在解决应用内存泄露的问题时，常常要用到 Instruments 调试工具的 Leak Check 工具。然而，有时打开 Leak Check，应用就闪退了，导致无法调试。</p>\n<p>这似乎是 Xcode 的一个 bug。解决方法很简单：打开 Allocations 分析工具（而不是 Leaks）、点击右上角 + 按钮添加 Leaks 工具就可以了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"解决内存泄露分析导致的App闪退\"><a href=\"#解决内存泄露分析导致的App闪退\" class=\"headerlink\" title=\"解决内存泄露分析导致的App闪退\"></a>解决内存泄露分析导致的App闪退</h1><p>我们在解决应用内存泄露的问题时，常常要用到 Instruments 调试工具的 Leak Check 工具。然而，有时打开 Leak Check，应用就闪退了，导致无法调试。</p>\n<p>这似乎是 Xcode 的一个 bug。解决方法很简单：打开 Allocations 分析工具（而不是 Leaks）、点击右上角 + 按钮添加 Leaks 工具就可以了。</p>\n"},{"title":"用Swift写算法-递归和分治法","date":"2017-07-14T08:53:09.000Z","_content":"\n# 用 Swift 写算法——递归和分治法\n\n### 分治法简介\n\n将问题分解，通过求解局部性的小问题来解决原本的问题，这种技巧叫分治法。实现分治法需要使用递归，其主要步骤如下：\n\n- 将问题分割成局部问题 （Divide）\n- 递归地求解局部问题 （Slove）\n- 将局部问题的解整合，解决原问题 （Conquer）\n\n### 应用-穷举搜索\n\n**题目：**\n\n现有数列 A 和 整数 m。请编写一程序，判断 A 中任意几个元素相加是否能得到 m。A 中每个数只能用一次。\n\n**Swift 实现：**\n\n```swift\nlet array = [1,5,7,10,21]\nfunc solve(i: Int, m: Int) -> Bool {\n    if m == 0 {\n        return true\n    }\n    if i >= array.count {\n        return false\n    }\n    let res = solve(i: i + 1, m: m) || solve(i: i + 1, m: m - array[i])\n    return res\n}\n\nsolve(i: 0, m: 8)\n```\n\n**分析：**\n\n我们把问题分解成两个更小的局部问题：选择当前元素／不选择当前元素的情况下搜索。如此递归下去，便能解决原问题。\n\n检查所有排列组合需要使用两个递归函数，时间复杂度为 $O(2^n)$ ，因此 n 不能太大。\n\n### 应用-科赫曲线\n\n**题目：**\n\n编写一程序，输入整数 n，输出科赫曲线的顶点坐标。\n\n科赫曲线是一种广为人知的不规则碎片形。该图形具有递归结构，可以通过如下方法画出：\n\n- 给定线段三等分\n- 以三等分点作出正三角形\n- 对新产生的线段重复上述操作\n\n![Koch Curve](https://i.loli.net/2017/07/14/59687af87adae.jpg)\n\n设端点为（0，0）和（100，0）\n\n**Swift 实现：**\n\n```swift\nfunc koch(deep:Int, a:(Double, Double), b:(Double, Double)) {\n    if deep == 0 {\n        return\n    }\n    let left = ((b.0 - a.0)/3.0 + a.0, (b.1 - a.1)/3.0 + a.1)\n    let right = ((a.0 + 2.0 * b.0)/3.0, (a.1 + 2.0*b.1)/3.0)\n    let mid = ((right.0 - left.0)*cos(1.0/3.0*Double.pi) - (right.1 - left.1)*sin(1.0/3.0*Double.pi) + left.0, (right.0 - left.0)*sin(1.0/3.0*Double.pi) - (right.1 - left.1)*cos(1.0/3.0*Double.pi) + left.1)\n    koch(deep: deep - 1, a: a, b: left)\n    print(left)\n    koch(deep: deep - 1, a: left, b: mid)\n    print(mid)\n    koch(deep: deep - 1, a: mid, b: right)\n    print(right)\n    koch(deep: deep - 1, a: right, b: b)\n}\n\nkoch(deep: 2, a: (0,0), b: (100,0))\n```\n\n**分析：**\n\n每次都计算出左、中、右三个点的坐标，然后逐层递归。把最原始的问题化成端点到左，左到中，中到右，右到端点这些规模较小的子问题，同时，递归层级递减，直到 0。","source":"_posts/用Swift写算法-递归和分治法.md","raw":"---\ntitle: 用Swift写算法-递归和分治法\ndate: 2017-07-14 16:53:09\ntags: Algorithm\n---\n\n# 用 Swift 写算法——递归和分治法\n\n### 分治法简介\n\n将问题分解，通过求解局部性的小问题来解决原本的问题，这种技巧叫分治法。实现分治法需要使用递归，其主要步骤如下：\n\n- 将问题分割成局部问题 （Divide）\n- 递归地求解局部问题 （Slove）\n- 将局部问题的解整合，解决原问题 （Conquer）\n\n### 应用-穷举搜索\n\n**题目：**\n\n现有数列 A 和 整数 m。请编写一程序，判断 A 中任意几个元素相加是否能得到 m。A 中每个数只能用一次。\n\n**Swift 实现：**\n\n```swift\nlet array = [1,5,7,10,21]\nfunc solve(i: Int, m: Int) -> Bool {\n    if m == 0 {\n        return true\n    }\n    if i >= array.count {\n        return false\n    }\n    let res = solve(i: i + 1, m: m) || solve(i: i + 1, m: m - array[i])\n    return res\n}\n\nsolve(i: 0, m: 8)\n```\n\n**分析：**\n\n我们把问题分解成两个更小的局部问题：选择当前元素／不选择当前元素的情况下搜索。如此递归下去，便能解决原问题。\n\n检查所有排列组合需要使用两个递归函数，时间复杂度为 $O(2^n)$ ，因此 n 不能太大。\n\n### 应用-科赫曲线\n\n**题目：**\n\n编写一程序，输入整数 n，输出科赫曲线的顶点坐标。\n\n科赫曲线是一种广为人知的不规则碎片形。该图形具有递归结构，可以通过如下方法画出：\n\n- 给定线段三等分\n- 以三等分点作出正三角形\n- 对新产生的线段重复上述操作\n\n![Koch Curve](https://i.loli.net/2017/07/14/59687af87adae.jpg)\n\n设端点为（0，0）和（100，0）\n\n**Swift 实现：**\n\n```swift\nfunc koch(deep:Int, a:(Double, Double), b:(Double, Double)) {\n    if deep == 0 {\n        return\n    }\n    let left = ((b.0 - a.0)/3.0 + a.0, (b.1 - a.1)/3.0 + a.1)\n    let right = ((a.0 + 2.0 * b.0)/3.0, (a.1 + 2.0*b.1)/3.0)\n    let mid = ((right.0 - left.0)*cos(1.0/3.0*Double.pi) - (right.1 - left.1)*sin(1.0/3.0*Double.pi) + left.0, (right.0 - left.0)*sin(1.0/3.0*Double.pi) - (right.1 - left.1)*cos(1.0/3.0*Double.pi) + left.1)\n    koch(deep: deep - 1, a: a, b: left)\n    print(left)\n    koch(deep: deep - 1, a: left, b: mid)\n    print(mid)\n    koch(deep: deep - 1, a: mid, b: right)\n    print(right)\n    koch(deep: deep - 1, a: right, b: b)\n}\n\nkoch(deep: 2, a: (0,0), b: (100,0))\n```\n\n**分析：**\n\n每次都计算出左、中、右三个点的坐标，然后逐层递归。把最原始的问题化成端点到左，左到中，中到右，右到端点这些规模较小的子问题，同时，递归层级递减，直到 0。","slug":"用Swift写算法-递归和分治法","published":1,"updated":"2020-01-04T08:16:16.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3h001oljc3vz5y37gg","content":"<h1 id=\"用-Swift-写算法——递归和分治法\"><a href=\"#用-Swift-写算法——递归和分治法\" class=\"headerlink\" title=\"用 Swift 写算法——递归和分治法\"></a>用 Swift 写算法——递归和分治法</h1><h3 id=\"分治法简介\"><a href=\"#分治法简介\" class=\"headerlink\" title=\"分治法简介\"></a>分治法简介</h3><p>将问题分解，通过求解局部性的小问题来解决原本的问题，这种技巧叫分治法。实现分治法需要使用递归，其主要步骤如下：</p>\n<ul>\n<li>将问题分割成局部问题 （Divide）</li>\n<li>递归地求解局部问题 （Slove）</li>\n<li>将局部问题的解整合，解决原问题 （Conquer）</li>\n</ul>\n<h3 id=\"应用-穷举搜索\"><a href=\"#应用-穷举搜索\" class=\"headerlink\" title=\"应用-穷举搜索\"></a>应用-穷举搜索</h3><p><strong>题目：</strong></p>\n<p>现有数列 A 和 整数 m。请编写一程序，判断 A 中任意几个元素相加是否能得到 m。A 中每个数只能用一次。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">10</span>,<span class=\"number\">21</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">solve</span><span class=\"params\">(i: Int, m: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> m == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &gt;= array.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = solve(i: i + <span class=\"number\">1</span>, m: m) || solve(i: i + <span class=\"number\">1</span>, m: m - array[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">solve(i: <span class=\"number\">0</span>, m: <span class=\"number\">8</span>)</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>我们把问题分解成两个更小的局部问题：选择当前元素／不选择当前元素的情况下搜索。如此递归下去，便能解决原问题。</p>\n<p>检查所有排列组合需要使用两个递归函数，时间复杂度为 $O(2^n)$ ，因此 n 不能太大。</p>\n<h3 id=\"应用-科赫曲线\"><a href=\"#应用-科赫曲线\" class=\"headerlink\" title=\"应用-科赫曲线\"></a>应用-科赫曲线</h3><p><strong>题目：</strong></p>\n<p>编写一程序，输入整数 n，输出科赫曲线的顶点坐标。</p>\n<p>科赫曲线是一种广为人知的不规则碎片形。该图形具有递归结构，可以通过如下方法画出：</p>\n<ul>\n<li>给定线段三等分</li>\n<li>以三等分点作出正三角形</li>\n<li>对新产生的线段重复上述操作</li>\n</ul>\n<p><img src=\"https://i.loli.net/2017/07/14/59687af87adae.jpg\" alt=\"Koch Curve\"></p>\n<p>设端点为（0，0）和（100，0）</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">koch</span><span class=\"params\">(deep:Int, a:<span class=\"params\">(Double, Double)</span></span></span>, b:(<span class=\"type\">Double</span>, <span class=\"type\">Double</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> deep == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">left</span> = ((b.<span class=\"number\">0</span> - a.<span class=\"number\">0</span>)/<span class=\"number\">3.0</span> + a.<span class=\"number\">0</span>, (b.<span class=\"number\">1</span> - a.<span class=\"number\">1</span>)/<span class=\"number\">3.0</span> + a.<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">right</span> = ((a.<span class=\"number\">0</span> + <span class=\"number\">2.0</span> * b.<span class=\"number\">0</span>)/<span class=\"number\">3.0</span>, (a.<span class=\"number\">1</span> + <span class=\"number\">2.0</span>*b.<span class=\"number\">1</span>)/<span class=\"number\">3.0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = ((<span class=\"keyword\">right</span>.<span class=\"number\">0</span> - <span class=\"keyword\">left</span>.<span class=\"number\">0</span>)*cos(<span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>*<span class=\"type\">Double</span>.pi) - (<span class=\"keyword\">right</span>.<span class=\"number\">1</span> - <span class=\"keyword\">left</span>.<span class=\"number\">1</span>)*sin(<span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>*<span class=\"type\">Double</span>.pi) + <span class=\"keyword\">left</span>.<span class=\"number\">0</span>, (<span class=\"keyword\">right</span>.<span class=\"number\">0</span> - <span class=\"keyword\">left</span>.<span class=\"number\">0</span>)*sin(<span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>*<span class=\"type\">Double</span>.pi) - (<span class=\"keyword\">right</span>.<span class=\"number\">1</span> - <span class=\"keyword\">left</span>.<span class=\"number\">1</span>)*cos(<span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>*<span class=\"type\">Double</span>.pi) + <span class=\"keyword\">left</span>.<span class=\"number\">1</span>)</span><br><span class=\"line\">    koch(deep: deep - <span class=\"number\">1</span>, a: a, b: <span class=\"keyword\">left</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"keyword\">left</span>)</span><br><span class=\"line\">    koch(deep: deep - <span class=\"number\">1</span>, a: <span class=\"keyword\">left</span>, b: mid)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(mid)</span><br><span class=\"line\">    koch(deep: deep - <span class=\"number\">1</span>, a: mid, b: <span class=\"keyword\">right</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"keyword\">right</span>)</span><br><span class=\"line\">    koch(deep: deep - <span class=\"number\">1</span>, a: <span class=\"keyword\">right</span>, b: b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">koch(deep: <span class=\"number\">2</span>, a: (<span class=\"number\">0</span>,<span class=\"number\">0</span>), b: (<span class=\"number\">100</span>,<span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>每次都计算出左、中、右三个点的坐标，然后逐层递归。把最原始的问题化成端点到左，左到中，中到右，右到端点这些规模较小的子问题，同时，递归层级递减，直到 0。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"用-Swift-写算法——递归和分治法\"><a href=\"#用-Swift-写算法——递归和分治法\" class=\"headerlink\" title=\"用 Swift 写算法——递归和分治法\"></a>用 Swift 写算法——递归和分治法</h1><h3 id=\"分治法简介\"><a href=\"#分治法简介\" class=\"headerlink\" title=\"分治法简介\"></a>分治法简介</h3><p>将问题分解，通过求解局部性的小问题来解决原本的问题，这种技巧叫分治法。实现分治法需要使用递归，其主要步骤如下：</p>\n<ul>\n<li>将问题分割成局部问题 （Divide）</li>\n<li>递归地求解局部问题 （Slove）</li>\n<li>将局部问题的解整合，解决原问题 （Conquer）</li>\n</ul>\n<h3 id=\"应用-穷举搜索\"><a href=\"#应用-穷举搜索\" class=\"headerlink\" title=\"应用-穷举搜索\"></a>应用-穷举搜索</h3><p><strong>题目：</strong></p>\n<p>现有数列 A 和 整数 m。请编写一程序，判断 A 中任意几个元素相加是否能得到 m。A 中每个数只能用一次。</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> array = [<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">10</span>,<span class=\"number\">21</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">solve</span><span class=\"params\">(i: Int, m: Int)</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> m == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i &gt;= array.<span class=\"built_in\">count</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> res = solve(i: i + <span class=\"number\">1</span>, m: m) || solve(i: i + <span class=\"number\">1</span>, m: m - array[i])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">solve(i: <span class=\"number\">0</span>, m: <span class=\"number\">8</span>)</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>我们把问题分解成两个更小的局部问题：选择当前元素／不选择当前元素的情况下搜索。如此递归下去，便能解决原问题。</p>\n<p>检查所有排列组合需要使用两个递归函数，时间复杂度为 $O(2^n)$ ，因此 n 不能太大。</p>\n<h3 id=\"应用-科赫曲线\"><a href=\"#应用-科赫曲线\" class=\"headerlink\" title=\"应用-科赫曲线\"></a>应用-科赫曲线</h3><p><strong>题目：</strong></p>\n<p>编写一程序，输入整数 n，输出科赫曲线的顶点坐标。</p>\n<p>科赫曲线是一种广为人知的不规则碎片形。该图形具有递归结构，可以通过如下方法画出：</p>\n<ul>\n<li>给定线段三等分</li>\n<li>以三等分点作出正三角形</li>\n<li>对新产生的线段重复上述操作</li>\n</ul>\n<p><img src=\"https://i.loli.net/2017/07/14/59687af87adae.jpg\" alt=\"Koch Curve\"></p>\n<p>设端点为（0，0）和（100，0）</p>\n<p><strong>Swift 实现：</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">koch</span><span class=\"params\">(deep:Int, a:<span class=\"params\">(Double, Double)</span></span></span>, b:(<span class=\"type\">Double</span>, <span class=\"type\">Double</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> deep == <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">left</span> = ((b.<span class=\"number\">0</span> - a.<span class=\"number\">0</span>)/<span class=\"number\">3.0</span> + a.<span class=\"number\">0</span>, (b.<span class=\"number\">1</span> - a.<span class=\"number\">1</span>)/<span class=\"number\">3.0</span> + a.<span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> <span class=\"keyword\">right</span> = ((a.<span class=\"number\">0</span> + <span class=\"number\">2.0</span> * b.<span class=\"number\">0</span>)/<span class=\"number\">3.0</span>, (a.<span class=\"number\">1</span> + <span class=\"number\">2.0</span>*b.<span class=\"number\">1</span>)/<span class=\"number\">3.0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> mid = ((<span class=\"keyword\">right</span>.<span class=\"number\">0</span> - <span class=\"keyword\">left</span>.<span class=\"number\">0</span>)*cos(<span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>*<span class=\"type\">Double</span>.pi) - (<span class=\"keyword\">right</span>.<span class=\"number\">1</span> - <span class=\"keyword\">left</span>.<span class=\"number\">1</span>)*sin(<span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>*<span class=\"type\">Double</span>.pi) + <span class=\"keyword\">left</span>.<span class=\"number\">0</span>, (<span class=\"keyword\">right</span>.<span class=\"number\">0</span> - <span class=\"keyword\">left</span>.<span class=\"number\">0</span>)*sin(<span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>*<span class=\"type\">Double</span>.pi) - (<span class=\"keyword\">right</span>.<span class=\"number\">1</span> - <span class=\"keyword\">left</span>.<span class=\"number\">1</span>)*cos(<span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>*<span class=\"type\">Double</span>.pi) + <span class=\"keyword\">left</span>.<span class=\"number\">1</span>)</span><br><span class=\"line\">    koch(deep: deep - <span class=\"number\">1</span>, a: a, b: <span class=\"keyword\">left</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"keyword\">left</span>)</span><br><span class=\"line\">    koch(deep: deep - <span class=\"number\">1</span>, a: <span class=\"keyword\">left</span>, b: mid)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(mid)</span><br><span class=\"line\">    koch(deep: deep - <span class=\"number\">1</span>, a: mid, b: <span class=\"keyword\">right</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"keyword\">right</span>)</span><br><span class=\"line\">    koch(deep: deep - <span class=\"number\">1</span>, a: <span class=\"keyword\">right</span>, b: b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">koch(deep: <span class=\"number\">2</span>, a: (<span class=\"number\">0</span>,<span class=\"number\">0</span>), b: (<span class=\"number\">100</span>,<span class=\"number\">0</span>))</span><br></pre></td></tr></table></figure>\n<p><strong>分析：</strong></p>\n<p>每次都计算出左、中、右三个点的坐标，然后逐层递归。把最原始的问题化成端点到左，左到中，中到右，右到端点这些规模较小的子问题，同时，递归层级递减，直到 0。</p>\n"},{"title":"解决Unacceptable Content-Type问题","date":"2018-07-13T13:23:09.000Z","_content":"\n# 解决 Unacceptable Content-Type\n\n最近在通过 API 的形式访问腾讯云的 [COS 服务](https://cloud.tencent.com/product/cos)时，一直请求失败。通过 `po error` 命令打印出 AFNetworking 回调方法中的 NSError 对象，控制台输出如下：\n\n```\n(lldb)po error\nError Domain=com.alamofire.error.serialization.response Code=-1016 \"Request failed: unacceptable content-type: application/x-www-form-urlencoded\" UserInfo={NSLocalizedDescription=Request failed: unacceptable content-type: application/x-www-form-urlencoded, NSErrorFailingURLKey=https://my.url, com.alamofire.serialization.response.error.data=<mydata>, com.alamofire.serialization.response.error.response=<NSHTTPURLResponse: 0x608000037600> { URL: https://my.url } { Status Code: 200, Headers {\n\t//......\n    \"Content-Type\" =     (\n        \"application/x-www-form-urlencoded\"\n    );\n    Server =     (\n        \"tencent-cos\"\n    );\n    //......\n} }}\n```\n\n比较奇怪的一点是，可以看到腾讯云返回的 Status Code 是 200，而且如果查看 error 的 userinfo 信息 `error.userInfo[@\"com.alamofire.serialization.response.error.data\"] ` ，是可以看到返回的 HTTP Body 信息的。这说明我们的请求是成功了的，毕竟正确的数据已经返回了，只是 AFNetworking 认为失败了。\n\n## 错误原因\n\n根据报错信息，可以看到错误的原因是 `unacceptable content-type: application/x-www-form-urlencoded` 。也就是腾讯云返回给我们的 content type 并不能被 AFNetworking 解析。而事实上这个接口中，返回的 body 信息本身就是我们需要的二进制数据，并不需要解析。因此要解决这个问题，只需要让 AFNetworking 不认为这是个错误就可以了，思路就是让它认为 `application/x-www-form-urlencoded` 是可以接受的。\n\n## 添加 Content-Type\n\n最直接的想法，就是我们取出 AFNetworking 支持的 content-type 集合，再把腾讯云的这个值添加进去：\n\n```objc\nNSMutableSet *set = [manager.responseSerializer.acceptableContentTypes mutableCopy];\n[set addObject:@\"application/x-www-form-urlencoded\"];\nmanager.responseSerializer.acceptableContentTypes = [set copy];\n```\n\n再次运行，果然不再报错说不接受 content-type 了，而是换了个新的错误：\n\n```\nError Domain=NSCocoaErrorDomain Code=3840 \"JSON text did not start with array or object and option to allow fragments not set.\" UserInfo={NSDebugDescription=JSON text did not start with array or object and option to allow fragments not set.}\n```\n\n新的错误信息提示我们 JSON 格式不正确。但是，腾讯云的这个接口并不会返回结构化的数据，body 里面只是二进制数据。而且，就算要返回被编码的信息，也是 XML 的，并不是 JSON。如果 AFNetworking 以 JSON 的格式去解析，当然会产生错误。\n\n要解决这个问题，靠直觉就不够了，需要看看 AFNetworking 的源码。\n\n## 寻找问题根源\n\n我们跳转到 `acceptableContentTypes` 的定义中，在 `AFURLResponseSerialization.m ` 文件中，可以看到这样一个函数：\n\n```objc\n- (BOOL)validateResponse:(NSHTTPURLResponse *)response\n                    data:(NSData *)data\n                   error:(NSError * __autoreleasing *)error\n{\n    BOOL responseIsValid = YES;\n    NSError *validationError = nil;\n    if (response && [response isKindOfClass:[NSHTTPURLResponse class]]) {\n        if (self.acceptableContentTypes && ![self.acceptableContentTypes containsObject:[response MIMEType]] &&\n            !([response MIMEType] == nil && [data length] == 0)) {\n            //......\n            responseIsValid = NO;\n        }\n        //......\n    }\n    //......\n    return responseIsValid;\n}\n```\n\n可以看到它确实有在判断接收到的 MIME type 是不是被包含在 acceptableContentTypes 里面的。由于我们刚才的添加，这里是可以被验证通过的，之前的思路肯定是正确的。就需要找到哪个地方产生了新问题。\n\n查看 `AFHTTPSessionManager ` 的实现，可以看到这两个初始化方法：\n\n```objc\n+ (instancetype)manager {\n    return [[[self class] alloc] initWithBaseURL:nil];\n}\n\n- (instancetype)initWithBaseURL:(NSURL *)url\n           sessionConfiguration:(NSURLSessionConfiguration *)configuration\n{\n    self = [super initWithSessionConfiguration:configuration];\n    if (!self) {\n        return nil;\n    }\n    //......\n    self.requestSerializer = [AFHTTPRequestSerializer serializer];\n    self.responseSerializer = [AFJSONResponseSerializer serializer];\n\n    return self;\n}\n```\n\n原来，在我们通过 `AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; ` 方法初始化 manager 的时候，它的 responseSerializer 就被设置成了 `AFJSONResponseSerializer` 。终于找到了问题的根源！\n\n当然，这种错误是由于我们的接口返回的不是 JSON 数据导致的。如果你的接口返回的是 JSON，那么问题应该在上一步就已经解决了。\n\n## 解决问题\n\n我们只需要把 manager 的 responseSerializer 换掉就可以了：\n\n```objc\nmanager.responseSerializer = [[AFHTTPResponseSerializer alloc] init];\n```\n\n使用 HTTPResponseSerializer，不需要它来解析 JSON。\n\n再次运行程序，就可以成功拿到数据了。\n\n------\n\n## 附录\n\n腾讯云的 API 在签名时需要做 md5 / SHA-1 / HMAC - SHA1 等加密算法。正确可用的实现不太好找，故将这几种算法代码附在这里：\n\n```objc\n#import <CommonCrypto/CommonDigest.h>\n#import <CommonCrypto/CommonHMAC.h>\n\n- (NSString*)sha1WithStr :(NSString*)string\n{\n    NSString * test =string;\n    const char *cstr = [test   cStringUsingEncoding:NSUTF8StringEncoding];\n    NSData *data = [NSData dataWithBytes:cstr length:test.length];\n    \n    uint8_t digest[CC_SHA1_DIGEST_LENGTH];\n    \n    CC_SHA1(data.bytes, (int)data.length, digest);\n    \n    NSMutableString* output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH * 2];\n    \n    for(int i = 0; i < CC_SHA1_DIGEST_LENGTH; i++)\n        [output appendFormat:@\"%02x\", digest[i]];\n    \n    return output;\n}\n\n- (NSString *)hmac:(NSString *)plaintext withKey:(NSString *)key\n{\n    const char *cKey  = [key cStringUsingEncoding:NSASCIIStringEncoding];\n    const char *cData = [plaintext cStringUsingEncoding:NSASCIIStringEncoding];\n    unsigned char cHMAC[CC_SHA1_DIGEST_LENGTH];\n    CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), cData, strlen(cData), cHMAC);\n    NSData *HMACData = [NSData dataWithBytes:cHMAC length:sizeof(cHMAC)];\n    const unsigned char *buffer = (const unsigned char *)[HMACData bytes];\n    NSMutableString *HMAC = [NSMutableString stringWithCapacity:HMACData.length * 2];\n    for (int i = 0; i < HMACData.length; ++i){\n        [HMAC appendFormat:@\"%02x\", buffer[i]];\n    }\n    return HMAC;\n}\n\n- (NSString*)md5WithData:(NSData *)data{\n    unsigned char result[16];\n    CC_MD5( data.bytes, (CC_LONG)data.length, result ); // This is the md5 call\n    return [NSString stringWithFormat:\n            @\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\",\n            result[0], result[1], result[2], result[3],\n            result[4], result[5], result[6], result[7],\n            result[8], result[9], result[10], result[11],\n            result[12], result[13], result[14], result[15]\n            ];\n}\n```\n\n","source":"_posts/解决Unacceptable-Content-Type.md","raw":"---\ntitle: 解决Unacceptable Content-Type问题\ndate: 2018-07-13 21:23:09\ntags: AFNetworking\n---\n\n# 解决 Unacceptable Content-Type\n\n最近在通过 API 的形式访问腾讯云的 [COS 服务](https://cloud.tencent.com/product/cos)时，一直请求失败。通过 `po error` 命令打印出 AFNetworking 回调方法中的 NSError 对象，控制台输出如下：\n\n```\n(lldb)po error\nError Domain=com.alamofire.error.serialization.response Code=-1016 \"Request failed: unacceptable content-type: application/x-www-form-urlencoded\" UserInfo={NSLocalizedDescription=Request failed: unacceptable content-type: application/x-www-form-urlencoded, NSErrorFailingURLKey=https://my.url, com.alamofire.serialization.response.error.data=<mydata>, com.alamofire.serialization.response.error.response=<NSHTTPURLResponse: 0x608000037600> { URL: https://my.url } { Status Code: 200, Headers {\n\t//......\n    \"Content-Type\" =     (\n        \"application/x-www-form-urlencoded\"\n    );\n    Server =     (\n        \"tencent-cos\"\n    );\n    //......\n} }}\n```\n\n比较奇怪的一点是，可以看到腾讯云返回的 Status Code 是 200，而且如果查看 error 的 userinfo 信息 `error.userInfo[@\"com.alamofire.serialization.response.error.data\"] ` ，是可以看到返回的 HTTP Body 信息的。这说明我们的请求是成功了的，毕竟正确的数据已经返回了，只是 AFNetworking 认为失败了。\n\n## 错误原因\n\n根据报错信息，可以看到错误的原因是 `unacceptable content-type: application/x-www-form-urlencoded` 。也就是腾讯云返回给我们的 content type 并不能被 AFNetworking 解析。而事实上这个接口中，返回的 body 信息本身就是我们需要的二进制数据，并不需要解析。因此要解决这个问题，只需要让 AFNetworking 不认为这是个错误就可以了，思路就是让它认为 `application/x-www-form-urlencoded` 是可以接受的。\n\n## 添加 Content-Type\n\n最直接的想法，就是我们取出 AFNetworking 支持的 content-type 集合，再把腾讯云的这个值添加进去：\n\n```objc\nNSMutableSet *set = [manager.responseSerializer.acceptableContentTypes mutableCopy];\n[set addObject:@\"application/x-www-form-urlencoded\"];\nmanager.responseSerializer.acceptableContentTypes = [set copy];\n```\n\n再次运行，果然不再报错说不接受 content-type 了，而是换了个新的错误：\n\n```\nError Domain=NSCocoaErrorDomain Code=3840 \"JSON text did not start with array or object and option to allow fragments not set.\" UserInfo={NSDebugDescription=JSON text did not start with array or object and option to allow fragments not set.}\n```\n\n新的错误信息提示我们 JSON 格式不正确。但是，腾讯云的这个接口并不会返回结构化的数据，body 里面只是二进制数据。而且，就算要返回被编码的信息，也是 XML 的，并不是 JSON。如果 AFNetworking 以 JSON 的格式去解析，当然会产生错误。\n\n要解决这个问题，靠直觉就不够了，需要看看 AFNetworking 的源码。\n\n## 寻找问题根源\n\n我们跳转到 `acceptableContentTypes` 的定义中，在 `AFURLResponseSerialization.m ` 文件中，可以看到这样一个函数：\n\n```objc\n- (BOOL)validateResponse:(NSHTTPURLResponse *)response\n                    data:(NSData *)data\n                   error:(NSError * __autoreleasing *)error\n{\n    BOOL responseIsValid = YES;\n    NSError *validationError = nil;\n    if (response && [response isKindOfClass:[NSHTTPURLResponse class]]) {\n        if (self.acceptableContentTypes && ![self.acceptableContentTypes containsObject:[response MIMEType]] &&\n            !([response MIMEType] == nil && [data length] == 0)) {\n            //......\n            responseIsValid = NO;\n        }\n        //......\n    }\n    //......\n    return responseIsValid;\n}\n```\n\n可以看到它确实有在判断接收到的 MIME type 是不是被包含在 acceptableContentTypes 里面的。由于我们刚才的添加，这里是可以被验证通过的，之前的思路肯定是正确的。就需要找到哪个地方产生了新问题。\n\n查看 `AFHTTPSessionManager ` 的实现，可以看到这两个初始化方法：\n\n```objc\n+ (instancetype)manager {\n    return [[[self class] alloc] initWithBaseURL:nil];\n}\n\n- (instancetype)initWithBaseURL:(NSURL *)url\n           sessionConfiguration:(NSURLSessionConfiguration *)configuration\n{\n    self = [super initWithSessionConfiguration:configuration];\n    if (!self) {\n        return nil;\n    }\n    //......\n    self.requestSerializer = [AFHTTPRequestSerializer serializer];\n    self.responseSerializer = [AFJSONResponseSerializer serializer];\n\n    return self;\n}\n```\n\n原来，在我们通过 `AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; ` 方法初始化 manager 的时候，它的 responseSerializer 就被设置成了 `AFJSONResponseSerializer` 。终于找到了问题的根源！\n\n当然，这种错误是由于我们的接口返回的不是 JSON 数据导致的。如果你的接口返回的是 JSON，那么问题应该在上一步就已经解决了。\n\n## 解决问题\n\n我们只需要把 manager 的 responseSerializer 换掉就可以了：\n\n```objc\nmanager.responseSerializer = [[AFHTTPResponseSerializer alloc] init];\n```\n\n使用 HTTPResponseSerializer，不需要它来解析 JSON。\n\n再次运行程序，就可以成功拿到数据了。\n\n------\n\n## 附录\n\n腾讯云的 API 在签名时需要做 md5 / SHA-1 / HMAC - SHA1 等加密算法。正确可用的实现不太好找，故将这几种算法代码附在这里：\n\n```objc\n#import <CommonCrypto/CommonDigest.h>\n#import <CommonCrypto/CommonHMAC.h>\n\n- (NSString*)sha1WithStr :(NSString*)string\n{\n    NSString * test =string;\n    const char *cstr = [test   cStringUsingEncoding:NSUTF8StringEncoding];\n    NSData *data = [NSData dataWithBytes:cstr length:test.length];\n    \n    uint8_t digest[CC_SHA1_DIGEST_LENGTH];\n    \n    CC_SHA1(data.bytes, (int)data.length, digest);\n    \n    NSMutableString* output = [NSMutableString stringWithCapacity:CC_SHA1_DIGEST_LENGTH * 2];\n    \n    for(int i = 0; i < CC_SHA1_DIGEST_LENGTH; i++)\n        [output appendFormat:@\"%02x\", digest[i]];\n    \n    return output;\n}\n\n- (NSString *)hmac:(NSString *)plaintext withKey:(NSString *)key\n{\n    const char *cKey  = [key cStringUsingEncoding:NSASCIIStringEncoding];\n    const char *cData = [plaintext cStringUsingEncoding:NSASCIIStringEncoding];\n    unsigned char cHMAC[CC_SHA1_DIGEST_LENGTH];\n    CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), cData, strlen(cData), cHMAC);\n    NSData *HMACData = [NSData dataWithBytes:cHMAC length:sizeof(cHMAC)];\n    const unsigned char *buffer = (const unsigned char *)[HMACData bytes];\n    NSMutableString *HMAC = [NSMutableString stringWithCapacity:HMACData.length * 2];\n    for (int i = 0; i < HMACData.length; ++i){\n        [HMAC appendFormat:@\"%02x\", buffer[i]];\n    }\n    return HMAC;\n}\n\n- (NSString*)md5WithData:(NSData *)data{\n    unsigned char result[16];\n    CC_MD5( data.bytes, (CC_LONG)data.length, result ); // This is the md5 call\n    return [NSString stringWithFormat:\n            @\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\",\n            result[0], result[1], result[2], result[3],\n            result[4], result[5], result[6], result[7],\n            result[8], result[9], result[10], result[11],\n            result[12], result[13], result[14], result[15]\n            ];\n}\n```\n\n","slug":"解决Unacceptable-Content-Type","published":1,"updated":"2020-01-04T08:16:16.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3i001pljc3j2zc998t","content":"<h1 id=\"解决-Unacceptable-Content-Type\"><a href=\"#解决-Unacceptable-Content-Type\" class=\"headerlink\" title=\"解决 Unacceptable Content-Type\"></a>解决 Unacceptable Content-Type</h1><p>最近在通过 API 的形式访问腾讯云的 <a href=\"https://cloud.tencent.com/product/cos\">COS 服务</a>时，一直请求失败。通过 <code>po error</code> 命令打印出 AFNetworking 回调方法中的 NSError 对象，控制台输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb)po error</span><br><span class=\"line\">Error Domain=com.alamofire.error.serialization.response Code=-1016 &quot;Request failed: unacceptable content-type: application/x-www-form-urlencoded&quot; UserInfo=&#123;NSLocalizedDescription=Request failed: unacceptable content-type: application/x-www-form-urlencoded, NSErrorFailingURLKey=https://my.url, com.alamofire.serialization.response.error.data=&lt;mydata&gt;, com.alamofire.serialization.response.error.response=&lt;NSHTTPURLResponse: 0x608000037600&gt; &#123; URL: https://my.url &#125; &#123; Status Code: 200, Headers &#123;</span><br><span class=\"line\">\t//......</span><br><span class=\"line\">    &quot;Content-Type&quot; =     (</span><br><span class=\"line\">        &quot;application/x-www-form-urlencoded&quot;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    Server =     (</span><br><span class=\"line\">        &quot;tencent-cos&quot;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    //......</span><br><span class=\"line\">&#125; &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>比较奇怪的一点是，可以看到腾讯云返回的 Status Code 是 200，而且如果查看 error 的 userinfo 信息 <code>error.userInfo[@&quot;com.alamofire.serialization.response.error.data&quot;]</code> ，是可以看到返回的 HTTP Body 信息的。这说明我们的请求是成功了的，毕竟正确的数据已经返回了，只是 AFNetworking 认为失败了。</p>\n<h2 id=\"错误原因\"><a href=\"#错误原因\" class=\"headerlink\" title=\"错误原因\"></a>错误原因</h2><p>根据报错信息，可以看到错误的原因是 <code>unacceptable content-type: application/x-www-form-urlencoded</code> 。也就是腾讯云返回给我们的 content type 并不能被 AFNetworking 解析。而事实上这个接口中，返回的 body 信息本身就是我们需要的二进制数据，并不需要解析。因此要解决这个问题，只需要让 AFNetworking 不认为这是个错误就可以了，思路就是让它认为 <code>application/x-www-form-urlencoded</code> 是可以接受的。</p>\n<h2 id=\"添加-Content-Type\"><a href=\"#添加-Content-Type\" class=\"headerlink\" title=\"添加 Content-Type\"></a>添加 Content-Type</h2><p>最直接的想法，就是我们取出 AFNetworking 支持的 content-type 集合，再把腾讯云的这个值添加进去：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableSet</span> *set = [manager.responseSerializer.acceptableContentTypes mutableCopy];</span><br><span class=\"line\">[set addObject:<span class=\"string\">@\"application/x-www-form-urlencoded\"</span>];</span><br><span class=\"line\">manager.responseSerializer.acceptableContentTypes = [set <span class=\"keyword\">copy</span>];</span><br></pre></td></tr></table></figure>\n<p>再次运行，果然不再报错说不接受 content-type 了，而是换了个新的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error Domain=NSCocoaErrorDomain Code=3840 &quot;JSON text did not start with array or object and option to allow fragments not set.&quot; UserInfo=&#123;NSDebugDescription=JSON text did not start with array or object and option to allow fragments not set.&#125;</span><br></pre></td></tr></table></figure>\n<p>新的错误信息提示我们 JSON 格式不正确。但是，腾讯云的这个接口并不会返回结构化的数据，body 里面只是二进制数据。而且，就算要返回被编码的信息，也是 XML 的，并不是 JSON。如果 AFNetworking 以 JSON 的格式去解析，当然会产生错误。</p>\n<p>要解决这个问题，靠直觉就不够了，需要看看 AFNetworking 的源码。</p>\n<h2 id=\"寻找问题根源\"><a href=\"#寻找问题根源\" class=\"headerlink\" title=\"寻找问题根源\"></a>寻找问题根源</h2><p>我们跳转到 <code>acceptableContentTypes</code> 的定义中，在 <code>AFURLResponseSerialization.m</code> 文件中，可以看到这样一个函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)validateResponse:(<span class=\"built_in\">NSHTTPURLResponse</span> *)response</span><br><span class=\"line\">                    data:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                   error:(<span class=\"built_in\">NSError</span> * __autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> responseIsValid = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *validationError = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response &amp;&amp; [response isKindOfClass:[<span class=\"built_in\">NSHTTPURLResponse</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.acceptableContentTypes &amp;&amp; ![<span class=\"keyword\">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class=\"line\">            !([response MIMEType] == <span class=\"literal\">nil</span> &amp;&amp; [data length] == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//......</span></span><br><span class=\"line\">            responseIsValid = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//......</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> responseIsValid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到它确实有在判断接收到的 MIME type 是不是被包含在 acceptableContentTypes 里面的。由于我们刚才的添加，这里是可以被验证通过的，之前的思路肯定是正确的。就需要找到哪个地方产生了新问题。</p>\n<p>查看 <code>AFHTTPSessionManager</code> 的实现，可以看到这两个初始化方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)manager &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] alloc] initWithBaseURL:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithBaseURL:(<span class=\"built_in\">NSURL</span> *)url</span><br><span class=\"line\">           sessionConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithSessionConfiguration:configuration];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原来，在我们通过 <code>AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</code> 方法初始化 manager 的时候，它的 responseSerializer 就被设置成了 <code>AFJSONResponseSerializer</code> 。终于找到了问题的根源！</p>\n<p>当然，这种错误是由于我们的接口返回的不是 JSON 数据导致的。如果你的接口返回的是 JSON，那么问题应该在上一步就已经解决了。</p>\n<h2 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h2><p>我们只需要把 manager 的 responseSerializer 换掉就可以了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">manager.responseSerializer = [[AFHTTPResponseSerializer alloc] init];</span><br></pre></td></tr></table></figure>\n<p>使用 HTTPResponseSerializer，不需要它来解析 JSON。</p>\n<p>再次运行程序，就可以成功拿到数据了。</p>\n<hr>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p>腾讯云的 API 在签名时需要做 md5 / SHA-1 / HMAC - SHA1 等加密算法。正确可用的实现不太好找，故将这几种算法代码附在这里：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;CommonCrypto/CommonDigest.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;CommonCrypto/CommonHMAC.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span>*)sha1WithStr :(<span class=\"built_in\">NSString</span>*)string</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * test =string;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cstr = [test   cStringUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithBytes:cstr length:test.length];</span><br><span class=\"line\">    </span><br><span class=\"line\">    uint8_t digest[CC_SHA1_DIGEST_LENGTH];</span><br><span class=\"line\">    </span><br><span class=\"line\">    CC_SHA1(data.bytes, (<span class=\"keyword\">int</span>)data.length, digest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span>* output = [<span class=\"built_in\">NSMutableString</span> stringWithCapacity:CC_SHA1_DIGEST_LENGTH * <span class=\"number\">2</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; CC_SHA1_DIGEST_LENGTH; i++)</span><br><span class=\"line\">        [output appendFormat:<span class=\"string\">@\"%02x\"</span>, digest[i]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)hmac:(<span class=\"built_in\">NSString</span> *)plaintext withKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cKey  = [key cStringUsingEncoding:<span class=\"built_in\">NSASCIIStringEncoding</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cData = [plaintext cStringUsingEncoding:<span class=\"built_in\">NSASCIIStringEncoding</span>];</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> cHMAC[CC_SHA1_DIGEST_LENGTH];</span><br><span class=\"line\">    CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), cData, strlen(cData), cHMAC);</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *HMACData = [<span class=\"built_in\">NSData</span> dataWithBytes:cHMAC length:<span class=\"keyword\">sizeof</span>(cHMAC)];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buffer = (<span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)[HMACData bytes];</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *HMAC = [<span class=\"built_in\">NSMutableString</span> stringWithCapacity:HMACData.length * <span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; HMACData.length; ++i)&#123;</span><br><span class=\"line\">        [HMAC appendFormat:<span class=\"string\">@\"%02x\"</span>, buffer[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HMAC;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span>*)md5WithData:(<span class=\"built_in\">NSData</span> *)data&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> result[<span class=\"number\">16</span>];</span><br><span class=\"line\">    CC_MD5( data.bytes, (CC_LONG)data.length, result ); <span class=\"comment\">// This is the md5 call</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:</span><br><span class=\"line\">            <span class=\"string\">@\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\"</span>,</span><br><span class=\"line\">            result[<span class=\"number\">0</span>], result[<span class=\"number\">1</span>], result[<span class=\"number\">2</span>], result[<span class=\"number\">3</span>],</span><br><span class=\"line\">            result[<span class=\"number\">4</span>], result[<span class=\"number\">5</span>], result[<span class=\"number\">6</span>], result[<span class=\"number\">7</span>],</span><br><span class=\"line\">            result[<span class=\"number\">8</span>], result[<span class=\"number\">9</span>], result[<span class=\"number\">10</span>], result[<span class=\"number\">11</span>],</span><br><span class=\"line\">            result[<span class=\"number\">12</span>], result[<span class=\"number\">13</span>], result[<span class=\"number\">14</span>], result[<span class=\"number\">15</span>]</span><br><span class=\"line\">            ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"解决-Unacceptable-Content-Type\"><a href=\"#解决-Unacceptable-Content-Type\" class=\"headerlink\" title=\"解决 Unacceptable Content-Type\"></a>解决 Unacceptable Content-Type</h1><p>最近在通过 API 的形式访问腾讯云的 <a href=\"https://cloud.tencent.com/product/cos\">COS 服务</a>时，一直请求失败。通过 <code>po error</code> 命令打印出 AFNetworking 回调方法中的 NSError 对象，控制台输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lldb)po error</span><br><span class=\"line\">Error Domain=com.alamofire.error.serialization.response Code=-1016 &quot;Request failed: unacceptable content-type: application/x-www-form-urlencoded&quot; UserInfo=&#123;NSLocalizedDescription=Request failed: unacceptable content-type: application/x-www-form-urlencoded, NSErrorFailingURLKey=https://my.url, com.alamofire.serialization.response.error.data=&lt;mydata&gt;, com.alamofire.serialization.response.error.response=&lt;NSHTTPURLResponse: 0x608000037600&gt; &#123; URL: https://my.url &#125; &#123; Status Code: 200, Headers &#123;</span><br><span class=\"line\">\t//......</span><br><span class=\"line\">    &quot;Content-Type&quot; =     (</span><br><span class=\"line\">        &quot;application/x-www-form-urlencoded&quot;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    Server =     (</span><br><span class=\"line\">        &quot;tencent-cos&quot;</span><br><span class=\"line\">    );</span><br><span class=\"line\">    //......</span><br><span class=\"line\">&#125; &#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>比较奇怪的一点是，可以看到腾讯云返回的 Status Code 是 200，而且如果查看 error 的 userinfo 信息 <code>error.userInfo[@&quot;com.alamofire.serialization.response.error.data&quot;]</code> ，是可以看到返回的 HTTP Body 信息的。这说明我们的请求是成功了的，毕竟正确的数据已经返回了，只是 AFNetworking 认为失败了。</p>\n<h2 id=\"错误原因\"><a href=\"#错误原因\" class=\"headerlink\" title=\"错误原因\"></a>错误原因</h2><p>根据报错信息，可以看到错误的原因是 <code>unacceptable content-type: application/x-www-form-urlencoded</code> 。也就是腾讯云返回给我们的 content type 并不能被 AFNetworking 解析。而事实上这个接口中，返回的 body 信息本身就是我们需要的二进制数据，并不需要解析。因此要解决这个问题，只需要让 AFNetworking 不认为这是个错误就可以了，思路就是让它认为 <code>application/x-www-form-urlencoded</code> 是可以接受的。</p>\n<h2 id=\"添加-Content-Type\"><a href=\"#添加-Content-Type\" class=\"headerlink\" title=\"添加 Content-Type\"></a>添加 Content-Type</h2><p>最直接的想法，就是我们取出 AFNetworking 支持的 content-type 集合，再把腾讯云的这个值添加进去：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">NSMutableSet</span> *set = [manager.responseSerializer.acceptableContentTypes mutableCopy];</span><br><span class=\"line\">[set addObject:<span class=\"string\">@\"application/x-www-form-urlencoded\"</span>];</span><br><span class=\"line\">manager.responseSerializer.acceptableContentTypes = [set <span class=\"keyword\">copy</span>];</span><br></pre></td></tr></table></figure>\n<p>再次运行，果然不再报错说不接受 content-type 了，而是换了个新的错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Error Domain=NSCocoaErrorDomain Code=3840 &quot;JSON text did not start with array or object and option to allow fragments not set.&quot; UserInfo=&#123;NSDebugDescription=JSON text did not start with array or object and option to allow fragments not set.&#125;</span><br></pre></td></tr></table></figure>\n<p>新的错误信息提示我们 JSON 格式不正确。但是，腾讯云的这个接口并不会返回结构化的数据，body 里面只是二进制数据。而且，就算要返回被编码的信息，也是 XML 的，并不是 JSON。如果 AFNetworking 以 JSON 的格式去解析，当然会产生错误。</p>\n<p>要解决这个问题，靠直觉就不够了，需要看看 AFNetworking 的源码。</p>\n<h2 id=\"寻找问题根源\"><a href=\"#寻找问题根源\" class=\"headerlink\" title=\"寻找问题根源\"></a>寻找问题根源</h2><p>我们跳转到 <code>acceptableContentTypes</code> 的定义中，在 <code>AFURLResponseSerialization.m</code> 文件中，可以看到这样一个函数：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">BOOL</span>)validateResponse:(<span class=\"built_in\">NSHTTPURLResponse</span> *)response</span><br><span class=\"line\">                    data:(<span class=\"built_in\">NSData</span> *)data</span><br><span class=\"line\">                   error:(<span class=\"built_in\">NSError</span> * __autoreleasing *)error</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">BOOL</span> responseIsValid = <span class=\"literal\">YES</span>;</span><br><span class=\"line\">    <span class=\"built_in\">NSError</span> *validationError = <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (response &amp;&amp; [response isKindOfClass:[<span class=\"built_in\">NSHTTPURLResponse</span> <span class=\"keyword\">class</span>]]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">self</span>.acceptableContentTypes &amp;&amp; ![<span class=\"keyword\">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class=\"line\">            !([response MIMEType] == <span class=\"literal\">nil</span> &amp;&amp; [data length] == <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//......</span></span><br><span class=\"line\">            responseIsValid = <span class=\"literal\">NO</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//......</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> responseIsValid;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到它确实有在判断接收到的 MIME type 是不是被包含在 acceptableContentTypes 里面的。由于我们刚才的添加，这里是可以被验证通过的，之前的思路肯定是正确的。就需要找到哪个地方产生了新问题。</p>\n<p>查看 <code>AFHTTPSessionManager</code> 的实现，可以看到这两个初始化方法：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+ (<span class=\"keyword\">instancetype</span>)manager &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [[[<span class=\"keyword\">self</span> <span class=\"keyword\">class</span>] alloc] initWithBaseURL:<span class=\"literal\">nil</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"keyword\">instancetype</span>)initWithBaseURL:(<span class=\"built_in\">NSURL</span> *)url</span><br><span class=\"line\">           sessionConfiguration:(<span class=\"built_in\">NSURLSessionConfiguration</span> *)configuration</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span> = [<span class=\"keyword\">super</span> initWithSessionConfiguration:configuration];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">self</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>原来，在我们通过 <code>AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</code> 方法初始化 manager 的时候，它的 responseSerializer 就被设置成了 <code>AFJSONResponseSerializer</code> 。终于找到了问题的根源！</p>\n<p>当然，这种错误是由于我们的接口返回的不是 JSON 数据导致的。如果你的接口返回的是 JSON，那么问题应该在上一步就已经解决了。</p>\n<h2 id=\"解决问题\"><a href=\"#解决问题\" class=\"headerlink\" title=\"解决问题\"></a>解决问题</h2><p>我们只需要把 manager 的 responseSerializer 换掉就可以了：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">manager.responseSerializer = [[AFHTTPResponseSerializer alloc] init];</span><br></pre></td></tr></table></figure>\n<p>使用 HTTPResponseSerializer，不需要它来解析 JSON。</p>\n<p>再次运行程序，就可以成功拿到数据了。</p>\n<hr>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><p>腾讯云的 API 在签名时需要做 md5 / SHA-1 / HMAC - SHA1 等加密算法。正确可用的实现不太好找，故将这几种算法代码附在这里：</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;CommonCrypto/CommonDigest.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#import <span class=\"meta-string\">&lt;CommonCrypto/CommonHMAC.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span>*)sha1WithStr :(<span class=\"built_in\">NSString</span>*)string</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSString</span> * test =string;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cstr = [test   cStringUsingEncoding:<span class=\"built_in\">NSUTF8StringEncoding</span>];</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *data = [<span class=\"built_in\">NSData</span> dataWithBytes:cstr length:test.length];</span><br><span class=\"line\">    </span><br><span class=\"line\">    uint8_t digest[CC_SHA1_DIGEST_LENGTH];</span><br><span class=\"line\">    </span><br><span class=\"line\">    CC_SHA1(data.bytes, (<span class=\"keyword\">int</span>)data.length, digest);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span>* output = [<span class=\"built_in\">NSMutableString</span> stringWithCapacity:CC_SHA1_DIGEST_LENGTH * <span class=\"number\">2</span>];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; CC_SHA1_DIGEST_LENGTH; i++)</span><br><span class=\"line\">        [output appendFormat:<span class=\"string\">@\"%02x\"</span>, digest[i]];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span> *)hmac:(<span class=\"built_in\">NSString</span> *)plaintext withKey:(<span class=\"built_in\">NSString</span> *)key</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cKey  = [key cStringUsingEncoding:<span class=\"built_in\">NSASCIIStringEncoding</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *cData = [plaintext cStringUsingEncoding:<span class=\"built_in\">NSASCIIStringEncoding</span>];</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> cHMAC[CC_SHA1_DIGEST_LENGTH];</span><br><span class=\"line\">    CCHmac(kCCHmacAlgSHA1, cKey, strlen(cKey), cData, strlen(cData), cHMAC);</span><br><span class=\"line\">    <span class=\"built_in\">NSData</span> *HMACData = [<span class=\"built_in\">NSData</span> dataWithBytes:cHMAC length:<span class=\"keyword\">sizeof</span>(cHMAC)];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *buffer = (<span class=\"keyword\">const</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> *)[HMACData bytes];</span><br><span class=\"line\">    <span class=\"built_in\">NSMutableString</span> *HMAC = [<span class=\"built_in\">NSMutableString</span> stringWithCapacity:HMACData.length * <span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; HMACData.length; ++i)&#123;</span><br><span class=\"line\">        [HMAC appendFormat:<span class=\"string\">@\"%02x\"</span>, buffer[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HMAC;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">- (<span class=\"built_in\">NSString</span>*)md5WithData:(<span class=\"built_in\">NSData</span> *)data&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> result[<span class=\"number\">16</span>];</span><br><span class=\"line\">    CC_MD5( data.bytes, (CC_LONG)data.length, result ); <span class=\"comment\">// This is the md5 call</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> [<span class=\"built_in\">NSString</span> stringWithFormat:</span><br><span class=\"line\">            <span class=\"string\">@\"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\"</span>,</span><br><span class=\"line\">            result[<span class=\"number\">0</span>], result[<span class=\"number\">1</span>], result[<span class=\"number\">2</span>], result[<span class=\"number\">3</span>],</span><br><span class=\"line\">            result[<span class=\"number\">4</span>], result[<span class=\"number\">5</span>], result[<span class=\"number\">6</span>], result[<span class=\"number\">7</span>],</span><br><span class=\"line\">            result[<span class=\"number\">8</span>], result[<span class=\"number\">9</span>], result[<span class=\"number\">10</span>], result[<span class=\"number\">11</span>],</span><br><span class=\"line\">            result[<span class=\"number\">12</span>], result[<span class=\"number\">13</span>], result[<span class=\"number\">14</span>], result[<span class=\"number\">15</span>]</span><br><span class=\"line\">            ];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"让Xcode控制台打印彩色文字","date":"2018-06-15T11:53:30.000Z","_content":"\n# 让 Xcode 控制台打印彩色文字\n\n让控制台打印彩色文字可以帮助我们更清晰地调试程序，但 Xcode 本身是不支持这一特性的。我们需要借助 XcodeColors 这款插件。\n\n### 安装插件\n\n去 Github 上找到 [XcodeColors](https://github.com/robbiehanson/XcodeColors) 并把项目下载下来。用 Xcode 把工程打开，run 一下 XcodeColors target，插件就会自动被安装好。这个时候重启 Xcode，把 target 切换到 TestXcodeColors，再 run 一次来测试插件是否被成功安装了。这个时候我们会发现并没有打印出来带有颜色的信息，而是打印了许多掺杂了转义字符的字符串。虽然尝试没有成功，但我们得以知道它的原理就是利用转义字符来确定字符串的颜色，所以我们后续的使用中只要向字符串中也添加上这些转义字符，就可以控制打印的颜色了。\n\n### 让插件可用\n\n由于之前曾经出现过有人利用 Xcode 插件添加恶意代码的行为，苹果自 Xcode8 起，就禁用了第三方插件功能。如果一定要用的话，就需要利用一些工具手动打开。这个过程较为繁琐，也可能会导致 Xcode 不安全。不过我们可以用 update_xcode_plugins 工具来简化流程。\n\n首先要升级一下 ruby 环境：\n\n```shell\ncurl -L https://get.rvm.io | bash -s stable\n```\n\n之后列出最新的 ruby 版本：\n\n```shell\nrvm list known\n```\n\n在列表中，可以看到当前最新的 ruby 版本是 2.4.1。接下来安装该版本的 ruby：\n\n```shell\nrvm install 2.4.1\n```\n\n成功后，通过 Gem 安装 update_xcode_plugins：\n\n```shell\nsudo gem install update_xcode_plugins\n```\n\n之后就可以更新已经安装过的插件了。虽然之前的插件不能运行，但其实是已经安装成功了的：\n\n```shell\nupdate_xcode_plugins\n```\n\n最后，解除掉 Xcode 的签名：\n\n```shell\nupdate_xcode_plugins --unsign\n```\n\n这可能会导致 Xcode 没有办法进行上架操作。需要上架时，应当恢复 Xcode 的签名(未尝试)：\n\n```shell\nupdate_xcode_plugins --restore\n```\n\n这个时候再重启 Xcode，就会询问师傅哦加载插件包，选择 Load Bundle 即可。\n\n### 使用\n\n先打开 XcodeColors：\n\n```objective-c\nsetenv(\"XcodeColors\", \"YES\", 0);\n```\n\n然后可以定义一些宏来帮助我们打印颜色信息：\n\n```objective-c\n#define XCODE_COLORS_ESCAPE @\"\\033[\"\n#define XCODE_COLORS_RESET     XCODE_COLORS_ESCAPE @\";\"\n#define LogRed(frmt, ...) NSLog((XCODE_COLORS_ESCAPE @\"fg255,0,0;\" frmt XCODE_COLORS_RESET), ##__VA_ARGS__)\n```\n\n就可以像 NSLog 一样使用了：\n\n```objective-c\nLogRed(@\"Sprocket error: %@\", error);\n```\n\n我们可以看到，控制台打印的文字颜色变为红色了。\n\n### 最后\n\n虽然打印带有颜色的信息会非常清晰，但我们可以看到，第一非常麻烦，尤其是上架时还需要把 Xcode 签名恢复。二是这会带来安全风险，之前正是由于 XcodeGhost 等事件才让苹果封杀第三方插件的。总体来说，并不推荐这么做。\n\n","source":"_posts/让Xcode控制台打印彩色文字.md","raw":"---\ntitle: 让Xcode控制台打印彩色文字\ndate: 2018-06-15 19:53:30\ntags: Xcode\n---\n\n# 让 Xcode 控制台打印彩色文字\n\n让控制台打印彩色文字可以帮助我们更清晰地调试程序，但 Xcode 本身是不支持这一特性的。我们需要借助 XcodeColors 这款插件。\n\n### 安装插件\n\n去 Github 上找到 [XcodeColors](https://github.com/robbiehanson/XcodeColors) 并把项目下载下来。用 Xcode 把工程打开，run 一下 XcodeColors target，插件就会自动被安装好。这个时候重启 Xcode，把 target 切换到 TestXcodeColors，再 run 一次来测试插件是否被成功安装了。这个时候我们会发现并没有打印出来带有颜色的信息，而是打印了许多掺杂了转义字符的字符串。虽然尝试没有成功，但我们得以知道它的原理就是利用转义字符来确定字符串的颜色，所以我们后续的使用中只要向字符串中也添加上这些转义字符，就可以控制打印的颜色了。\n\n### 让插件可用\n\n由于之前曾经出现过有人利用 Xcode 插件添加恶意代码的行为，苹果自 Xcode8 起，就禁用了第三方插件功能。如果一定要用的话，就需要利用一些工具手动打开。这个过程较为繁琐，也可能会导致 Xcode 不安全。不过我们可以用 update_xcode_plugins 工具来简化流程。\n\n首先要升级一下 ruby 环境：\n\n```shell\ncurl -L https://get.rvm.io | bash -s stable\n```\n\n之后列出最新的 ruby 版本：\n\n```shell\nrvm list known\n```\n\n在列表中，可以看到当前最新的 ruby 版本是 2.4.1。接下来安装该版本的 ruby：\n\n```shell\nrvm install 2.4.1\n```\n\n成功后，通过 Gem 安装 update_xcode_plugins：\n\n```shell\nsudo gem install update_xcode_plugins\n```\n\n之后就可以更新已经安装过的插件了。虽然之前的插件不能运行，但其实是已经安装成功了的：\n\n```shell\nupdate_xcode_plugins\n```\n\n最后，解除掉 Xcode 的签名：\n\n```shell\nupdate_xcode_plugins --unsign\n```\n\n这可能会导致 Xcode 没有办法进行上架操作。需要上架时，应当恢复 Xcode 的签名(未尝试)：\n\n```shell\nupdate_xcode_plugins --restore\n```\n\n这个时候再重启 Xcode，就会询问师傅哦加载插件包，选择 Load Bundle 即可。\n\n### 使用\n\n先打开 XcodeColors：\n\n```objective-c\nsetenv(\"XcodeColors\", \"YES\", 0);\n```\n\n然后可以定义一些宏来帮助我们打印颜色信息：\n\n```objective-c\n#define XCODE_COLORS_ESCAPE @\"\\033[\"\n#define XCODE_COLORS_RESET     XCODE_COLORS_ESCAPE @\";\"\n#define LogRed(frmt, ...) NSLog((XCODE_COLORS_ESCAPE @\"fg255,0,0;\" frmt XCODE_COLORS_RESET), ##__VA_ARGS__)\n```\n\n就可以像 NSLog 一样使用了：\n\n```objective-c\nLogRed(@\"Sprocket error: %@\", error);\n```\n\n我们可以看到，控制台打印的文字颜色变为红色了。\n\n### 最后\n\n虽然打印带有颜色的信息会非常清晰，但我们可以看到，第一非常麻烦，尤其是上架时还需要把 Xcode 签名恢复。二是这会带来安全风险，之前正是由于 XcodeGhost 等事件才让苹果封杀第三方插件的。总体来说，并不推荐这么做。\n\n","slug":"让Xcode控制台打印彩色文字","published":1,"updated":"2020-01-04T08:16:16.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3j001rljc3rba002ky","content":"<h1 id=\"让-Xcode-控制台打印彩色文字\"><a href=\"#让-Xcode-控制台打印彩色文字\" class=\"headerlink\" title=\"让 Xcode 控制台打印彩色文字\"></a>让 Xcode 控制台打印彩色文字</h1><p>让控制台打印彩色文字可以帮助我们更清晰地调试程序，但 Xcode 本身是不支持这一特性的。我们需要借助 XcodeColors 这款插件。</p>\n<h3 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h3><p>去 Github 上找到 <a href=\"https://github.com/robbiehanson/XcodeColors\">XcodeColors</a> 并把项目下载下来。用 Xcode 把工程打开，run 一下 XcodeColors target，插件就会自动被安装好。这个时候重启 Xcode，把 target 切换到 TestXcodeColors，再 run 一次来测试插件是否被成功安装了。这个时候我们会发现并没有打印出来带有颜色的信息，而是打印了许多掺杂了转义字符的字符串。虽然尝试没有成功，但我们得以知道它的原理就是利用转义字符来确定字符串的颜色，所以我们后续的使用中只要向字符串中也添加上这些转义字符，就可以控制打印的颜色了。</p>\n<h3 id=\"让插件可用\"><a href=\"#让插件可用\" class=\"headerlink\" title=\"让插件可用\"></a>让插件可用</h3><p>由于之前曾经出现过有人利用 Xcode 插件添加恶意代码的行为，苹果自 Xcode8 起，就禁用了第三方插件功能。如果一定要用的话，就需要利用一些工具手动打开。这个过程较为繁琐，也可能会导致 Xcode 不安全。不过我们可以用 update_xcode_plugins 工具来简化流程。</p>\n<p>首先要升级一下 ruby 环境：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure>\n<p>之后列出最新的 ruby 版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm list known</span><br></pre></td></tr></table></figure>\n<p>在列表中，可以看到当前最新的 ruby 版本是 2.4.1。接下来安装该版本的 ruby：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.4.1</span><br></pre></td></tr></table></figure>\n<p>成功后，通过 Gem 安装 update_xcode_plugins：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install update_xcode_plugins</span><br></pre></td></tr></table></figure>\n<p>之后就可以更新已经安装过的插件了。虽然之前的插件不能运行，但其实是已经安装成功了的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update_xcode_plugins</span><br></pre></td></tr></table></figure>\n<p>最后，解除掉 Xcode 的签名：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update_xcode_plugins --unsign</span><br></pre></td></tr></table></figure>\n<p>这可能会导致 Xcode 没有办法进行上架操作。需要上架时，应当恢复 Xcode 的签名(未尝试)：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update_xcode_plugins --restore</span><br></pre></td></tr></table></figure>\n<p>这个时候再重启 Xcode，就会询问师傅哦加载插件包，选择 Load Bundle 即可。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>先打开 XcodeColors：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setenv(&quot;XcodeColors&quot;, &quot;YES&quot;, 0);</span><br></pre></td></tr></table></figure>\n<p>然后可以定义一些宏来帮助我们打印颜色信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define XCODE_COLORS_ESCAPE @&quot;\\033[&quot;</span><br><span class=\"line\">#define XCODE_COLORS_RESET     XCODE_COLORS_ESCAPE @&quot;;&quot;</span><br><span class=\"line\">#define LogRed(frmt, ...) NSLog((XCODE_COLORS_ESCAPE @&quot;fg255,0,0;&quot; frmt XCODE_COLORS_RESET), ##__VA_ARGS__)</span><br></pre></td></tr></table></figure>\n<p>就可以像 NSLog 一样使用了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogRed(@&quot;Sprocket error: %@&quot;, error);</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，控制台打印的文字颜色变为红色了。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>虽然打印带有颜色的信息会非常清晰，但我们可以看到，第一非常麻烦，尤其是上架时还需要把 Xcode 签名恢复。二是这会带来安全风险，之前正是由于 XcodeGhost 等事件才让苹果封杀第三方插件的。总体来说，并不推荐这么做。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"让-Xcode-控制台打印彩色文字\"><a href=\"#让-Xcode-控制台打印彩色文字\" class=\"headerlink\" title=\"让 Xcode 控制台打印彩色文字\"></a>让 Xcode 控制台打印彩色文字</h1><p>让控制台打印彩色文字可以帮助我们更清晰地调试程序，但 Xcode 本身是不支持这一特性的。我们需要借助 XcodeColors 这款插件。</p>\n<h3 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h3><p>去 Github 上找到 <a href=\"https://github.com/robbiehanson/XcodeColors\">XcodeColors</a> 并把项目下载下来。用 Xcode 把工程打开，run 一下 XcodeColors target，插件就会自动被安装好。这个时候重启 Xcode，把 target 切换到 TestXcodeColors，再 run 一次来测试插件是否被成功安装了。这个时候我们会发现并没有打印出来带有颜色的信息，而是打印了许多掺杂了转义字符的字符串。虽然尝试没有成功，但我们得以知道它的原理就是利用转义字符来确定字符串的颜色，所以我们后续的使用中只要向字符串中也添加上这些转义字符，就可以控制打印的颜色了。</p>\n<h3 id=\"让插件可用\"><a href=\"#让插件可用\" class=\"headerlink\" title=\"让插件可用\"></a>让插件可用</h3><p>由于之前曾经出现过有人利用 Xcode 插件添加恶意代码的行为，苹果自 Xcode8 起，就禁用了第三方插件功能。如果一定要用的话，就需要利用一些工具手动打开。这个过程较为繁琐，也可能会导致 Xcode 不安全。不过我们可以用 update_xcode_plugins 工具来简化流程。</p>\n<p>首先要升级一下 ruby 环境：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -L https://get.rvm.io | bash -s stable</span><br></pre></td></tr></table></figure>\n<p>之后列出最新的 ruby 版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm list known</span><br></pre></td></tr></table></figure>\n<p>在列表中，可以看到当前最新的 ruby 版本是 2.4.1。接下来安装该版本的 ruby：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rvm install 2.4.1</span><br></pre></td></tr></table></figure>\n<p>成功后，通过 Gem 安装 update_xcode_plugins：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gem install update_xcode_plugins</span><br></pre></td></tr></table></figure>\n<p>之后就可以更新已经安装过的插件了。虽然之前的插件不能运行，但其实是已经安装成功了的：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update_xcode_plugins</span><br></pre></td></tr></table></figure>\n<p>最后，解除掉 Xcode 的签名：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update_xcode_plugins --unsign</span><br></pre></td></tr></table></figure>\n<p>这可能会导致 Xcode 没有办法进行上架操作。需要上架时，应当恢复 Xcode 的签名(未尝试)：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update_xcode_plugins --restore</span><br></pre></td></tr></table></figure>\n<p>这个时候再重启 Xcode，就会询问师傅哦加载插件包，选择 Load Bundle 即可。</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>先打开 XcodeColors：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setenv(&quot;XcodeColors&quot;, &quot;YES&quot;, 0);</span><br></pre></td></tr></table></figure>\n<p>然后可以定义一些宏来帮助我们打印颜色信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define XCODE_COLORS_ESCAPE @&quot;\\033[&quot;</span><br><span class=\"line\">#define XCODE_COLORS_RESET     XCODE_COLORS_ESCAPE @&quot;;&quot;</span><br><span class=\"line\">#define LogRed(frmt, ...) NSLog((XCODE_COLORS_ESCAPE @&quot;fg255,0,0;&quot; frmt XCODE_COLORS_RESET), ##__VA_ARGS__)</span><br></pre></td></tr></table></figure>\n<p>就可以像 NSLog 一样使用了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogRed(@&quot;Sprocket error: %@&quot;, error);</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，控制台打印的文字颜色变为红色了。</p>\n<h3 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h3><p>虽然打印带有颜色的信息会非常清晰，但我们可以看到，第一非常麻烦，尤其是上架时还需要把 Xcode 签名恢复。二是这会带来安全风险，之前正是由于 XcodeGhost 等事件才让苹果封杀第三方插件的。总体来说，并不推荐这么做。</p>\n"},{"title":"设计模式-创建型模式","date":"2018-05-16T09:37:31.000Z","_content":"\n# 设计模式-创建型模式\n\n### 对象模版模式\n\n对象模版模式是最简单的一种设计模式，即使用类和结构体创建对象，而不是使用零散的变量、变量数组或元组来保存信息。使用对象模版模式可以将数据与操作数据的方法封装在一起，从而隐藏接口的内部实现，松散耦合。\n\n### 原型模式\n\n原型模式是指用已有的对象作为原型，通过克隆的方式来创建新的对象，而不是通过初始化函数。这样可以将创建对象的代码隐藏，无需知道创建新的对象需要用到哪些类或结构体。当初始化的开销很大，或是想要降低对模版的依赖时，就可以使用此模式。\n\n当使用值类型时，Swift 会自动使用原型模式。而当我们使用引用类型时，就需要让类继承 NSObject 并遵循 NSCopying 协议，实现其中的 `copyWithZone` 方法来定义如何复制对象。需要注意在复制对象时使用深拷贝还是浅拷贝。\n\n### 单例模式\n\n单例模式可以确保某个类型的对象在应用程序中只出现一个实例。单例模式的实现与所使用的语言密切相关。\n\n在 Swift 中，可以使用全局常量来实现单例模式：\n\n```swift\n//Logger.swift\nlet globalLogger = Logger()\nfinal class Logger {\n    fileprivate init() {\n        //required to stop instances being created by code in other files.\n    }\n    //...\n}\n```\n\nSwift 的全局常量是惰性初始化的，且能保证线程安全。只有在第一次访问全局常量时才会初始化，且只初始化一次。即使在另外的线程中读取，也只会创建一个实例。\n\n我们使用 final 关键字来修饰类，来防止子类的创建。把 init 函数前面加上 fileprivate 来阻止 Logger.swift 以外的地方的代码来创建实例。通过 let 关键字来声明对象，可以防止引用的指向被修改。这样就实现了一个单例。\n\n当然还有更简单的实现方法：\n\n```swift\nfinal class Logger {\n    static let sharedLogger = Logger()\n    private init() {}\n}\n```\n\nCocoa 中许多地方都使用了单例模式，比如 UIApplication 的 sharedApplication。\n\n### 对象池模式\n\n对象池模式是单例模式的一种变体，不同的是它提供了多个完全相同的对象，而非单个对象。使用时应该从对象池中取出对象，使用它完成任务后再归还给对象池。在归还以前，其他组件将不能使用它。\n\n举例来说明，图书馆中绝大多数书都不止一本，但是范围又是有限定的。创建或复制 Book 对象并不能使图书馆的藏书量真的增多，这个时候就应该使用对象池来管理图书。\n\n```swift\nclass Pool<T> {\n    private var data = [T]()\n    \n    init(items: [T]) {\n        for eachItem in items {\n            data.append(eachItem)\n        }\n    }\n    \n    func getFromPool() -> T? {\n        var result: T?\n        if data.count > 0 {\n            result = data.removeAtIndex(0)\n        }\n        return result\n    }\n    \n    func returnToPool(item: T) {\n        data.append(item)\n    }\n}\n```\n\n我们维护了一个队列来管理对象池。需要注意的是，如果程序中使用了多线程，则需要做好数据的保护。\n\nCocoa 中，UITableView 维护了一个 UITableViewCell 的对象池来节省内存开销。\n\n### 工厂方法模式\n\n当多个类遵循同一个协议，或是继承自同一个基类，而我们需要根据条件选择一个类来初始化对象时，就可以使用工厂方法模式。工厂方法模式同意了实现类的选取逻辑，从而避免了相关逻辑散布在整个程序中，调用组件无需了解实现类即选取实现类的过程。\n\n```swift\n//RentalCar.swift\nclass RentalCar {\n    fileprivate var name = \"\"\n    fileprivate var passengers = 0\n    \n    fileprivate init(name: String, passengers: Int) {\n        self.name = name\n        self.passengers = passengers\n    }\n    \n    final var name: String {\n        get { return name }\n    }\n    \n    final var passengers: Int {\n        get { return passengers }\n    }\n    \n    class func createRentalCar(passengers: Int) -> RentalCar? {\n        var car: RentalCar?\n        switch passengers {\n            case 0...3:\n            \tcar = Compact()\n            case 4...8:\n            \tcar = SUV()\n            default:\n            \tcar = nil\n        }\n        return car\n    }\n}\n\nclass Compact: RentalCar {\n    fileprivate init() {\n        super.init(name: \"Golf\", passengers: 3)\n    }\n}\n\nclass SUV: RentalCar {\n    fileprivate init() {\n        super.init(name: \"Range Rover\", passengers: 8)\n    }\n}\n\n//CarSelector.swift\nclass CarSelector {\n    class func selectCar(passengers: Int) -> String? {\n        return RentalCar.createRentalCar(passengers)?.name\n    }\n}\n```\n\n### 抽象工厂模式\n\n当调用组件需要一组互相协作的对象，又不需要关心这些对象的具体协作方式时，就可以使用抽象工厂模式。\n\n当调用抽象工厂去创建对象时，抽象工厂会检查请求，然后选择一个具体工厂，使用具体工厂创建对象并返回给调用组件。\n\n### 建造者模式\n\n建造者模式用于分离对象的创建和配置。调用组件负责提供配置对象的数据，把数据传给中间人建造者，建造者再去创建对象。这样调用者就无需过多掌握其使用的对象的信息，而默认配置可以集中放置在建造者中。如果创建对象需要进行复杂的配置，就可以使用这种模式。\n\n```swift\nclass Burger {\n    let pickles: Bool //泡菜\n    let mayo: Bool //蛋黄酱\n    let lettuce: Bool //生菜\n    let ketchup: Bool\n   \t\n    init(pickles: Bool, mayo: Bool, lettuce: Bool, ketchup: Bool) {\n        self.pickles = pickles\n        self.mayo = mayo\n        self.lettuce = lettuce\n        self.ketchup = ketchup\n    }\n}\n\nclass BurgerBuilder {\n    private var pickles = false\n    private var mayo = false\n    private var lettuce = true\n    private var ketchup = true\n    \n    func setPickles(choice: Bool) {\n        self.pickles = choice\n    }\n    \n    func setMayo(choice: Bool) {\n        self.mayo = choice\n    }\n    \n    func setLettuce(choice: Bool) {\n        self.lettuce = choice\n    }\n    \n    func setKetchup(choice: Bool) {\n        self.ketchup = choice\n    }\n    \n    func buildBurger() -> Burger {\n        return Burget(pickles: picklse, mayo: mayo, lettuce: lettuce, ketchup: ketchup)\n    }\n}\n```\n\n","source":"_posts/设计模式-创建型模式.md","raw":"---\ntitle: 设计模式-创建型模式\ndate: 2018-05-16 17:37:31\ntags: DesignPattern\n---\n\n# 设计模式-创建型模式\n\n### 对象模版模式\n\n对象模版模式是最简单的一种设计模式，即使用类和结构体创建对象，而不是使用零散的变量、变量数组或元组来保存信息。使用对象模版模式可以将数据与操作数据的方法封装在一起，从而隐藏接口的内部实现，松散耦合。\n\n### 原型模式\n\n原型模式是指用已有的对象作为原型，通过克隆的方式来创建新的对象，而不是通过初始化函数。这样可以将创建对象的代码隐藏，无需知道创建新的对象需要用到哪些类或结构体。当初始化的开销很大，或是想要降低对模版的依赖时，就可以使用此模式。\n\n当使用值类型时，Swift 会自动使用原型模式。而当我们使用引用类型时，就需要让类继承 NSObject 并遵循 NSCopying 协议，实现其中的 `copyWithZone` 方法来定义如何复制对象。需要注意在复制对象时使用深拷贝还是浅拷贝。\n\n### 单例模式\n\n单例模式可以确保某个类型的对象在应用程序中只出现一个实例。单例模式的实现与所使用的语言密切相关。\n\n在 Swift 中，可以使用全局常量来实现单例模式：\n\n```swift\n//Logger.swift\nlet globalLogger = Logger()\nfinal class Logger {\n    fileprivate init() {\n        //required to stop instances being created by code in other files.\n    }\n    //...\n}\n```\n\nSwift 的全局常量是惰性初始化的，且能保证线程安全。只有在第一次访问全局常量时才会初始化，且只初始化一次。即使在另外的线程中读取，也只会创建一个实例。\n\n我们使用 final 关键字来修饰类，来防止子类的创建。把 init 函数前面加上 fileprivate 来阻止 Logger.swift 以外的地方的代码来创建实例。通过 let 关键字来声明对象，可以防止引用的指向被修改。这样就实现了一个单例。\n\n当然还有更简单的实现方法：\n\n```swift\nfinal class Logger {\n    static let sharedLogger = Logger()\n    private init() {}\n}\n```\n\nCocoa 中许多地方都使用了单例模式，比如 UIApplication 的 sharedApplication。\n\n### 对象池模式\n\n对象池模式是单例模式的一种变体，不同的是它提供了多个完全相同的对象，而非单个对象。使用时应该从对象池中取出对象，使用它完成任务后再归还给对象池。在归还以前，其他组件将不能使用它。\n\n举例来说明，图书馆中绝大多数书都不止一本，但是范围又是有限定的。创建或复制 Book 对象并不能使图书馆的藏书量真的增多，这个时候就应该使用对象池来管理图书。\n\n```swift\nclass Pool<T> {\n    private var data = [T]()\n    \n    init(items: [T]) {\n        for eachItem in items {\n            data.append(eachItem)\n        }\n    }\n    \n    func getFromPool() -> T? {\n        var result: T?\n        if data.count > 0 {\n            result = data.removeAtIndex(0)\n        }\n        return result\n    }\n    \n    func returnToPool(item: T) {\n        data.append(item)\n    }\n}\n```\n\n我们维护了一个队列来管理对象池。需要注意的是，如果程序中使用了多线程，则需要做好数据的保护。\n\nCocoa 中，UITableView 维护了一个 UITableViewCell 的对象池来节省内存开销。\n\n### 工厂方法模式\n\n当多个类遵循同一个协议，或是继承自同一个基类，而我们需要根据条件选择一个类来初始化对象时，就可以使用工厂方法模式。工厂方法模式同意了实现类的选取逻辑，从而避免了相关逻辑散布在整个程序中，调用组件无需了解实现类即选取实现类的过程。\n\n```swift\n//RentalCar.swift\nclass RentalCar {\n    fileprivate var name = \"\"\n    fileprivate var passengers = 0\n    \n    fileprivate init(name: String, passengers: Int) {\n        self.name = name\n        self.passengers = passengers\n    }\n    \n    final var name: String {\n        get { return name }\n    }\n    \n    final var passengers: Int {\n        get { return passengers }\n    }\n    \n    class func createRentalCar(passengers: Int) -> RentalCar? {\n        var car: RentalCar?\n        switch passengers {\n            case 0...3:\n            \tcar = Compact()\n            case 4...8:\n            \tcar = SUV()\n            default:\n            \tcar = nil\n        }\n        return car\n    }\n}\n\nclass Compact: RentalCar {\n    fileprivate init() {\n        super.init(name: \"Golf\", passengers: 3)\n    }\n}\n\nclass SUV: RentalCar {\n    fileprivate init() {\n        super.init(name: \"Range Rover\", passengers: 8)\n    }\n}\n\n//CarSelector.swift\nclass CarSelector {\n    class func selectCar(passengers: Int) -> String? {\n        return RentalCar.createRentalCar(passengers)?.name\n    }\n}\n```\n\n### 抽象工厂模式\n\n当调用组件需要一组互相协作的对象，又不需要关心这些对象的具体协作方式时，就可以使用抽象工厂模式。\n\n当调用抽象工厂去创建对象时，抽象工厂会检查请求，然后选择一个具体工厂，使用具体工厂创建对象并返回给调用组件。\n\n### 建造者模式\n\n建造者模式用于分离对象的创建和配置。调用组件负责提供配置对象的数据，把数据传给中间人建造者，建造者再去创建对象。这样调用者就无需过多掌握其使用的对象的信息，而默认配置可以集中放置在建造者中。如果创建对象需要进行复杂的配置，就可以使用这种模式。\n\n```swift\nclass Burger {\n    let pickles: Bool //泡菜\n    let mayo: Bool //蛋黄酱\n    let lettuce: Bool //生菜\n    let ketchup: Bool\n   \t\n    init(pickles: Bool, mayo: Bool, lettuce: Bool, ketchup: Bool) {\n        self.pickles = pickles\n        self.mayo = mayo\n        self.lettuce = lettuce\n        self.ketchup = ketchup\n    }\n}\n\nclass BurgerBuilder {\n    private var pickles = false\n    private var mayo = false\n    private var lettuce = true\n    private var ketchup = true\n    \n    func setPickles(choice: Bool) {\n        self.pickles = choice\n    }\n    \n    func setMayo(choice: Bool) {\n        self.mayo = choice\n    }\n    \n    func setLettuce(choice: Bool) {\n        self.lettuce = choice\n    }\n    \n    func setKetchup(choice: Bool) {\n        self.ketchup = choice\n    }\n    \n    func buildBurger() -> Burger {\n        return Burget(pickles: picklse, mayo: mayo, lettuce: lettuce, ketchup: ketchup)\n    }\n}\n```\n\n","slug":"设计模式-创建型模式","published":1,"updated":"2020-01-04T08:16:16.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3j001tljc3owkqgcdl","content":"<h1 id=\"设计模式-创建型模式\"><a href=\"#设计模式-创建型模式\" class=\"headerlink\" title=\"设计模式-创建型模式\"></a>设计模式-创建型模式</h1><h3 id=\"对象模版模式\"><a href=\"#对象模版模式\" class=\"headerlink\" title=\"对象模版模式\"></a>对象模版模式</h3><p>对象模版模式是最简单的一种设计模式，即使用类和结构体创建对象，而不是使用零散的变量、变量数组或元组来保存信息。使用对象模版模式可以将数据与操作数据的方法封装在一起，从而隐藏接口的内部实现，松散耦合。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>原型模式是指用已有的对象作为原型，通过克隆的方式来创建新的对象，而不是通过初始化函数。这样可以将创建对象的代码隐藏，无需知道创建新的对象需要用到哪些类或结构体。当初始化的开销很大，或是想要降低对模版的依赖时，就可以使用此模式。</p>\n<p>当使用值类型时，Swift 会自动使用原型模式。而当我们使用引用类型时，就需要让类继承 NSObject 并遵循 NSCopying 协议，实现其中的 <code>copyWithZone</code> 方法来定义如何复制对象。需要注意在复制对象时使用深拷贝还是浅拷贝。</p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>单例模式可以确保某个类型的对象在应用程序中只出现一个实例。单例模式的实现与所使用的语言密切相关。</p>\n<p>在 Swift 中，可以使用全局常量来实现单例模式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Logger.swift</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> globalLogger = <span class=\"type\">Logger</span>()</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//required to stop instances being created by code in other files.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Swift 的全局常量是惰性初始化的，且能保证线程安全。只有在第一次访问全局常量时才会初始化，且只初始化一次。即使在另外的线程中读取，也只会创建一个实例。</p>\n<p>我们使用 final 关键字来修饰类，来防止子类的创建。把 init 函数前面加上 fileprivate 来阻止 Logger.swift 以外的地方的代码来创建实例。通过 let 关键字来声明对象，可以防止引用的指向被修改。这样就实现了一个单例。</p>\n<p>当然还有更简单的实现方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> sharedLogger = <span class=\"type\">Logger</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">init</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Cocoa 中许多地方都使用了单例模式，比如 UIApplication 的 sharedApplication。</p>\n<h3 id=\"对象池模式\"><a href=\"#对象池模式\" class=\"headerlink\" title=\"对象池模式\"></a>对象池模式</h3><p>对象池模式是单例模式的一种变体，不同的是它提供了多个完全相同的对象，而非单个对象。使用时应该从对象池中取出对象，使用它完成任务后再归还给对象池。在归还以前，其他组件将不能使用它。</p>\n<p>举例来说明，图书馆中绝大多数书都不止一本，但是范围又是有限定的。创建或复制 Book 对象并不能使图书馆的藏书量真的增多，这个时候就应该使用对象池来管理图书。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pool</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> data = [<span class=\"type\">T</span>]()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(items: [<span class=\"type\">T</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> eachItem <span class=\"keyword\">in</span> items &#123;</span><br><span class=\"line\">            data.append(eachItem)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFromPool</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">T?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result: <span class=\"type\">T?</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> data.<span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            result = data.removeAtIndex(<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">returnToPool</span><span class=\"params\">(item: T)</span></span> &#123;</span><br><span class=\"line\">        data.append(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们维护了一个队列来管理对象池。需要注意的是，如果程序中使用了多线程，则需要做好数据的保护。</p>\n<p>Cocoa 中，UITableView 维护了一个 UITableViewCell 的对象池来节省内存开销。</p>\n<h3 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h3><p>当多个类遵循同一个协议，或是继承自同一个基类，而我们需要根据条件选择一个类来初始化对象时，就可以使用工厂方法模式。工厂方法模式同意了实现类的选取逻辑，从而避免了相关逻辑散布在整个程序中，调用组件无需了解实现类即选取实现类的过程。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//RentalCar.swift</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RentalCar</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">var</span> name = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">var</span> passengers = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, passengers: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.passengers = passengers</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> name &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">var</span> passengers: <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> passengers &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">createRentalCar</span>(<span class=\"title\">passengers</span>: <span class=\"title\">Int</span>) -&gt; <span class=\"title\">RentalCar</span>? </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> car: <span class=\"type\">RentalCar?</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> passengers &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>...<span class=\"number\">3</span>:</span><br><span class=\"line\">            \tcar = <span class=\"type\">Compact</span>()</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>...<span class=\"number\">8</span>:</span><br><span class=\"line\">            \tcar = <span class=\"type\">SUV</span>()</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            \tcar = <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> car</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Compact</span>: <span class=\"title\">RentalCar</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: <span class=\"string\">\"Golf\"</span>, passengers: <span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SUV</span>: <span class=\"title\">RentalCar</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: <span class=\"string\">\"Range Rover\"</span>, passengers: <span class=\"number\">8</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//CarSelector.swift</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CarSelector</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">selectCar</span>(<span class=\"title\">passengers</span>: <span class=\"title\">Int</span>) -&gt; <span class=\"title\">String</span>? </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">RentalCar</span>.createRentalCar(passengers)?.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h3><p>当调用组件需要一组互相协作的对象，又不需要关心这些对象的具体协作方式时，就可以使用抽象工厂模式。</p>\n<p>当调用抽象工厂去创建对象时，抽象工厂会检查请求，然后选择一个具体工厂，使用具体工厂创建对象并返回给调用组件。</p>\n<h3 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h3><p>建造者模式用于分离对象的创建和配置。调用组件负责提供配置对象的数据，把数据传给中间人建造者，建造者再去创建对象。这样调用者就无需过多掌握其使用的对象的信息，而默认配置可以集中放置在建造者中。如果创建对象需要进行复杂的配置，就可以使用这种模式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Burger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickles: <span class=\"type\">Bool</span> <span class=\"comment\">//泡菜</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> mayo: <span class=\"type\">Bool</span> <span class=\"comment\">//蛋黄酱</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lettuce: <span class=\"type\">Bool</span> <span class=\"comment\">//生菜</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> ketchup: <span class=\"type\">Bool</span></span><br><span class=\"line\">   \t</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(pickles: <span class=\"type\">Bool</span>, mayo: <span class=\"type\">Bool</span>, lettuce: <span class=\"type\">Bool</span>, ketchup: <span class=\"type\">Bool</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pickles = pickles</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.mayo = mayo</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lettuce = lettuce</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ketchup = ketchup</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BurgerBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> pickles = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mayo = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> lettuce = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> ketchup = <span class=\"literal\">true</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setPickles</span><span class=\"params\">(choice: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pickles = choice</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setMayo</span><span class=\"params\">(choice: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.mayo = choice</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setLettuce</span><span class=\"params\">(choice: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lettuce = choice</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setKetchup</span><span class=\"params\">(choice: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ketchup = choice</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildBurger</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Burger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Burget</span>(pickles: picklse, mayo: mayo, lettuce: lettuce, ketchup: ketchup)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设计模式-创建型模式\"><a href=\"#设计模式-创建型模式\" class=\"headerlink\" title=\"设计模式-创建型模式\"></a>设计模式-创建型模式</h1><h3 id=\"对象模版模式\"><a href=\"#对象模版模式\" class=\"headerlink\" title=\"对象模版模式\"></a>对象模版模式</h3><p>对象模版模式是最简单的一种设计模式，即使用类和结构体创建对象，而不是使用零散的变量、变量数组或元组来保存信息。使用对象模版模式可以将数据与操作数据的方法封装在一起，从而隐藏接口的内部实现，松散耦合。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>原型模式是指用已有的对象作为原型，通过克隆的方式来创建新的对象，而不是通过初始化函数。这样可以将创建对象的代码隐藏，无需知道创建新的对象需要用到哪些类或结构体。当初始化的开销很大，或是想要降低对模版的依赖时，就可以使用此模式。</p>\n<p>当使用值类型时，Swift 会自动使用原型模式。而当我们使用引用类型时，就需要让类继承 NSObject 并遵循 NSCopying 协议，实现其中的 <code>copyWithZone</code> 方法来定义如何复制对象。需要注意在复制对象时使用深拷贝还是浅拷贝。</p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>单例模式可以确保某个类型的对象在应用程序中只出现一个实例。单例模式的实现与所使用的语言密切相关。</p>\n<p>在 Swift 中，可以使用全局常量来实现单例模式：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Logger.swift</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> globalLogger = <span class=\"type\">Logger</span>()</span><br><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">//required to stop instances being created by code in other files.</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Swift 的全局常量是惰性初始化的，且能保证线程安全。只有在第一次访问全局常量时才会初始化，且只初始化一次。即使在另外的线程中读取，也只会创建一个实例。</p>\n<p>我们使用 final 关键字来修饰类，来防止子类的创建。把 init 函数前面加上 fileprivate 来阻止 Logger.swift 以外的地方的代码来创建实例。通过 let 关键字来声明对象，可以防止引用的指向被修改。这样就实现了一个单例。</p>\n<p>当然还有更简单的实现方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">let</span> sharedLogger = <span class=\"type\">Logger</span>()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">init</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Cocoa 中许多地方都使用了单例模式，比如 UIApplication 的 sharedApplication。</p>\n<h3 id=\"对象池模式\"><a href=\"#对象池模式\" class=\"headerlink\" title=\"对象池模式\"></a>对象池模式</h3><p>对象池模式是单例模式的一种变体，不同的是它提供了多个完全相同的对象，而非单个对象。使用时应该从对象池中取出对象，使用它完成任务后再归还给对象池。在归还以前，其他组件将不能使用它。</p>\n<p>举例来说明，图书馆中绝大多数书都不止一本，但是范围又是有限定的。创建或复制 Book 对象并不能使图书馆的藏书量真的增多，这个时候就应该使用对象池来管理图书。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pool</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> data = [<span class=\"type\">T</span>]()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">init</span>(items: [<span class=\"type\">T</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> eachItem <span class=\"keyword\">in</span> items &#123;</span><br><span class=\"line\">            data.append(eachItem)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getFromPool</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">T?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result: <span class=\"type\">T?</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> data.<span class=\"built_in\">count</span> &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            result = data.removeAtIndex(<span class=\"number\">0</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">returnToPool</span><span class=\"params\">(item: T)</span></span> &#123;</span><br><span class=\"line\">        data.append(item)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们维护了一个队列来管理对象池。需要注意的是，如果程序中使用了多线程，则需要做好数据的保护。</p>\n<p>Cocoa 中，UITableView 维护了一个 UITableViewCell 的对象池来节省内存开销。</p>\n<h3 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h3><p>当多个类遵循同一个协议，或是继承自同一个基类，而我们需要根据条件选择一个类来初始化对象时，就可以使用工厂方法模式。工厂方法模式同意了实现类的选取逻辑，从而避免了相关逻辑散布在整个程序中，调用组件无需了解实现类即选取实现类的过程。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//RentalCar.swift</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RentalCar</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">var</span> name = <span class=\"string\">\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">var</span> passengers = <span class=\"number\">0</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">init</span>(name: <span class=\"type\">String</span>, passengers: <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.passengers = passengers</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> name &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">var</span> passengers: <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123; <span class=\"keyword\">return</span> passengers &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">createRentalCar</span>(<span class=\"title\">passengers</span>: <span class=\"title\">Int</span>) -&gt; <span class=\"title\">RentalCar</span>? </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> car: <span class=\"type\">RentalCar?</span></span><br><span class=\"line\">        <span class=\"keyword\">switch</span> passengers &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>...<span class=\"number\">3</span>:</span><br><span class=\"line\">            \tcar = <span class=\"type\">Compact</span>()</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>...<span class=\"number\">8</span>:</span><br><span class=\"line\">            \tcar = <span class=\"type\">SUV</span>()</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            \tcar = <span class=\"literal\">nil</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> car</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Compact</span>: <span class=\"title\">RentalCar</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: <span class=\"string\">\"Golf\"</span>, passengers: <span class=\"number\">3</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SUV</span>: <span class=\"title\">RentalCar</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">fileprivate</span> <span class=\"keyword\">init</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: <span class=\"string\">\"Range Rover\"</span>, passengers: <span class=\"number\">8</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//CarSelector.swift</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CarSelector</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">func</span> <span class=\"title\">selectCar</span>(<span class=\"title\">passengers</span>: <span class=\"title\">Int</span>) -&gt; <span class=\"title\">String</span>? </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">RentalCar</span>.createRentalCar(passengers)?.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h3><p>当调用组件需要一组互相协作的对象，又不需要关心这些对象的具体协作方式时，就可以使用抽象工厂模式。</p>\n<p>当调用抽象工厂去创建对象时，抽象工厂会检查请求，然后选择一个具体工厂，使用具体工厂创建对象并返回给调用组件。</p>\n<h3 id=\"建造者模式\"><a href=\"#建造者模式\" class=\"headerlink\" title=\"建造者模式\"></a>建造者模式</h3><p>建造者模式用于分离对象的创建和配置。调用组件负责提供配置对象的数据，把数据传给中间人建造者，建造者再去创建对象。这样调用者就无需过多掌握其使用的对象的信息，而默认配置可以集中放置在建造者中。如果创建对象需要进行复杂的配置，就可以使用这种模式。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Burger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pickles: <span class=\"type\">Bool</span> <span class=\"comment\">//泡菜</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> mayo: <span class=\"type\">Bool</span> <span class=\"comment\">//蛋黄酱</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> lettuce: <span class=\"type\">Bool</span> <span class=\"comment\">//生菜</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> ketchup: <span class=\"type\">Bool</span></span><br><span class=\"line\">   \t</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(pickles: <span class=\"type\">Bool</span>, mayo: <span class=\"type\">Bool</span>, lettuce: <span class=\"type\">Bool</span>, ketchup: <span class=\"type\">Bool</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pickles = pickles</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.mayo = mayo</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lettuce = lettuce</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ketchup = ketchup</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BurgerBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> pickles = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> mayo = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> lettuce = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> ketchup = <span class=\"literal\">true</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setPickles</span><span class=\"params\">(choice: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.pickles = choice</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setMayo</span><span class=\"params\">(choice: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.mayo = choice</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setLettuce</span><span class=\"params\">(choice: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.lettuce = choice</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">setKetchup</span><span class=\"params\">(choice: Bool)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.ketchup = choice</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">buildBurger</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Burger</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Burget</span>(pickles: picklse, mayo: mayo, lettuce: lettuce, ketchup: ketchup)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"调试JSCore小技巧","date":"2019-02-10T13:49:29.000Z","_content":"\n# 调试 JSCore 小技巧\n\n在编写 iOS 和 JavaScript 交互的代码时，调试起来实在令人头大。但其实有一个小技巧可以帮助我们调试：\n\n1. 打开 Safari，点击“开发”选项。如果没有顶部菜单栏没有开发选项，则先去“偏好设置”，“高级”中打开“显示开发菜单”。\n2. 选择“模拟器”，点击“自动显示 JSContext 的网页检查器”。\n3. 重新运行程序，检查器就会自动弹出来了。\n\n苹果爸爸太给力了！！","source":"_posts/调试JSCore小技巧.md","raw":"---\ntitle: 调试JSCore小技巧\ndate: 2019-02-10 21:49:29\ntags: JSCore\n---\n\n# 调试 JSCore 小技巧\n\n在编写 iOS 和 JavaScript 交互的代码时，调试起来实在令人头大。但其实有一个小技巧可以帮助我们调试：\n\n1. 打开 Safari，点击“开发”选项。如果没有顶部菜单栏没有开发选项，则先去“偏好设置”，“高级”中打开“显示开发菜单”。\n2. 选择“模拟器”，点击“自动显示 JSContext 的网页检查器”。\n3. 重新运行程序，检查器就会自动弹出来了。\n\n苹果爸爸太给力了！！","slug":"调试JSCore小技巧","published":1,"updated":"2020-01-04T08:16:16.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3k001wljc3yim1ftsm","content":"<h1 id=\"调试-JSCore-小技巧\"><a href=\"#调试-JSCore-小技巧\" class=\"headerlink\" title=\"调试 JSCore 小技巧\"></a>调试 JSCore 小技巧</h1><p>在编写 iOS 和 JavaScript 交互的代码时，调试起来实在令人头大。但其实有一个小技巧可以帮助我们调试：</p>\n<ol>\n<li>打开 Safari，点击“开发”选项。如果没有顶部菜单栏没有开发选项，则先去“偏好设置”，“高级”中打开“显示开发菜单”。</li>\n<li>选择“模拟器”，点击“自动显示 JSContext 的网页检查器”。</li>\n<li>重新运行程序，检查器就会自动弹出来了。</li>\n</ol>\n<p>苹果爸爸太给力了！！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"调试-JSCore-小技巧\"><a href=\"#调试-JSCore-小技巧\" class=\"headerlink\" title=\"调试 JSCore 小技巧\"></a>调试 JSCore 小技巧</h1><p>在编写 iOS 和 JavaScript 交互的代码时，调试起来实在令人头大。但其实有一个小技巧可以帮助我们调试：</p>\n<ol>\n<li>打开 Safari，点击“开发”选项。如果没有顶部菜单栏没有开发选项，则先去“偏好设置”，“高级”中打开“显示开发菜单”。</li>\n<li>选择“模拟器”，点击“自动显示 JSContext 的网页检查器”。</li>\n<li>重新运行程序，检查器就会自动弹出来了。</li>\n</ol>\n<p>苹果爸爸太给力了！！</p>\n"},{"title":"阿里一面凉了之旅","date":"2018-03-27T05:04:44.000Z","_content":"\n# 阿里一面凉了之旅\n\n昨天才投的阿里巴巴，要我做的测评和在线编程题还没做，今天居然就打电话来面试了！真是猝不及防。在听我bb了半天项目经验，又问了点其他的 iOS 知识之后，面试官说：“我们来考察一下编程的思想吧！”。我说：“来吧！”，然后，然后我就跪了。。。\n\n### 事情是这样的\n\n面试官：“这道题很常见，你之前也可能听说过。”\n\n我：“嗯，您说。”\n\n面试官：“给你 1、2、5 三种面值的硬币，凑成 10，一共有多少种组合？”\n\n我：“嗯。。。。我之前没听说过。。。。。让我想一下。。。。”\n\n于是我在脑海中抽象了一下**题目描述**：\n\n------\n\n现有面值分别为 $v_i$ 的 N 种硬币，需要凑成 V 元，每种硬币使用次数不限，求一共有多少种凑法？\n\n------\n\n我：“嗯。。。。最直观的想法就是暴力求解。。。”\n\n面试官：“怎么暴力求解呢？”\n\n我：“嗯。。。。估计要用到递归。。。”（内心OS：这样复杂度好高啊）\n\n面试官：“怎么递归呢？”\n\n我：“嗯。。。。每种硬币加加加，然后超过范围就退回到上一种状态。。。然后尝试下一种”（内心OS：复杂度好高！估计要用动态规划来优化下，咋搞呢）\n\n面试官：“能说一下代码会有哪些结构吗？”\n\n我：“\\*……&*@!@#)(&&)”（我也不知道我瞎说了些啥，反正答得很烂）\n\n再又聊了一点点别的东西之后，\n\n面试官：“好的，我会如实反映这次面试的情况。应该会在一周之内联系你，如果两周都没有联系你，那就不用再等了。”\n\n我（带着哭腔）：“好的我清楚了T^T”\n\n### 挂掉电话之后\n\n卧槽！这不就是一个动态规划吗！我咋这都没想出来！让我写一下代码！\n\n**思路：**\n\n我们需要数组 `T[i][j]` 表示用前 i 种硬币凑出 j 元时所有的组合数。\n\n逐步增加 j 至 V，计算 `T[i][j]` 的规则如下：\n\n遍历第 i 种硬币使用的个数，从 0（不使用）到不超过 V 的个数，记录为 k。当前硬币面值记为 v。\n\n​\t`T[i][j] += T[i-1][j-k*v]`\n\n也就是我们考虑第 i 种硬币使用 1 个、2 个、3 个的情况，每种情况的组合数分别对应不使用这种硬币时，减去这种硬币当前凑出的面值的组合数，做一个累加就可以了。\n\n**Java实现：**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        int[] C = {1,2,5};\n        System.out.println(getTotoalCombinationCount(C, 10));\n    }\n    static int getTotoalCombinationCount(int[] C, int value) {\n        int T[][] = new int[C.length+1][value+1];\n        for(int i=0; i<=C.length; i++) {\n            for(int j=0; j<=value; j++) {\n                if(j==0) {\n                    T[i][j] = 1;\n                } else {\n                    T[i][j] = 0;\n                }\n            }\n        }\n        for(int i=1; i<=C.length; i++) {\n            for(int j=1; j<=value; j++) {\n                int v = C[i-1];\n                for(int k=0; k*v <= j; k++) {\n                    T[i][j] += T[i - 1][j - k*v];\n                }\n            }\n        }\n        return T[C.length][value];\n    }\n}\n```\n\n需要注意的是，我们需要给二维数组 T 一个合适的初始值。当 j == 0 时，也就是需要凑成 0 元钱的时候，无论硬币有多少种，我们都有 1 种凑法：那就是不用凑。\n\n### 从这个故事我们学到了\n\n这道题确实很简单，而且又是我刚刚才学过的动态规划法。事实上我挂掉电话后用了不到半个小时就写出来了。也许是刚学过动态规划还不太熟练、也许是面试时太紧张、也许是面试过程中大脑傻掉了，反正答的很不好，还是自己太菜啊！面试官特意说两个星期内没收到后续结果就是凉了，估计是在暗示我真的凉了吧。。。我自己是感觉凉了。。\n\n痛定思痛吧！继续努力！为找到实习而奋斗！\n\n### 如果万一没凉……\n\n虽然概率趋近于 0，但如果万一我没凉，还收到了后续面试的通知的话……我就用阿里的支付宝给贫困山区的小朋友捐 10 块钱辣条钱！\n\n---\n\n**4.7 Update:**\n\n震惊！居然没凉！已捐款10元。","source":"_posts/阿里一面凉了之旅.md","raw":"---\ntitle: 阿里一面凉了之旅\ndate: 2018-03-27 13:04:44\ntags: Interview\n---\n\n# 阿里一面凉了之旅\n\n昨天才投的阿里巴巴，要我做的测评和在线编程题还没做，今天居然就打电话来面试了！真是猝不及防。在听我bb了半天项目经验，又问了点其他的 iOS 知识之后，面试官说：“我们来考察一下编程的思想吧！”。我说：“来吧！”，然后，然后我就跪了。。。\n\n### 事情是这样的\n\n面试官：“这道题很常见，你之前也可能听说过。”\n\n我：“嗯，您说。”\n\n面试官：“给你 1、2、5 三种面值的硬币，凑成 10，一共有多少种组合？”\n\n我：“嗯。。。。我之前没听说过。。。。。让我想一下。。。。”\n\n于是我在脑海中抽象了一下**题目描述**：\n\n------\n\n现有面值分别为 $v_i$ 的 N 种硬币，需要凑成 V 元，每种硬币使用次数不限，求一共有多少种凑法？\n\n------\n\n我：“嗯。。。。最直观的想法就是暴力求解。。。”\n\n面试官：“怎么暴力求解呢？”\n\n我：“嗯。。。。估计要用到递归。。。”（内心OS：这样复杂度好高啊）\n\n面试官：“怎么递归呢？”\n\n我：“嗯。。。。每种硬币加加加，然后超过范围就退回到上一种状态。。。然后尝试下一种”（内心OS：复杂度好高！估计要用动态规划来优化下，咋搞呢）\n\n面试官：“能说一下代码会有哪些结构吗？”\n\n我：“\\*……&*@!@#)(&&)”（我也不知道我瞎说了些啥，反正答得很烂）\n\n再又聊了一点点别的东西之后，\n\n面试官：“好的，我会如实反映这次面试的情况。应该会在一周之内联系你，如果两周都没有联系你，那就不用再等了。”\n\n我（带着哭腔）：“好的我清楚了T^T”\n\n### 挂掉电话之后\n\n卧槽！这不就是一个动态规划吗！我咋这都没想出来！让我写一下代码！\n\n**思路：**\n\n我们需要数组 `T[i][j]` 表示用前 i 种硬币凑出 j 元时所有的组合数。\n\n逐步增加 j 至 V，计算 `T[i][j]` 的规则如下：\n\n遍历第 i 种硬币使用的个数，从 0（不使用）到不超过 V 的个数，记录为 k。当前硬币面值记为 v。\n\n​\t`T[i][j] += T[i-1][j-k*v]`\n\n也就是我们考虑第 i 种硬币使用 1 个、2 个、3 个的情况，每种情况的组合数分别对应不使用这种硬币时，减去这种硬币当前凑出的面值的组合数，做一个累加就可以了。\n\n**Java实现：**\n\n```java\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        int[] C = {1,2,5};\n        System.out.println(getTotoalCombinationCount(C, 10));\n    }\n    static int getTotoalCombinationCount(int[] C, int value) {\n        int T[][] = new int[C.length+1][value+1];\n        for(int i=0; i<=C.length; i++) {\n            for(int j=0; j<=value; j++) {\n                if(j==0) {\n                    T[i][j] = 1;\n                } else {\n                    T[i][j] = 0;\n                }\n            }\n        }\n        for(int i=1; i<=C.length; i++) {\n            for(int j=1; j<=value; j++) {\n                int v = C[i-1];\n                for(int k=0; k*v <= j; k++) {\n                    T[i][j] += T[i - 1][j - k*v];\n                }\n            }\n        }\n        return T[C.length][value];\n    }\n}\n```\n\n需要注意的是，我们需要给二维数组 T 一个合适的初始值。当 j == 0 时，也就是需要凑成 0 元钱的时候，无论硬币有多少种，我们都有 1 种凑法：那就是不用凑。\n\n### 从这个故事我们学到了\n\n这道题确实很简单，而且又是我刚刚才学过的动态规划法。事实上我挂掉电话后用了不到半个小时就写出来了。也许是刚学过动态规划还不太熟练、也许是面试时太紧张、也许是面试过程中大脑傻掉了，反正答的很不好，还是自己太菜啊！面试官特意说两个星期内没收到后续结果就是凉了，估计是在暗示我真的凉了吧。。。我自己是感觉凉了。。\n\n痛定思痛吧！继续努力！为找到实习而奋斗！\n\n### 如果万一没凉……\n\n虽然概率趋近于 0，但如果万一我没凉，还收到了后续面试的通知的话……我就用阿里的支付宝给贫困山区的小朋友捐 10 块钱辣条钱！\n\n---\n\n**4.7 Update:**\n\n震惊！居然没凉！已捐款10元。","slug":"阿里一面凉了之旅","published":1,"updated":"2020-01-04T08:16:16.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3l001yljc3nkxqdmcj","content":"<h1 id=\"阿里一面凉了之旅\"><a href=\"#阿里一面凉了之旅\" class=\"headerlink\" title=\"阿里一面凉了之旅\"></a>阿里一面凉了之旅</h1><p>昨天才投的阿里巴巴，要我做的测评和在线编程题还没做，今天居然就打电话来面试了！真是猝不及防。在听我bb了半天项目经验，又问了点其他的 iOS 知识之后，面试官说：“我们来考察一下编程的思想吧！”。我说：“来吧！”，然后，然后我就跪了。。。</p>\n<h3 id=\"事情是这样的\"><a href=\"#事情是这样的\" class=\"headerlink\" title=\"事情是这样的\"></a>事情是这样的</h3><p>面试官：“这道题很常见，你之前也可能听说过。”</p>\n<p>我：“嗯，您说。”</p>\n<p>面试官：“给你 1、2、5 三种面值的硬币，凑成 10，一共有多少种组合？”</p>\n<p>我：“嗯。。。。我之前没听说过。。。。。让我想一下。。。。”</p>\n<p>于是我在脑海中抽象了一下<strong>题目描述</strong>：</p>\n<hr>\n<p>现有面值分别为 $v_i$ 的 N 种硬币，需要凑成 V 元，每种硬币使用次数不限，求一共有多少种凑法？</p>\n<hr>\n<p>我：“嗯。。。。最直观的想法就是暴力求解。。。”</p>\n<p>面试官：“怎么暴力求解呢？”</p>\n<p>我：“嗯。。。。估计要用到递归。。。”（内心OS：这样复杂度好高啊）</p>\n<p>面试官：“怎么递归呢？”</p>\n<p>我：“嗯。。。。每种硬币加加加，然后超过范围就退回到上一种状态。。。然后尝试下一种”（内心OS：复杂度好高！估计要用动态规划来优化下，咋搞呢）</p>\n<p>面试官：“能说一下代码会有哪些结构吗？”</p>\n<p>我：“*……&amp;*@!@#)(&amp;&amp;)”（我也不知道我瞎说了些啥，反正答得很烂）</p>\n<p>再又聊了一点点别的东西之后，</p>\n<p>面试官：“好的，我会如实反映这次面试的情况。应该会在一周之内联系你，如果两周都没有联系你，那就不用再等了。”</p>\n<p>我（带着哭腔）：“好的我清楚了T^T”</p>\n<h3 id=\"挂掉电话之后\"><a href=\"#挂掉电话之后\" class=\"headerlink\" title=\"挂掉电话之后\"></a>挂掉电话之后</h3><p>卧槽！这不就是一个动态规划吗！我咋这都没想出来！让我写一下代码！</p>\n<p><strong>思路：</strong></p>\n<p>我们需要数组 <code>T[i][j]</code> 表示用前 i 种硬币凑出 j 元时所有的组合数。</p>\n<p>逐步增加 j 至 V，计算 <code>T[i][j]</code> 的规则如下：</p>\n<p>遍历第 i 种硬币使用的个数，从 0（不使用）到不超过 V 的个数，记录为 k。当前硬币面值记为 v。</p>\n<p>​    <code>T[i][j] += T[i-1][j-k*v]</code></p>\n<p>也就是我们考虑第 i 种硬币使用 1 个、2 个、3 个的情况，每种情况的组合数分别对应不使用这种硬币时，减去这种硬币当前凑出的面值的组合数，做一个累加就可以了。</p>\n<p><strong>Java实现：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] C = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">        System.out.println(getTotoalCombinationCount(C, <span class=\"number\">10</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getTotoalCombinationCount</span><span class=\"params\">(<span class=\"keyword\">int</span>[] C, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> T[][] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[C.length+<span class=\"number\">1</span>][value+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=C.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;=value; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    T[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    T[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=C.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;=value; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> v = C[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>; k*v &lt;= j; k++) &#123;</span><br><span class=\"line\">                    T[i][j] += T[i - <span class=\"number\">1</span>][j - k*v];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> T[C.length][value];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，我们需要给二维数组 T 一个合适的初始值。当 j == 0 时，也就是需要凑成 0 元钱的时候，无论硬币有多少种，我们都有 1 种凑法：那就是不用凑。</p>\n<h3 id=\"从这个故事我们学到了\"><a href=\"#从这个故事我们学到了\" class=\"headerlink\" title=\"从这个故事我们学到了\"></a>从这个故事我们学到了</h3><p>这道题确实很简单，而且又是我刚刚才学过的动态规划法。事实上我挂掉电话后用了不到半个小时就写出来了。也许是刚学过动态规划还不太熟练、也许是面试时太紧张、也许是面试过程中大脑傻掉了，反正答的很不好，还是自己太菜啊！面试官特意说两个星期内没收到后续结果就是凉了，估计是在暗示我真的凉了吧。。。我自己是感觉凉了。。</p>\n<p>痛定思痛吧！继续努力！为找到实习而奋斗！</p>\n<h3 id=\"如果万一没凉……\"><a href=\"#如果万一没凉……\" class=\"headerlink\" title=\"如果万一没凉……\"></a>如果万一没凉……</h3><p>虽然概率趋近于 0，但如果万一我没凉，还收到了后续面试的通知的话……我就用阿里的支付宝给贫困山区的小朋友捐 10 块钱辣条钱！</p>\n<hr>\n<p><strong>4.7 Update:</strong></p>\n<p>震惊！居然没凉！已捐款10元。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"阿里一面凉了之旅\"><a href=\"#阿里一面凉了之旅\" class=\"headerlink\" title=\"阿里一面凉了之旅\"></a>阿里一面凉了之旅</h1><p>昨天才投的阿里巴巴，要我做的测评和在线编程题还没做，今天居然就打电话来面试了！真是猝不及防。在听我bb了半天项目经验，又问了点其他的 iOS 知识之后，面试官说：“我们来考察一下编程的思想吧！”。我说：“来吧！”，然后，然后我就跪了。。。</p>\n<h3 id=\"事情是这样的\"><a href=\"#事情是这样的\" class=\"headerlink\" title=\"事情是这样的\"></a>事情是这样的</h3><p>面试官：“这道题很常见，你之前也可能听说过。”</p>\n<p>我：“嗯，您说。”</p>\n<p>面试官：“给你 1、2、5 三种面值的硬币，凑成 10，一共有多少种组合？”</p>\n<p>我：“嗯。。。。我之前没听说过。。。。。让我想一下。。。。”</p>\n<p>于是我在脑海中抽象了一下<strong>题目描述</strong>：</p>\n<hr>\n<p>现有面值分别为 $v_i$ 的 N 种硬币，需要凑成 V 元，每种硬币使用次数不限，求一共有多少种凑法？</p>\n<hr>\n<p>我：“嗯。。。。最直观的想法就是暴力求解。。。”</p>\n<p>面试官：“怎么暴力求解呢？”</p>\n<p>我：“嗯。。。。估计要用到递归。。。”（内心OS：这样复杂度好高啊）</p>\n<p>面试官：“怎么递归呢？”</p>\n<p>我：“嗯。。。。每种硬币加加加，然后超过范围就退回到上一种状态。。。然后尝试下一种”（内心OS：复杂度好高！估计要用动态规划来优化下，咋搞呢）</p>\n<p>面试官：“能说一下代码会有哪些结构吗？”</p>\n<p>我：“*……&amp;*@!@#)(&amp;&amp;)”（我也不知道我瞎说了些啥，反正答得很烂）</p>\n<p>再又聊了一点点别的东西之后，</p>\n<p>面试官：“好的，我会如实反映这次面试的情况。应该会在一周之内联系你，如果两周都没有联系你，那就不用再等了。”</p>\n<p>我（带着哭腔）：“好的我清楚了T^T”</p>\n<h3 id=\"挂掉电话之后\"><a href=\"#挂掉电话之后\" class=\"headerlink\" title=\"挂掉电话之后\"></a>挂掉电话之后</h3><p>卧槽！这不就是一个动态规划吗！我咋这都没想出来！让我写一下代码！</p>\n<p><strong>思路：</strong></p>\n<p>我们需要数组 <code>T[i][j]</code> 表示用前 i 种硬币凑出 j 元时所有的组合数。</p>\n<p>逐步增加 j 至 V，计算 <code>T[i][j]</code> 的规则如下：</p>\n<p>遍历第 i 种硬币使用的个数，从 0（不使用）到不超过 V 的个数，记录为 k。当前硬币面值记为 v。</p>\n<p>​    <code>T[i][j] += T[i-1][j-k*v]</code></p>\n<p>也就是我们考虑第 i 种硬币使用 1 个、2 个、3 个的情况，每种情况的组合数分别对应不使用这种硬币时，减去这种硬币当前凑出的面值的组合数，做一个累加就可以了。</p>\n<p><strong>Java实现：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] C = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">        System.out.println(getTotoalCombinationCount(C, <span class=\"number\">10</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">getTotoalCombinationCount</span><span class=\"params\">(<span class=\"keyword\">int</span>[] C, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> T[][] = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[C.length+<span class=\"number\">1</span>][value+<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;=C.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;=value; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(j==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    T[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    T[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>; i&lt;=C.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>; j&lt;=value; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> v = C[i-<span class=\"number\">1</span>];</span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=<span class=\"number\">0</span>; k*v &lt;= j; k++) &#123;</span><br><span class=\"line\">                    T[i][j] += T[i - <span class=\"number\">1</span>][j - k*v];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> T[C.length][value];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，我们需要给二维数组 T 一个合适的初始值。当 j == 0 时，也就是需要凑成 0 元钱的时候，无论硬币有多少种，我们都有 1 种凑法：那就是不用凑。</p>\n<h3 id=\"从这个故事我们学到了\"><a href=\"#从这个故事我们学到了\" class=\"headerlink\" title=\"从这个故事我们学到了\"></a>从这个故事我们学到了</h3><p>这道题确实很简单，而且又是我刚刚才学过的动态规划法。事实上我挂掉电话后用了不到半个小时就写出来了。也许是刚学过动态规划还不太熟练、也许是面试时太紧张、也许是面试过程中大脑傻掉了，反正答的很不好，还是自己太菜啊！面试官特意说两个星期内没收到后续结果就是凉了，估计是在暗示我真的凉了吧。。。我自己是感觉凉了。。</p>\n<p>痛定思痛吧！继续努力！为找到实习而奋斗！</p>\n<h3 id=\"如果万一没凉……\"><a href=\"#如果万一没凉……\" class=\"headerlink\" title=\"如果万一没凉……\"></a>如果万一没凉……</h3><p>虽然概率趋近于 0，但如果万一我没凉，还收到了后续面试的通知的话……我就用阿里的支付宝给贫困山区的小朋友捐 10 块钱辣条钱！</p>\n<hr>\n<p><strong>4.7 Update:</strong></p>\n<p>震惊！居然没凉！已捐款10元。</p>\n"},{"title":"JavaScript基础分享","date":"2018-07-26T13:59:18.000Z","_content":"\n# JavaScript 基础分享\n\n> Any application that can be written in JavaScript, will eventually be written in JavaScript.\n\n## JS 简介\n\nJavaScript 是一门动态的、弱类型的、基于原型（而不是基于类）的解释型（或 JIT 编译型）语言。它是一门多范式语言，支持命令式、面向对象，以及函数式编程。语言本身不支持 I/O 操作，而是依赖于宿主环境。现在，JS 不仅可以在浏览器中运行，也可以运行在 Node 等非浏览器环境中。\n\nJS 是一门单线程语言，这意味着在浏览器中，JS 代码只能在 JS 引擎线程中执行。但这并不意味着耗时操作（如 HTTP 请求）会把界面卡死，因为浏览器本身是可以开启多线程的。在 HTML 5 中，可以通过 Web Workers 来在多个线程中执行 JS 代码，但这和“JS 是单线程语言”并不冲突。因为多个 worker 之间并不共享资源，而只能通过 message 来通信。\n\nJavaScript 已由 ECMA 进行了标准化，这个标准被称为 ECMAScript。JavaScript 是 ECMAScript 的一种实现，但在绝大多数情况下，这两个词是可以互换的。每年的 6 月，ECMA 都会发布一个新标准，不过大家通常使用 ES6 来指代 ES2015 及以后的版本，泛指“下一代 JavaScript”。在《JavaScript 高级程序设计》这本书中，讲解的是 ES5。\n\n## 基本概念\n\n### 变量\n\nJavaScript 的变量是松散类型的，一个变量可以用来保存任意类型的值。如果没有被初始化，那么变量就会保存一个特殊的值 `undefined`。\n\n```javascript\nvar a;\nconsole.log(a); //undefined\na = 5;\nconsole.log(a); //5\na = 'hello world!';\nconsole.log(a); //hello world!\n```\n\n声明变量需要使用 var 操作符，但是如果不使用，不仅不会报错，反而变量会变成全局变量，不鼓励这种行为。\n\n### 数据类型\n\nJavaScript 中有 5 种基本数据类型：\n\n- Undefined\n- Null\n- Boolean\n- Number\n- String\n\n和一种复杂类型：\n\n- Object\n\n之前提到，JavaScript 不是基于类的，因此它也不支持创建自定义的类型。所有值都将是上述的 6 种类型之一。虽然在 ES6 中引入了 `class`，但这只是语法糖而已。\n\n可以使用 `typeof` 操作符来判断类型。typeof 操作符会返回一些字符串：\n\n- \"undefined\"\n- \"boolean\"\n- \"string\"\n- \"number\"\n- \"object\"\n- \"function\"\n\n函数在 JS 中也是对象，但是 typeof 操作符还是会把函数和普通对象作出区分。\n\n还有比较神奇的一点是，虽然 Null 类型只有一个特殊的值 null，但是 `typeof null` 返回的却是 `\"object\"`，这是因为 null 表示一个**空对象**指针。\n\n```javascript\nconsole.log(typeof \"hello?\"); //\"string\"\n\nfunction foo() {}\nconsole.log(typeof foo); //\"function\"\n\nconsole.log(typeof(null)); //\"object\"\n```\n\n### 关系操作符\n\n关系操作符遇到非数值类型时，会发生一些比较神奇的事情，比如：\n\n```javascript\n\"23\" < \"3\" //true\n\"23\" < 3 //false\n\"a\" < 3 //false\n\"a\" >= 3 //false\n```\n\n首先，两个字符串比较的是字符编码值。字符\"2\"的编码值小于\"3\"，因此是 true。\n\n但是，如果一边是数值，则另一边会被转化成数值再做比较。\"23\" 会被转化成 23，所以返回 false。\n\n但是第三行和第四行中，\"a\" 转化成数值会变成 NaN。NaN 与任何数值比较都会返回 false，所以会出现既不大于，也不等于，还不小于的情况。\n\n如果操作数是对象，则会先调用 `valueOf()` 方法。如果没有这个方法，则会调用 `toString()` 再根据之前的标准比较。\n\n### 相等操作符\n\nJavaScript 中有两种比较：`==` 和 `===`。\n\n使用 `==`，会在比较前先做类型转换，而 `===` 直接比较。由于 JS 臭名昭著的蜜汁类型转换会带来各种各样的奇怪现象，强烈建议经常使用 === 做全等判断。\n\n```javascript\n5 == '5' //true\nnull == undefined //true\ntrue == 1 //true\ntrue == 2 //false\nNaN === NaN //false\n```\n\n想彻底搞懂？\n\n```javascript\n[{}] + [] === \"[object Object]\" //true 😊\n\n25[[[+[] == +[]][0] + []][0][0] + [[{}] + []][0][1]+ [[] + []][0][([[{}] + []][0][5]) + ([[{}] + []][0][1]) + ([[][0]+[]][0][1]) + ([[[] == []][0] + []][0][3]) + ([[+[] == +[]][0] + []][0][0]) + ([[+[] == +[]][0] + []][0][1]) + ([[][0]+[]][0][0]) + ([[{}] + []][0][5]) + ([[+[] == +[]][0] + []][0][0]) + ([[{}] + []][0][1]) + ([[+[] == +[]][0] + []][0][1])][[[][0]+[]][0][1] + [[[] == []][0] + []][0][1] + [0[([[{}] + []][0][5]) + ([[{}] + []][0][1]) + ([[][0]+[]][0][1]) + ([[[] == []][0] + []][0][3]) + ([[+[] == +[]][0] + []][0][0]) + ([[+[] == +[]][0] + []][0][1]) + ([[][0]+[]][0][0]) + ([[{}] + []][0][5]) + ([[+[] == +[]][0] + []][0][0]) + ([[{}] + []][0][1]) + ([[+[] == +[]][0] + []][0][1])]+[]][0][11] +  [[[] == []][0] + []][0][4]]](30) //\"p\"\n```\n\n### for-in\n\n和其他语言不一样，我们可以使用 for-in 循环来遍历对象的属性名，比如：\n\n```javascript\nvar person = new Object();\nperson.name = \"Luyuan Wang\";\nperson.age = 20;\nperson.school = \"Huazhong University of Science and Technology\";\nfor (var propName in person) {\n    console.log(propName);\n}\n//name\n//age\n//school\n```\n\n这个顺序是不保证的。\n\n如果遍历的对象是数组，那么取出来的是数组下标，而不是元素，这个跟 Objective-C 或者 Swift 等语言都不一样：\n\n```javascript\nvar list = [\"a\", \"b\", \"c\"];\nfor (var each in list) {\n    console.log(each);\n}\n//0\n//1\n//2\n```\n\n因此，上面代码的 each 更应该被命名为 index。\n\n### 函数\n\nJavaScript 的函数不用定义返回值类型，甚至有没有返回值都不是确定的。\n\n```javascript\nfunction divide(a, b) {\n    if (b === 0) {\n        return;\n    }\n    return a / b;\n}\nconsole.log(divide(1, 0)); //undefined\n```\n\nJavaScript 函数的参数是通过数组来访问的（只是类似数组，但并不是 Array 的实例），因此它并不关心你传入多少个变量，更不关心变量的类型。你甚至可以通过 arguments + 下标来访问参数，参数名其实只是一种便利：\n\n```javascript\nfunction foo() {\n    console.log(arguments[0]); //很像数组\n}\nfoo('hello world!');\n```\n\n```javascript\nvar array = [];\nconsole.log(Array.isArray(array)); //true\n\nfunction foo() {\n    console.log(Array.isArray(arguments)); //false 并不是Array的实例\n}\nfoo();\n```\n\n这和 OC 中用函数参数名、参数类型等作为函数签名有很大区别。需要注意的是，JavaScript 的参数传递的永远是值，而不是引用（这点在后面会再次提及）。\n\nJavaScript 中的函数不支持重载，但是可以利用 `arguments.length` 判断参数个数，从而表现出不同的行为。\n\n## 变量、作用域和内存问题\n\n### 基本类型和引用类型的值\n\n尽管 JavaScript 是松散类型的，但变量的值还是分为基本类型的值和引用类型的值。前面提到的 5 种基本类型是按值访问的，而 Object 类型操作的是引用。和许多其他的语言不同，String 是基本类型值，而不是引用，这和 Swift 很像。\n\n```javascript\nvar num = 5;\nvar num2 = num;\nnum2 += 1;\nconsole.log(num); //5\nconsole.log(num2); //6\n```\n\n```javascript\nvar obj = new Object();\nobj.value = 5;\nvar obj2 = obj;\nobj2.value += 1;\nconsole.log(obj.value); //6\nconsole.log(obj2.value); //6\n```\n\n```javascript\nvar str = \"123\";\nvar str2 = str;\nstr2 += \"4\";\nconsole.log(str); //\"123\"\nconsole.log(str2); //\"1234\" 和Swift一样，String不是引用类型\n```\n\n### 函数参数\n\n之前提到，JavaScript 中函数的参数是以值来传递的，而永远不是引用。那么，下面这个例子应该输出什么呢？\n\n```javascript\nfunction changeSchool(person) {\n    person.school = \"Mizzou\";\n}\nvar luyuanwang = {\n    school: \"HUST\"\n}\nchangeSchool(luyuanwang);\nconsole.log(luyuanwang.school);\n```\n\n答案是“Mizzou”。看起来很奇怪，似乎不符合我们说传递的是值，而更像是在传递引用？其实，这里传递的值，是指把“对象”复制一遍。这里的对象是一个引用，那么就把这个指针复制了，因此这里是两个不同的、指向同一个地址的引用。所谓的传递的是值，并不是指把内存中的对象复制一遍，这里要搞清楚。\n\n### 没有块级作用域\n\n虽然函数会创建局部的执行环境，但是花括号封闭的代码块并没有自己的执行环境：\n\n```javascript\nvar flag = true;\nif (flag) {\n    var num = 10;\n}\nconsole.log(num); //10 仍有定义\n```\n\n这和一般的语言都不同。如果想要“正常一点”，可以使用 ES6 中引入的关键字 let：\n\n```javascript\nvar flag = true;\nif (flag) {\n    let num = 10;\n}\nconsole.log(num); //ReferenceError: num is not defined\n```\n\n### 垃圾收集\n\nJavaScript 是有 GC 的，通过“标记清除“的方式，周期性地回收垃圾。有些浏览器也曾经使用过引用计数，不过发现有循环引用的问题后，后来就又放弃了。所以一般情况下，我们都不必操心内存的事情。\n\n通过标记清除算法，GC 将会从根对象开始（根对象是一个全局对象），开始寻找根对象引用的对象，并递归地寻找下去。那些无法触达的对象，将被认为是垃圾对象，会被 GC 回收。从 2012 年开始，所有现代浏览器都使用了标记清除或其改进型算法，即使产生循环引用，照样可以被清除掉。\n\n## 原型链\n\n之前提到过，JavaScript 是基于原型的语言，这和我们所熟悉的其他语言都不一样。\n\n### 构造函数\n\n在 JS 中，可以使用**原型模式**来创建一个对象（尽管这不是唯一的方法）：\n\n```javascript\nfunction Employer() {\n\n}\nEmployer.prototype.name = \"Lei, Jun\";\nEmployer.prototype.company = \"Xiao Mi\";\nEmployer.prototype.makeSpeech = function() {\n    console.log(\"Are u ok?\");\n}\n\nvar person = new Employer();\nperson.makeSpeech(); //Are u ok?\n```\n\nEmployer 和普通的方法没有任何区别，但是如果在调用的时候使用了 new 关键字，就会成为一个构造函数。每个函数都有一个 `prototype` 属性，这个属性指向的就是创造出来的实例的原型对象。\n\n### 原型对象\n\n原型最初会包含一个 constructor，指向它的构造函数。也就是 Employer.prototype.constructor 就是 Employer。每个对象也都有一个 `[[Prototype]] ` 属性来指向原型对象，但这个属性是私有的，不能通过外界访问。不过在有一些浏览器（比如 Safari 和 Chrome 中），提供了一个 `__proto__` 属性来访问原型。\n\n如果你修改属性的值，其实只是对变量创建了一个新的属性，屏蔽掉了在对象原型中查找的操作。在多数情况下，这都没什么问题，但如果原型对象中放置了一个引用类型的属性，那么原型共享的特性就会导致问题了。为了解决这个问题，可以用普通的构造函数构造属性，而用原型构造方法。\n\n```javascript\nfunction Employer(name) {\n    this.name = name;\n}\nEmployer.prototype = {\n    constructor: Employer,\n    makeSpeech: () => {console.log('Are u ok?')}\n}\n\nvar person = new Employer('Lei, Jun');\nperson.makeSpeech();\n```\n\n### 终于来到原型链\n\n如果我们修改掉 prototype，把它指向一个实例，那么在搜索属性和方法的时候，就会一层一层地搜索下去，也就间接地实现了继承。每个对象都有原型对象，原型对象又有自己的原型对象，从而构成了一个原型链。原型链的最后一环是 null，null 没有原型。\n\n```javascript\nfunction Father() {\n    this.sex = \"male\";\n}\n\nfunction Son() {\n    this.job = \"programmer\";\n}\n\nSon.prototype = new Father();\n\nvar person = new Son();\nconsole.log(person.sex); //male 通过查找原型的属性找到\nconsole.log(person.job); //programmer 自己的属性\n```\n\n不过直接使用原型链是有缺陷的。首先，由于原型是共享的，那么含有引用类型属性的原型就会出问题。而且，不能在子类中向父类的构造函数中传递参数。为了解决这些问题，程序员们想出了很多方法。不过，现在我们有个 ES6，可以使用 ES6 的新关键字 `class` 来定义类了。但这只是语法糖，并没有改变 JS 基于原型的事实。\n\n```javascript\nclass Father {\n    constructor() {\n        this.sex = \"male\";\n    }\n}\n\nclass Son extends Father {\n    constructor(job) {\n        super();\n        this.job = job;\n    }\n}\n\nvar person = new Son(\"programmer\");\nconsole.log(person.sex); //male\nconsole.log(person.job); //programmer\n```","source":"_posts/JavaScript基础分享.md","raw":"---\ntitle: JavaScript基础分享\ndate: 2018-07-26 21:59:18\ntags: JavaScript\n---\n\n# JavaScript 基础分享\n\n> Any application that can be written in JavaScript, will eventually be written in JavaScript.\n\n## JS 简介\n\nJavaScript 是一门动态的、弱类型的、基于原型（而不是基于类）的解释型（或 JIT 编译型）语言。它是一门多范式语言，支持命令式、面向对象，以及函数式编程。语言本身不支持 I/O 操作，而是依赖于宿主环境。现在，JS 不仅可以在浏览器中运行，也可以运行在 Node 等非浏览器环境中。\n\nJS 是一门单线程语言，这意味着在浏览器中，JS 代码只能在 JS 引擎线程中执行。但这并不意味着耗时操作（如 HTTP 请求）会把界面卡死，因为浏览器本身是可以开启多线程的。在 HTML 5 中，可以通过 Web Workers 来在多个线程中执行 JS 代码，但这和“JS 是单线程语言”并不冲突。因为多个 worker 之间并不共享资源，而只能通过 message 来通信。\n\nJavaScript 已由 ECMA 进行了标准化，这个标准被称为 ECMAScript。JavaScript 是 ECMAScript 的一种实现，但在绝大多数情况下，这两个词是可以互换的。每年的 6 月，ECMA 都会发布一个新标准，不过大家通常使用 ES6 来指代 ES2015 及以后的版本，泛指“下一代 JavaScript”。在《JavaScript 高级程序设计》这本书中，讲解的是 ES5。\n\n## 基本概念\n\n### 变量\n\nJavaScript 的变量是松散类型的，一个变量可以用来保存任意类型的值。如果没有被初始化，那么变量就会保存一个特殊的值 `undefined`。\n\n```javascript\nvar a;\nconsole.log(a); //undefined\na = 5;\nconsole.log(a); //5\na = 'hello world!';\nconsole.log(a); //hello world!\n```\n\n声明变量需要使用 var 操作符，但是如果不使用，不仅不会报错，反而变量会变成全局变量，不鼓励这种行为。\n\n### 数据类型\n\nJavaScript 中有 5 种基本数据类型：\n\n- Undefined\n- Null\n- Boolean\n- Number\n- String\n\n和一种复杂类型：\n\n- Object\n\n之前提到，JavaScript 不是基于类的，因此它也不支持创建自定义的类型。所有值都将是上述的 6 种类型之一。虽然在 ES6 中引入了 `class`，但这只是语法糖而已。\n\n可以使用 `typeof` 操作符来判断类型。typeof 操作符会返回一些字符串：\n\n- \"undefined\"\n- \"boolean\"\n- \"string\"\n- \"number\"\n- \"object\"\n- \"function\"\n\n函数在 JS 中也是对象，但是 typeof 操作符还是会把函数和普通对象作出区分。\n\n还有比较神奇的一点是，虽然 Null 类型只有一个特殊的值 null，但是 `typeof null` 返回的却是 `\"object\"`，这是因为 null 表示一个**空对象**指针。\n\n```javascript\nconsole.log(typeof \"hello?\"); //\"string\"\n\nfunction foo() {}\nconsole.log(typeof foo); //\"function\"\n\nconsole.log(typeof(null)); //\"object\"\n```\n\n### 关系操作符\n\n关系操作符遇到非数值类型时，会发生一些比较神奇的事情，比如：\n\n```javascript\n\"23\" < \"3\" //true\n\"23\" < 3 //false\n\"a\" < 3 //false\n\"a\" >= 3 //false\n```\n\n首先，两个字符串比较的是字符编码值。字符\"2\"的编码值小于\"3\"，因此是 true。\n\n但是，如果一边是数值，则另一边会被转化成数值再做比较。\"23\" 会被转化成 23，所以返回 false。\n\n但是第三行和第四行中，\"a\" 转化成数值会变成 NaN。NaN 与任何数值比较都会返回 false，所以会出现既不大于，也不等于，还不小于的情况。\n\n如果操作数是对象，则会先调用 `valueOf()` 方法。如果没有这个方法，则会调用 `toString()` 再根据之前的标准比较。\n\n### 相等操作符\n\nJavaScript 中有两种比较：`==` 和 `===`。\n\n使用 `==`，会在比较前先做类型转换，而 `===` 直接比较。由于 JS 臭名昭著的蜜汁类型转换会带来各种各样的奇怪现象，强烈建议经常使用 === 做全等判断。\n\n```javascript\n5 == '5' //true\nnull == undefined //true\ntrue == 1 //true\ntrue == 2 //false\nNaN === NaN //false\n```\n\n想彻底搞懂？\n\n```javascript\n[{}] + [] === \"[object Object]\" //true 😊\n\n25[[[+[] == +[]][0] + []][0][0] + [[{}] + []][0][1]+ [[] + []][0][([[{}] + []][0][5]) + ([[{}] + []][0][1]) + ([[][0]+[]][0][1]) + ([[[] == []][0] + []][0][3]) + ([[+[] == +[]][0] + []][0][0]) + ([[+[] == +[]][0] + []][0][1]) + ([[][0]+[]][0][0]) + ([[{}] + []][0][5]) + ([[+[] == +[]][0] + []][0][0]) + ([[{}] + []][0][1]) + ([[+[] == +[]][0] + []][0][1])][[[][0]+[]][0][1] + [[[] == []][0] + []][0][1] + [0[([[{}] + []][0][5]) + ([[{}] + []][0][1]) + ([[][0]+[]][0][1]) + ([[[] == []][0] + []][0][3]) + ([[+[] == +[]][0] + []][0][0]) + ([[+[] == +[]][0] + []][0][1]) + ([[][0]+[]][0][0]) + ([[{}] + []][0][5]) + ([[+[] == +[]][0] + []][0][0]) + ([[{}] + []][0][1]) + ([[+[] == +[]][0] + []][0][1])]+[]][0][11] +  [[[] == []][0] + []][0][4]]](30) //\"p\"\n```\n\n### for-in\n\n和其他语言不一样，我们可以使用 for-in 循环来遍历对象的属性名，比如：\n\n```javascript\nvar person = new Object();\nperson.name = \"Luyuan Wang\";\nperson.age = 20;\nperson.school = \"Huazhong University of Science and Technology\";\nfor (var propName in person) {\n    console.log(propName);\n}\n//name\n//age\n//school\n```\n\n这个顺序是不保证的。\n\n如果遍历的对象是数组，那么取出来的是数组下标，而不是元素，这个跟 Objective-C 或者 Swift 等语言都不一样：\n\n```javascript\nvar list = [\"a\", \"b\", \"c\"];\nfor (var each in list) {\n    console.log(each);\n}\n//0\n//1\n//2\n```\n\n因此，上面代码的 each 更应该被命名为 index。\n\n### 函数\n\nJavaScript 的函数不用定义返回值类型，甚至有没有返回值都不是确定的。\n\n```javascript\nfunction divide(a, b) {\n    if (b === 0) {\n        return;\n    }\n    return a / b;\n}\nconsole.log(divide(1, 0)); //undefined\n```\n\nJavaScript 函数的参数是通过数组来访问的（只是类似数组，但并不是 Array 的实例），因此它并不关心你传入多少个变量，更不关心变量的类型。你甚至可以通过 arguments + 下标来访问参数，参数名其实只是一种便利：\n\n```javascript\nfunction foo() {\n    console.log(arguments[0]); //很像数组\n}\nfoo('hello world!');\n```\n\n```javascript\nvar array = [];\nconsole.log(Array.isArray(array)); //true\n\nfunction foo() {\n    console.log(Array.isArray(arguments)); //false 并不是Array的实例\n}\nfoo();\n```\n\n这和 OC 中用函数参数名、参数类型等作为函数签名有很大区别。需要注意的是，JavaScript 的参数传递的永远是值，而不是引用（这点在后面会再次提及）。\n\nJavaScript 中的函数不支持重载，但是可以利用 `arguments.length` 判断参数个数，从而表现出不同的行为。\n\n## 变量、作用域和内存问题\n\n### 基本类型和引用类型的值\n\n尽管 JavaScript 是松散类型的，但变量的值还是分为基本类型的值和引用类型的值。前面提到的 5 种基本类型是按值访问的，而 Object 类型操作的是引用。和许多其他的语言不同，String 是基本类型值，而不是引用，这和 Swift 很像。\n\n```javascript\nvar num = 5;\nvar num2 = num;\nnum2 += 1;\nconsole.log(num); //5\nconsole.log(num2); //6\n```\n\n```javascript\nvar obj = new Object();\nobj.value = 5;\nvar obj2 = obj;\nobj2.value += 1;\nconsole.log(obj.value); //6\nconsole.log(obj2.value); //6\n```\n\n```javascript\nvar str = \"123\";\nvar str2 = str;\nstr2 += \"4\";\nconsole.log(str); //\"123\"\nconsole.log(str2); //\"1234\" 和Swift一样，String不是引用类型\n```\n\n### 函数参数\n\n之前提到，JavaScript 中函数的参数是以值来传递的，而永远不是引用。那么，下面这个例子应该输出什么呢？\n\n```javascript\nfunction changeSchool(person) {\n    person.school = \"Mizzou\";\n}\nvar luyuanwang = {\n    school: \"HUST\"\n}\nchangeSchool(luyuanwang);\nconsole.log(luyuanwang.school);\n```\n\n答案是“Mizzou”。看起来很奇怪，似乎不符合我们说传递的是值，而更像是在传递引用？其实，这里传递的值，是指把“对象”复制一遍。这里的对象是一个引用，那么就把这个指针复制了，因此这里是两个不同的、指向同一个地址的引用。所谓的传递的是值，并不是指把内存中的对象复制一遍，这里要搞清楚。\n\n### 没有块级作用域\n\n虽然函数会创建局部的执行环境，但是花括号封闭的代码块并没有自己的执行环境：\n\n```javascript\nvar flag = true;\nif (flag) {\n    var num = 10;\n}\nconsole.log(num); //10 仍有定义\n```\n\n这和一般的语言都不同。如果想要“正常一点”，可以使用 ES6 中引入的关键字 let：\n\n```javascript\nvar flag = true;\nif (flag) {\n    let num = 10;\n}\nconsole.log(num); //ReferenceError: num is not defined\n```\n\n### 垃圾收集\n\nJavaScript 是有 GC 的，通过“标记清除“的方式，周期性地回收垃圾。有些浏览器也曾经使用过引用计数，不过发现有循环引用的问题后，后来就又放弃了。所以一般情况下，我们都不必操心内存的事情。\n\n通过标记清除算法，GC 将会从根对象开始（根对象是一个全局对象），开始寻找根对象引用的对象，并递归地寻找下去。那些无法触达的对象，将被认为是垃圾对象，会被 GC 回收。从 2012 年开始，所有现代浏览器都使用了标记清除或其改进型算法，即使产生循环引用，照样可以被清除掉。\n\n## 原型链\n\n之前提到过，JavaScript 是基于原型的语言，这和我们所熟悉的其他语言都不一样。\n\n### 构造函数\n\n在 JS 中，可以使用**原型模式**来创建一个对象（尽管这不是唯一的方法）：\n\n```javascript\nfunction Employer() {\n\n}\nEmployer.prototype.name = \"Lei, Jun\";\nEmployer.prototype.company = \"Xiao Mi\";\nEmployer.prototype.makeSpeech = function() {\n    console.log(\"Are u ok?\");\n}\n\nvar person = new Employer();\nperson.makeSpeech(); //Are u ok?\n```\n\nEmployer 和普通的方法没有任何区别，但是如果在调用的时候使用了 new 关键字，就会成为一个构造函数。每个函数都有一个 `prototype` 属性，这个属性指向的就是创造出来的实例的原型对象。\n\n### 原型对象\n\n原型最初会包含一个 constructor，指向它的构造函数。也就是 Employer.prototype.constructor 就是 Employer。每个对象也都有一个 `[[Prototype]] ` 属性来指向原型对象，但这个属性是私有的，不能通过外界访问。不过在有一些浏览器（比如 Safari 和 Chrome 中），提供了一个 `__proto__` 属性来访问原型。\n\n如果你修改属性的值，其实只是对变量创建了一个新的属性，屏蔽掉了在对象原型中查找的操作。在多数情况下，这都没什么问题，但如果原型对象中放置了一个引用类型的属性，那么原型共享的特性就会导致问题了。为了解决这个问题，可以用普通的构造函数构造属性，而用原型构造方法。\n\n```javascript\nfunction Employer(name) {\n    this.name = name;\n}\nEmployer.prototype = {\n    constructor: Employer,\n    makeSpeech: () => {console.log('Are u ok?')}\n}\n\nvar person = new Employer('Lei, Jun');\nperson.makeSpeech();\n```\n\n### 终于来到原型链\n\n如果我们修改掉 prototype，把它指向一个实例，那么在搜索属性和方法的时候，就会一层一层地搜索下去，也就间接地实现了继承。每个对象都有原型对象，原型对象又有自己的原型对象，从而构成了一个原型链。原型链的最后一环是 null，null 没有原型。\n\n```javascript\nfunction Father() {\n    this.sex = \"male\";\n}\n\nfunction Son() {\n    this.job = \"programmer\";\n}\n\nSon.prototype = new Father();\n\nvar person = new Son();\nconsole.log(person.sex); //male 通过查找原型的属性找到\nconsole.log(person.job); //programmer 自己的属性\n```\n\n不过直接使用原型链是有缺陷的。首先，由于原型是共享的，那么含有引用类型属性的原型就会出问题。而且，不能在子类中向父类的构造函数中传递参数。为了解决这些问题，程序员们想出了很多方法。不过，现在我们有个 ES6，可以使用 ES6 的新关键字 `class` 来定义类了。但这只是语法糖，并没有改变 JS 基于原型的事实。\n\n```javascript\nclass Father {\n    constructor() {\n        this.sex = \"male\";\n    }\n}\n\nclass Son extends Father {\n    constructor(job) {\n        super();\n        this.job = job;\n    }\n}\n\nvar person = new Son(\"programmer\");\nconsole.log(person.sex); //male\nconsole.log(person.job); //programmer\n```","slug":"JavaScript基础分享","published":1,"updated":"2020-01-04T08:16:16.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3v002yljc3td16btks","content":"<h1 id=\"JavaScript-基础分享\"><a href=\"#JavaScript-基础分享\" class=\"headerlink\" title=\"JavaScript 基础分享\"></a>JavaScript 基础分享</h1><blockquote>\n<p>Any application that can be written in JavaScript, will eventually be written in JavaScript.</p>\n</blockquote>\n<h2 id=\"JS-简介\"><a href=\"#JS-简介\" class=\"headerlink\" title=\"JS 简介\"></a>JS 简介</h2><p>JavaScript 是一门动态的、弱类型的、基于原型（而不是基于类）的解释型（或 JIT 编译型）语言。它是一门多范式语言，支持命令式、面向对象，以及函数式编程。语言本身不支持 I/O 操作，而是依赖于宿主环境。现在，JS 不仅可以在浏览器中运行，也可以运行在 Node 等非浏览器环境中。</p>\n<p>JS 是一门单线程语言，这意味着在浏览器中，JS 代码只能在 JS 引擎线程中执行。但这并不意味着耗时操作（如 HTTP 请求）会把界面卡死，因为浏览器本身是可以开启多线程的。在 HTML 5 中，可以通过 Web Workers 来在多个线程中执行 JS 代码，但这和“JS 是单线程语言”并不冲突。因为多个 worker 之间并不共享资源，而只能通过 message 来通信。</p>\n<p>JavaScript 已由 ECMA 进行了标准化，这个标准被称为 ECMAScript。JavaScript 是 ECMAScript 的一种实现，但在绝大多数情况下，这两个词是可以互换的。每年的 6 月，ECMA 都会发布一个新标准，不过大家通常使用 ES6 来指代 ES2015 及以后的版本，泛指“下一代 JavaScript”。在《JavaScript 高级程序设计》这本书中，讲解的是 ES5。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>JavaScript 的变量是松散类型的，一个变量可以用来保存任意类型的值。如果没有被初始化，那么变量就会保存一个特殊的值 <code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//5</span></span><br><span class=\"line\">a = <span class=\"string\">'hello world!'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//hello world!</span></span><br></pre></td></tr></table></figure>\n<p>声明变量需要使用 var 操作符，但是如果不使用，不仅不会报错，反而变量会变成全局变量，不鼓励这种行为。</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>JavaScript 中有 5 种基本数据类型：</p>\n<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n</ul>\n<p>和一种复杂类型：</p>\n<ul>\n<li>Object</li>\n</ul>\n<p>之前提到，JavaScript 不是基于类的，因此它也不支持创建自定义的类型。所有值都将是上述的 6 种类型之一。虽然在 ES6 中引入了 <code>class</code>，但这只是语法糖而已。</p>\n<p>可以使用 <code>typeof</code> 操作符来判断类型。typeof 操作符会返回一些字符串：</p>\n<ul>\n<li>“undefined”</li>\n<li>“boolean”</li>\n<li>“string”</li>\n<li>“number”</li>\n<li>“object”</li>\n<li>“function”</li>\n</ul>\n<p>函数在 JS 中也是对象，但是 typeof 操作符还是会把函数和普通对象作出区分。</p>\n<p>还有比较神奇的一点是，虽然 Null 类型只有一个特殊的值 null，但是 <code>typeof null</code> 返回的却是 <code>&quot;object&quot;</code>，这是因为 null 表示一个<strong>空对象</strong>指针。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"string\">\"hello?\"</span>); <span class=\"comment\">//\"string\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> foo); <span class=\"comment\">//\"function\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"literal\">null</span>)); <span class=\"comment\">//\"object\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"关系操作符\"><a href=\"#关系操作符\" class=\"headerlink\" title=\"关系操作符\"></a>关系操作符</h3><p>关系操作符遇到非数值类型时，会发生一些比较神奇的事情，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"23\"</span> &lt; <span class=\"string\">\"3\"</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"string\">\"23\"</span> &lt; <span class=\"number\">3</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"string\">\"a\"</span> &lt; <span class=\"number\">3</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"string\">\"a\"</span> &gt;= <span class=\"number\">3</span> <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>首先，两个字符串比较的是字符编码值。字符”2”的编码值小于”3”，因此是 true。</p>\n<p>但是，如果一边是数值，则另一边会被转化成数值再做比较。”23” 会被转化成 23，所以返回 false。</p>\n<p>但是第三行和第四行中，”a” 转化成数值会变成 NaN。NaN 与任何数值比较都会返回 false，所以会出现既不大于，也不等于，还不小于的情况。</p>\n<p>如果操作数是对象，则会先调用 <code>valueOf()</code> 方法。如果没有这个方法，则会调用 <code>toString()</code> 再根据之前的标准比较。</p>\n<h3 id=\"相等操作符\"><a href=\"#相等操作符\" class=\"headerlink\" title=\"相等操作符\"></a>相等操作符</h3><p>JavaScript 中有两种比较：<code>==</code> 和 <code>===</code>。</p>\n<p>使用 <code>==</code>，会在比较前先做类型转换，而 <code>===</code> 直接比较。由于 JS 臭名昭著的蜜汁类型转换会带来各种各样的奇怪现象，强烈建议经常使用 === 做全等判断。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> == <span class=\"string\">'5'</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"number\">1</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"number\">2</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>想彻底搞懂？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;&#125;] + [] === <span class=\"string\">\"[object Object]\"</span> <span class=\"comment\">//true 😊</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">25</span>[[[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">0</span>] + [[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]+ [[] + []][<span class=\"number\">0</span>][([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">5</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[][<span class=\"number\">0</span>]+[]][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[[] == []][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">3</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[][<span class=\"number\">0</span>]+[]][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">5</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>])][[[][<span class=\"number\">0</span>]+[]][<span class=\"number\">0</span>][<span class=\"number\">1</span>] + [[[] == []][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>] + [<span class=\"number\">0</span>[([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">5</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[][<span class=\"number\">0</span>]+[]][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[[] == []][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">3</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[][<span class=\"number\">0</span>]+[]][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">5</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>])]+[]][<span class=\"number\">0</span>][<span class=\"number\">11</span>] +  [[[] == []][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">4</span>]]](<span class=\"number\">30</span>) <span class=\"comment\">//\"p\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for-in\"></a>for-in</h3><p>和其他语言不一样，我们可以使用 for-in 循环来遍历对象的属性名，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">person.name = <span class=\"string\">\"Luyuan Wang\"</span>;</span><br><span class=\"line\">person.age = <span class=\"number\">20</span>;</span><br><span class=\"line\">person.school = <span class=\"string\">\"Huazhong University of Science and Technology\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> propName <span class=\"keyword\">in</span> person) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(propName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//name</span></span><br><span class=\"line\"><span class=\"comment\">//age</span></span><br><span class=\"line\"><span class=\"comment\">//school</span></span><br></pre></td></tr></table></figure>\n<p>这个顺序是不保证的。</p>\n<p>如果遍历的对象是数组，那么取出来的是数组下标，而不是元素，这个跟 Objective-C 或者 Swift 等语言都不一样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> each <span class=\"keyword\">in</span> list) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(each);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>因此，上面代码的 each 更应该被命名为 index。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>JavaScript 的函数不用定义返回值类型，甚至有没有返回值都不是确定的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">divide</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a / b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(divide(<span class=\"number\">1</span>, <span class=\"number\">0</span>)); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p>JavaScript 函数的参数是通过数组来访问的（只是类似数组，但并不是 Array 的实例），因此它并不关心你传入多少个变量，更不关心变量的类型。你甚至可以通过 arguments + 下标来访问参数，参数名其实只是一种便利：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]); <span class=\"comment\">//很像数组</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(<span class=\"string\">'hello world!'</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(array)); <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(<span class=\"built_in\">arguments</span>)); <span class=\"comment\">//false 并不是Array的实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>这和 OC 中用函数参数名、参数类型等作为函数签名有很大区别。需要注意的是，JavaScript 的参数传递的永远是值，而不是引用（这点在后面会再次提及）。</p>\n<p>JavaScript 中的函数不支持重载，但是可以利用 <code>arguments.length</code> 判断参数个数，从而表现出不同的行为。</p>\n<h2 id=\"变量、作用域和内存问题\"><a href=\"#变量、作用域和内存问题\" class=\"headerlink\" title=\"变量、作用域和内存问题\"></a>变量、作用域和内存问题</h2><h3 id=\"基本类型和引用类型的值\"><a href=\"#基本类型和引用类型的值\" class=\"headerlink\" title=\"基本类型和引用类型的值\"></a>基本类型和引用类型的值</h3><p>尽管 JavaScript 是松散类型的，但变量的值还是分为基本类型的值和引用类型的值。前面提到的 5 种基本类型是按值访问的，而 Object 类型操作的是引用。和许多其他的语言不同，String 是基本类型值，而不是引用，这和 Swift 很像。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> num2 = num;</span><br><span class=\"line\">num2 += <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num); <span class=\"comment\">//5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num2); <span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">obj.value = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = obj;</span><br><span class=\"line\">obj2.value += <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.value); <span class=\"comment\">//6</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.value); <span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str2 = str;</span><br><span class=\"line\">str2 += <span class=\"string\">\"4\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">//\"123\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str2); <span class=\"comment\">//\"1234\" 和Swift一样，String不是引用类型</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h3><p>之前提到，JavaScript 中函数的参数是以值来传递的，而永远不是引用。那么，下面这个例子应该输出什么呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeSchool</span>(<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">    person.school = <span class=\"string\">\"Mizzou\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> luyuanwang = &#123;</span><br><span class=\"line\">    school: <span class=\"string\">\"HUST\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">changeSchool(luyuanwang);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(luyuanwang.school);</span><br></pre></td></tr></table></figure>\n<p>答案是“Mizzou”。看起来很奇怪，似乎不符合我们说传递的是值，而更像是在传递引用？其实，这里传递的值，是指把“对象”复制一遍。这里的对象是一个引用，那么就把这个指针复制了，因此这里是两个不同的、指向同一个地址的引用。所谓的传递的是值，并不是指把内存中的对象复制一遍，这里要搞清楚。</p>\n<h3 id=\"没有块级作用域\"><a href=\"#没有块级作用域\" class=\"headerlink\" title=\"没有块级作用域\"></a>没有块级作用域</h3><p>虽然函数会创建局部的执行环境，但是花括号封闭的代码块并没有自己的执行环境：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num); <span class=\"comment\">//10 仍有定义</span></span><br></pre></td></tr></table></figure>\n<p>这和一般的语言都不同。如果想要“正常一点”，可以使用 ES6 中引入的关键字 let：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num); <span class=\"comment\">//ReferenceError: num is not defined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"垃圾收集\"><a href=\"#垃圾收集\" class=\"headerlink\" title=\"垃圾收集\"></a>垃圾收集</h3><p>JavaScript 是有 GC 的，通过“标记清除“的方式，周期性地回收垃圾。有些浏览器也曾经使用过引用计数，不过发现有循环引用的问题后，后来就又放弃了。所以一般情况下，我们都不必操心内存的事情。</p>\n<p>通过标记清除算法，GC 将会从根对象开始（根对象是一个全局对象），开始寻找根对象引用的对象，并递归地寻找下去。那些无法触达的对象，将被认为是垃圾对象，会被 GC 回收。从 2012 年开始，所有现代浏览器都使用了标记清除或其改进型算法，即使产生循环引用，照样可以被清除掉。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>之前提到过，JavaScript 是基于原型的语言，这和我们所熟悉的其他语言都不一样。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>在 JS 中，可以使用<strong>原型模式</strong>来创建一个对象（尽管这不是唯一的方法）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Employer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Employer.prototype.name = <span class=\"string\">\"Lei, Jun\"</span>;</span><br><span class=\"line\">Employer.prototype.company = <span class=\"string\">\"Xiao Mi\"</span>;</span><br><span class=\"line\">Employer.prototype.makeSpeech = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Are u ok?\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Employer();</span><br><span class=\"line\">person.makeSpeech(); <span class=\"comment\">//Are u ok?</span></span><br></pre></td></tr></table></figure>\n<p>Employer 和普通的方法没有任何区别，但是如果在调用的时候使用了 new 关键字，就会成为一个构造函数。每个函数都有一个 <code>prototype</code> 属性，这个属性指向的就是创造出来的实例的原型对象。</p>\n<h3 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h3><p>原型最初会包含一个 constructor，指向它的构造函数。也就是 Employer.prototype.constructor 就是 Employer。每个对象也都有一个 <code>[[Prototype]]</code> 属性来指向原型对象，但这个属性是私有的，不能通过外界访问。不过在有一些浏览器（比如 Safari 和 Chrome 中），提供了一个 <code>__proto__</code> 属性来访问原型。</p>\n<p>如果你修改属性的值，其实只是对变量创建了一个新的属性，屏蔽掉了在对象原型中查找的操作。在多数情况下，这都没什么问题，但如果原型对象中放置了一个引用类型的属性，那么原型共享的特性就会导致问题了。为了解决这个问题，可以用普通的构造函数构造属性，而用原型构造方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Employer</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Employer.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Employer,</span><br><span class=\"line\">    makeSpeech: () =&gt; &#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'Are u ok?'</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Employer(<span class=\"string\">'Lei, Jun'</span>);</span><br><span class=\"line\">person.makeSpeech();</span><br></pre></td></tr></table></figure>\n<h3 id=\"终于来到原型链\"><a href=\"#终于来到原型链\" class=\"headerlink\" title=\"终于来到原型链\"></a>终于来到原型链</h3><p>如果我们修改掉 prototype，把它指向一个实例，那么在搜索属性和方法的时候，就会一层一层地搜索下去，也就间接地实现了继承。每个对象都有原型对象，原型对象又有自己的原型对象，从而构成了一个原型链。原型链的最后一环是 null，null 没有原型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sex = <span class=\"string\">\"male\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.job = <span class=\"string\">\"programmer\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Father();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.sex); <span class=\"comment\">//male 通过查找原型的属性找到</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.job); <span class=\"comment\">//programmer 自己的属性</span></span><br></pre></td></tr></table></figure>\n<p>不过直接使用原型链是有缺陷的。首先，由于原型是共享的，那么含有引用类型属性的原型就会出问题。而且，不能在子类中向父类的构造函数中传递参数。为了解决这些问题，程序员们想出了很多方法。不过，现在我们有个 ES6，可以使用 ES6 的新关键字 <code>class</code> 来定义类了。但这只是语法糖，并没有改变 JS 基于原型的事实。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = <span class=\"string\">\"male\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(job) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.job = job;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Son(<span class=\"string\">\"programmer\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.sex); <span class=\"comment\">//male</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.job); <span class=\"comment\">//programmer</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript-基础分享\"><a href=\"#JavaScript-基础分享\" class=\"headerlink\" title=\"JavaScript 基础分享\"></a>JavaScript 基础分享</h1><blockquote>\n<p>Any application that can be written in JavaScript, will eventually be written in JavaScript.</p>\n</blockquote>\n<h2 id=\"JS-简介\"><a href=\"#JS-简介\" class=\"headerlink\" title=\"JS 简介\"></a>JS 简介</h2><p>JavaScript 是一门动态的、弱类型的、基于原型（而不是基于类）的解释型（或 JIT 编译型）语言。它是一门多范式语言，支持命令式、面向对象，以及函数式编程。语言本身不支持 I/O 操作，而是依赖于宿主环境。现在，JS 不仅可以在浏览器中运行，也可以运行在 Node 等非浏览器环境中。</p>\n<p>JS 是一门单线程语言，这意味着在浏览器中，JS 代码只能在 JS 引擎线程中执行。但这并不意味着耗时操作（如 HTTP 请求）会把界面卡死，因为浏览器本身是可以开启多线程的。在 HTML 5 中，可以通过 Web Workers 来在多个线程中执行 JS 代码，但这和“JS 是单线程语言”并不冲突。因为多个 worker 之间并不共享资源，而只能通过 message 来通信。</p>\n<p>JavaScript 已由 ECMA 进行了标准化，这个标准被称为 ECMAScript。JavaScript 是 ECMAScript 的一种实现，但在绝大多数情况下，这两个词是可以互换的。每年的 6 月，ECMA 都会发布一个新标准，不过大家通常使用 ES6 来指代 ES2015 及以后的版本，泛指“下一代 JavaScript”。在《JavaScript 高级程序设计》这本书中，讲解的是 ES5。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>JavaScript 的变量是松散类型的，一个变量可以用来保存任意类型的值。如果没有被初始化，那么变量就会保存一个特殊的值 <code>undefined</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//5</span></span><br><span class=\"line\">a = <span class=\"string\">'hello world!'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//hello world!</span></span><br></pre></td></tr></table></figure>\n<p>声明变量需要使用 var 操作符，但是如果不使用，不仅不会报错，反而变量会变成全局变量，不鼓励这种行为。</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>JavaScript 中有 5 种基本数据类型：</p>\n<ul>\n<li>Undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>String</li>\n</ul>\n<p>和一种复杂类型：</p>\n<ul>\n<li>Object</li>\n</ul>\n<p>之前提到，JavaScript 不是基于类的，因此它也不支持创建自定义的类型。所有值都将是上述的 6 种类型之一。虽然在 ES6 中引入了 <code>class</code>，但这只是语法糖而已。</p>\n<p>可以使用 <code>typeof</code> 操作符来判断类型。typeof 操作符会返回一些字符串：</p>\n<ul>\n<li>“undefined”</li>\n<li>“boolean”</li>\n<li>“string”</li>\n<li>“number”</li>\n<li>“object”</li>\n<li>“function”</li>\n</ul>\n<p>函数在 JS 中也是对象，但是 typeof 操作符还是会把函数和普通对象作出区分。</p>\n<p>还有比较神奇的一点是，虽然 Null 类型只有一个特殊的值 null，但是 <code>typeof null</code> 返回的却是 <code>&quot;object&quot;</code>，这是因为 null 表示一个<strong>空对象</strong>指针。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"string\">\"hello?\"</span>); <span class=\"comment\">//\"string\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> foo); <span class=\"comment\">//\"function\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span>(<span class=\"literal\">null</span>)); <span class=\"comment\">//\"object\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"关系操作符\"><a href=\"#关系操作符\" class=\"headerlink\" title=\"关系操作符\"></a>关系操作符</h3><p>关系操作符遇到非数值类型时，会发生一些比较神奇的事情，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"23\"</span> &lt; <span class=\"string\">\"3\"</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"string\">\"23\"</span> &lt; <span class=\"number\">3</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"string\">\"a\"</span> &lt; <span class=\"number\">3</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"string\">\"a\"</span> &gt;= <span class=\"number\">3</span> <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>首先，两个字符串比较的是字符编码值。字符”2”的编码值小于”3”，因此是 true。</p>\n<p>但是，如果一边是数值，则另一边会被转化成数值再做比较。”23” 会被转化成 23，所以返回 false。</p>\n<p>但是第三行和第四行中，”a” 转化成数值会变成 NaN。NaN 与任何数值比较都会返回 false，所以会出现既不大于，也不等于，还不小于的情况。</p>\n<p>如果操作数是对象，则会先调用 <code>valueOf()</code> 方法。如果没有这个方法，则会调用 <code>toString()</code> 再根据之前的标准比较。</p>\n<h3 id=\"相等操作符\"><a href=\"#相等操作符\" class=\"headerlink\" title=\"相等操作符\"></a>相等操作符</h3><p>JavaScript 中有两种比较：<code>==</code> 和 <code>===</code>。</p>\n<p>使用 <code>==</code>，会在比较前先做类型转换，而 <code>===</code> 直接比较。由于 JS 臭名昭著的蜜汁类型转换会带来各种各样的奇怪现象，强烈建议经常使用 === 做全等判断。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span> == <span class=\"string\">'5'</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"number\">1</span> <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"number\">2</span> <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span> <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>想彻底搞懂？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&#123;&#125;] + [] === <span class=\"string\">\"[object Object]\"</span> <span class=\"comment\">//true 😊</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">25</span>[[[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">0</span>] + [[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]+ [[] + []][<span class=\"number\">0</span>][([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">5</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[][<span class=\"number\">0</span>]+[]][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[[] == []][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">3</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[][<span class=\"number\">0</span>]+[]][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">5</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>])][[[][<span class=\"number\">0</span>]+[]][<span class=\"number\">0</span>][<span class=\"number\">1</span>] + [[[] == []][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>] + [<span class=\"number\">0</span>[([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">5</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[][<span class=\"number\">0</span>]+[]][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[[] == []][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">3</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[][<span class=\"number\">0</span>]+[]][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">5</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">0</span>]) + ([[&#123;&#125;] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>]) + ([[+[] == +[]][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">1</span>])]+[]][<span class=\"number\">0</span>][<span class=\"number\">11</span>] +  [[[] == []][<span class=\"number\">0</span>] + []][<span class=\"number\">0</span>][<span class=\"number\">4</span>]]](<span class=\"number\">30</span>) <span class=\"comment\">//\"p\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"for-in\"><a href=\"#for-in\" class=\"headerlink\" title=\"for-in\"></a>for-in</h3><p>和其他语言不一样，我们可以使用 for-in 循环来遍历对象的属性名，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">person.name = <span class=\"string\">\"Luyuan Wang\"</span>;</span><br><span class=\"line\">person.age = <span class=\"number\">20</span>;</span><br><span class=\"line\">person.school = <span class=\"string\">\"Huazhong University of Science and Technology\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> propName <span class=\"keyword\">in</span> person) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(propName);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//name</span></span><br><span class=\"line\"><span class=\"comment\">//age</span></span><br><span class=\"line\"><span class=\"comment\">//school</span></span><br></pre></td></tr></table></figure>\n<p>这个顺序是不保证的。</p>\n<p>如果遍历的对象是数组，那么取出来的是数组下标，而不是元素，这个跟 Objective-C 或者 Swift 等语言都不一样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> each <span class=\"keyword\">in</span> list) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(each);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<p>因此，上面代码的 each 更应该被命名为 index。</p>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>JavaScript 的函数不用定义返回值类型，甚至有没有返回值都不是确定的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">divide</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a / b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(divide(<span class=\"number\">1</span>, <span class=\"number\">0</span>)); <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p>JavaScript 函数的参数是通过数组来访问的（只是类似数组，但并不是 Array 的实例），因此它并不关心你传入多少个变量，更不关心变量的类型。你甚至可以通过 arguments + 下标来访问参数，参数名其实只是一种便利：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]); <span class=\"comment\">//很像数组</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(<span class=\"string\">'hello world!'</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(array)); <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.isArray(<span class=\"built_in\">arguments</span>)); <span class=\"comment\">//false 并不是Array的实例</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo();</span><br></pre></td></tr></table></figure>\n<p>这和 OC 中用函数参数名、参数类型等作为函数签名有很大区别。需要注意的是，JavaScript 的参数传递的永远是值，而不是引用（这点在后面会再次提及）。</p>\n<p>JavaScript 中的函数不支持重载，但是可以利用 <code>arguments.length</code> 判断参数个数，从而表现出不同的行为。</p>\n<h2 id=\"变量、作用域和内存问题\"><a href=\"#变量、作用域和内存问题\" class=\"headerlink\" title=\"变量、作用域和内存问题\"></a>变量、作用域和内存问题</h2><h3 id=\"基本类型和引用类型的值\"><a href=\"#基本类型和引用类型的值\" class=\"headerlink\" title=\"基本类型和引用类型的值\"></a>基本类型和引用类型的值</h3><p>尽管 JavaScript 是松散类型的，但变量的值还是分为基本类型的值和引用类型的值。前面提到的 5 种基本类型是按值访问的，而 Object 类型操作的是引用。和许多其他的语言不同，String 是基本类型值，而不是引用，这和 Swift 很像。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> num2 = num;</span><br><span class=\"line\">num2 += <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num); <span class=\"comment\">//5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num2); <span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">obj.value = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = obj;</span><br><span class=\"line\">obj2.value += <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.value); <span class=\"comment\">//6</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj2.value); <span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str2 = str;</span><br><span class=\"line\">str2 += <span class=\"string\">\"4\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str); <span class=\"comment\">//\"123\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str2); <span class=\"comment\">//\"1234\" 和Swift一样，String不是引用类型</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数参数\"><a href=\"#函数参数\" class=\"headerlink\" title=\"函数参数\"></a>函数参数</h3><p>之前提到，JavaScript 中函数的参数是以值来传递的，而永远不是引用。那么，下面这个例子应该输出什么呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeSchool</span>(<span class=\"params\">person</span>) </span>&#123;</span><br><span class=\"line\">    person.school = <span class=\"string\">\"Mizzou\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> luyuanwang = &#123;</span><br><span class=\"line\">    school: <span class=\"string\">\"HUST\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">changeSchool(luyuanwang);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(luyuanwang.school);</span><br></pre></td></tr></table></figure>\n<p>答案是“Mizzou”。看起来很奇怪，似乎不符合我们说传递的是值，而更像是在传递引用？其实，这里传递的值，是指把“对象”复制一遍。这里的对象是一个引用，那么就把这个指针复制了，因此这里是两个不同的、指向同一个地址的引用。所谓的传递的是值，并不是指把内存中的对象复制一遍，这里要搞清楚。</p>\n<h3 id=\"没有块级作用域\"><a href=\"#没有块级作用域\" class=\"headerlink\" title=\"没有块级作用域\"></a>没有块级作用域</h3><p>虽然函数会创建局部的执行环境，但是花括号封闭的代码块并没有自己的执行环境：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num); <span class=\"comment\">//10 仍有定义</span></span><br></pre></td></tr></table></figure>\n<p>这和一般的语言都不同。如果想要“正常一点”，可以使用 ES6 中引入的关键字 let：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> num = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num); <span class=\"comment\">//ReferenceError: num is not defined</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"垃圾收集\"><a href=\"#垃圾收集\" class=\"headerlink\" title=\"垃圾收集\"></a>垃圾收集</h3><p>JavaScript 是有 GC 的，通过“标记清除“的方式，周期性地回收垃圾。有些浏览器也曾经使用过引用计数，不过发现有循环引用的问题后，后来就又放弃了。所以一般情况下，我们都不必操心内存的事情。</p>\n<p>通过标记清除算法，GC 将会从根对象开始（根对象是一个全局对象），开始寻找根对象引用的对象，并递归地寻找下去。那些无法触达的对象，将被认为是垃圾对象，会被 GC 回收。从 2012 年开始，所有现代浏览器都使用了标记清除或其改进型算法，即使产生循环引用，照样可以被清除掉。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><p>之前提到过，JavaScript 是基于原型的语言，这和我们所熟悉的其他语言都不一样。</p>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>在 JS 中，可以使用<strong>原型模式</strong>来创建一个对象（尽管这不是唯一的方法）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Employer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Employer.prototype.name = <span class=\"string\">\"Lei, Jun\"</span>;</span><br><span class=\"line\">Employer.prototype.company = <span class=\"string\">\"Xiao Mi\"</span>;</span><br><span class=\"line\">Employer.prototype.makeSpeech = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Are u ok?\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Employer();</span><br><span class=\"line\">person.makeSpeech(); <span class=\"comment\">//Are u ok?</span></span><br></pre></td></tr></table></figure>\n<p>Employer 和普通的方法没有任何区别，但是如果在调用的时候使用了 new 关键字，就会成为一个构造函数。每个函数都有一个 <code>prototype</code> 属性，这个属性指向的就是创造出来的实例的原型对象。</p>\n<h3 id=\"原型对象\"><a href=\"#原型对象\" class=\"headerlink\" title=\"原型对象\"></a>原型对象</h3><p>原型最初会包含一个 constructor，指向它的构造函数。也就是 Employer.prototype.constructor 就是 Employer。每个对象也都有一个 <code>[[Prototype]]</code> 属性来指向原型对象，但这个属性是私有的，不能通过外界访问。不过在有一些浏览器（比如 Safari 和 Chrome 中），提供了一个 <code>__proto__</code> 属性来访问原型。</p>\n<p>如果你修改属性的值，其实只是对变量创建了一个新的属性，屏蔽掉了在对象原型中查找的操作。在多数情况下，这都没什么问题，但如果原型对象中放置了一个引用类型的属性，那么原型共享的特性就会导致问题了。为了解决这个问题，可以用普通的构造函数构造属性，而用原型构造方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Employer</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Employer.prototype = &#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>: Employer,</span><br><span class=\"line\">    makeSpeech: () =&gt; &#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">'Are u ok?'</span>)&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Employer(<span class=\"string\">'Lei, Jun'</span>);</span><br><span class=\"line\">person.makeSpeech();</span><br></pre></td></tr></table></figure>\n<h3 id=\"终于来到原型链\"><a href=\"#终于来到原型链\" class=\"headerlink\" title=\"终于来到原型链\"></a>终于来到原型链</h3><p>如果我们修改掉 prototype，把它指向一个实例，那么在搜索属性和方法的时候，就会一层一层地搜索下去，也就间接地实现了继承。每个对象都有原型对象，原型对象又有自己的原型对象，从而构成了一个原型链。原型链的最后一环是 null，null 没有原型。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sex = <span class=\"string\">\"male\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Son</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.job = <span class=\"string\">\"programmer\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype = <span class=\"keyword\">new</span> Father();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Son();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.sex); <span class=\"comment\">//male 通过查找原型的属性找到</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.job); <span class=\"comment\">//programmer 自己的属性</span></span><br></pre></td></tr></table></figure>\n<p>不过直接使用原型链是有缺陷的。首先，由于原型是共享的，那么含有引用类型属性的原型就会出问题。而且，不能在子类中向父类的构造函数中传递参数。为了解决这些问题，程序员们想出了很多方法。不过，现在我们有个 ES6，可以使用 ES6 的新关键字 <code>class</code> 来定义类了。但这只是语法糖，并没有改变 JS 基于原型的事实。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sex = <span class=\"string\">\"male\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Son</span> <span class=\"keyword\">extends</span> <span class=\"title\">Father</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(job) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.job = job;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person = <span class=\"keyword\">new</span> Son(<span class=\"string\">\"programmer\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.sex); <span class=\"comment\">//male</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.job); <span class=\"comment\">//programmer</span></span><br></pre></td></tr></table></figure>"},{"title":"JS调用Swift造成卡顿问题","date":"2019-02-15T10:33:12.000Z","_content":"\n# JS调用Swift造成卡顿问题\n\n最近正在构思一个新的项目，是一个控制蓝牙外设的 App，主要目标用户是电子爱好者，或者是做课程设计的大学生。这部分人群往往有一定的编程能力，但学习开发一款移动应用的成本又太高了。比如，如果希望用手机控制蓝牙小车，在这个小众场景下，这款 App 就会有用武之地了。\n\n## 背景\n\n鉴于目标用户是有一定编程能力的（毕竟蓝牙外设端还需要自己编程），为了增加 App 控制的灵活性，我就考虑增加一个通过 JavaScript 脚本自定义蓝牙收发逻辑的功能。这个想法也是受到钟大 JSBox 的启发。但有一个问题就是，如果用户编写的脚本包含耗时很久的循环，甚至死循环，比如用户想让蓝牙小车永远沿矩形运动，就可能会编出这样的代码：\n\n```javascript\nwhile (true) {\n    send_message(\"move forward\"); //通过蓝牙发送前进指令，小车接收到之后前进\n    //注意非浏览器环境没有setTimeOut函数\n    for (var i=0; i<10000000000; i++); //通过空循环延迟一段时间\n    send_message(\"turn left\"); //左转\n    for (var i=0; i<10000000000; i++); //延迟，并不断重复\n}\n```\n\n一旦写出了这样的死循环，那么 App 的主线程就全部用来执行 JavaScript 代码，从而完全卡死。用户当然能达到他的需求——毕竟蓝牙消息在不断发送，但是完全卡死的 App 就再也无法使用了，用户体验极差。在当前版本的 JSBox 中，运行死循环也会造成卡死现象，只能强制退出 App。\n\n## 开辟后台线程\n\n既然死循环会把主线程卡死，那么我们在后台执行 JavaScript 不就解决这个问题了么？这是一个非常直观的想法，我也很快写出了这样的代码：\n\n```swift\nwork = DispatchWorkItem { [unowned self] in\n\tself.jsvm = JSVirtualMachine()\n\tself.context = self.generateJSContext(vm: self.jsvm!)\n\tself.context?.evaluateScript(code)\n}\nDispatchQueue.global().async(execute: work!)\n```\n\n这里要注意的一点是，如果需要在多线程中使用 JavaScriptCore，则需要给每个线程一个自己的 JS 虚拟机。否则，JS 虚拟机永远都会执行完上一次的程序，再来执行新加入的程序。\n\n然后，我编写了这样的 JavaScript 代码来测试效果，看是不是不会卡死主线程了：\n\n```javascript\nwhile (true) {\n    for (var i=0; i<10000000000; i++); //延时一段时间\n    toast(\"Hello JS!\"); \n}\n```\n\n`toast` 函数会回调 Swift 代码，从而在屏幕上弹出一段消息。当然，UIKit 不是线程安全的，所以在回调函数中必须回到主线程操作 UI：\n\n```swift\nfunc toast(_ msg: JSValue) {\n\tDispatchQueue.main.async {\n    \tToast.show(string: msg.toString(), type: .js)\n    }\n}\n```\n\n写完这段天衣无缝的程序，我就很开心的去执行上面的那段测试代码了。果然，程序运行那段耗时空循环的时候，ScrollView 还可以顺畅的滚动，看来真的不会卡顿了。“我是天才！”，我心里默想。\n\n但是好景不长！当 App 第一次展示了那条 toast 之后，主线程瞬间变得非常卡顿——没有完全卡死，偶尔还能相应输入，但是反应速度慢到了完全不可操作的地步。这是为什么呢？\n\n## 分析问题原因\n\n第一个想法当然是要看看卡顿的点在哪里，我首先在主线程的代码块里加入了一些调试代码。别忘了 print 不是线程安全的，这里最好使用 NSLog，而且 NSLog 还自带线程 id 号，很适合调试多线程程序。\n\n```swift\nfunc toast(_ msg: JSValue) {\n\tDispatchQueue.main.async {\n        //NSLog\n    \tToast.show(string: msg.toString(), type: .js)\n        //NSLog\n    }\n}\n```\n\n这时我发现，两次 Log 之间间隔了很久，显然是这里发生了卡顿。而第二次 Log 结束后，很快就又打印出了第一条 Log，仿佛 JS 里面那条空循环不耗时一样，问题变得蹊跷起来。\n\n会不会是 Toast.show 函数用时太久了呢？我干脆把这个函数注释成了空函数，但完全没有影响。看来是有什么隐蔽的操作在耗时，而不是这个函数本身。而奇怪的是，当我把 JS 里空循环的循环次数增加后，两次 Log 的间隔竟然也跟着变长了，这就有点让我摸不到头脑。毕竟，JS 代码是在另一个线程里面运行的，怎么会影响到我这短短两行的主线程代码块呢？\n\n为了找到原因，我干脆监听了 RunLoop 状态。毕竟这段代码块是给主线程这个串行队列队尾的，如果主线程在忙于处理什么事情，这段代码执行的时间就会变晚。结果发现卡顿点确实发生在 RunLoop 处理 source0 的阶段，但这并没有给我什么启发。\n\n## 调试\n\n现在 Swift 级别的代码调试已经看不出来问题在哪了，只好进入汇编级别调试一下，看看这段时间主线程到底在忙些什么。Xcode 用的编译器是 llvm，调试器自然就是 lldb。lldb 的命令和 gdb 很像（毕竟当时就是为了替换 gdb 才搞出来的），使用 `stepi` 命令可以 step into 到下一个指令。\n\n![屏幕快照 2019-02-15 17.06.33](/img/JS调用Swift卡顿/screenshot.png)\n\n很快我就发现，我调用的 `toString` 函数中，有些加锁的操作。这里就非常值得警惕了。好在，JSCore 其实是开源的，我们可以去 Github 上看一下 JSCore 的源代码：\n\n```objective-c\nid valueToString(JSGlobalContextRef context, JSValueRef value, JSValueRef* exception)\n{\n    ASSERT(!*exception);\n    if (id wrapped = tryUnwrapObjcObject(context, value)) { \n        if ([wrapped isKindOfClass:[NSString class]])\n            return wrapped;\n    }\n\t//...\n}\n```\n\n上面是 JSCore 源码中，toString 函数调用的一个函数。我们可以看到，它果然继续调用了刚刚汇编代码中 `tryUnwrapObjcObject` 函数。我们继续找到 `tryUnwrapObjcObject` 函数的源码：\n\n```objective-c\nid tryUnwrapObjcObject(JSGlobalContextRef context, JSValueRef value)\n{\n    //...\n    JSC::JSLockHolder locker(toJS(context));\n    //...\n    return nil;\n}\n```\n\n可以看到，这个函数中给 JS 的上下文环境加了锁。\n\n继续阅读源码，有一段注释解释了为什么要给 context 加锁：\n\n```\n// This is fairly nasty.  We allow multiple threads to run on the same\n// context, and we do not require any locking semantics in doing so -\n// clients of the API may simply use the context from multiple threads\n// concurently, and assume this will work.  In order to make this work,\n// We lock the context when a thread enters, and unlock it when it leaves.\n// However we do not only unlock when the thread returns from its\n// entry point (evaluate script or call function), we also unlock the\n// context if the thread leaves JSC by making a call out to an external\n// function through a callback.\n```\n\n可以看到，这是为了保证线程安全而做的工作，而且，在线程切换的时候也会加锁/解锁！\n\n## 原理（猜测）\n\n所以对于发生卡顿的原因，我做如下猜测（不敢 100% 确定）：\n\n最开始，JS 执行延时循环的时候，是正常在子线程里运行的，所以主线程不卡顿，一切都相安无事。\n\n在调用 `toast` 函数的时候，发生了线程切换。这个时候，JSCore 会给 context 加锁，然后瞬间返回，解锁继续给 JS 代码使用。接着，代码块被闲下来的主线程执行了。由于 `toString` 函数在主线程运行，所以它必须要等到 JSCore 把 context 解锁才能执行。这个时候，由于代码块是异步执行的，所以子线程又开始回去执行耗时循环了。而正在执行的 JavaScript 是不会释放锁的，所以主线程只好等待——造成了卡顿现象。\n\n终于，JS 代码跑完了耗时循环，JS 代码释放了锁，主线程终于能运行了。主线程很快执行完显示 toast 的函数，然后释放，让 JS 能继续跑。这也解释了为什么增加循环次数也会影响卡顿时间。但是，这个时候主线程执行的还是上一次的 toast 请求，而这已经是第二次 JS 完成耗时循环了。所以，JS 又会把一个代码块加到主队列中…而只有第三次的时候，主线程才能等到资源，完成第二次的请求……如此反复，主线程虽然总有一点机会执行代码而不至于被饿死，但是多数时间都处于等待资源的状态，导致异常的卡顿。\n\n## 验证\n\n我写了一段 JS 代码来验证我的猜测：\n\n```javascript\nvar count = 0;\nwhile (true) {\n    for (var i=0; i<10000000000; i++); //延时一段时间\n    if (count == 0) {\n        toast(\"Hello JS!\"); \n        count++;\n    }\n}\n```\n\n这样，只调用主线程一次。按照上面的分析，一直再次发生线程切换，JS 就一直持有锁而不释放，主线程就永远没有机会执行。经验证，主线程确实完全卡死，等再久也没有反应。主线程被饿死，验证成功。\n\n我又把 Swift 代码块改成同步代码块。这样，JS 要等待主线程执行完才能继续执行，而主线程又需要 JS 线程再次调用才能完成，因此会发生死锁。经验证，主线程完全卡死，再次验证成功。\n\n## 改正与总结\n\n有了以上分析，改正变得非常容易：\n\n```swift\nfunc toast(_ msg: JSValue) {\n    let str = msg.toString()\n\tDispatchQueue.main.async {\n    \tToast.show(string: str, type: .js)\n    }\n}\n```\n\n只需要把 `toString` 放在子线程中执行，就不存在主线程等待资源的问题了。可见，写代码时的一念之差，就会需要我花很久来调试、分析。如果最开始随手一写就写成正确的样子，就能省下大把的时间了。但话说回来，也就规避了问题。问题暴露出来，才能让我有机会深入学习。这也正是经验的来源吧。","source":"_posts/JS调用Swift造成卡顿问题.md","raw":"---\ntitle: JS调用Swift造成卡顿问题\ndate: 2019-02-15 18:33:12\ntags: JSCore\n---\n\n# JS调用Swift造成卡顿问题\n\n最近正在构思一个新的项目，是一个控制蓝牙外设的 App，主要目标用户是电子爱好者，或者是做课程设计的大学生。这部分人群往往有一定的编程能力，但学习开发一款移动应用的成本又太高了。比如，如果希望用手机控制蓝牙小车，在这个小众场景下，这款 App 就会有用武之地了。\n\n## 背景\n\n鉴于目标用户是有一定编程能力的（毕竟蓝牙外设端还需要自己编程），为了增加 App 控制的灵活性，我就考虑增加一个通过 JavaScript 脚本自定义蓝牙收发逻辑的功能。这个想法也是受到钟大 JSBox 的启发。但有一个问题就是，如果用户编写的脚本包含耗时很久的循环，甚至死循环，比如用户想让蓝牙小车永远沿矩形运动，就可能会编出这样的代码：\n\n```javascript\nwhile (true) {\n    send_message(\"move forward\"); //通过蓝牙发送前进指令，小车接收到之后前进\n    //注意非浏览器环境没有setTimeOut函数\n    for (var i=0; i<10000000000; i++); //通过空循环延迟一段时间\n    send_message(\"turn left\"); //左转\n    for (var i=0; i<10000000000; i++); //延迟，并不断重复\n}\n```\n\n一旦写出了这样的死循环，那么 App 的主线程就全部用来执行 JavaScript 代码，从而完全卡死。用户当然能达到他的需求——毕竟蓝牙消息在不断发送，但是完全卡死的 App 就再也无法使用了，用户体验极差。在当前版本的 JSBox 中，运行死循环也会造成卡死现象，只能强制退出 App。\n\n## 开辟后台线程\n\n既然死循环会把主线程卡死，那么我们在后台执行 JavaScript 不就解决这个问题了么？这是一个非常直观的想法，我也很快写出了这样的代码：\n\n```swift\nwork = DispatchWorkItem { [unowned self] in\n\tself.jsvm = JSVirtualMachine()\n\tself.context = self.generateJSContext(vm: self.jsvm!)\n\tself.context?.evaluateScript(code)\n}\nDispatchQueue.global().async(execute: work!)\n```\n\n这里要注意的一点是，如果需要在多线程中使用 JavaScriptCore，则需要给每个线程一个自己的 JS 虚拟机。否则，JS 虚拟机永远都会执行完上一次的程序，再来执行新加入的程序。\n\n然后，我编写了这样的 JavaScript 代码来测试效果，看是不是不会卡死主线程了：\n\n```javascript\nwhile (true) {\n    for (var i=0; i<10000000000; i++); //延时一段时间\n    toast(\"Hello JS!\"); \n}\n```\n\n`toast` 函数会回调 Swift 代码，从而在屏幕上弹出一段消息。当然，UIKit 不是线程安全的，所以在回调函数中必须回到主线程操作 UI：\n\n```swift\nfunc toast(_ msg: JSValue) {\n\tDispatchQueue.main.async {\n    \tToast.show(string: msg.toString(), type: .js)\n    }\n}\n```\n\n写完这段天衣无缝的程序，我就很开心的去执行上面的那段测试代码了。果然，程序运行那段耗时空循环的时候，ScrollView 还可以顺畅的滚动，看来真的不会卡顿了。“我是天才！”，我心里默想。\n\n但是好景不长！当 App 第一次展示了那条 toast 之后，主线程瞬间变得非常卡顿——没有完全卡死，偶尔还能相应输入，但是反应速度慢到了完全不可操作的地步。这是为什么呢？\n\n## 分析问题原因\n\n第一个想法当然是要看看卡顿的点在哪里，我首先在主线程的代码块里加入了一些调试代码。别忘了 print 不是线程安全的，这里最好使用 NSLog，而且 NSLog 还自带线程 id 号，很适合调试多线程程序。\n\n```swift\nfunc toast(_ msg: JSValue) {\n\tDispatchQueue.main.async {\n        //NSLog\n    \tToast.show(string: msg.toString(), type: .js)\n        //NSLog\n    }\n}\n```\n\n这时我发现，两次 Log 之间间隔了很久，显然是这里发生了卡顿。而第二次 Log 结束后，很快就又打印出了第一条 Log，仿佛 JS 里面那条空循环不耗时一样，问题变得蹊跷起来。\n\n会不会是 Toast.show 函数用时太久了呢？我干脆把这个函数注释成了空函数，但完全没有影响。看来是有什么隐蔽的操作在耗时，而不是这个函数本身。而奇怪的是，当我把 JS 里空循环的循环次数增加后，两次 Log 的间隔竟然也跟着变长了，这就有点让我摸不到头脑。毕竟，JS 代码是在另一个线程里面运行的，怎么会影响到我这短短两行的主线程代码块呢？\n\n为了找到原因，我干脆监听了 RunLoop 状态。毕竟这段代码块是给主线程这个串行队列队尾的，如果主线程在忙于处理什么事情，这段代码执行的时间就会变晚。结果发现卡顿点确实发生在 RunLoop 处理 source0 的阶段，但这并没有给我什么启发。\n\n## 调试\n\n现在 Swift 级别的代码调试已经看不出来问题在哪了，只好进入汇编级别调试一下，看看这段时间主线程到底在忙些什么。Xcode 用的编译器是 llvm，调试器自然就是 lldb。lldb 的命令和 gdb 很像（毕竟当时就是为了替换 gdb 才搞出来的），使用 `stepi` 命令可以 step into 到下一个指令。\n\n![屏幕快照 2019-02-15 17.06.33](/img/JS调用Swift卡顿/screenshot.png)\n\n很快我就发现，我调用的 `toString` 函数中，有些加锁的操作。这里就非常值得警惕了。好在，JSCore 其实是开源的，我们可以去 Github 上看一下 JSCore 的源代码：\n\n```objective-c\nid valueToString(JSGlobalContextRef context, JSValueRef value, JSValueRef* exception)\n{\n    ASSERT(!*exception);\n    if (id wrapped = tryUnwrapObjcObject(context, value)) { \n        if ([wrapped isKindOfClass:[NSString class]])\n            return wrapped;\n    }\n\t//...\n}\n```\n\n上面是 JSCore 源码中，toString 函数调用的一个函数。我们可以看到，它果然继续调用了刚刚汇编代码中 `tryUnwrapObjcObject` 函数。我们继续找到 `tryUnwrapObjcObject` 函数的源码：\n\n```objective-c\nid tryUnwrapObjcObject(JSGlobalContextRef context, JSValueRef value)\n{\n    //...\n    JSC::JSLockHolder locker(toJS(context));\n    //...\n    return nil;\n}\n```\n\n可以看到，这个函数中给 JS 的上下文环境加了锁。\n\n继续阅读源码，有一段注释解释了为什么要给 context 加锁：\n\n```\n// This is fairly nasty.  We allow multiple threads to run on the same\n// context, and we do not require any locking semantics in doing so -\n// clients of the API may simply use the context from multiple threads\n// concurently, and assume this will work.  In order to make this work,\n// We lock the context when a thread enters, and unlock it when it leaves.\n// However we do not only unlock when the thread returns from its\n// entry point (evaluate script or call function), we also unlock the\n// context if the thread leaves JSC by making a call out to an external\n// function through a callback.\n```\n\n可以看到，这是为了保证线程安全而做的工作，而且，在线程切换的时候也会加锁/解锁！\n\n## 原理（猜测）\n\n所以对于发生卡顿的原因，我做如下猜测（不敢 100% 确定）：\n\n最开始，JS 执行延时循环的时候，是正常在子线程里运行的，所以主线程不卡顿，一切都相安无事。\n\n在调用 `toast` 函数的时候，发生了线程切换。这个时候，JSCore 会给 context 加锁，然后瞬间返回，解锁继续给 JS 代码使用。接着，代码块被闲下来的主线程执行了。由于 `toString` 函数在主线程运行，所以它必须要等到 JSCore 把 context 解锁才能执行。这个时候，由于代码块是异步执行的，所以子线程又开始回去执行耗时循环了。而正在执行的 JavaScript 是不会释放锁的，所以主线程只好等待——造成了卡顿现象。\n\n终于，JS 代码跑完了耗时循环，JS 代码释放了锁，主线程终于能运行了。主线程很快执行完显示 toast 的函数，然后释放，让 JS 能继续跑。这也解释了为什么增加循环次数也会影响卡顿时间。但是，这个时候主线程执行的还是上一次的 toast 请求，而这已经是第二次 JS 完成耗时循环了。所以，JS 又会把一个代码块加到主队列中…而只有第三次的时候，主线程才能等到资源，完成第二次的请求……如此反复，主线程虽然总有一点机会执行代码而不至于被饿死，但是多数时间都处于等待资源的状态，导致异常的卡顿。\n\n## 验证\n\n我写了一段 JS 代码来验证我的猜测：\n\n```javascript\nvar count = 0;\nwhile (true) {\n    for (var i=0; i<10000000000; i++); //延时一段时间\n    if (count == 0) {\n        toast(\"Hello JS!\"); \n        count++;\n    }\n}\n```\n\n这样，只调用主线程一次。按照上面的分析，一直再次发生线程切换，JS 就一直持有锁而不释放，主线程就永远没有机会执行。经验证，主线程确实完全卡死，等再久也没有反应。主线程被饿死，验证成功。\n\n我又把 Swift 代码块改成同步代码块。这样，JS 要等待主线程执行完才能继续执行，而主线程又需要 JS 线程再次调用才能完成，因此会发生死锁。经验证，主线程完全卡死，再次验证成功。\n\n## 改正与总结\n\n有了以上分析，改正变得非常容易：\n\n```swift\nfunc toast(_ msg: JSValue) {\n    let str = msg.toString()\n\tDispatchQueue.main.async {\n    \tToast.show(string: str, type: .js)\n    }\n}\n```\n\n只需要把 `toString` 放在子线程中执行，就不存在主线程等待资源的问题了。可见，写代码时的一念之差，就会需要我花很久来调试、分析。如果最开始随手一写就写成正确的样子，就能省下大把的时间了。但话说回来，也就规避了问题。问题暴露出来，才能让我有机会深入学习。这也正是经验的来源吧。","slug":"JS调用Swift造成卡顿问题","published":1,"updated":"2020-01-04T08:16:16.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3v002zljc3hjjd2b7y","content":"<h1 id=\"JS调用Swift造成卡顿问题\"><a href=\"#JS调用Swift造成卡顿问题\" class=\"headerlink\" title=\"JS调用Swift造成卡顿问题\"></a>JS调用Swift造成卡顿问题</h1><p>最近正在构思一个新的项目，是一个控制蓝牙外设的 App，主要目标用户是电子爱好者，或者是做课程设计的大学生。这部分人群往往有一定的编程能力，但学习开发一款移动应用的成本又太高了。比如，如果希望用手机控制蓝牙小车，在这个小众场景下，这款 App 就会有用武之地了。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>鉴于目标用户是有一定编程能力的（毕竟蓝牙外设端还需要自己编程），为了增加 App 控制的灵活性，我就考虑增加一个通过 JavaScript 脚本自定义蓝牙收发逻辑的功能。这个想法也是受到钟大 JSBox 的启发。但有一个问题就是，如果用户编写的脚本包含耗时很久的循环，甚至死循环，比如用户想让蓝牙小车永远沿矩形运动，就可能会编出这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    send_message(<span class=\"string\">\"move forward\"</span>); <span class=\"comment\">//通过蓝牙发送前进指令，小车接收到之后前进</span></span><br><span class=\"line\">    <span class=\"comment\">//注意非浏览器环境没有setTimeOut函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000000000</span>; i++); <span class=\"comment\">//通过空循环延迟一段时间</span></span><br><span class=\"line\">    send_message(<span class=\"string\">\"turn left\"</span>); <span class=\"comment\">//左转</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000000000</span>; i++); <span class=\"comment\">//延迟，并不断重复</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一旦写出了这样的死循环，那么 App 的主线程就全部用来执行 JavaScript 代码，从而完全卡死。用户当然能达到他的需求——毕竟蓝牙消息在不断发送，但是完全卡死的 App 就再也无法使用了，用户体验极差。在当前版本的 JSBox 中，运行死循环也会造成卡死现象，只能强制退出 App。</p>\n<h2 id=\"开辟后台线程\"><a href=\"#开辟后台线程\" class=\"headerlink\" title=\"开辟后台线程\"></a>开辟后台线程</h2><p>既然死循环会把主线程卡死，那么我们在后台执行 JavaScript 不就解决这个问题了么？这是一个非常直观的想法，我也很快写出了这样的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">work = <span class=\"type\">DispatchWorkItem</span> &#123; [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>] <span class=\"keyword\">in</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.jsvm = <span class=\"type\">JSVirtualMachine</span>()</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.context = <span class=\"keyword\">self</span>.generateJSContext(vm: <span class=\"keyword\">self</span>.jsvm!)</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.context?.evaluateScript(code)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async(execute: work!)</span><br></pre></td></tr></table></figure>\n<p>这里要注意的一点是，如果需要在多线程中使用 JavaScriptCore，则需要给每个线程一个自己的 JS 虚拟机。否则，JS 虚拟机永远都会执行完上一次的程序，再来执行新加入的程序。</p>\n<p>然后，我编写了这样的 JavaScript 代码来测试效果，看是不是不会卡死主线程了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000000000</span>; i++); <span class=\"comment\">//延时一段时间</span></span><br><span class=\"line\">    toast(<span class=\"string\">\"Hello JS!\"</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>toast</code> 函数会回调 Swift 代码，从而在屏幕上弹出一段消息。当然，UIKit 不是线程安全的，所以在回调函数中必须回到主线程操作 UI：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toast</span><span class=\"params\">(<span class=\"number\">_</span> msg: JSValue)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">    \t<span class=\"type\">Toast</span>.show(string: msg.<span class=\"built_in\">toString</span>(), type: .js)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写完这段天衣无缝的程序，我就很开心的去执行上面的那段测试代码了。果然，程序运行那段耗时空循环的时候，ScrollView 还可以顺畅的滚动，看来真的不会卡顿了。“我是天才！”，我心里默想。</p>\n<p>但是好景不长！当 App 第一次展示了那条 toast 之后，主线程瞬间变得非常卡顿——没有完全卡死，偶尔还能相应输入，但是反应速度慢到了完全不可操作的地步。这是为什么呢？</p>\n<h2 id=\"分析问题原因\"><a href=\"#分析问题原因\" class=\"headerlink\" title=\"分析问题原因\"></a>分析问题原因</h2><p>第一个想法当然是要看看卡顿的点在哪里，我首先在主线程的代码块里加入了一些调试代码。别忘了 print 不是线程安全的，这里最好使用 NSLog，而且 NSLog 还自带线程 id 号，很适合调试多线程程序。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toast</span><span class=\"params\">(<span class=\"number\">_</span> msg: JSValue)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">        <span class=\"comment\">//NSLog</span></span><br><span class=\"line\">    \t<span class=\"type\">Toast</span>.show(string: msg.<span class=\"built_in\">toString</span>(), type: .js)</span><br><span class=\"line\">        <span class=\"comment\">//NSLog</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时我发现，两次 Log 之间间隔了很久，显然是这里发生了卡顿。而第二次 Log 结束后，很快就又打印出了第一条 Log，仿佛 JS 里面那条空循环不耗时一样，问题变得蹊跷起来。</p>\n<p>会不会是 Toast.show 函数用时太久了呢？我干脆把这个函数注释成了空函数，但完全没有影响。看来是有什么隐蔽的操作在耗时，而不是这个函数本身。而奇怪的是，当我把 JS 里空循环的循环次数增加后，两次 Log 的间隔竟然也跟着变长了，这就有点让我摸不到头脑。毕竟，JS 代码是在另一个线程里面运行的，怎么会影响到我这短短两行的主线程代码块呢？</p>\n<p>为了找到原因，我干脆监听了 RunLoop 状态。毕竟这段代码块是给主线程这个串行队列队尾的，如果主线程在忙于处理什么事情，这段代码执行的时间就会变晚。结果发现卡顿点确实发生在 RunLoop 处理 source0 的阶段，但这并没有给我什么启发。</p>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>现在 Swift 级别的代码调试已经看不出来问题在哪了，只好进入汇编级别调试一下，看看这段时间主线程到底在忙些什么。Xcode 用的编译器是 llvm，调试器自然就是 lldb。lldb 的命令和 gdb 很像（毕竟当时就是为了替换 gdb 才搞出来的），使用 <code>stepi</code> 命令可以 step into 到下一个指令。</p>\n<p><img src=\"/img/JS调用Swift卡顿/screenshot.png\" alt=\"屏幕快照 2019-02-15 17.06.33\"></p>\n<p>很快我就发现，我调用的 <code>toString</code> 函数中，有些加锁的操作。这里就非常值得警惕了。好在，JSCore 其实是开源的，我们可以去 Github 上看一下 JSCore 的源代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id valueToString(JSGlobalContextRef context, JSValueRef value, JSValueRef* exception)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ASSERT(!*exception);</span><br><span class=\"line\">    if (id wrapped = tryUnwrapObjcObject(context, value)) &#123; </span><br><span class=\"line\">        if ([wrapped isKindOfClass:[NSString class]])</span><br><span class=\"line\">            return wrapped;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面是 JSCore 源码中，toString 函数调用的一个函数。我们可以看到，它果然继续调用了刚刚汇编代码中 <code>tryUnwrapObjcObject</code> 函数。我们继续找到 <code>tryUnwrapObjcObject</code> 函数的源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id tryUnwrapObjcObject(JSGlobalContextRef context, JSValueRef value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    JSC::JSLockHolder locker(toJS(context));</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这个函数中给 JS 的上下文环境加了锁。</p>\n<p>继续阅读源码，有一段注释解释了为什么要给 context 加锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This is fairly nasty.  We allow multiple threads to run on the same</span><br><span class=\"line\">// context, and we do not require any locking semantics in doing so -</span><br><span class=\"line\">// clients of the API may simply use the context from multiple threads</span><br><span class=\"line\">// concurently, and assume this will work.  In order to make this work,</span><br><span class=\"line\">// We lock the context when a thread enters, and unlock it when it leaves.</span><br><span class=\"line\">// However we do not only unlock when the thread returns from its</span><br><span class=\"line\">// entry point (evaluate script or call function), we also unlock the</span><br><span class=\"line\">// context if the thread leaves JSC by making a call out to an external</span><br><span class=\"line\">// function through a callback.</span><br></pre></td></tr></table></figure>\n<p>可以看到，这是为了保证线程安全而做的工作，而且，在线程切换的时候也会加锁/解锁！</p>\n<h2 id=\"原理（猜测）\"><a href=\"#原理（猜测）\" class=\"headerlink\" title=\"原理（猜测）\"></a>原理（猜测）</h2><p>所以对于发生卡顿的原因，我做如下猜测（不敢 100% 确定）：</p>\n<p>最开始，JS 执行延时循环的时候，是正常在子线程里运行的，所以主线程不卡顿，一切都相安无事。</p>\n<p>在调用 <code>toast</code> 函数的时候，发生了线程切换。这个时候，JSCore 会给 context 加锁，然后瞬间返回，解锁继续给 JS 代码使用。接着，代码块被闲下来的主线程执行了。由于 <code>toString</code> 函数在主线程运行，所以它必须要等到 JSCore 把 context 解锁才能执行。这个时候，由于代码块是异步执行的，所以子线程又开始回去执行耗时循环了。而正在执行的 JavaScript 是不会释放锁的，所以主线程只好等待——造成了卡顿现象。</p>\n<p>终于，JS 代码跑完了耗时循环，JS 代码释放了锁，主线程终于能运行了。主线程很快执行完显示 toast 的函数，然后释放，让 JS 能继续跑。这也解释了为什么增加循环次数也会影响卡顿时间。但是，这个时候主线程执行的还是上一次的 toast 请求，而这已经是第二次 JS 完成耗时循环了。所以，JS 又会把一个代码块加到主队列中…而只有第三次的时候，主线程才能等到资源，完成第二次的请求……如此反复，主线程虽然总有一点机会执行代码而不至于被饿死，但是多数时间都处于等待资源的状态，导致异常的卡顿。</p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>我写了一段 JS 代码来验证我的猜测：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000000000</span>; i++); <span class=\"comment\">//延时一段时间</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        toast(<span class=\"string\">\"Hello JS!\"</span>); </span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，只调用主线程一次。按照上面的分析，一直再次发生线程切换，JS 就一直持有锁而不释放，主线程就永远没有机会执行。经验证，主线程确实完全卡死，等再久也没有反应。主线程被饿死，验证成功。</p>\n<p>我又把 Swift 代码块改成同步代码块。这样，JS 要等待主线程执行完才能继续执行，而主线程又需要 JS 线程再次调用才能完成，因此会发生死锁。经验证，主线程完全卡死，再次验证成功。</p>\n<h2 id=\"改正与总结\"><a href=\"#改正与总结\" class=\"headerlink\" title=\"改正与总结\"></a>改正与总结</h2><p>有了以上分析，改正变得非常容易：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toast</span><span class=\"params\">(<span class=\"number\">_</span> msg: JSValue)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> str = msg.<span class=\"built_in\">toString</span>()</span><br><span class=\"line\">\t<span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">    \t<span class=\"type\">Toast</span>.show(string: str, type: .js)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只需要把 <code>toString</code> 放在子线程中执行，就不存在主线程等待资源的问题了。可见，写代码时的一念之差，就会需要我花很久来调试、分析。如果最开始随手一写就写成正确的样子，就能省下大把的时间了。但话说回来，也就规避了问题。问题暴露出来，才能让我有机会深入学习。这也正是经验的来源吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JS调用Swift造成卡顿问题\"><a href=\"#JS调用Swift造成卡顿问题\" class=\"headerlink\" title=\"JS调用Swift造成卡顿问题\"></a>JS调用Swift造成卡顿问题</h1><p>最近正在构思一个新的项目，是一个控制蓝牙外设的 App，主要目标用户是电子爱好者，或者是做课程设计的大学生。这部分人群往往有一定的编程能力，但学习开发一款移动应用的成本又太高了。比如，如果希望用手机控制蓝牙小车，在这个小众场景下，这款 App 就会有用武之地了。</p>\n<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>鉴于目标用户是有一定编程能力的（毕竟蓝牙外设端还需要自己编程），为了增加 App 控制的灵活性，我就考虑增加一个通过 JavaScript 脚本自定义蓝牙收发逻辑的功能。这个想法也是受到钟大 JSBox 的启发。但有一个问题就是，如果用户编写的脚本包含耗时很久的循环，甚至死循环，比如用户想让蓝牙小车永远沿矩形运动，就可能会编出这样的代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    send_message(<span class=\"string\">\"move forward\"</span>); <span class=\"comment\">//通过蓝牙发送前进指令，小车接收到之后前进</span></span><br><span class=\"line\">    <span class=\"comment\">//注意非浏览器环境没有setTimeOut函数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000000000</span>; i++); <span class=\"comment\">//通过空循环延迟一段时间</span></span><br><span class=\"line\">    send_message(<span class=\"string\">\"turn left\"</span>); <span class=\"comment\">//左转</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000000000</span>; i++); <span class=\"comment\">//延迟，并不断重复</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一旦写出了这样的死循环，那么 App 的主线程就全部用来执行 JavaScript 代码，从而完全卡死。用户当然能达到他的需求——毕竟蓝牙消息在不断发送，但是完全卡死的 App 就再也无法使用了，用户体验极差。在当前版本的 JSBox 中，运行死循环也会造成卡死现象，只能强制退出 App。</p>\n<h2 id=\"开辟后台线程\"><a href=\"#开辟后台线程\" class=\"headerlink\" title=\"开辟后台线程\"></a>开辟后台线程</h2><p>既然死循环会把主线程卡死，那么我们在后台执行 JavaScript 不就解决这个问题了么？这是一个非常直观的想法，我也很快写出了这样的代码：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">work = <span class=\"type\">DispatchWorkItem</span> &#123; [<span class=\"keyword\">unowned</span> <span class=\"keyword\">self</span>] <span class=\"keyword\">in</span></span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.jsvm = <span class=\"type\">JSVirtualMachine</span>()</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.context = <span class=\"keyword\">self</span>.generateJSContext(vm: <span class=\"keyword\">self</span>.jsvm!)</span><br><span class=\"line\">\t<span class=\"keyword\">self</span>.context?.evaluateScript(code)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async(execute: work!)</span><br></pre></td></tr></table></figure>\n<p>这里要注意的一点是，如果需要在多线程中使用 JavaScriptCore，则需要给每个线程一个自己的 JS 虚拟机。否则，JS 虚拟机永远都会执行完上一次的程序，再来执行新加入的程序。</p>\n<p>然后，我编写了这样的 JavaScript 代码来测试效果，看是不是不会卡死主线程了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000000000</span>; i++); <span class=\"comment\">//延时一段时间</span></span><br><span class=\"line\">    toast(<span class=\"string\">\"Hello JS!\"</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>toast</code> 函数会回调 Swift 代码，从而在屏幕上弹出一段消息。当然，UIKit 不是线程安全的，所以在回调函数中必须回到主线程操作 UI：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toast</span><span class=\"params\">(<span class=\"number\">_</span> msg: JSValue)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">    \t<span class=\"type\">Toast</span>.show(string: msg.<span class=\"built_in\">toString</span>(), type: .js)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>写完这段天衣无缝的程序，我就很开心的去执行上面的那段测试代码了。果然，程序运行那段耗时空循环的时候，ScrollView 还可以顺畅的滚动，看来真的不会卡顿了。“我是天才！”，我心里默想。</p>\n<p>但是好景不长！当 App 第一次展示了那条 toast 之后，主线程瞬间变得非常卡顿——没有完全卡死，偶尔还能相应输入，但是反应速度慢到了完全不可操作的地步。这是为什么呢？</p>\n<h2 id=\"分析问题原因\"><a href=\"#分析问题原因\" class=\"headerlink\" title=\"分析问题原因\"></a>分析问题原因</h2><p>第一个想法当然是要看看卡顿的点在哪里，我首先在主线程的代码块里加入了一些调试代码。别忘了 print 不是线程安全的，这里最好使用 NSLog，而且 NSLog 还自带线程 id 号，很适合调试多线程程序。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toast</span><span class=\"params\">(<span class=\"number\">_</span> msg: JSValue)</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">        <span class=\"comment\">//NSLog</span></span><br><span class=\"line\">    \t<span class=\"type\">Toast</span>.show(string: msg.<span class=\"built_in\">toString</span>(), type: .js)</span><br><span class=\"line\">        <span class=\"comment\">//NSLog</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时我发现，两次 Log 之间间隔了很久，显然是这里发生了卡顿。而第二次 Log 结束后，很快就又打印出了第一条 Log，仿佛 JS 里面那条空循环不耗时一样，问题变得蹊跷起来。</p>\n<p>会不会是 Toast.show 函数用时太久了呢？我干脆把这个函数注释成了空函数，但完全没有影响。看来是有什么隐蔽的操作在耗时，而不是这个函数本身。而奇怪的是，当我把 JS 里空循环的循环次数增加后，两次 Log 的间隔竟然也跟着变长了，这就有点让我摸不到头脑。毕竟，JS 代码是在另一个线程里面运行的，怎么会影响到我这短短两行的主线程代码块呢？</p>\n<p>为了找到原因，我干脆监听了 RunLoop 状态。毕竟这段代码块是给主线程这个串行队列队尾的，如果主线程在忙于处理什么事情，这段代码执行的时间就会变晚。结果发现卡顿点确实发生在 RunLoop 处理 source0 的阶段，但这并没有给我什么启发。</p>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>现在 Swift 级别的代码调试已经看不出来问题在哪了，只好进入汇编级别调试一下，看看这段时间主线程到底在忙些什么。Xcode 用的编译器是 llvm，调试器自然就是 lldb。lldb 的命令和 gdb 很像（毕竟当时就是为了替换 gdb 才搞出来的），使用 <code>stepi</code> 命令可以 step into 到下一个指令。</p>\n<p><img src=\"/img/JS调用Swift卡顿/screenshot.png\" alt=\"屏幕快照 2019-02-15 17.06.33\"></p>\n<p>很快我就发现，我调用的 <code>toString</code> 函数中，有些加锁的操作。这里就非常值得警惕了。好在，JSCore 其实是开源的，我们可以去 Github 上看一下 JSCore 的源代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id valueToString(JSGlobalContextRef context, JSValueRef value, JSValueRef* exception)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ASSERT(!*exception);</span><br><span class=\"line\">    if (id wrapped = tryUnwrapObjcObject(context, value)) &#123; </span><br><span class=\"line\">        if ([wrapped isKindOfClass:[NSString class]])</span><br><span class=\"line\">            return wrapped;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t//...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面是 JSCore 源码中，toString 函数调用的一个函数。我们可以看到，它果然继续调用了刚刚汇编代码中 <code>tryUnwrapObjcObject</code> 函数。我们继续找到 <code>tryUnwrapObjcObject</code> 函数的源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">id tryUnwrapObjcObject(JSGlobalContextRef context, JSValueRef value)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    JSC::JSLockHolder locker(toJS(context));</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    return nil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这个函数中给 JS 的上下文环境加了锁。</p>\n<p>继续阅读源码，有一段注释解释了为什么要给 context 加锁：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// This is fairly nasty.  We allow multiple threads to run on the same</span><br><span class=\"line\">// context, and we do not require any locking semantics in doing so -</span><br><span class=\"line\">// clients of the API may simply use the context from multiple threads</span><br><span class=\"line\">// concurently, and assume this will work.  In order to make this work,</span><br><span class=\"line\">// We lock the context when a thread enters, and unlock it when it leaves.</span><br><span class=\"line\">// However we do not only unlock when the thread returns from its</span><br><span class=\"line\">// entry point (evaluate script or call function), we also unlock the</span><br><span class=\"line\">// context if the thread leaves JSC by making a call out to an external</span><br><span class=\"line\">// function through a callback.</span><br></pre></td></tr></table></figure>\n<p>可以看到，这是为了保证线程安全而做的工作，而且，在线程切换的时候也会加锁/解锁！</p>\n<h2 id=\"原理（猜测）\"><a href=\"#原理（猜测）\" class=\"headerlink\" title=\"原理（猜测）\"></a>原理（猜测）</h2><p>所以对于发生卡顿的原因，我做如下猜测（不敢 100% 确定）：</p>\n<p>最开始，JS 执行延时循环的时候，是正常在子线程里运行的，所以主线程不卡顿，一切都相安无事。</p>\n<p>在调用 <code>toast</code> 函数的时候，发生了线程切换。这个时候，JSCore 会给 context 加锁，然后瞬间返回，解锁继续给 JS 代码使用。接着，代码块被闲下来的主线程执行了。由于 <code>toString</code> 函数在主线程运行，所以它必须要等到 JSCore 把 context 解锁才能执行。这个时候，由于代码块是异步执行的，所以子线程又开始回去执行耗时循环了。而正在执行的 JavaScript 是不会释放锁的，所以主线程只好等待——造成了卡顿现象。</p>\n<p>终于，JS 代码跑完了耗时循环，JS 代码释放了锁，主线程终于能运行了。主线程很快执行完显示 toast 的函数，然后释放，让 JS 能继续跑。这也解释了为什么增加循环次数也会影响卡顿时间。但是，这个时候主线程执行的还是上一次的 toast 请求，而这已经是第二次 JS 完成耗时循环了。所以，JS 又会把一个代码块加到主队列中…而只有第三次的时候，主线程才能等到资源，完成第二次的请求……如此反复，主线程虽然总有一点机会执行代码而不至于被饿死，但是多数时间都处于等待资源的状态，导致异常的卡顿。</p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>我写了一段 JS 代码来验证我的猜测：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000000000</span>; i++); <span class=\"comment\">//延时一段时间</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        toast(<span class=\"string\">\"Hello JS!\"</span>); </span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，只调用主线程一次。按照上面的分析，一直再次发生线程切换，JS 就一直持有锁而不释放，主线程就永远没有机会执行。经验证，主线程确实完全卡死，等再久也没有反应。主线程被饿死，验证成功。</p>\n<p>我又把 Swift 代码块改成同步代码块。这样，JS 要等待主线程执行完才能继续执行，而主线程又需要 JS 线程再次调用才能完成，因此会发生死锁。经验证，主线程完全卡死，再次验证成功。</p>\n<h2 id=\"改正与总结\"><a href=\"#改正与总结\" class=\"headerlink\" title=\"改正与总结\"></a>改正与总结</h2><p>有了以上分析，改正变得非常容易：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">toast</span><span class=\"params\">(<span class=\"number\">_</span> msg: JSValue)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> str = msg.<span class=\"built_in\">toString</span>()</span><br><span class=\"line\">\t<span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">    \t<span class=\"type\">Toast</span>.show(string: str, type: .js)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只需要把 <code>toString</code> 放在子线程中执行，就不存在主线程等待资源的问题了。可见，写代码时的一念之差，就会需要我花很久来调试、分析。如果最开始随手一写就写成正确的样子，就能省下大把的时间了。但话说回来，也就规避了问题。问题暴露出来，才能让我有机会深入学习。这也正是经验的来源吧。</p>\n"},{"title":"LoopUnrolling优化效果对比","date":"2019-03-25T17:04:52.000Z","_content":"\n# Loop Unrolling 优化效果对比\n\n循环是计算机程序中非常重要的结构。如果对循环加以优化，就可以大幅提高程序的运行速度。本文通过一段简单的小程序，对比了 Loop Unrolling 前后的性能差异。\n\n## 什么是 Loop Unrolling\n\n简单来说，循环展开就是把循环中的内容复制多次，然后减少循环次数。这是一种牺牲程序占用空间换取执行时间的优化方法。Loop Unrolling 有利于指令级并行，也有利于 pipeline 调度。\n\n指令级并行（multiple issue）是在同一时刻执行多条指令。这建立在 CPU 的结构\"冗余\"上。例如，如果我们有两个 ALU，我们就可以同时执行两个 ALU 运算操作。\n\nLoop Unrolling 可以由编译器自动优化。\n\n## 例子\n\n为了测试 Loop Unrolling，我编写了如下的代码：\n\n```c\n#include <stdio.h>\n#include <time.h>\nint main()\n{\n    int array[1000000];\n    printf(\"tick: %ld\\n\", clock());\n    for (int j=0; j<100000; j++) {\n        for (int i = 1; i < 1000000; i++) {\n           array[i] += 970815;\n        }\n    }\n    return 0;\n}\n```\n\n可以想像，如果存在 Loop Unrolling，中间的加法运算就会被复制多次，而循环次数也对应减少。\n\n使用 LLVM 进行编译，选择 O0 优化，即最低优化级别：\n\n`clang -O0 -S -emit-llvm unrolling.c`\n\n部分汇编代码如下：\n\n![ll0](/img/LoopUnrolling/ll0.png)\n\n这里的代码不是真正的汇编代码，而是 LLVM 的中间语言（IR）。clang 作为 LLVM 的前端，负责解析 C 代码，之后 LLVM 会生成 IR 代码并作优化，最后由 IR 再翻译成平台相关的汇编代码。\n\n这里 970815 （我的生日）是一个 magic number，通过这个数字我们可以迅速定位到循环的位置。可以看到，并没有什么稀奇之处，这个加法运算只出现了一次。\n\n如果使用 O3，即最高级别优化：\n\n`clang -O0 -S -emit-llvm unrolling.c`\n\n可以看到 IR 代码如下：\n\n![ll3](/img/LoopUnrolling/ll3.png)\n\n这里可以很明显的看到，相加运算被复制了很多很多次，即编译器做了 Loop Unrolling 优化。当然，真实的代码可能会和 IR 有所出入，因为在 IR 中，寄存器的数量是无限制的，而真正的 CPU 的寄存器数量很少，所以会有所变动。不过可以确定的是，在 LLVM O3 级别的优化下，确实产生了 Loop Unrolling 现象。\n\n## 使用 gperftools 测试性能\n\nLinux 下有很多性能分析工具，这里我选择了可以配合 clang 使用的 Google gperftools。注意，gperftools 每隔 10ms 做一次采样，因此我设置的循环次数较大，这样才能有足够的时间来统计采样次数。而采样次数也就反映了程序的运行时间。\n\n![unrolling_vs](/img/LoopUnrolling/unrolling_vs.png)\n\n这张图中，纵坐标是 gperftools 的采样次数（与程序耗时成正比），前三组数据使用 O0 优化，而后三组数据使用 O3 优化。在 clang 中，即使是 O0 级别也是会做出一些基本的优化的。如果想要完全不优化，则需要自己更改 clang 的源代码。（逃\n\n不过根据前面的 IR 代码可以知道，O0 是没有 Loop Unrolling 的。\n\n通过这组数据可以看出，在有 Loop Unrolling 的情况下，性能的提升是显著的。虽然 O3 级别优化肯定也会对其他地方进行优化，但是在如此简单的情景下，可以假定对影响程序时间起主要作用的就是对循环作出的优化。\n\n## 使用 gem5 模拟器分析\n\n在刚才的分析中，我是使用了 VMWare 的 Linux 虚拟机来做的测试。然而，这样的测试变量较多，如系统的负载在不同时刻不一致等。使用 CPU 模拟器，可以得到非常精确的结果。\n\nGem5 有两种运行模式，SE 和 FS。SE 是 system emulation 的缩写，即模拟了 system call，而并没有真实的操作系统。这是一种较低层次的虚拟化技术。SE 模式下可以运行一些简单的静态编译程序（Linux 格式）。所以，在编译完成后，我将可执行文件从 Linux 虚拟机拷贝回宿主 macOS 上，并交给 gem5 执行。为了静态链接，需要在编译时添加 `--static` 参数。\n\n`clang -O3 unrolling.c -o unrolling_3 --static`\n\n未优化时，消耗的 CPU tick 数为：43233500。优化后为：40620500。可以看到优化后性能有所提高。提升没有之前显著的原因是，我将循环次数减少了数万至数十万倍。这是因为 gem5 效率更低，在之前的循环数量下会消耗过长的时间进行仿真。\n\n使用 gem5 仿真的命令是：\n\n`build/X86/gem5.opt configs/turtorial/two-level.py`\n\n这里，使用 opt 模式 X86 架构的模拟器，而后一半是自行编写的 CPU 配置脚本。通过自定义配置脚本，可以指定 CPU 参数，cache 系统等。当然，gem5 本身也提供了一些现成的配置供我们使用。\n\n运行完毕后，gem5 会在 `m5out` 文件夹下生成 `stats.txt` 文件展示统计信息。通过统计信息可以看到 cache 命中率等信息。\n\n下面是优化后的缓存 miss rate：\n\n![dmissw](/img/LoopUnrolling/dmissw.png)\n\n![imissw](/img/LoopUnrolling/imissw.png)\n\n下面是未优化的：\n\n![dmisswo](/img/LoopUnrolling/dmisswo.png)\n\n![dmisswo](/img/LoopUnrolling/imisswo.png)\n\n可以看到缓存 miss 比率在优化后反而升高了。这不能解释我们观察到的性能提升现象。（为什么 cache 反而命中率低了？我目前没有想到合理的解释）\n\n使用现有的配置文件，gem5 可以可视化的展示 CPU pipeline。不过要知道，静态链接后程序会变得非常臃肿。而且，真实的汇编代码可读性很低，所以需要找到办法在完整的 pipeline 中找到我们感兴趣的循环部分。\n\n为了定位循环的位置，首先阅读一下真实的汇编代码：\n\n![asm_0](/img/LoopUnrolling/asm_0.png)\n\n通过 magic number 970815 可以看到对应的 addl 指令位置。而这个立即数的 16 进制值为 `imm = 0xED03F`。\n\n通过 objdump 工具可以反汇编出可执行文件的结构：\n\n`objdump -d unrolling_3 > obj.txt`\n\n输出的结果默认是打在控制台上的，但由于静态链接后程序体积非常大，我把输出结果重定向在 obj.txt 文件中，方便查看。\n\n![dump](/img/LoopUnrolling/dump.png)\n\n搜索 magic number 0xed03f 可以快速定位到位置。可以看到 address 是 `0x400b5d` 。由于这里是 SE 模式模拟，可以理解为程序在裸的 CPU 上运行，所以可以假象运行时的 PC 值就是这个地址。\n\n使用 gem5 提供的 CPU 配置和可视化工具，可以检查 pipeline。\n\n```\nbuild/X86/gem5.opt --debug-flags=O3PipeView --debug-start=1 --debug-file=trace.out configs/example/se.py --cpu-type=DerivO3CPU --caches -c /Users/wangluyuan/Desktop/COProject/test/unrolling_0\n```\n\n这里需要注意的是，官网教程中，向 `se.py` 传入的参数是 `--cpu-type=detailed` 。然而实际上 se.py 并不支持这个参数，可能是教程太过于陈旧了。需要传入的参数实际是 `DerivO3CPU`。\n\n之后把输出结果格式进行转换：\n\n`./util/o3-pipeview.py -c 250 -o pipeview.out --color m5out/trace.out`\n\n最后打开：\n\n`less -r pipeview.out `\n\n这里的颜色是通过逃逸字符实现的，所以一般的文本编辑器打开是看不到颜色，而只能看到逃逸字符本身。所以最好使用 less 打开。\n\n通过之前的 address 可以在完整的 pipeline 中找到加法对应的位置。当然，如果不想查看完整的 pipeline （太长了），可以在运行时指定参数 `--debug-start`：\n\n```\nbuild/X86/gem5.opt --debug-flags=O3PipeView --debug-start=33800000 --debug-file=trace.out configs/example/se.py --cpu-type=DerivO3CPU --caches -c /Users/wangluyuan/Desktop/COProject/test/unrolling_3\n```\n\n优化前：\n\n![pipewo](/img/LoopUnrolling/pipewo.png)\n\n优化后：\n\n![pipew](/img/LoopUnrolling/pipew.png)\n\n优化后，ADD 指令连续出现了多次。这里，不同的字母代表流水线的不同 stage：\n\n```\nf = fetch, d = decode, n = rename, p = dispatch, i = issue, c = complete, r = retire, s = store-complete\n```\n\nX86 的流水线比 MIPS 的五段（fetch, decode, exe, mem, wb）流水线复杂很多。但直观上来看，优化后的流水线似乎更满、更完整。或许是这个原因导致的运行速度更快。\n\n","source":"_posts/LoopUnrolling优化效果对比.md","raw":"---\ntitle: LoopUnrolling优化效果对比\ndate: 2019-03-26 01:04:52\ntags: Computer Organization\n---\n\n# Loop Unrolling 优化效果对比\n\n循环是计算机程序中非常重要的结构。如果对循环加以优化，就可以大幅提高程序的运行速度。本文通过一段简单的小程序，对比了 Loop Unrolling 前后的性能差异。\n\n## 什么是 Loop Unrolling\n\n简单来说，循环展开就是把循环中的内容复制多次，然后减少循环次数。这是一种牺牲程序占用空间换取执行时间的优化方法。Loop Unrolling 有利于指令级并行，也有利于 pipeline 调度。\n\n指令级并行（multiple issue）是在同一时刻执行多条指令。这建立在 CPU 的结构\"冗余\"上。例如，如果我们有两个 ALU，我们就可以同时执行两个 ALU 运算操作。\n\nLoop Unrolling 可以由编译器自动优化。\n\n## 例子\n\n为了测试 Loop Unrolling，我编写了如下的代码：\n\n```c\n#include <stdio.h>\n#include <time.h>\nint main()\n{\n    int array[1000000];\n    printf(\"tick: %ld\\n\", clock());\n    for (int j=0; j<100000; j++) {\n        for (int i = 1; i < 1000000; i++) {\n           array[i] += 970815;\n        }\n    }\n    return 0;\n}\n```\n\n可以想像，如果存在 Loop Unrolling，中间的加法运算就会被复制多次，而循环次数也对应减少。\n\n使用 LLVM 进行编译，选择 O0 优化，即最低优化级别：\n\n`clang -O0 -S -emit-llvm unrolling.c`\n\n部分汇编代码如下：\n\n![ll0](/img/LoopUnrolling/ll0.png)\n\n这里的代码不是真正的汇编代码，而是 LLVM 的中间语言（IR）。clang 作为 LLVM 的前端，负责解析 C 代码，之后 LLVM 会生成 IR 代码并作优化，最后由 IR 再翻译成平台相关的汇编代码。\n\n这里 970815 （我的生日）是一个 magic number，通过这个数字我们可以迅速定位到循环的位置。可以看到，并没有什么稀奇之处，这个加法运算只出现了一次。\n\n如果使用 O3，即最高级别优化：\n\n`clang -O0 -S -emit-llvm unrolling.c`\n\n可以看到 IR 代码如下：\n\n![ll3](/img/LoopUnrolling/ll3.png)\n\n这里可以很明显的看到，相加运算被复制了很多很多次，即编译器做了 Loop Unrolling 优化。当然，真实的代码可能会和 IR 有所出入，因为在 IR 中，寄存器的数量是无限制的，而真正的 CPU 的寄存器数量很少，所以会有所变动。不过可以确定的是，在 LLVM O3 级别的优化下，确实产生了 Loop Unrolling 现象。\n\n## 使用 gperftools 测试性能\n\nLinux 下有很多性能分析工具，这里我选择了可以配合 clang 使用的 Google gperftools。注意，gperftools 每隔 10ms 做一次采样，因此我设置的循环次数较大，这样才能有足够的时间来统计采样次数。而采样次数也就反映了程序的运行时间。\n\n![unrolling_vs](/img/LoopUnrolling/unrolling_vs.png)\n\n这张图中，纵坐标是 gperftools 的采样次数（与程序耗时成正比），前三组数据使用 O0 优化，而后三组数据使用 O3 优化。在 clang 中，即使是 O0 级别也是会做出一些基本的优化的。如果想要完全不优化，则需要自己更改 clang 的源代码。（逃\n\n不过根据前面的 IR 代码可以知道，O0 是没有 Loop Unrolling 的。\n\n通过这组数据可以看出，在有 Loop Unrolling 的情况下，性能的提升是显著的。虽然 O3 级别优化肯定也会对其他地方进行优化，但是在如此简单的情景下，可以假定对影响程序时间起主要作用的就是对循环作出的优化。\n\n## 使用 gem5 模拟器分析\n\n在刚才的分析中，我是使用了 VMWare 的 Linux 虚拟机来做的测试。然而，这样的测试变量较多，如系统的负载在不同时刻不一致等。使用 CPU 模拟器，可以得到非常精确的结果。\n\nGem5 有两种运行模式，SE 和 FS。SE 是 system emulation 的缩写，即模拟了 system call，而并没有真实的操作系统。这是一种较低层次的虚拟化技术。SE 模式下可以运行一些简单的静态编译程序（Linux 格式）。所以，在编译完成后，我将可执行文件从 Linux 虚拟机拷贝回宿主 macOS 上，并交给 gem5 执行。为了静态链接，需要在编译时添加 `--static` 参数。\n\n`clang -O3 unrolling.c -o unrolling_3 --static`\n\n未优化时，消耗的 CPU tick 数为：43233500。优化后为：40620500。可以看到优化后性能有所提高。提升没有之前显著的原因是，我将循环次数减少了数万至数十万倍。这是因为 gem5 效率更低，在之前的循环数量下会消耗过长的时间进行仿真。\n\n使用 gem5 仿真的命令是：\n\n`build/X86/gem5.opt configs/turtorial/two-level.py`\n\n这里，使用 opt 模式 X86 架构的模拟器，而后一半是自行编写的 CPU 配置脚本。通过自定义配置脚本，可以指定 CPU 参数，cache 系统等。当然，gem5 本身也提供了一些现成的配置供我们使用。\n\n运行完毕后，gem5 会在 `m5out` 文件夹下生成 `stats.txt` 文件展示统计信息。通过统计信息可以看到 cache 命中率等信息。\n\n下面是优化后的缓存 miss rate：\n\n![dmissw](/img/LoopUnrolling/dmissw.png)\n\n![imissw](/img/LoopUnrolling/imissw.png)\n\n下面是未优化的：\n\n![dmisswo](/img/LoopUnrolling/dmisswo.png)\n\n![dmisswo](/img/LoopUnrolling/imisswo.png)\n\n可以看到缓存 miss 比率在优化后反而升高了。这不能解释我们观察到的性能提升现象。（为什么 cache 反而命中率低了？我目前没有想到合理的解释）\n\n使用现有的配置文件，gem5 可以可视化的展示 CPU pipeline。不过要知道，静态链接后程序会变得非常臃肿。而且，真实的汇编代码可读性很低，所以需要找到办法在完整的 pipeline 中找到我们感兴趣的循环部分。\n\n为了定位循环的位置，首先阅读一下真实的汇编代码：\n\n![asm_0](/img/LoopUnrolling/asm_0.png)\n\n通过 magic number 970815 可以看到对应的 addl 指令位置。而这个立即数的 16 进制值为 `imm = 0xED03F`。\n\n通过 objdump 工具可以反汇编出可执行文件的结构：\n\n`objdump -d unrolling_3 > obj.txt`\n\n输出的结果默认是打在控制台上的，但由于静态链接后程序体积非常大，我把输出结果重定向在 obj.txt 文件中，方便查看。\n\n![dump](/img/LoopUnrolling/dump.png)\n\n搜索 magic number 0xed03f 可以快速定位到位置。可以看到 address 是 `0x400b5d` 。由于这里是 SE 模式模拟，可以理解为程序在裸的 CPU 上运行，所以可以假象运行时的 PC 值就是这个地址。\n\n使用 gem5 提供的 CPU 配置和可视化工具，可以检查 pipeline。\n\n```\nbuild/X86/gem5.opt --debug-flags=O3PipeView --debug-start=1 --debug-file=trace.out configs/example/se.py --cpu-type=DerivO3CPU --caches -c /Users/wangluyuan/Desktop/COProject/test/unrolling_0\n```\n\n这里需要注意的是，官网教程中，向 `se.py` 传入的参数是 `--cpu-type=detailed` 。然而实际上 se.py 并不支持这个参数，可能是教程太过于陈旧了。需要传入的参数实际是 `DerivO3CPU`。\n\n之后把输出结果格式进行转换：\n\n`./util/o3-pipeview.py -c 250 -o pipeview.out --color m5out/trace.out`\n\n最后打开：\n\n`less -r pipeview.out `\n\n这里的颜色是通过逃逸字符实现的，所以一般的文本编辑器打开是看不到颜色，而只能看到逃逸字符本身。所以最好使用 less 打开。\n\n通过之前的 address 可以在完整的 pipeline 中找到加法对应的位置。当然，如果不想查看完整的 pipeline （太长了），可以在运行时指定参数 `--debug-start`：\n\n```\nbuild/X86/gem5.opt --debug-flags=O3PipeView --debug-start=33800000 --debug-file=trace.out configs/example/se.py --cpu-type=DerivO3CPU --caches -c /Users/wangluyuan/Desktop/COProject/test/unrolling_3\n```\n\n优化前：\n\n![pipewo](/img/LoopUnrolling/pipewo.png)\n\n优化后：\n\n![pipew](/img/LoopUnrolling/pipew.png)\n\n优化后，ADD 指令连续出现了多次。这里，不同的字母代表流水线的不同 stage：\n\n```\nf = fetch, d = decode, n = rename, p = dispatch, i = issue, c = complete, r = retire, s = store-complete\n```\n\nX86 的流水线比 MIPS 的五段（fetch, decode, exe, mem, wb）流水线复杂很多。但直观上来看，优化后的流水线似乎更满、更完整。或许是这个原因导致的运行速度更快。\n\n","slug":"LoopUnrolling优化效果对比","published":1,"updated":"2020-01-04T08:16:16.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3w0031ljc3srfuechj","content":"<h1 id=\"Loop-Unrolling-优化效果对比\"><a href=\"#Loop-Unrolling-优化效果对比\" class=\"headerlink\" title=\"Loop Unrolling 优化效果对比\"></a>Loop Unrolling 优化效果对比</h1><p>循环是计算机程序中非常重要的结构。如果对循环加以优化，就可以大幅提高程序的运行速度。本文通过一段简单的小程序，对比了 Loop Unrolling 前后的性能差异。</p>\n<h2 id=\"什么是-Loop-Unrolling\"><a href=\"#什么是-Loop-Unrolling\" class=\"headerlink\" title=\"什么是 Loop Unrolling\"></a>什么是 Loop Unrolling</h2><p>简单来说，循环展开就是把循环中的内容复制多次，然后减少循环次数。这是一种牺牲程序占用空间换取执行时间的优化方法。Loop Unrolling 有利于指令级并行，也有利于 pipeline 调度。</p>\n<p>指令级并行（multiple issue）是在同一时刻执行多条指令。这建立在 CPU 的结构”冗余”上。例如，如果我们有两个 ALU，我们就可以同时执行两个 ALU 运算操作。</p>\n<p>Loop Unrolling 可以由编译器自动优化。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>为了测试 Loop Unrolling，我编写了如下的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[<span class=\"number\">1000000</span>];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"tick: %ld\\n\"</span>, clock());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">100000</span>; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"built_in\">array</span>[i] += <span class=\"number\">970815</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以想像，如果存在 Loop Unrolling，中间的加法运算就会被复制多次，而循环次数也对应减少。</p>\n<p>使用 LLVM 进行编译，选择 O0 优化，即最低优化级别：</p>\n<p><code>clang -O0 -S -emit-llvm unrolling.c</code></p>\n<p>部分汇编代码如下：</p>\n<p><img src=\"/img/LoopUnrolling/ll0.png\" alt=\"ll0\"></p>\n<p>这里的代码不是真正的汇编代码，而是 LLVM 的中间语言（IR）。clang 作为 LLVM 的前端，负责解析 C 代码，之后 LLVM 会生成 IR 代码并作优化，最后由 IR 再翻译成平台相关的汇编代码。</p>\n<p>这里 970815 （我的生日）是一个 magic number，通过这个数字我们可以迅速定位到循环的位置。可以看到，并没有什么稀奇之处，这个加法运算只出现了一次。</p>\n<p>如果使用 O3，即最高级别优化：</p>\n<p><code>clang -O0 -S -emit-llvm unrolling.c</code></p>\n<p>可以看到 IR 代码如下：</p>\n<p><img src=\"/img/LoopUnrolling/ll3.png\" alt=\"ll3\"></p>\n<p>这里可以很明显的看到，相加运算被复制了很多很多次，即编译器做了 Loop Unrolling 优化。当然，真实的代码可能会和 IR 有所出入，因为在 IR 中，寄存器的数量是无限制的，而真正的 CPU 的寄存器数量很少，所以会有所变动。不过可以确定的是，在 LLVM O3 级别的优化下，确实产生了 Loop Unrolling 现象。</p>\n<h2 id=\"使用-gperftools-测试性能\"><a href=\"#使用-gperftools-测试性能\" class=\"headerlink\" title=\"使用 gperftools 测试性能\"></a>使用 gperftools 测试性能</h2><p>Linux 下有很多性能分析工具，这里我选择了可以配合 clang 使用的 Google gperftools。注意，gperftools 每隔 10ms 做一次采样，因此我设置的循环次数较大，这样才能有足够的时间来统计采样次数。而采样次数也就反映了程序的运行时间。</p>\n<p><img src=\"/img/LoopUnrolling/unrolling_vs.png\" alt=\"unrolling_vs\"></p>\n<p>这张图中，纵坐标是 gperftools 的采样次数（与程序耗时成正比），前三组数据使用 O0 优化，而后三组数据使用 O3 优化。在 clang 中，即使是 O0 级别也是会做出一些基本的优化的。如果想要完全不优化，则需要自己更改 clang 的源代码。（逃</p>\n<p>不过根据前面的 IR 代码可以知道，O0 是没有 Loop Unrolling 的。</p>\n<p>通过这组数据可以看出，在有 Loop Unrolling 的情况下，性能的提升是显著的。虽然 O3 级别优化肯定也会对其他地方进行优化，但是在如此简单的情景下，可以假定对影响程序时间起主要作用的就是对循环作出的优化。</p>\n<h2 id=\"使用-gem5-模拟器分析\"><a href=\"#使用-gem5-模拟器分析\" class=\"headerlink\" title=\"使用 gem5 模拟器分析\"></a>使用 gem5 模拟器分析</h2><p>在刚才的分析中，我是使用了 VMWare 的 Linux 虚拟机来做的测试。然而，这样的测试变量较多，如系统的负载在不同时刻不一致等。使用 CPU 模拟器，可以得到非常精确的结果。</p>\n<p>Gem5 有两种运行模式，SE 和 FS。SE 是 system emulation 的缩写，即模拟了 system call，而并没有真实的操作系统。这是一种较低层次的虚拟化技术。SE 模式下可以运行一些简单的静态编译程序（Linux 格式）。所以，在编译完成后，我将可执行文件从 Linux 虚拟机拷贝回宿主 macOS 上，并交给 gem5 执行。为了静态链接，需要在编译时添加 <code>--static</code> 参数。</p>\n<p><code>clang -O3 unrolling.c -o unrolling_3 --static</code></p>\n<p>未优化时，消耗的 CPU tick 数为：43233500。优化后为：40620500。可以看到优化后性能有所提高。提升没有之前显著的原因是，我将循环次数减少了数万至数十万倍。这是因为 gem5 效率更低，在之前的循环数量下会消耗过长的时间进行仿真。</p>\n<p>使用 gem5 仿真的命令是：</p>\n<p><code>build/X86/gem5.opt configs/turtorial/two-level.py</code></p>\n<p>这里，使用 opt 模式 X86 架构的模拟器，而后一半是自行编写的 CPU 配置脚本。通过自定义配置脚本，可以指定 CPU 参数，cache 系统等。当然，gem5 本身也提供了一些现成的配置供我们使用。</p>\n<p>运行完毕后，gem5 会在 <code>m5out</code> 文件夹下生成 <code>stats.txt</code> 文件展示统计信息。通过统计信息可以看到 cache 命中率等信息。</p>\n<p>下面是优化后的缓存 miss rate：</p>\n<p><img src=\"/img/LoopUnrolling/dmissw.png\" alt=\"dmissw\"></p>\n<p><img src=\"/img/LoopUnrolling/imissw.png\" alt=\"imissw\"></p>\n<p>下面是未优化的：</p>\n<p><img src=\"/img/LoopUnrolling/dmisswo.png\" alt=\"dmisswo\"></p>\n<p><img src=\"/img/LoopUnrolling/imisswo.png\" alt=\"dmisswo\"></p>\n<p>可以看到缓存 miss 比率在优化后反而升高了。这不能解释我们观察到的性能提升现象。（为什么 cache 反而命中率低了？我目前没有想到合理的解释）</p>\n<p>使用现有的配置文件，gem5 可以可视化的展示 CPU pipeline。不过要知道，静态链接后程序会变得非常臃肿。而且，真实的汇编代码可读性很低，所以需要找到办法在完整的 pipeline 中找到我们感兴趣的循环部分。</p>\n<p>为了定位循环的位置，首先阅读一下真实的汇编代码：</p>\n<p><img src=\"/img/LoopUnrolling/asm_0.png\" alt=\"asm_0\"></p>\n<p>通过 magic number 970815 可以看到对应的 addl 指令位置。而这个立即数的 16 进制值为 <code>imm = 0xED03F</code>。</p>\n<p>通过 objdump 工具可以反汇编出可执行文件的结构：</p>\n<p><code>objdump -d unrolling_3 &gt; obj.txt</code></p>\n<p>输出的结果默认是打在控制台上的，但由于静态链接后程序体积非常大，我把输出结果重定向在 obj.txt 文件中，方便查看。</p>\n<p><img src=\"/img/LoopUnrolling/dump.png\" alt=\"dump\"></p>\n<p>搜索 magic number 0xed03f 可以快速定位到位置。可以看到 address 是 <code>0x400b5d</code> 。由于这里是 SE 模式模拟，可以理解为程序在裸的 CPU 上运行，所以可以假象运行时的 PC 值就是这个地址。</p>\n<p>使用 gem5 提供的 CPU 配置和可视化工具，可以检查 pipeline。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/X86/gem5.opt --debug-flags=O3PipeView --debug-start=1 --debug-file=trace.out configs/example/se.py --cpu-type=DerivO3CPU --caches -c /Users/wangluyuan/Desktop/COProject/test/unrolling_0</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是，官网教程中，向 <code>se.py</code> 传入的参数是 <code>--cpu-type=detailed</code> 。然而实际上 se.py 并不支持这个参数，可能是教程太过于陈旧了。需要传入的参数实际是 <code>DerivO3CPU</code>。</p>\n<p>之后把输出结果格式进行转换：</p>\n<p><code>./util/o3-pipeview.py -c 250 -o pipeview.out --color m5out/trace.out</code></p>\n<p>最后打开：</p>\n<p><code>less -r pipeview.out</code></p>\n<p>这里的颜色是通过逃逸字符实现的，所以一般的文本编辑器打开是看不到颜色，而只能看到逃逸字符本身。所以最好使用 less 打开。</p>\n<p>通过之前的 address 可以在完整的 pipeline 中找到加法对应的位置。当然，如果不想查看完整的 pipeline （太长了），可以在运行时指定参数 <code>--debug-start</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/X86/gem5.opt --debug-flags=O3PipeView --debug-start=33800000 --debug-file=trace.out configs/example/se.py --cpu-type=DerivO3CPU --caches -c /Users/wangluyuan/Desktop/COProject/test/unrolling_3</span><br></pre></td></tr></table></figure>\n<p>优化前：</p>\n<p><img src=\"/img/LoopUnrolling/pipewo.png\" alt=\"pipewo\"></p>\n<p>优化后：</p>\n<p><img src=\"/img/LoopUnrolling/pipew.png\" alt=\"pipew\"></p>\n<p>优化后，ADD 指令连续出现了多次。这里，不同的字母代表流水线的不同 stage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = fetch, d = decode, n = rename, p = dispatch, i = issue, c = complete, r = retire, s = store-complete</span><br></pre></td></tr></table></figure>\n<p>X86 的流水线比 MIPS 的五段（fetch, decode, exe, mem, wb）流水线复杂很多。但直观上来看，优化后的流水线似乎更满、更完整。或许是这个原因导致的运行速度更快。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Loop-Unrolling-优化效果对比\"><a href=\"#Loop-Unrolling-优化效果对比\" class=\"headerlink\" title=\"Loop Unrolling 优化效果对比\"></a>Loop Unrolling 优化效果对比</h1><p>循环是计算机程序中非常重要的结构。如果对循环加以优化，就可以大幅提高程序的运行速度。本文通过一段简单的小程序，对比了 Loop Unrolling 前后的性能差异。</p>\n<h2 id=\"什么是-Loop-Unrolling\"><a href=\"#什么是-Loop-Unrolling\" class=\"headerlink\" title=\"什么是 Loop Unrolling\"></a>什么是 Loop Unrolling</h2><p>简单来说，循环展开就是把循环中的内容复制多次，然后减少循环次数。这是一种牺牲程序占用空间换取执行时间的优化方法。Loop Unrolling 有利于指令级并行，也有利于 pipeline 调度。</p>\n<p>指令级并行（multiple issue）是在同一时刻执行多条指令。这建立在 CPU 的结构”冗余”上。例如，如果我们有两个 ALU，我们就可以同时执行两个 ALU 运算操作。</p>\n<p>Loop Unrolling 可以由编译器自动优化。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>为了测试 Loop Unrolling，我编写了如下的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;time.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">array</span>[<span class=\"number\">1000000</span>];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"tick: %ld\\n\"</span>, clock());</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">100000</span>; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">           <span class=\"built_in\">array</span>[i] += <span class=\"number\">970815</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以想像，如果存在 Loop Unrolling，中间的加法运算就会被复制多次，而循环次数也对应减少。</p>\n<p>使用 LLVM 进行编译，选择 O0 优化，即最低优化级别：</p>\n<p><code>clang -O0 -S -emit-llvm unrolling.c</code></p>\n<p>部分汇编代码如下：</p>\n<p><img src=\"/img/LoopUnrolling/ll0.png\" alt=\"ll0\"></p>\n<p>这里的代码不是真正的汇编代码，而是 LLVM 的中间语言（IR）。clang 作为 LLVM 的前端，负责解析 C 代码，之后 LLVM 会生成 IR 代码并作优化，最后由 IR 再翻译成平台相关的汇编代码。</p>\n<p>这里 970815 （我的生日）是一个 magic number，通过这个数字我们可以迅速定位到循环的位置。可以看到，并没有什么稀奇之处，这个加法运算只出现了一次。</p>\n<p>如果使用 O3，即最高级别优化：</p>\n<p><code>clang -O0 -S -emit-llvm unrolling.c</code></p>\n<p>可以看到 IR 代码如下：</p>\n<p><img src=\"/img/LoopUnrolling/ll3.png\" alt=\"ll3\"></p>\n<p>这里可以很明显的看到，相加运算被复制了很多很多次，即编译器做了 Loop Unrolling 优化。当然，真实的代码可能会和 IR 有所出入，因为在 IR 中，寄存器的数量是无限制的，而真正的 CPU 的寄存器数量很少，所以会有所变动。不过可以确定的是，在 LLVM O3 级别的优化下，确实产生了 Loop Unrolling 现象。</p>\n<h2 id=\"使用-gperftools-测试性能\"><a href=\"#使用-gperftools-测试性能\" class=\"headerlink\" title=\"使用 gperftools 测试性能\"></a>使用 gperftools 测试性能</h2><p>Linux 下有很多性能分析工具，这里我选择了可以配合 clang 使用的 Google gperftools。注意，gperftools 每隔 10ms 做一次采样，因此我设置的循环次数较大，这样才能有足够的时间来统计采样次数。而采样次数也就反映了程序的运行时间。</p>\n<p><img src=\"/img/LoopUnrolling/unrolling_vs.png\" alt=\"unrolling_vs\"></p>\n<p>这张图中，纵坐标是 gperftools 的采样次数（与程序耗时成正比），前三组数据使用 O0 优化，而后三组数据使用 O3 优化。在 clang 中，即使是 O0 级别也是会做出一些基本的优化的。如果想要完全不优化，则需要自己更改 clang 的源代码。（逃</p>\n<p>不过根据前面的 IR 代码可以知道，O0 是没有 Loop Unrolling 的。</p>\n<p>通过这组数据可以看出，在有 Loop Unrolling 的情况下，性能的提升是显著的。虽然 O3 级别优化肯定也会对其他地方进行优化，但是在如此简单的情景下，可以假定对影响程序时间起主要作用的就是对循环作出的优化。</p>\n<h2 id=\"使用-gem5-模拟器分析\"><a href=\"#使用-gem5-模拟器分析\" class=\"headerlink\" title=\"使用 gem5 模拟器分析\"></a>使用 gem5 模拟器分析</h2><p>在刚才的分析中，我是使用了 VMWare 的 Linux 虚拟机来做的测试。然而，这样的测试变量较多，如系统的负载在不同时刻不一致等。使用 CPU 模拟器，可以得到非常精确的结果。</p>\n<p>Gem5 有两种运行模式，SE 和 FS。SE 是 system emulation 的缩写，即模拟了 system call，而并没有真实的操作系统。这是一种较低层次的虚拟化技术。SE 模式下可以运行一些简单的静态编译程序（Linux 格式）。所以，在编译完成后，我将可执行文件从 Linux 虚拟机拷贝回宿主 macOS 上，并交给 gem5 执行。为了静态链接，需要在编译时添加 <code>--static</code> 参数。</p>\n<p><code>clang -O3 unrolling.c -o unrolling_3 --static</code></p>\n<p>未优化时，消耗的 CPU tick 数为：43233500。优化后为：40620500。可以看到优化后性能有所提高。提升没有之前显著的原因是，我将循环次数减少了数万至数十万倍。这是因为 gem5 效率更低，在之前的循环数量下会消耗过长的时间进行仿真。</p>\n<p>使用 gem5 仿真的命令是：</p>\n<p><code>build/X86/gem5.opt configs/turtorial/two-level.py</code></p>\n<p>这里，使用 opt 模式 X86 架构的模拟器，而后一半是自行编写的 CPU 配置脚本。通过自定义配置脚本，可以指定 CPU 参数，cache 系统等。当然，gem5 本身也提供了一些现成的配置供我们使用。</p>\n<p>运行完毕后，gem5 会在 <code>m5out</code> 文件夹下生成 <code>stats.txt</code> 文件展示统计信息。通过统计信息可以看到 cache 命中率等信息。</p>\n<p>下面是优化后的缓存 miss rate：</p>\n<p><img src=\"/img/LoopUnrolling/dmissw.png\" alt=\"dmissw\"></p>\n<p><img src=\"/img/LoopUnrolling/imissw.png\" alt=\"imissw\"></p>\n<p>下面是未优化的：</p>\n<p><img src=\"/img/LoopUnrolling/dmisswo.png\" alt=\"dmisswo\"></p>\n<p><img src=\"/img/LoopUnrolling/imisswo.png\" alt=\"dmisswo\"></p>\n<p>可以看到缓存 miss 比率在优化后反而升高了。这不能解释我们观察到的性能提升现象。（为什么 cache 反而命中率低了？我目前没有想到合理的解释）</p>\n<p>使用现有的配置文件，gem5 可以可视化的展示 CPU pipeline。不过要知道，静态链接后程序会变得非常臃肿。而且，真实的汇编代码可读性很低，所以需要找到办法在完整的 pipeline 中找到我们感兴趣的循环部分。</p>\n<p>为了定位循环的位置，首先阅读一下真实的汇编代码：</p>\n<p><img src=\"/img/LoopUnrolling/asm_0.png\" alt=\"asm_0\"></p>\n<p>通过 magic number 970815 可以看到对应的 addl 指令位置。而这个立即数的 16 进制值为 <code>imm = 0xED03F</code>。</p>\n<p>通过 objdump 工具可以反汇编出可执行文件的结构：</p>\n<p><code>objdump -d unrolling_3 &gt; obj.txt</code></p>\n<p>输出的结果默认是打在控制台上的，但由于静态链接后程序体积非常大，我把输出结果重定向在 obj.txt 文件中，方便查看。</p>\n<p><img src=\"/img/LoopUnrolling/dump.png\" alt=\"dump\"></p>\n<p>搜索 magic number 0xed03f 可以快速定位到位置。可以看到 address 是 <code>0x400b5d</code> 。由于这里是 SE 模式模拟，可以理解为程序在裸的 CPU 上运行，所以可以假象运行时的 PC 值就是这个地址。</p>\n<p>使用 gem5 提供的 CPU 配置和可视化工具，可以检查 pipeline。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/X86/gem5.opt --debug-flags=O3PipeView --debug-start=1 --debug-file=trace.out configs/example/se.py --cpu-type=DerivO3CPU --caches -c /Users/wangluyuan/Desktop/COProject/test/unrolling_0</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是，官网教程中，向 <code>se.py</code> 传入的参数是 <code>--cpu-type=detailed</code> 。然而实际上 se.py 并不支持这个参数，可能是教程太过于陈旧了。需要传入的参数实际是 <code>DerivO3CPU</code>。</p>\n<p>之后把输出结果格式进行转换：</p>\n<p><code>./util/o3-pipeview.py -c 250 -o pipeview.out --color m5out/trace.out</code></p>\n<p>最后打开：</p>\n<p><code>less -r pipeview.out</code></p>\n<p>这里的颜色是通过逃逸字符实现的，所以一般的文本编辑器打开是看不到颜色，而只能看到逃逸字符本身。所以最好使用 less 打开。</p>\n<p>通过之前的 address 可以在完整的 pipeline 中找到加法对应的位置。当然，如果不想查看完整的 pipeline （太长了），可以在运行时指定参数 <code>--debug-start</code>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build/X86/gem5.opt --debug-flags=O3PipeView --debug-start=33800000 --debug-file=trace.out configs/example/se.py --cpu-type=DerivO3CPU --caches -c /Users/wangluyuan/Desktop/COProject/test/unrolling_3</span><br></pre></td></tr></table></figure>\n<p>优化前：</p>\n<p><img src=\"/img/LoopUnrolling/pipewo.png\" alt=\"pipewo\"></p>\n<p>优化后：</p>\n<p><img src=\"/img/LoopUnrolling/pipew.png\" alt=\"pipew\"></p>\n<p>优化后，ADD 指令连续出现了多次。这里，不同的字母代表流水线的不同 stage：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = fetch, d = decode, n = rename, p = dispatch, i = issue, c = complete, r = retire, s = store-complete</span><br></pre></td></tr></table></figure>\n<p>X86 的流水线比 MIPS 的五段（fetch, decode, exe, mem, wb）流水线复杂很多。但直观上来看，优化后的流水线似乎更满、更完整。或许是这个原因导致的运行速度更快。</p>\n"},{"title":"Promise是什么","date":"2018-05-20T08:17:48.000Z","_content":"\n# Promise 是什么\n\n之前和前端组的同学聊天，发现他们有一个很有意思的东西叫 Promise。既然要是从前端组那里听说的 Promise，那么我们就先谈一些关于前端的东西。\n\n### 单线程的 JavaScript\n\nJavaScript 是单线程语言，也就是同一时间只能做一件事情。准确来说，是负责解释并执行 JS 代码的线程只有一个。为什么要把 JavaScript 设定为单线程呢？这是因为它的工作环境主要是在浏览器中与用户互动，并操作 DOM。如果它是多线程的，那么就可能会并发地操作 DOM，从而带来非常复杂的同步问题。在新标准中，JavaScript 也被允许开启子线程，但子线程完全受主线程控制，且禁止操作 DOM。因此，JavaScript 仍然是单线程语言。\n\n既然 JS 是单线程的，那么当我们进行耗时操作，比如前端非常常见的网络请求时，不就会发生界面卡死的情况吗？但我们又可以看到，浏览网页时是非常顺滑流畅的，并没有发生这种情况。因为虽然 JS 是单线程的，但浏览器作为一个 App 是支持多线程的。JS 通过一些方法，完全可以做到异步操作。异步和单线程并不是冲突的。\n\n### JavaScript 异步原理\n\n首先来区分一下同步和异步。同步是指排队执行的任务，即前一个任务执行完成了，后一个任务才能开始执行，也就是我们熟悉的 sync。所有的同步任务都会在主线程执行，并形成一个执行栈。而异步任务有了运行结果后，就会把对应的事件放到任务队列中，比如鼠标点击事件、键盘事件、网络请求事件等等。当执行栈空了之后，系统就会读取任务队列，把相应的任务放入执行栈中执行。这个过程会不断的重复。\n\n这里说的执行异步任务，指的是回调函数。异步任务在创建时必须指定回调函数，这个函数会被挂起，在主线程空闲后被拿来执行。这个重复的过程被称为 Event Loop。\n\n清楚了回调方法后，再来谈具体是怎么实现异步的。前面提到，浏览器是多线程的，在浏览器中，会有这些线程：\n\n- UI 线程。我们非常熟悉的线程，负责渲染 UI 界面。\n- JS 引擎线程。JS 代码在这个线程上执行。但是 JS 引擎线程并不仅是一个线程，会有子线程来配合它。JS 会影响页面渲染，因此它和 UI 线程是互斥的，这也是为什么 JS 执行时会阻塞 UI 线程。\n- HTTP 请求线程。\n- Event Loop 轮询线程。\n- ……\n\n向网络请求这类的操作，实际上是通过浏览器的 API 委托给浏览器执行的。执行完毕，回调函数再给 JS 引擎执行。\n\n### 回调地狱 Callback Hell\n\n回调函数大家都很熟悉。每次异步任务，都要指定一个回调函数。那当我们想完成一步操作后，再进行下一步操作，就要在上一步的回调函数中写。如果下一步依赖上一步完成的情况多了，就会出现回调地狱：\n\n```javascript\n{\n    {\n        {\n            {\n                {\n                    //很容易编写出三角形的代码\n                }\n            }\n        }\n    }\n}\n```\n\n举个例子：先登录，登录之后我们可以拿到用户的信息。根据用户信息去请求用户的头像，拿到头像后再去设置图片……我们在平时编写 iOS 应用时很容易就写成这样：\n\n```swift\nlogin { info, error in\n    if let info = info {\n        fetch(avatar: info.userAvatarURL) { image, error in\n            if let image = image {\n                self.imageView = image\n            }\n        }\n    }\n}\n```\n\n饱受回调地狱折磨的显然不仅是前端，还有我们 iOS 啊！\n\n### 初识 Promise\n\nPromise 最早由开源社区提出并实现，最终被加入到了 JS ES6 标准中。Promise 代表了异步操作最终完成的或失败的对象。你可以把回调函数绑定在这个由函数返回的对象上，而不是把回调函数当作参数传进函数。\n\n当作参数传进函数的例子：\n\n```javascript\nfunction successCallback(result) {\n  console.log(\"It succeeded with \" + result);\n}\n\nfunction failureCallback(error) {\n  console.log(\"It failed with \" + error);\n}\n\ndoSomething(successCallback, failureCallback);\n```\n\n绑定 Promise 对象的例子：\n\n```javascript\ndoSomething().then(successCallback, failureCallback);\n```\n\n### Promise 了什么？\n\nPromise 到底保证了什么呢？\n\n- 当前运行完成前，回调函数永远不会被调用。\n- .then 添加的回调函数，都会被调用。\n- 多次调用 .then 可以添加多个回调函数，它们会按照插入顺序独立运行。\n\nPromise 对象有三种状态，Pending、Resolved、Rejected。只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变状态，且状态一旦改变就不会再变。这也是 Promise 名字的来源。\n\n### Promise 使用\n\n我们可以直接 new 一个 Promise 对象，也可以把 Promise 对象作为返回值。Promise 里的代码会立即执行。\n\n```javascript\n//1\nlet promise = new Promise((resolve, reject) => { //使用了箭头函数\n    if(success) {\n        resolve(value)\n    } else {\n        reject(error)\n    }\n})\n\n//2\nfunction doSomething() {\n    return new Promise(function (resolve, reject) {\n        if(success) {\n            resolve(value)\n        } else {\n            reject(error)\n        }\n    })\n}\n```\n\nPromise 接受一个函数作为参数，这个函数又有两个参数 resolve 和 reject。resolve 和 reject 又分别是两个函数。这两个函数有 JavaScript 引擎提供，不需要自己实现。resolve 的作用是把状态从 pending 变为 resolved；reject 的作用是把状态从 pending 变为 rejected，同时把错误作为参数传递出去。\n\n生成 Promise 实例后，可以用 then 方法制定状态变为 Resolved 和 Rejected 时的回调函数：\n\n```javascript\npromise.then(function(value) {\n    //success\n}, function(value) {\n    //failure\n});\n```\n\nthen 方法的第二个参数是可选的，不一定要提供。这两个函数接受 Promise 对象传出的值作为参数。\n\n整体来看就是这样：\n\n```javascript\nfunction timeout(ms) {\n\treturn new Promise((resolve, reject) => {\n        setTimeout(resolve, ms, 'done'); //'done'作为参数传递给resolve函数\n\t});\n}\ntimeout(100).then((value) => {\n\tconsole.log(value);\n});\n```\n\nthen 的返回值也是一个 Promise 对象，因此可以链式调用。而 Promise 的错误具有冒泡性质，会一直向后传递直到捕获为止，因此可以在最后用 catch 统一捕获错误。\n\n### 看一段代码\n\n到现在，我们终于能看懂前端组的同学写的部分代码了，一起欣赏一下：\n\n```javascript\nfunction createRequest(......) {\n    const options = {......};\n    ......\n    return new Promise((resolve, reject) => {\n    \trequest(options, (error, res, body) => {\n      \t\tif (error) {\n        \t\treject(error);\n      \t\t} else {\n        \t\tresolve({ error, res, body });\n      \t\t}\n\t\t});\n\t});\n}\n```\n\n首先，这是一个用于发送 HTTP 请求的函数，它传入了一些参数用来构建请求的参数 options。函数的结尾，返回了一个 Promise 对象。构造这个 Promise 对象时，传入了一个函数。这个函数体里，调用 request 函数实际发送请求，request 函数除了接受刚刚构建的 options 以外，还有一个回调函数作为参数。请求成功，resolve；失败，reject。\n\n当然，在实际调用这个函数的时候，他是使用了 await 语法糖结合 try / catch 捕获错误。不过这里就不再讨论 await / async 这些东西了。\n\n### 回到 iOS\n\n讲了这么多 JavaScript 的东西，是时候回到 iOS 了。既然前端有 Promise 这么好的东西，我们当然也可以使用。\n\n感谢开源社区，我们有了 [Promise Kit](https://github.com/mxcl/PromiseKit) 。\n\n再来看我们已开始举的例子：登录 - 获取头像，用 Promise Kit 可以这样写：\n\n```swift\nimport UIKit\nimport PromiseKit\n\nstruct Info {\n    var url = \"\"\n}\n\nstruct MyError: Error {\n    var description: String\n}\n\nclass ViewController: UIViewController {\n    \n    var imageView = UIImageView()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n     \n        firstly {\n            login()\n        }.then { info in\n            self.fetch(imageUrl: info.url)\n        }.done { image in\n            self.imageView.image = image\n            print(\"got image\")\n        }.catch { error in\n            print(error)\n        }\n        \n    }\n    \n    func login() -> Promise<Info> {\n        print(\"start login\")\n        return Promise { seal in\n            DispatchQueue.global().async {\n                Thread.sleep(forTimeInterval: 2)\n                seal.fulfill(Info(url: \"https://www.baidu.com\"))\n            }\n        }\n    }\n    \n    func fetch(imageUrl: String) -> Promise<UIImage> {\n        print(\"start fetch image\")\n        return Promise { seal in\n            DispatchQueue.global().async {\n                Thread.sleep(forTimeInterval: 2)\n                seal.reject(MyError(description: \"获取图片出错了\"))\n            }\n        }\n    }\n\n}\n```\n\n这里我就简单的 sleep 了两秒钟来模拟网络请求。我们可以看到，代码成功地变成了扁平的，避免了层层嵌套。在 Promise Kit 中，执行成功的函数被叫做了 fulfilll。firstly 只是语法糖，直接调用 `login().then` 是完全一样的，但是使用 firstly 将使得语义更加清晰。\n\n","source":"_posts/Promise是什么.md","raw":"---\ntitle: Promise是什么\ndate: 2018-05-20 16:17:48\ntags: Promise\n---\n\n# Promise 是什么\n\n之前和前端组的同学聊天，发现他们有一个很有意思的东西叫 Promise。既然要是从前端组那里听说的 Promise，那么我们就先谈一些关于前端的东西。\n\n### 单线程的 JavaScript\n\nJavaScript 是单线程语言，也就是同一时间只能做一件事情。准确来说，是负责解释并执行 JS 代码的线程只有一个。为什么要把 JavaScript 设定为单线程呢？这是因为它的工作环境主要是在浏览器中与用户互动，并操作 DOM。如果它是多线程的，那么就可能会并发地操作 DOM，从而带来非常复杂的同步问题。在新标准中，JavaScript 也被允许开启子线程，但子线程完全受主线程控制，且禁止操作 DOM。因此，JavaScript 仍然是单线程语言。\n\n既然 JS 是单线程的，那么当我们进行耗时操作，比如前端非常常见的网络请求时，不就会发生界面卡死的情况吗？但我们又可以看到，浏览网页时是非常顺滑流畅的，并没有发生这种情况。因为虽然 JS 是单线程的，但浏览器作为一个 App 是支持多线程的。JS 通过一些方法，完全可以做到异步操作。异步和单线程并不是冲突的。\n\n### JavaScript 异步原理\n\n首先来区分一下同步和异步。同步是指排队执行的任务，即前一个任务执行完成了，后一个任务才能开始执行，也就是我们熟悉的 sync。所有的同步任务都会在主线程执行，并形成一个执行栈。而异步任务有了运行结果后，就会把对应的事件放到任务队列中，比如鼠标点击事件、键盘事件、网络请求事件等等。当执行栈空了之后，系统就会读取任务队列，把相应的任务放入执行栈中执行。这个过程会不断的重复。\n\n这里说的执行异步任务，指的是回调函数。异步任务在创建时必须指定回调函数，这个函数会被挂起，在主线程空闲后被拿来执行。这个重复的过程被称为 Event Loop。\n\n清楚了回调方法后，再来谈具体是怎么实现异步的。前面提到，浏览器是多线程的，在浏览器中，会有这些线程：\n\n- UI 线程。我们非常熟悉的线程，负责渲染 UI 界面。\n- JS 引擎线程。JS 代码在这个线程上执行。但是 JS 引擎线程并不仅是一个线程，会有子线程来配合它。JS 会影响页面渲染，因此它和 UI 线程是互斥的，这也是为什么 JS 执行时会阻塞 UI 线程。\n- HTTP 请求线程。\n- Event Loop 轮询线程。\n- ……\n\n向网络请求这类的操作，实际上是通过浏览器的 API 委托给浏览器执行的。执行完毕，回调函数再给 JS 引擎执行。\n\n### 回调地狱 Callback Hell\n\n回调函数大家都很熟悉。每次异步任务，都要指定一个回调函数。那当我们想完成一步操作后，再进行下一步操作，就要在上一步的回调函数中写。如果下一步依赖上一步完成的情况多了，就会出现回调地狱：\n\n```javascript\n{\n    {\n        {\n            {\n                {\n                    //很容易编写出三角形的代码\n                }\n            }\n        }\n    }\n}\n```\n\n举个例子：先登录，登录之后我们可以拿到用户的信息。根据用户信息去请求用户的头像，拿到头像后再去设置图片……我们在平时编写 iOS 应用时很容易就写成这样：\n\n```swift\nlogin { info, error in\n    if let info = info {\n        fetch(avatar: info.userAvatarURL) { image, error in\n            if let image = image {\n                self.imageView = image\n            }\n        }\n    }\n}\n```\n\n饱受回调地狱折磨的显然不仅是前端，还有我们 iOS 啊！\n\n### 初识 Promise\n\nPromise 最早由开源社区提出并实现，最终被加入到了 JS ES6 标准中。Promise 代表了异步操作最终完成的或失败的对象。你可以把回调函数绑定在这个由函数返回的对象上，而不是把回调函数当作参数传进函数。\n\n当作参数传进函数的例子：\n\n```javascript\nfunction successCallback(result) {\n  console.log(\"It succeeded with \" + result);\n}\n\nfunction failureCallback(error) {\n  console.log(\"It failed with \" + error);\n}\n\ndoSomething(successCallback, failureCallback);\n```\n\n绑定 Promise 对象的例子：\n\n```javascript\ndoSomething().then(successCallback, failureCallback);\n```\n\n### Promise 了什么？\n\nPromise 到底保证了什么呢？\n\n- 当前运行完成前，回调函数永远不会被调用。\n- .then 添加的回调函数，都会被调用。\n- 多次调用 .then 可以添加多个回调函数，它们会按照插入顺序独立运行。\n\nPromise 对象有三种状态，Pending、Resolved、Rejected。只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变状态，且状态一旦改变就不会再变。这也是 Promise 名字的来源。\n\n### Promise 使用\n\n我们可以直接 new 一个 Promise 对象，也可以把 Promise 对象作为返回值。Promise 里的代码会立即执行。\n\n```javascript\n//1\nlet promise = new Promise((resolve, reject) => { //使用了箭头函数\n    if(success) {\n        resolve(value)\n    } else {\n        reject(error)\n    }\n})\n\n//2\nfunction doSomething() {\n    return new Promise(function (resolve, reject) {\n        if(success) {\n            resolve(value)\n        } else {\n            reject(error)\n        }\n    })\n}\n```\n\nPromise 接受一个函数作为参数，这个函数又有两个参数 resolve 和 reject。resolve 和 reject 又分别是两个函数。这两个函数有 JavaScript 引擎提供，不需要自己实现。resolve 的作用是把状态从 pending 变为 resolved；reject 的作用是把状态从 pending 变为 rejected，同时把错误作为参数传递出去。\n\n生成 Promise 实例后，可以用 then 方法制定状态变为 Resolved 和 Rejected 时的回调函数：\n\n```javascript\npromise.then(function(value) {\n    //success\n}, function(value) {\n    //failure\n});\n```\n\nthen 方法的第二个参数是可选的，不一定要提供。这两个函数接受 Promise 对象传出的值作为参数。\n\n整体来看就是这样：\n\n```javascript\nfunction timeout(ms) {\n\treturn new Promise((resolve, reject) => {\n        setTimeout(resolve, ms, 'done'); //'done'作为参数传递给resolve函数\n\t});\n}\ntimeout(100).then((value) => {\n\tconsole.log(value);\n});\n```\n\nthen 的返回值也是一个 Promise 对象，因此可以链式调用。而 Promise 的错误具有冒泡性质，会一直向后传递直到捕获为止，因此可以在最后用 catch 统一捕获错误。\n\n### 看一段代码\n\n到现在，我们终于能看懂前端组的同学写的部分代码了，一起欣赏一下：\n\n```javascript\nfunction createRequest(......) {\n    const options = {......};\n    ......\n    return new Promise((resolve, reject) => {\n    \trequest(options, (error, res, body) => {\n      \t\tif (error) {\n        \t\treject(error);\n      \t\t} else {\n        \t\tresolve({ error, res, body });\n      \t\t}\n\t\t});\n\t});\n}\n```\n\n首先，这是一个用于发送 HTTP 请求的函数，它传入了一些参数用来构建请求的参数 options。函数的结尾，返回了一个 Promise 对象。构造这个 Promise 对象时，传入了一个函数。这个函数体里，调用 request 函数实际发送请求，request 函数除了接受刚刚构建的 options 以外，还有一个回调函数作为参数。请求成功，resolve；失败，reject。\n\n当然，在实际调用这个函数的时候，他是使用了 await 语法糖结合 try / catch 捕获错误。不过这里就不再讨论 await / async 这些东西了。\n\n### 回到 iOS\n\n讲了这么多 JavaScript 的东西，是时候回到 iOS 了。既然前端有 Promise 这么好的东西，我们当然也可以使用。\n\n感谢开源社区，我们有了 [Promise Kit](https://github.com/mxcl/PromiseKit) 。\n\n再来看我们已开始举的例子：登录 - 获取头像，用 Promise Kit 可以这样写：\n\n```swift\nimport UIKit\nimport PromiseKit\n\nstruct Info {\n    var url = \"\"\n}\n\nstruct MyError: Error {\n    var description: String\n}\n\nclass ViewController: UIViewController {\n    \n    var imageView = UIImageView()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n     \n        firstly {\n            login()\n        }.then { info in\n            self.fetch(imageUrl: info.url)\n        }.done { image in\n            self.imageView.image = image\n            print(\"got image\")\n        }.catch { error in\n            print(error)\n        }\n        \n    }\n    \n    func login() -> Promise<Info> {\n        print(\"start login\")\n        return Promise { seal in\n            DispatchQueue.global().async {\n                Thread.sleep(forTimeInterval: 2)\n                seal.fulfill(Info(url: \"https://www.baidu.com\"))\n            }\n        }\n    }\n    \n    func fetch(imageUrl: String) -> Promise<UIImage> {\n        print(\"start fetch image\")\n        return Promise { seal in\n            DispatchQueue.global().async {\n                Thread.sleep(forTimeInterval: 2)\n                seal.reject(MyError(description: \"获取图片出错了\"))\n            }\n        }\n    }\n\n}\n```\n\n这里我就简单的 sleep 了两秒钟来模拟网络请求。我们可以看到，代码成功地变成了扁平的，避免了层层嵌套。在 Promise Kit 中，执行成功的函数被叫做了 fulfilll。firstly 只是语法糖，直接调用 `login().then` 是完全一样的，但是使用 firstly 将使得语义更加清晰。\n\n","slug":"Promise是什么","published":1,"updated":"2020-01-04T08:16:16.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3x0033ljc3ofjxaw5w","content":"<h1 id=\"Promise-是什么\"><a href=\"#Promise-是什么\" class=\"headerlink\" title=\"Promise 是什么\"></a>Promise 是什么</h1><p>之前和前端组的同学聊天，发现他们有一个很有意思的东西叫 Promise。既然要是从前端组那里听说的 Promise，那么我们就先谈一些关于前端的东西。</p>\n<h3 id=\"单线程的-JavaScript\"><a href=\"#单线程的-JavaScript\" class=\"headerlink\" title=\"单线程的 JavaScript\"></a>单线程的 JavaScript</h3><p>JavaScript 是单线程语言，也就是同一时间只能做一件事情。准确来说，是负责解释并执行 JS 代码的线程只有一个。为什么要把 JavaScript 设定为单线程呢？这是因为它的工作环境主要是在浏览器中与用户互动，并操作 DOM。如果它是多线程的，那么就可能会并发地操作 DOM，从而带来非常复杂的同步问题。在新标准中，JavaScript 也被允许开启子线程，但子线程完全受主线程控制，且禁止操作 DOM。因此，JavaScript 仍然是单线程语言。</p>\n<p>既然 JS 是单线程的，那么当我们进行耗时操作，比如前端非常常见的网络请求时，不就会发生界面卡死的情况吗？但我们又可以看到，浏览网页时是非常顺滑流畅的，并没有发生这种情况。因为虽然 JS 是单线程的，但浏览器作为一个 App 是支持多线程的。JS 通过一些方法，完全可以做到异步操作。异步和单线程并不是冲突的。</p>\n<h3 id=\"JavaScript-异步原理\"><a href=\"#JavaScript-异步原理\" class=\"headerlink\" title=\"JavaScript 异步原理\"></a>JavaScript 异步原理</h3><p>首先来区分一下同步和异步。同步是指排队执行的任务，即前一个任务执行完成了，后一个任务才能开始执行，也就是我们熟悉的 sync。所有的同步任务都会在主线程执行，并形成一个执行栈。而异步任务有了运行结果后，就会把对应的事件放到任务队列中，比如鼠标点击事件、键盘事件、网络请求事件等等。当执行栈空了之后，系统就会读取任务队列，把相应的任务放入执行栈中执行。这个过程会不断的重复。</p>\n<p>这里说的执行异步任务，指的是回调函数。异步任务在创建时必须指定回调函数，这个函数会被挂起，在主线程空闲后被拿来执行。这个重复的过程被称为 Event Loop。</p>\n<p>清楚了回调方法后，再来谈具体是怎么实现异步的。前面提到，浏览器是多线程的，在浏览器中，会有这些线程：</p>\n<ul>\n<li>UI 线程。我们非常熟悉的线程，负责渲染 UI 界面。</li>\n<li>JS 引擎线程。JS 代码在这个线程上执行。但是 JS 引擎线程并不仅是一个线程，会有子线程来配合它。JS 会影响页面渲染，因此它和 UI 线程是互斥的，这也是为什么 JS 执行时会阻塞 UI 线程。</li>\n<li>HTTP 请求线程。</li>\n<li>Event Loop 轮询线程。</li>\n<li>……</li>\n</ul>\n<p>向网络请求这类的操作，实际上是通过浏览器的 API 委托给浏览器执行的。执行完毕，回调函数再给 JS 引擎执行。</p>\n<h3 id=\"回调地狱-Callback-Hell\"><a href=\"#回调地狱-Callback-Hell\" class=\"headerlink\" title=\"回调地狱 Callback Hell\"></a>回调地狱 Callback Hell</h3><p>回调函数大家都很熟悉。每次异步任务，都要指定一个回调函数。那当我们想完成一步操作后，再进行下一步操作，就要在上一步的回调函数中写。如果下一步依赖上一步完成的情况多了，就会出现回调地狱：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//很容易编写出三角形的代码</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>举个例子：先登录，登录之后我们可以拿到用户的信息。根据用户信息去请求用户的头像，拿到头像后再去设置图片……我们在平时编写 iOS 应用时很容易就写成这样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">login &#123; info, error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> info = info &#123;</span><br><span class=\"line\">        fetch(avatar: info.userAvatarURL) &#123; image, error <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> image = image &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.imageView = image</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>饱受回调地狱折磨的显然不仅是前端，还有我们 iOS 啊！</p>\n<h3 id=\"初识-Promise\"><a href=\"#初识-Promise\" class=\"headerlink\" title=\"初识 Promise\"></a>初识 Promise</h3><p>Promise 最早由开源社区提出并实现，最终被加入到了 JS ES6 标准中。Promise 代表了异步操作最终完成的或失败的对象。你可以把回调函数绑定在这个由函数返回的对象上，而不是把回调函数当作参数传进函数。</p>\n<p>当作参数传进函数的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">successCallback</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"It succeeded with \"</span> + result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">failureCallback</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"It failed with \"</span> + error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSomething(successCallback, failureCallback);</span><br></pre></td></tr></table></figure>\n<p>绑定 Promise 对象的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(successCallback, failureCallback);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-了什么？\"><a href=\"#Promise-了什么？\" class=\"headerlink\" title=\"Promise 了什么？\"></a>Promise 了什么？</h3><p>Promise 到底保证了什么呢？</p>\n<ul>\n<li>当前运行完成前，回调函数永远不会被调用。</li>\n<li>.then 添加的回调函数，都会被调用。</li>\n<li>多次调用 .then 可以添加多个回调函数，它们会按照插入顺序独立运行。</li>\n</ul>\n<p>Promise 对象有三种状态，Pending、Resolved、Rejected。只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变状态，且状态一旦改变就不会再变。这也是 Promise 名字的来源。</p>\n<h3 id=\"Promise-使用\"><a href=\"#Promise-使用\" class=\"headerlink\" title=\"Promise 使用\"></a>Promise 使用</h3><p>我们可以直接 new 一个 Promise 对象，也可以把 Promise 对象作为返回值。Promise 里的代码会立即执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; <span class=\"comment\">//使用了箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(success) &#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(success) &#123;</span><br><span class=\"line\">            resolve(value)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Promise 接受一个函数作为参数，这个函数又有两个参数 resolve 和 reject。resolve 和 reject 又分别是两个函数。这两个函数有 JavaScript 引擎提供，不需要自己实现。resolve 的作用是把状态从 pending 变为 resolved；reject 的作用是把状态从 pending 变为 rejected，同时把错误作为参数传递出去。</p>\n<p>生成 Promise 实例后，可以用 then 方法制定状态变为 Resolved 和 Rejected 时的回调函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>then 方法的第二个参数是可选的，不一定要提供。这两个函数接受 Promise 对象传出的值作为参数。</p>\n<p>整体来看就是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(resolve, ms, <span class=\"string\">'done'</span>); <span class=\"comment\">//'done'作为参数传递给resolve函数</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">timeout(<span class=\"number\">100</span>).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>then 的返回值也是一个 Promise 对象，因此可以链式调用。而 Promise 的错误具有冒泡性质，会一直向后传递直到捕获为止，因此可以在最后用 catch 统一捕获错误。</p>\n<h3 id=\"看一段代码\"><a href=\"#看一段代码\" class=\"headerlink\" title=\"看一段代码\"></a>看一段代码</h3><p>到现在，我们终于能看懂前端组的同学写的部分代码了，一起欣赏一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createRequest</span>(<span class=\"params\">......</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = &#123;......&#125;;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    \trequest(options, (error, res, body) =&gt; &#123;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">        \t\treject(error);</span><br><span class=\"line\">      \t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        \t\tresolve(&#123; error, res, body &#125;);</span><br><span class=\"line\">      \t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，这是一个用于发送 HTTP 请求的函数，它传入了一些参数用来构建请求的参数 options。函数的结尾，返回了一个 Promise 对象。构造这个 Promise 对象时，传入了一个函数。这个函数体里，调用 request 函数实际发送请求，request 函数除了接受刚刚构建的 options 以外，还有一个回调函数作为参数。请求成功，resolve；失败，reject。</p>\n<p>当然，在实际调用这个函数的时候，他是使用了 await 语法糖结合 try / catch 捕获错误。不过这里就不再讨论 await / async 这些东西了。</p>\n<h3 id=\"回到-iOS\"><a href=\"#回到-iOS\" class=\"headerlink\" title=\"回到 iOS\"></a>回到 iOS</h3><p>讲了这么多 JavaScript 的东西，是时候回到 iOS 了。既然前端有 Promise 这么好的东西，我们当然也可以使用。</p>\n<p>感谢开源社区，我们有了 <a href=\"https://github.com/mxcl/PromiseKit\">Promise Kit</a> 。</p>\n<p>再来看我们已开始举的例子：登录 - 获取头像，用 Promise Kit 可以这样写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PromiseKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = <span class=\"string\">\"\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyError</span>: <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> imageView = <span class=\"type\">UIImageView</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">     </span><br><span class=\"line\">        firstly &#123;</span><br><span class=\"line\">            login()</span><br><span class=\"line\">        &#125;.then &#123; info <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.fetch(imageUrl: info.url)</span><br><span class=\"line\">        &#125;.done &#123; image <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.imageView.image = image</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"got image\"</span>)</span><br><span class=\"line\">        &#125;.<span class=\"keyword\">catch</span> &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">login</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Promise</span>&lt;<span class=\"type\">Info</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"start login\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Promise</span> &#123; seal <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span>.sleep(forTimeInterval: <span class=\"number\">2</span>)</span><br><span class=\"line\">                seal.fulfill(<span class=\"type\">Info</span>(url: <span class=\"string\">\"https://www.baidu.com\"</span>))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fetch</span><span class=\"params\">(imageUrl: String)</span></span> -&gt; <span class=\"type\">Promise</span>&lt;<span class=\"type\">UIImage</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"start fetch image\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Promise</span> &#123; seal <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span>.sleep(forTimeInterval: <span class=\"number\">2</span>)</span><br><span class=\"line\">                seal.reject(<span class=\"type\">MyError</span>(description: <span class=\"string\">\"获取图片出错了\"</span>))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我就简单的 sleep 了两秒钟来模拟网络请求。我们可以看到，代码成功地变成了扁平的，避免了层层嵌套。在 Promise Kit 中，执行成功的函数被叫做了 fulfilll。firstly 只是语法糖，直接调用 <code>login().then</code> 是完全一样的，但是使用 firstly 将使得语义更加清晰。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Promise-是什么\"><a href=\"#Promise-是什么\" class=\"headerlink\" title=\"Promise 是什么\"></a>Promise 是什么</h1><p>之前和前端组的同学聊天，发现他们有一个很有意思的东西叫 Promise。既然要是从前端组那里听说的 Promise，那么我们就先谈一些关于前端的东西。</p>\n<h3 id=\"单线程的-JavaScript\"><a href=\"#单线程的-JavaScript\" class=\"headerlink\" title=\"单线程的 JavaScript\"></a>单线程的 JavaScript</h3><p>JavaScript 是单线程语言，也就是同一时间只能做一件事情。准确来说，是负责解释并执行 JS 代码的线程只有一个。为什么要把 JavaScript 设定为单线程呢？这是因为它的工作环境主要是在浏览器中与用户互动，并操作 DOM。如果它是多线程的，那么就可能会并发地操作 DOM，从而带来非常复杂的同步问题。在新标准中，JavaScript 也被允许开启子线程，但子线程完全受主线程控制，且禁止操作 DOM。因此，JavaScript 仍然是单线程语言。</p>\n<p>既然 JS 是单线程的，那么当我们进行耗时操作，比如前端非常常见的网络请求时，不就会发生界面卡死的情况吗？但我们又可以看到，浏览网页时是非常顺滑流畅的，并没有发生这种情况。因为虽然 JS 是单线程的，但浏览器作为一个 App 是支持多线程的。JS 通过一些方法，完全可以做到异步操作。异步和单线程并不是冲突的。</p>\n<h3 id=\"JavaScript-异步原理\"><a href=\"#JavaScript-异步原理\" class=\"headerlink\" title=\"JavaScript 异步原理\"></a>JavaScript 异步原理</h3><p>首先来区分一下同步和异步。同步是指排队执行的任务，即前一个任务执行完成了，后一个任务才能开始执行，也就是我们熟悉的 sync。所有的同步任务都会在主线程执行，并形成一个执行栈。而异步任务有了运行结果后，就会把对应的事件放到任务队列中，比如鼠标点击事件、键盘事件、网络请求事件等等。当执行栈空了之后，系统就会读取任务队列，把相应的任务放入执行栈中执行。这个过程会不断的重复。</p>\n<p>这里说的执行异步任务，指的是回调函数。异步任务在创建时必须指定回调函数，这个函数会被挂起，在主线程空闲后被拿来执行。这个重复的过程被称为 Event Loop。</p>\n<p>清楚了回调方法后，再来谈具体是怎么实现异步的。前面提到，浏览器是多线程的，在浏览器中，会有这些线程：</p>\n<ul>\n<li>UI 线程。我们非常熟悉的线程，负责渲染 UI 界面。</li>\n<li>JS 引擎线程。JS 代码在这个线程上执行。但是 JS 引擎线程并不仅是一个线程，会有子线程来配合它。JS 会影响页面渲染，因此它和 UI 线程是互斥的，这也是为什么 JS 执行时会阻塞 UI 线程。</li>\n<li>HTTP 请求线程。</li>\n<li>Event Loop 轮询线程。</li>\n<li>……</li>\n</ul>\n<p>向网络请求这类的操作，实际上是通过浏览器的 API 委托给浏览器执行的。执行完毕，回调函数再给 JS 引擎执行。</p>\n<h3 id=\"回调地狱-Callback-Hell\"><a href=\"#回调地狱-Callback-Hell\" class=\"headerlink\" title=\"回调地狱 Callback Hell\"></a>回调地狱 Callback Hell</h3><p>回调函数大家都很熟悉。每次异步任务，都要指定一个回调函数。那当我们想完成一步操作后，再进行下一步操作，就要在上一步的回调函数中写。如果下一步依赖上一步完成的情况多了，就会出现回调地狱：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//很容易编写出三角形的代码</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>举个例子：先登录，登录之后我们可以拿到用户的信息。根据用户信息去请求用户的头像，拿到头像后再去设置图片……我们在平时编写 iOS 应用时很容易就写成这样：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">login &#123; info, error <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> info = info &#123;</span><br><span class=\"line\">        fetch(avatar: info.userAvatarURL) &#123; image, error <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> image = image &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.imageView = image</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>饱受回调地狱折磨的显然不仅是前端，还有我们 iOS 啊！</p>\n<h3 id=\"初识-Promise\"><a href=\"#初识-Promise\" class=\"headerlink\" title=\"初识 Promise\"></a>初识 Promise</h3><p>Promise 最早由开源社区提出并实现，最终被加入到了 JS ES6 标准中。Promise 代表了异步操作最终完成的或失败的对象。你可以把回调函数绑定在这个由函数返回的对象上，而不是把回调函数当作参数传进函数。</p>\n<p>当作参数传进函数的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">successCallback</span>(<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"It succeeded with \"</span> + result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">failureCallback</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"It failed with \"</span> + error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doSomething(successCallback, failureCallback);</span><br></pre></td></tr></table></figure>\n<p>绑定 Promise 对象的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doSomething().then(successCallback, failureCallback);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Promise-了什么？\"><a href=\"#Promise-了什么？\" class=\"headerlink\" title=\"Promise 了什么？\"></a>Promise 了什么？</h3><p>Promise 到底保证了什么呢？</p>\n<ul>\n<li>当前运行完成前，回调函数永远不会被调用。</li>\n<li>.then 添加的回调函数，都会被调用。</li>\n<li>多次调用 .then 可以添加多个回调函数，它们会按照插入顺序独立运行。</li>\n</ul>\n<p>Promise 对象有三种状态，Pending、Resolved、Rejected。只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都无法改变状态，且状态一旦改变就不会再变。这也是 Promise 名字的来源。</p>\n<h3 id=\"Promise-使用\"><a href=\"#Promise-使用\" class=\"headerlink\" title=\"Promise 使用\"></a>Promise 使用</h3><p>我们可以直接 new 一个 Promise 对象，也可以把 Promise 对象作为返回值。Promise 里的代码会立即执行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123; <span class=\"comment\">//使用了箭头函数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(success) &#123;</span><br><span class=\"line\">        resolve(value)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(success) &#123;</span><br><span class=\"line\">            resolve(value)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            reject(error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Promise 接受一个函数作为参数，这个函数又有两个参数 resolve 和 reject。resolve 和 reject 又分别是两个函数。这两个函数有 JavaScript 引擎提供，不需要自己实现。resolve 的作用是把状态从 pending 变为 resolved；reject 的作用是把状态从 pending 变为 rejected，同时把错误作为参数传递出去。</p>\n<p>生成 Promise 实例后，可以用 then 方法制定状态变为 Resolved 和 Rejected 时的回调函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>then 方法的第二个参数是可选的，不一定要提供。这两个函数接受 Promise 对象传出的值作为参数。</p>\n<p>整体来看就是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        setTimeout(resolve, ms, <span class=\"string\">'done'</span>); <span class=\"comment\">//'done'作为参数传递给resolve函数</span></span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">timeout(<span class=\"number\">100</span>).then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>then 的返回值也是一个 Promise 对象，因此可以链式调用。而 Promise 的错误具有冒泡性质，会一直向后传递直到捕获为止，因此可以在最后用 catch 统一捕获错误。</p>\n<h3 id=\"看一段代码\"><a href=\"#看一段代码\" class=\"headerlink\" title=\"看一段代码\"></a>看一段代码</h3><p>到现在，我们终于能看懂前端组的同学写的部分代码了，一起欣赏一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createRequest</span>(<span class=\"params\">......</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> options = &#123;......&#125;;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    \trequest(options, (error, res, body) =&gt; &#123;</span><br><span class=\"line\">      \t\t<span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">        \t\treject(error);</span><br><span class=\"line\">      \t\t&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        \t\tresolve(&#123; error, res, body &#125;);</span><br><span class=\"line\">      \t\t&#125;</span><br><span class=\"line\">\t\t&#125;);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先，这是一个用于发送 HTTP 请求的函数，它传入了一些参数用来构建请求的参数 options。函数的结尾，返回了一个 Promise 对象。构造这个 Promise 对象时，传入了一个函数。这个函数体里，调用 request 函数实际发送请求，request 函数除了接受刚刚构建的 options 以外，还有一个回调函数作为参数。请求成功，resolve；失败，reject。</p>\n<p>当然，在实际调用这个函数的时候，他是使用了 await 语法糖结合 try / catch 捕获错误。不过这里就不再讨论 await / async 这些东西了。</p>\n<h3 id=\"回到-iOS\"><a href=\"#回到-iOS\" class=\"headerlink\" title=\"回到 iOS\"></a>回到 iOS</h3><p>讲了这么多 JavaScript 的东西，是时候回到 iOS 了。既然前端有 Promise 这么好的东西，我们当然也可以使用。</p>\n<p>感谢开源社区，我们有了 <a href=\"https://github.com/mxcl/PromiseKit\">Promise Kit</a> 。</p>\n<p>再来看我们已开始举的例子：登录 - 获取头像，用 Promise Kit 可以这样写：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PromiseKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Info</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> url = <span class=\"string\">\"\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">MyError</span>: <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> imageView = <span class=\"type\">UIImageView</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">     </span><br><span class=\"line\">        firstly &#123;</span><br><span class=\"line\">            login()</span><br><span class=\"line\">        &#125;.then &#123; info <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.fetch(imageUrl: info.url)</span><br><span class=\"line\">        &#125;.done &#123; image <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>.imageView.image = image</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"got image\"</span>)</span><br><span class=\"line\">        &#125;.<span class=\"keyword\">catch</span> &#123; error <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">login</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Promise</span>&lt;<span class=\"type\">Info</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"start login\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Promise</span> &#123; seal <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span>.sleep(forTimeInterval: <span class=\"number\">2</span>)</span><br><span class=\"line\">                seal.fulfill(<span class=\"type\">Info</span>(url: <span class=\"string\">\"https://www.baidu.com\"</span>))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">fetch</span><span class=\"params\">(imageUrl: String)</span></span> -&gt; <span class=\"type\">Promise</span>&lt;<span class=\"type\">UIImage</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"start fetch image\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Promise</span> &#123; seal <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span>.sleep(forTimeInterval: <span class=\"number\">2</span>)</span><br><span class=\"line\">                seal.reject(<span class=\"type\">MyError</span>(description: <span class=\"string\">\"获取图片出错了\"</span>))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我就简单的 sleep 了两秒钟来模拟网络请求。我们可以看到，代码成功地变成了扁平的，避免了层层嵌套。在 Promise Kit 中，执行成功的函数被叫做了 fulfilll。firstly 只是语法糖，直接调用 <code>login().then</code> 是完全一样的，但是使用 firstly 将使得语义更加清晰。</p>\n"},{"title":"RunLoop 原理","date":"2019-12-23T14:07:50.000Z","_content":"\n# RunLoop - 原理\n\nRunLoop 是许多 iOS 开发者都会“假装”理解的概念。相关的概念常看常新，每次都有一番新的收获 （每次都不能彻底理解系列）～\n\n## 一句话概括 RunLoop 是干啥的\n\n就是一种 Event Loop。通过它来避免程序退出，同时高效地管理和相应各种事件。\n\n## 这个循环在哪里\n\n随着 Swift 的诞生，Apple 开源了一个跨平台的 Foundation 框架：https://github.com/apple/swift-corelibs-foundation 。我们可以在源码中找到这个循环：\n\n```c\nvoid CFRunLoopRun(void) {\t/* DOES CALLOUT */\n    int32_t result;\n    do {\n        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);\n        CHECK_FOR_FORK();\n    } while (kCFRunLoopRunStopped != result && kCFRunLoopRunFinished != result);\n}\n```\n\n可以看到就是一个简单的 do-while 循环，传入了当前的 RunLoop 作为参数。但这个循环并不是真正的 RunLoop 循环。\n\n---\n\n### 跑个题：啥是 check_for_fork\n\n当我们 fork 出来一个进程的时候，必须要紧接着调用一个 `exec` 家族的函数，从而让这个进程变成一个“全新的”进程。否则，包括 CoreFoundation, CoreData 甚至 Cocoa 等基础的框架都会出现异常。这里苹果检测了进程是否是 fork 出来的，如果是，就会调用 `__THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__` 这个断言让程序崩溃。\n\n---\n\n回归正题。\n\n## RunLoop 的获取\n\n我们看到在循环中，调用了 `CFRunLoopGetCurrent()` 函数来获取当前的 RunLoop，并作为参数传入。那么这个函数里都做了什么呢？\n\n我们都知道苹果不允许我们自己手动创建 RunLoop，除了主线程的 RunLoop 会自动被创建之外，其他线程的 RunLoop 都是在第一次获取的时候被创建出来的。来看一下这个获取当前 RunLoop 对象的函数实现：\n\n```c\nCFRunLoopRef CFRunLoopGetCurrent(void) {\n    CHECK_FOR_FORK();\n    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);\n    if (rl) return rl;\n    return _CFRunLoopGet0(pthread_self());\n}\n```\n\n这个函数的返回值是 `CFRunLoopRef` ，也就是 `RunLoop` 结构体的指针类型。之后，先尝试调用 `_CFGetTSD` 函数获取，如果拿不到，再调用 `_CFRunLoopGet0` 函数。\n\n---\n\n### 跑个题：啥是 TSD\n\nTSD 全称 Thread-Specific Data，线程特有数据，有时也叫 Thread-Local Storage, TLS。其中的数据对线程内部透明，而对其他线程屏蔽。使用的时候，可以理解成一个 KV 存储，并可以设定一个 `destructor` 析构函数指针，会在线程销毁时调用。\n\n每一个进程都持有一个 keys 的数组，数组中，每一个元素包含一个用于指示 key 状态的 flag，和 destructor 函数指针。每一个线程的 TCB 也都含有一个指针数组，其中每个元素和 keys 数组一一对应。TCB 中这个数组的每一个元素指向该线程的 TSD。\n\n![tsd](/img/RunLoop/tsd.png)\n\n---\n\n所以我们看到，其实 RunLoop 是存储在线程的 TSD 中的。这也就是为什么我们说每个 RunLoop 是和线程一一对应的。而在线程退出的时候，对应的 RunLoop 也会被销毁掉。\n\n继续看一下 `_CFRunLoopGet0` 函数里都做了什么。这里只保留了一些关键的代码。\n\n```c\n// should only be called by Foundation\n// t==0 is a synonym for \"main thread\" that always works\nCF_EXPORT CFRunLoopRef _CFRunLoopGet0(_CFThreadRef t) {\n    //...\n    __CFLock(&loopsLock);\n    if (!__CFRunLoops) { //__CFRunLoops 是一个全局的字典 如果为空\n\t\t\t\tCFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks); //就创造一个字典\n\t\t\t\tCFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); //然后创建主线程的 RunLoop\n\t\t\t\tCFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); //之后放到这个字典里\n\t\t\t\tif (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&__CFRunLoops)) {\n\t    \t\tCFRelease(dict);\n\t\t\t\t} //最后把这个字典设置为全局的 __CFRunLoops 并通过锁来保证线程安全\n\t\t\t\tCFRelease(mainLoop);\n    }\n    CFRunLoopRef newLoop = NULL;\n  \t//尝试从全局的字典里获取 RunLoop\n    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n    if (!loop) {\n\t\t\t\tnewLoop = __CFRunLoopCreate(t); //没有的话就创建一个\n        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); //然后放到字典里\n        loop = newLoop;\n    }\n    __CFUnlock(&loopsLock);\n    // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it\n    if (newLoop) { CFRelease(newLoop); }\n    \n  \t// 最后设置 TSD\n    if (pthread_equal(t, pthread_self())) {\n        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);\n        //...\n    }\n    return loop;\n}\n```\n\n### 困惑\n\n既然 RunLoop 已经被存储到线程的 TSD 里了，为什么还需要用一个字典再来记录一遍线程和 RunLoop 的对应关系呢？\n\n## RunLoop 的创建\n\n我们看到如果取不到 RunLoop 的时候，会调用 `__CFRunLoopCreate` 来创建一个。这个函数的实现比较简单，只是创建了一个 RunLoop 的实例，并赋初值。\n\n## 循环内部逻辑\n\n现在，描述 RunLoop 的对象已经被创建出来了。每次循环中，它都会被传入到 `CFRunLoopRunSpecific` 函数里。现在来看一下这个函数中每次都会执行哪些逻辑。这个函数比较长，简化之后核心逻辑是这样的：\n\n```c\nSInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */\n    CHECK_FOR_FORK();\n    if (modeName == NULL || modeName == kCFRunLoopCommonModes || CFEqual(modeName, kCFRunLoopCommonModes)) {\n        //参数不合法，直接返回并退出 RunLoop\n      \t//...\n        return kCFRunLoopRunFinished;\n    }\n    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;\n    __CFRunLoopLock(rl);\n  \t//根据 modeName 找 mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);\n    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl->_currentMode)) {\n\t\t\t//如果找不到，或 mode 里没有 source/timer/observer 直接返回\n\t\t\treturn did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;\n    }\n    //...\n\t\t\tif (currentMode->_observerMask & kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); //通知 observers 进入 loop\n     \tresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); //处理事件\n       if (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); //通知 observers 离开 loop\n  \t//...\n    return result;\n}\n```\n\n核心就是根据 modeName 拿到 mode，然后传给 `__CFRunLoopRun` 函数处理。期间通知观察者循环的进入和退出。\n\n再来看看 `__CFRunLoopRun` 里面都 run 了哪些逻辑。这里删除了不少代码，只留下核心部分。\n\n```c\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    int32_t retVal = 0;\n    do { //真正的 RunLoop 循环\n        if (rlm->_observerMask & kCFRunLoopBeforeTimers) {\n            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); //通知观察者，即将触发 Timers 回调\n        }\n        \n        if (rlm->_observerMask & kCFRunLoopBeforeSources) {\n            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); //通知观察者，即将触发 Sources 回调\n        }\n\n\t__CFRunLoopDoBlocks(rl, rlm); //执行被加入 RunLoop 的 blocks\n\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); //触发 Sources0 回调\n        if (sourceHandledThisLoop) {\n            __CFRunLoopDoBlocks(rl, rlm); //执行被加入 RunLoop 的 blocks\n        }\n\n\t#if TARGET_OS_MAC\n        msg = (mach_msg_header_t *)msg_buffer;\n       \tif (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL, rl, rlm)) { //如果是 macOS，处理 Source1\n        \tgoto handle_msg; //然后直接跳到 handle_msg\n        }\n\tif (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); //通知观察者即将休眠\n\t__CFRunLoopSetSleeping(rl); \n\n        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy, rl, rlm); //休眠，直到被 Timer，基于 port 的事件，超时等事件唤醒\n\n        rl->_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));\n\n\t__CFRunLoopUnsetSleeping(rl);\n\tif (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); //通知观察者结束休眠状态\n\n        handle_msg:; //开始处理 msg\n\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        else if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            cf_trace(KDEBUG_EVENT_CFRL_WAKEUP_FOR_TIMER, rl, rlm, livePort, 0);\n            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time()) //处理 timers 事件\n        }\n#endif\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); //执行 dispatch 到 main queue 的 block\n        }\n        else {\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);\n            if (rls) {\n#if TARGET_OS_MAC\n\t\tmach_msg_header_t *reply = NULL;\n\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop; //处理 source1 事件\n\t\tif (NULL != reply) {\n\t\t    (void)mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);\n\t\t    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);\n\t\t}\n            }\n            \n        }\n\t__CFRunLoopDoBlocks(rl, rlm); //处理被加入 RunLoop 的 block\n        \n    } while (0 == retVal); //如果没超时，mode没空，也没被停止，则继续循环\n    \n    return retVal;\n}\n```\n\n根据苹果的文档，一次 RunLoop 中处理步骤如下：\n\n1. 通知观察者进入 RunLoop\n2. 通知观察者 ready 的计时器即将触发\n3. 通知观察者不是基于 port 的 input sources 即将触发\n4. 触发 ready 的非基于 port 的 sources\n5. 如果有基于 port 的 sources 已经 ready，直接触发，goto 9\n6. 通知观察者即将休眠\n7. 让线程休眠，除非被一些事件唤醒\n8. 通知观察者线程已经苏醒\n9. 开始处理事件：\n   1. 如果 timer ready 了，处理并继续循环，回到 2\n   2. 超时等情况退出循环\n10. 通知观察者 RunLoop 退出了。\n\n**关于 source0 和 source1**：source1 是基于 port 的事件，是来自其他进程或系统内核的消息。source0 是其余的应用层事件。但有的时候，source1 事件会转交给 source0 来处理，比如触摸事件。当我们触摸屏幕时，会产生硬件中断；操作系统内核会把相关的消息通过 port 发送给应用程序，即 source1 事件；接着这些触摸事件会被丢到事件队列里，再交给 source0 处理。\n\n\n\n不出意外的话，后面还会有一篇 RunLoop 的使用～\n\n\n\nRef:\n\n1. [深入理解 RunLoop](https://blog.ibireme.com/2015/05/18/runloop/)\n2. [iOS底层原理总结 - RunLoop](https://www.jianshu.com/p/de752066d0ad)\n3. [重拾RunLoop原理](https://www.neroxie.com/2019/04/24/重拾RunLoop原理/)\n4. [RunLoop 源码阅读](https://juejin.im/post/5aaa15d36fb9a028d82b7d83)\n5. [线程特有数据](https://www.jianshu.com/p/61c2d33877f4)\n6. [Run Loops](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23) , Apple\n7. [关于RunLoop你想知道的事](https://zhuanlan.zhihu.com/p/62605958)","source":"_posts/RunLoop原理.md","raw":"---\ntitle: RunLoop 原理\ndate: 2019-12-23 22:07:50\ntags: RunLoop\n---\n\n# RunLoop - 原理\n\nRunLoop 是许多 iOS 开发者都会“假装”理解的概念。相关的概念常看常新，每次都有一番新的收获 （每次都不能彻底理解系列）～\n\n## 一句话概括 RunLoop 是干啥的\n\n就是一种 Event Loop。通过它来避免程序退出，同时高效地管理和相应各种事件。\n\n## 这个循环在哪里\n\n随着 Swift 的诞生，Apple 开源了一个跨平台的 Foundation 框架：https://github.com/apple/swift-corelibs-foundation 。我们可以在源码中找到这个循环：\n\n```c\nvoid CFRunLoopRun(void) {\t/* DOES CALLOUT */\n    int32_t result;\n    do {\n        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);\n        CHECK_FOR_FORK();\n    } while (kCFRunLoopRunStopped != result && kCFRunLoopRunFinished != result);\n}\n```\n\n可以看到就是一个简单的 do-while 循环，传入了当前的 RunLoop 作为参数。但这个循环并不是真正的 RunLoop 循环。\n\n---\n\n### 跑个题：啥是 check_for_fork\n\n当我们 fork 出来一个进程的时候，必须要紧接着调用一个 `exec` 家族的函数，从而让这个进程变成一个“全新的”进程。否则，包括 CoreFoundation, CoreData 甚至 Cocoa 等基础的框架都会出现异常。这里苹果检测了进程是否是 fork 出来的，如果是，就会调用 `__THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__` 这个断言让程序崩溃。\n\n---\n\n回归正题。\n\n## RunLoop 的获取\n\n我们看到在循环中，调用了 `CFRunLoopGetCurrent()` 函数来获取当前的 RunLoop，并作为参数传入。那么这个函数里都做了什么呢？\n\n我们都知道苹果不允许我们自己手动创建 RunLoop，除了主线程的 RunLoop 会自动被创建之外，其他线程的 RunLoop 都是在第一次获取的时候被创建出来的。来看一下这个获取当前 RunLoop 对象的函数实现：\n\n```c\nCFRunLoopRef CFRunLoopGetCurrent(void) {\n    CHECK_FOR_FORK();\n    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);\n    if (rl) return rl;\n    return _CFRunLoopGet0(pthread_self());\n}\n```\n\n这个函数的返回值是 `CFRunLoopRef` ，也就是 `RunLoop` 结构体的指针类型。之后，先尝试调用 `_CFGetTSD` 函数获取，如果拿不到，再调用 `_CFRunLoopGet0` 函数。\n\n---\n\n### 跑个题：啥是 TSD\n\nTSD 全称 Thread-Specific Data，线程特有数据，有时也叫 Thread-Local Storage, TLS。其中的数据对线程内部透明，而对其他线程屏蔽。使用的时候，可以理解成一个 KV 存储，并可以设定一个 `destructor` 析构函数指针，会在线程销毁时调用。\n\n每一个进程都持有一个 keys 的数组，数组中，每一个元素包含一个用于指示 key 状态的 flag，和 destructor 函数指针。每一个线程的 TCB 也都含有一个指针数组，其中每个元素和 keys 数组一一对应。TCB 中这个数组的每一个元素指向该线程的 TSD。\n\n![tsd](/img/RunLoop/tsd.png)\n\n---\n\n所以我们看到，其实 RunLoop 是存储在线程的 TSD 中的。这也就是为什么我们说每个 RunLoop 是和线程一一对应的。而在线程退出的时候，对应的 RunLoop 也会被销毁掉。\n\n继续看一下 `_CFRunLoopGet0` 函数里都做了什么。这里只保留了一些关键的代码。\n\n```c\n// should only be called by Foundation\n// t==0 is a synonym for \"main thread\" that always works\nCF_EXPORT CFRunLoopRef _CFRunLoopGet0(_CFThreadRef t) {\n    //...\n    __CFLock(&loopsLock);\n    if (!__CFRunLoops) { //__CFRunLoops 是一个全局的字典 如果为空\n\t\t\t\tCFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &kCFTypeDictionaryValueCallBacks); //就创造一个字典\n\t\t\t\tCFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); //然后创建主线程的 RunLoop\n\t\t\t\tCFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); //之后放到这个字典里\n\t\t\t\tif (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&__CFRunLoops)) {\n\t    \t\tCFRelease(dict);\n\t\t\t\t} //最后把这个字典设置为全局的 __CFRunLoops 并通过锁来保证线程安全\n\t\t\t\tCFRelease(mainLoop);\n    }\n    CFRunLoopRef newLoop = NULL;\n  \t//尝试从全局的字典里获取 RunLoop\n    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));\n    if (!loop) {\n\t\t\t\tnewLoop = __CFRunLoopCreate(t); //没有的话就创建一个\n        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); //然后放到字典里\n        loop = newLoop;\n    }\n    __CFUnlock(&loopsLock);\n    // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it\n    if (newLoop) { CFRelease(newLoop); }\n    \n  \t// 最后设置 TSD\n    if (pthread_equal(t, pthread_self())) {\n        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);\n        //...\n    }\n    return loop;\n}\n```\n\n### 困惑\n\n既然 RunLoop 已经被存储到线程的 TSD 里了，为什么还需要用一个字典再来记录一遍线程和 RunLoop 的对应关系呢？\n\n## RunLoop 的创建\n\n我们看到如果取不到 RunLoop 的时候，会调用 `__CFRunLoopCreate` 来创建一个。这个函数的实现比较简单，只是创建了一个 RunLoop 的实例，并赋初值。\n\n## 循环内部逻辑\n\n现在，描述 RunLoop 的对象已经被创建出来了。每次循环中，它都会被传入到 `CFRunLoopRunSpecific` 函数里。现在来看一下这个函数中每次都会执行哪些逻辑。这个函数比较长，简化之后核心逻辑是这样的：\n\n```c\nSInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     /* DOES CALLOUT */\n    CHECK_FOR_FORK();\n    if (modeName == NULL || modeName == kCFRunLoopCommonModes || CFEqual(modeName, kCFRunLoopCommonModes)) {\n        //参数不合法，直接返回并退出 RunLoop\n      \t//...\n        return kCFRunLoopRunFinished;\n    }\n    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;\n    __CFRunLoopLock(rl);\n  \t//根据 modeName 找 mode\n    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);\n    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl->_currentMode)) {\n\t\t\t//如果找不到，或 mode 里没有 source/timer/observer 直接返回\n\t\t\treturn did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;\n    }\n    //...\n\t\t\tif (currentMode->_observerMask & kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); //通知 observers 进入 loop\n     \tresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); //处理事件\n       if (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); //通知 observers 离开 loop\n  \t//...\n    return result;\n}\n```\n\n核心就是根据 modeName 拿到 mode，然后传给 `__CFRunLoopRun` 函数处理。期间通知观察者循环的进入和退出。\n\n再来看看 `__CFRunLoopRun` 里面都 run 了哪些逻辑。这里删除了不少代码，只留下核心部分。\n\n```c\nstatic int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {\n    int32_t retVal = 0;\n    do { //真正的 RunLoop 循环\n        if (rlm->_observerMask & kCFRunLoopBeforeTimers) {\n            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); //通知观察者，即将触发 Timers 回调\n        }\n        \n        if (rlm->_observerMask & kCFRunLoopBeforeSources) {\n            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); //通知观察者，即将触发 Sources 回调\n        }\n\n\t__CFRunLoopDoBlocks(rl, rlm); //执行被加入 RunLoop 的 blocks\n\n        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); //触发 Sources0 回调\n        if (sourceHandledThisLoop) {\n            __CFRunLoopDoBlocks(rl, rlm); //执行被加入 RunLoop 的 blocks\n        }\n\n\t#if TARGET_OS_MAC\n        msg = (mach_msg_header_t *)msg_buffer;\n       \tif (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL, rl, rlm)) { //如果是 macOS，处理 Source1\n        \tgoto handle_msg; //然后直接跳到 handle_msg\n        }\n\tif (!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); //通知观察者即将休眠\n\t__CFRunLoopSetSleeping(rl); \n\n        __CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy, rl, rlm); //休眠，直到被 Timer，基于 port 的事件，超时等事件唤醒\n\n        rl->_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));\n\n\t__CFRunLoopUnsetSleeping(rl);\n\tif (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); //通知观察者结束休眠状态\n\n        handle_msg:; //开始处理 msg\n\n#if USE_DISPATCH_SOURCE_FOR_TIMERS\n        else if (modeQueuePort != MACH_PORT_NULL && livePort == modeQueuePort) {\n            CFRUNLOOP_WAKEUP_FOR_TIMER();\n            cf_trace(KDEBUG_EVENT_CFRL_WAKEUP_FOR_TIMER, rl, rlm, livePort, 0);\n            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time()) //处理 timers 事件\n        }\n#endif\n            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); //执行 dispatch 到 main queue 的 block\n        }\n        else {\n            CFRUNLOOP_WAKEUP_FOR_SOURCE();\n            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);\n            if (rls) {\n#if TARGET_OS_MAC\n\t\tmach_msg_header_t *reply = NULL;\n\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply) || sourceHandledThisLoop; //处理 source1 事件\n\t\tif (NULL != reply) {\n\t\t    (void)mach_msg(reply, MACH_SEND_MSG, reply->msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);\n\t\t    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);\n\t\t}\n            }\n            \n        }\n\t__CFRunLoopDoBlocks(rl, rlm); //处理被加入 RunLoop 的 block\n        \n    } while (0 == retVal); //如果没超时，mode没空，也没被停止，则继续循环\n    \n    return retVal;\n}\n```\n\n根据苹果的文档，一次 RunLoop 中处理步骤如下：\n\n1. 通知观察者进入 RunLoop\n2. 通知观察者 ready 的计时器即将触发\n3. 通知观察者不是基于 port 的 input sources 即将触发\n4. 触发 ready 的非基于 port 的 sources\n5. 如果有基于 port 的 sources 已经 ready，直接触发，goto 9\n6. 通知观察者即将休眠\n7. 让线程休眠，除非被一些事件唤醒\n8. 通知观察者线程已经苏醒\n9. 开始处理事件：\n   1. 如果 timer ready 了，处理并继续循环，回到 2\n   2. 超时等情况退出循环\n10. 通知观察者 RunLoop 退出了。\n\n**关于 source0 和 source1**：source1 是基于 port 的事件，是来自其他进程或系统内核的消息。source0 是其余的应用层事件。但有的时候，source1 事件会转交给 source0 来处理，比如触摸事件。当我们触摸屏幕时，会产生硬件中断；操作系统内核会把相关的消息通过 port 发送给应用程序，即 source1 事件；接着这些触摸事件会被丢到事件队列里，再交给 source0 处理。\n\n\n\n不出意外的话，后面还会有一篇 RunLoop 的使用～\n\n\n\nRef:\n\n1. [深入理解 RunLoop](https://blog.ibireme.com/2015/05/18/runloop/)\n2. [iOS底层原理总结 - RunLoop](https://www.jianshu.com/p/de752066d0ad)\n3. [重拾RunLoop原理](https://www.neroxie.com/2019/04/24/重拾RunLoop原理/)\n4. [RunLoop 源码阅读](https://juejin.im/post/5aaa15d36fb9a028d82b7d83)\n5. [线程特有数据](https://www.jianshu.com/p/61c2d33877f4)\n6. [Run Loops](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23) , Apple\n7. [关于RunLoop你想知道的事](https://zhuanlan.zhihu.com/p/62605958)","slug":"RunLoop原理","published":1,"updated":"2020-01-04T08:16:16.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3y0035ljc3m4n8rk6h","content":"<h1 id=\"RunLoop-原理\"><a href=\"#RunLoop-原理\" class=\"headerlink\" title=\"RunLoop - 原理\"></a>RunLoop - 原理</h1><p>RunLoop 是许多 iOS 开发者都会“假装”理解的概念。相关的概念常看常新，每次都有一番新的收获 （每次都不能彻底理解系列）～</p>\n<h2 id=\"一句话概括-RunLoop-是干啥的\"><a href=\"#一句话概括-RunLoop-是干啥的\" class=\"headerlink\" title=\"一句话概括 RunLoop 是干啥的\"></a>一句话概括 RunLoop 是干啥的</h2><p>就是一种 Event Loop。通过它来避免程序退出，同时高效地管理和相应各种事件。</p>\n<h2 id=\"这个循环在哪里\"><a href=\"#这个循环在哪里\" class=\"headerlink\" title=\"这个循环在哪里\"></a>这个循环在哪里</h2><p>随着 Swift 的诞生，Apple 开源了一个跨平台的 Foundation 框架：<a href=\"https://github.com/apple/swift-corelibs-foundation\">https://github.com/apple/swift-corelibs-foundation</a> 。我们可以在源码中找到这个循环：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CFRunLoopRun</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;\t<span class=\"comment\">/* DOES CALLOUT */</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> result;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class=\"number\">1.0e10</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        CHECK_FOR_FORK();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到就是一个简单的 do-while 循环，传入了当前的 RunLoop 作为参数。但这个循环并不是真正的 RunLoop 循环。</p>\n<hr>\n<h3 id=\"跑个题：啥是-check-for-fork\"><a href=\"#跑个题：啥是-check-for-fork\" class=\"headerlink\" title=\"跑个题：啥是 check_for_fork\"></a>跑个题：啥是 check_for_fork</h3><p>当我们 fork 出来一个进程的时候，必须要紧接着调用一个 <code>exec</code> 家族的函数，从而让这个进程变成一个“全新的”进程。否则，包括 CoreFoundation, CoreData 甚至 Cocoa 等基础的框架都会出现异常。这里苹果检测了进程是否是 fork 出来的，如果是，就会调用 <code>__THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__</code> 这个断言让程序崩溃。</p>\n<hr>\n<p>回归正题。</p>\n<h2 id=\"RunLoop-的获取\"><a href=\"#RunLoop-的获取\" class=\"headerlink\" title=\"RunLoop 的获取\"></a>RunLoop 的获取</h2><p>我们看到在循环中，调用了 <code>CFRunLoopGetCurrent()</code> 函数来获取当前的 RunLoop，并作为参数传入。那么这个函数里都做了什么呢？</p>\n<p>我们都知道苹果不允许我们自己手动创建 RunLoop，除了主线程的 RunLoop 会自动被创建之外，其他线程的 RunLoop 都是在第一次获取的时候被创建出来的。来看一下这个获取当前 RunLoop 对象的函数实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">CFRunLoopRef <span class=\"title\">CFRunLoopGetCurrent</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    CHECK_FOR_FORK();</span><br><span class=\"line\">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rl) <span class=\"keyword\">return</span> rl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数的返回值是 <code>CFRunLoopRef</code> ，也就是 <code>RunLoop</code> 结构体的指针类型。之后，先尝试调用 <code>_CFGetTSD</code> 函数获取，如果拿不到，再调用 <code>_CFRunLoopGet0</code> 函数。</p>\n<hr>\n<h3 id=\"跑个题：啥是-TSD\"><a href=\"#跑个题：啥是-TSD\" class=\"headerlink\" title=\"跑个题：啥是 TSD\"></a>跑个题：啥是 TSD</h3><p>TSD 全称 Thread-Specific Data，线程特有数据，有时也叫 Thread-Local Storage, TLS。其中的数据对线程内部透明，而对其他线程屏蔽。使用的时候，可以理解成一个 KV 存储，并可以设定一个 <code>destructor</code> 析构函数指针，会在线程销毁时调用。</p>\n<p>每一个进程都持有一个 keys 的数组，数组中，每一个元素包含一个用于指示 key 状态的 flag，和 destructor 函数指针。每一个线程的 TCB 也都含有一个指针数组，其中每个元素和 keys 数组一一对应。TCB 中这个数组的每一个元素指向该线程的 TSD。</p>\n<p><img src=\"/img/RunLoop/tsd.png\" alt=\"tsd\"></p>\n<hr>\n<p>所以我们看到，其实 RunLoop 是存储在线程的 TSD 中的。这也就是为什么我们说每个 RunLoop 是和线程一一对应的。而在线程退出的时候，对应的 RunLoop 也会被销毁掉。</p>\n<p>继续看一下 <code>_CFRunLoopGet0</code> 函数里都做了什么。这里只保留了一些关键的代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// should only be called by Foundation</span></span><br><span class=\"line\"><span class=\"comment\">// t==0 is a synonym for \"main thread\" that always works</span></span><br><span class=\"line\">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(_CFThreadRef t) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    __CFLock(&amp;loopsLock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__CFRunLoops) &#123; <span class=\"comment\">//__CFRunLoops 是一个全局的字典 如果为空</span></span><br><span class=\"line\">\t\t\t\tCFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks); <span class=\"comment\">//就创造一个字典</span></span><br><span class=\"line\">\t\t\t\tCFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); <span class=\"comment\">//然后创建主线程的 RunLoop</span></span><br><span class=\"line\">\t\t\t\tCFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); <span class=\"comment\">//之后放到这个字典里</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class=\"literal\">NULL</span>, dict, (<span class=\"keyword\">void</span> * <span class=\"keyword\">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class=\"line\">\t    \t\tCFRelease(dict);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"comment\">//最后把这个字典设置为全局的 __CFRunLoops 并通过锁来保证线程安全</span></span><br><span class=\"line\">\t\t\t\tCFRelease(mainLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CFRunLoopRef newLoop = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  \t<span class=\"comment\">//尝试从全局的字典里获取 RunLoop</span></span><br><span class=\"line\">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loop) &#123;</span><br><span class=\"line\">\t\t\t\tnewLoop = __CFRunLoopCreate(t); <span class=\"comment\">//没有的话就创建一个</span></span><br><span class=\"line\">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); <span class=\"comment\">//然后放到字典里</span></span><br><span class=\"line\">        loop = newLoop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __CFUnlock(&amp;loopsLock);</span><br><span class=\"line\">    <span class=\"comment\">// don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newLoop) &#123; CFRelease(newLoop); &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  \t<span class=\"comment\">// 最后设置 TSD</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class=\"line\">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class=\"keyword\">void</span> *)loop, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"困惑\"><a href=\"#困惑\" class=\"headerlink\" title=\"困惑\"></a>困惑</h3><p>既然 RunLoop 已经被存储到线程的 TSD 里了，为什么还需要用一个字典再来记录一遍线程和 RunLoop 的对应关系呢？</p>\n<h2 id=\"RunLoop-的创建\"><a href=\"#RunLoop-的创建\" class=\"headerlink\" title=\"RunLoop 的创建\"></a>RunLoop 的创建</h2><p>我们看到如果取不到 RunLoop 的时候，会调用 <code>__CFRunLoopCreate</code> 来创建一个。这个函数的实现比较简单，只是创建了一个 RunLoop 的实例，并赋初值。</p>\n<h2 id=\"循环内部逻辑\"><a href=\"#循环内部逻辑\" class=\"headerlink\" title=\"循环内部逻辑\"></a>循环内部逻辑</h2><p>现在，描述 RunLoop 的对象已经被创建出来了。每次循环中，它都会被传入到 <code>CFRunLoopRunSpecific</code> 函数里。现在来看一下这个函数中每次都会执行哪些逻辑。这个函数比较长，简化之后核心逻辑是这样的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SInt32 <span class=\"title\">CFRunLoopRunSpecific</span><span class=\"params\">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class=\"comment\">/* DOES CALLOUT */</span></span><br><span class=\"line\">    CHECK_FOR_FORK();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modeName == <span class=\"literal\">NULL</span> || modeName == kCFRunLoopCommonModes || CFEqual(modeName, kCFRunLoopCommonModes)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//参数不合法，直接返回并退出 RunLoop</span></span><br><span class=\"line\">      \t<span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> kCFRunLoopRunFinished;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__CFRunLoopIsDeallocating(rl)) <span class=\"keyword\">return</span> kCFRunLoopRunFinished;</span><br><span class=\"line\">    __CFRunLoopLock(rl);</span><br><span class=\"line\">  \t<span class=\"comment\">//根据 modeName 找 mode</span></span><br><span class=\"line\">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果找不到，或 mode 里没有 source/timer/observer 直接返回</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); <span class=\"comment\">//通知 observers 进入 loop</span></span><br><span class=\"line\">     \tresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); <span class=\"comment\">//处理事件</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); <span class=\"comment\">//通知 observers 离开 loop</span></span><br><span class=\"line\">  \t<span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>核心就是根据 modeName 拿到 mode，然后传给 <code>__CFRunLoopRun</code> 函数处理。期间通知观察者循环的进入和退出。</p>\n<p>再来看看 <code>__CFRunLoopRun</code> 里面都 run 了哪些逻辑。这里删除了不少代码，只留下核心部分。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> retVal = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123; <span class=\"comment\">//真正的 RunLoop 循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) &#123;</span><br><span class=\"line\">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); <span class=\"comment\">//通知观察者，即将触发 Timers 回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) &#123;</span><br><span class=\"line\">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); <span class=\"comment\">//通知观察者，即将触发 Sources 回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm); <span class=\"comment\">//执行被加入 RunLoop 的 blocks</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); <span class=\"comment\">//触发 Sources0 回调</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceHandledThisLoop) &#123;</span><br><span class=\"line\">            __CFRunLoopDoBlocks(rl, rlm); <span class=\"comment\">//执行被加入 RunLoop 的 blocks</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_OS_MAC</span></span><br><span class=\"line\">        msg = (<span class=\"keyword\">mach_msg_header_t</span> *)msg_buffer;</span><br><span class=\"line\">       \t<span class=\"keyword\">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, <span class=\"number\">0</span>, &amp;voucherState, <span class=\"literal\">NULL</span>, rl, rlm)) &#123; <span class=\"comment\">//如果是 macOS，处理 Source1</span></span><br><span class=\"line\">        \t<span class=\"keyword\">goto</span> handle_msg; <span class=\"comment\">//然后直接跳到 handle_msg</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); <span class=\"comment\">//通知观察者即将休眠</span></span><br><span class=\"line\">\t__CFRunLoopSetSleeping(rl); </span><br><span class=\"line\"></span><br><span class=\"line\">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class=\"number\">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy, rl, rlm); <span class=\"comment\">//休眠，直到被 Timer，基于 port 的事件，超时等事件唤醒</span></span><br><span class=\"line\"></span><br><span class=\"line\">        rl-&gt;_sleepTime += (poll ? <span class=\"number\">0.0</span> : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class=\"line\"></span><br><span class=\"line\">\t__CFRunLoopUnsetSleeping(rl);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); <span class=\"comment\">//通知观察者结束休眠状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">        handle_msg:; <span class=\"comment\">//开始处理 msg</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class=\"line\">            cf_trace(KDEBUG_EVENT_CFRL_WAKEUP_FOR_TIMER, rl, rlm, livePort, <span class=\"number\">0</span>);</span><br><span class=\"line\">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time()) <span class=\"comment\">//处理 timers 事件</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); <span class=\"comment\">//执行 dispatch 到 main queue 的 block</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class=\"line\">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rls) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_OS_MAC</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">mach_msg_header_t</span> *reply = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop; <span class=\"comment\">//处理 source1 事件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != reply) &#123;</span><br><span class=\"line\">\t\t    (<span class=\"keyword\">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class=\"number\">0</span>, MACH_PORT_NULL, <span class=\"number\">0</span>, MACH_PORT_NULL);</span><br><span class=\"line\">\t\t    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm); <span class=\"comment\">//处理被加入 RunLoop 的 block</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span> == retVal); <span class=\"comment\">//如果没超时，mode没空，也没被停止，则继续循环</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> retVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据苹果的文档，一次 RunLoop 中处理步骤如下：</p>\n<ol>\n<li>通知观察者进入 RunLoop</li>\n<li>通知观察者 ready 的计时器即将触发</li>\n<li>通知观察者不是基于 port 的 input sources 即将触发</li>\n<li>触发 ready 的非基于 port 的 sources</li>\n<li>如果有基于 port 的 sources 已经 ready，直接触发，goto 9</li>\n<li>通知观察者即将休眠</li>\n<li>让线程休眠，除非被一些事件唤醒</li>\n<li>通知观察者线程已经苏醒</li>\n<li>开始处理事件：<ol>\n<li>如果 timer ready 了，处理并继续循环，回到 2</li>\n<li>超时等情况退出循环</li>\n</ol>\n</li>\n<li>通知观察者 RunLoop 退出了。</li>\n</ol>\n<p><strong>关于 source0 和 source1</strong>：source1 是基于 port 的事件，是来自其他进程或系统内核的消息。source0 是其余的应用层事件。但有的时候，source1 事件会转交给 source0 来处理，比如触摸事件。当我们触摸屏幕时，会产生硬件中断；操作系统内核会把相关的消息通过 port 发送给应用程序，即 source1 事件；接着这些触摸事件会被丢到事件队列里，再交给 source0 处理。</p>\n<p>不出意外的话，后面还会有一篇 RunLoop 的使用～</p>\n<p>Ref:</p>\n<ol>\n<li><a href=\"https://blog.ibireme.com/2015/05/18/runloop/\">深入理解 RunLoop</a></li>\n<li><a href=\"https://www.jianshu.com/p/de752066d0ad\">iOS底层原理总结 - RunLoop</a></li>\n<li><a href=\"https://www.neroxie.com/2019/04/24/重拾RunLoop原理/\">重拾RunLoop原理</a></li>\n<li><a href=\"https://juejin.im/post/5aaa15d36fb9a028d82b7d83\">RunLoop 源码阅读</a></li>\n<li><a href=\"https://www.jianshu.com/p/61c2d33877f4\">线程特有数据</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23\">Run Loops</a> , Apple</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/62605958\">关于RunLoop你想知道的事</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"RunLoop-原理\"><a href=\"#RunLoop-原理\" class=\"headerlink\" title=\"RunLoop - 原理\"></a>RunLoop - 原理</h1><p>RunLoop 是许多 iOS 开发者都会“假装”理解的概念。相关的概念常看常新，每次都有一番新的收获 （每次都不能彻底理解系列）～</p>\n<h2 id=\"一句话概括-RunLoop-是干啥的\"><a href=\"#一句话概括-RunLoop-是干啥的\" class=\"headerlink\" title=\"一句话概括 RunLoop 是干啥的\"></a>一句话概括 RunLoop 是干啥的</h2><p>就是一种 Event Loop。通过它来避免程序退出，同时高效地管理和相应各种事件。</p>\n<h2 id=\"这个循环在哪里\"><a href=\"#这个循环在哪里\" class=\"headerlink\" title=\"这个循环在哪里\"></a>这个循环在哪里</h2><p>随着 Swift 的诞生，Apple 开源了一个跨平台的 Foundation 框架：<a href=\"https://github.com/apple/swift-corelibs-foundation\">https://github.com/apple/swift-corelibs-foundation</a> 。我们可以在源码中找到这个循环：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CFRunLoopRun</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;\t<span class=\"comment\">/* DOES CALLOUT */</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> result;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class=\"number\">1.0e10</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        CHECK_FOR_FORK();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到就是一个简单的 do-while 循环，传入了当前的 RunLoop 作为参数。但这个循环并不是真正的 RunLoop 循环。</p>\n<hr>\n<h3 id=\"跑个题：啥是-check-for-fork\"><a href=\"#跑个题：啥是-check-for-fork\" class=\"headerlink\" title=\"跑个题：啥是 check_for_fork\"></a>跑个题：啥是 check_for_fork</h3><p>当我们 fork 出来一个进程的时候，必须要紧接着调用一个 <code>exec</code> 家族的函数，从而让这个进程变成一个“全新的”进程。否则，包括 CoreFoundation, CoreData 甚至 Cocoa 等基础的框架都会出现异常。这里苹果检测了进程是否是 fork 出来的，如果是，就会调用 <code>__THE_PROCESS_HAS_FORKED_AND_YOU_CANNOT_USE_THIS_COREFOUNDATION_FUNCTIONALITY___YOU_MUST_EXEC__</code> 这个断言让程序崩溃。</p>\n<hr>\n<p>回归正题。</p>\n<h2 id=\"RunLoop-的获取\"><a href=\"#RunLoop-的获取\" class=\"headerlink\" title=\"RunLoop 的获取\"></a>RunLoop 的获取</h2><p>我们看到在循环中，调用了 <code>CFRunLoopGetCurrent()</code> 函数来获取当前的 RunLoop，并作为参数传入。那么这个函数里都做了什么呢？</p>\n<p>我们都知道苹果不允许我们自己手动创建 RunLoop，除了主线程的 RunLoop 会自动被创建之外，其他线程的 RunLoop 都是在第一次获取的时候被创建出来的。来看一下这个获取当前 RunLoop 对象的函数实现：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">CFRunLoopRef <span class=\"title\">CFRunLoopGetCurrent</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    CHECK_FOR_FORK();</span><br><span class=\"line\">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rl) <span class=\"keyword\">return</span> rl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个函数的返回值是 <code>CFRunLoopRef</code> ，也就是 <code>RunLoop</code> 结构体的指针类型。之后，先尝试调用 <code>_CFGetTSD</code> 函数获取，如果拿不到，再调用 <code>_CFRunLoopGet0</code> 函数。</p>\n<hr>\n<h3 id=\"跑个题：啥是-TSD\"><a href=\"#跑个题：啥是-TSD\" class=\"headerlink\" title=\"跑个题：啥是 TSD\"></a>跑个题：啥是 TSD</h3><p>TSD 全称 Thread-Specific Data，线程特有数据，有时也叫 Thread-Local Storage, TLS。其中的数据对线程内部透明，而对其他线程屏蔽。使用的时候，可以理解成一个 KV 存储，并可以设定一个 <code>destructor</code> 析构函数指针，会在线程销毁时调用。</p>\n<p>每一个进程都持有一个 keys 的数组，数组中，每一个元素包含一个用于指示 key 状态的 flag，和 destructor 函数指针。每一个线程的 TCB 也都含有一个指针数组，其中每个元素和 keys 数组一一对应。TCB 中这个数组的每一个元素指向该线程的 TSD。</p>\n<p><img src=\"/img/RunLoop/tsd.png\" alt=\"tsd\"></p>\n<hr>\n<p>所以我们看到，其实 RunLoop 是存储在线程的 TSD 中的。这也就是为什么我们说每个 RunLoop 是和线程一一对应的。而在线程退出的时候，对应的 RunLoop 也会被销毁掉。</p>\n<p>继续看一下 <code>_CFRunLoopGet0</code> 函数里都做了什么。这里只保留了一些关键的代码。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// should only be called by Foundation</span></span><br><span class=\"line\"><span class=\"comment\">// t==0 is a synonym for \"main thread\" that always works</span></span><br><span class=\"line\">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(_CFThreadRef t) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    __CFLock(&amp;loopsLock);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!__CFRunLoops) &#123; <span class=\"comment\">//__CFRunLoops 是一个全局的字典 如果为空</span></span><br><span class=\"line\">\t\t\t\tCFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class=\"number\">0</span>, <span class=\"literal\">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks); <span class=\"comment\">//就创造一个字典</span></span><br><span class=\"line\">\t\t\t\tCFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); <span class=\"comment\">//然后创建主线程的 RunLoop</span></span><br><span class=\"line\">\t\t\t\tCFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); <span class=\"comment\">//之后放到这个字典里</span></span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class=\"literal\">NULL</span>, dict, (<span class=\"keyword\">void</span> * <span class=\"keyword\">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class=\"line\">\t    \t\tCFRelease(dict);</span><br><span class=\"line\">\t\t\t\t&#125; <span class=\"comment\">//最后把这个字典设置为全局的 __CFRunLoops 并通过锁来保证线程安全</span></span><br><span class=\"line\">\t\t\t\tCFRelease(mainLoop);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    CFRunLoopRef newLoop = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  \t<span class=\"comment\">//尝试从全局的字典里获取 RunLoop</span></span><br><span class=\"line\">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!loop) &#123;</span><br><span class=\"line\">\t\t\t\tnewLoop = __CFRunLoopCreate(t); <span class=\"comment\">//没有的话就创建一个</span></span><br><span class=\"line\">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); <span class=\"comment\">//然后放到字典里</span></span><br><span class=\"line\">        loop = newLoop;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __CFUnlock(&amp;loopsLock);</span><br><span class=\"line\">    <span class=\"comment\">// don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newLoop) &#123; CFRelease(newLoop); &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  \t<span class=\"comment\">// 最后设置 TSD</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class=\"line\">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class=\"keyword\">void</span> *)loop, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loop;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"困惑\"><a href=\"#困惑\" class=\"headerlink\" title=\"困惑\"></a>困惑</h3><p>既然 RunLoop 已经被存储到线程的 TSD 里了，为什么还需要用一个字典再来记录一遍线程和 RunLoop 的对应关系呢？</p>\n<h2 id=\"RunLoop-的创建\"><a href=\"#RunLoop-的创建\" class=\"headerlink\" title=\"RunLoop 的创建\"></a>RunLoop 的创建</h2><p>我们看到如果取不到 RunLoop 的时候，会调用 <code>__CFRunLoopCreate</code> 来创建一个。这个函数的实现比较简单，只是创建了一个 RunLoop 的实例，并赋初值。</p>\n<h2 id=\"循环内部逻辑\"><a href=\"#循环内部逻辑\" class=\"headerlink\" title=\"循环内部逻辑\"></a>循环内部逻辑</h2><p>现在，描述 RunLoop 的对象已经被创建出来了。每次循环中，它都会被传入到 <code>CFRunLoopRunSpecific</code> 函数里。现在来看一下这个函数中每次都会执行哪些逻辑。这个函数比较长，简化之后核心逻辑是这样的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SInt32 <span class=\"title\">CFRunLoopRunSpecific</span><span class=\"params\">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class=\"comment\">/* DOES CALLOUT */</span></span><br><span class=\"line\">    CHECK_FOR_FORK();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (modeName == <span class=\"literal\">NULL</span> || modeName == kCFRunLoopCommonModes || CFEqual(modeName, kCFRunLoopCommonModes)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//参数不合法，直接返回并退出 RunLoop</span></span><br><span class=\"line\">      \t<span class=\"comment\">//...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> kCFRunLoopRunFinished;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__CFRunLoopIsDeallocating(rl)) <span class=\"keyword\">return</span> kCFRunLoopRunFinished;</span><br><span class=\"line\">    __CFRunLoopLock(rl);</span><br><span class=\"line\">  \t<span class=\"comment\">//根据 modeName 找 mode</span></span><br><span class=\"line\">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//如果找不到，或 mode 里没有 source/timer/observer 直接返回</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); <span class=\"comment\">//通知 observers 进入 loop</span></span><br><span class=\"line\">     \tresult = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); <span class=\"comment\">//处理事件</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); <span class=\"comment\">//通知 observers 离开 loop</span></span><br><span class=\"line\">  \t<span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>核心就是根据 modeName 拿到 mode，然后传给 <code>__CFRunLoopRun</code> 函数处理。期间通知观察者循环的进入和退出。</p>\n<p>再来看看 <code>__CFRunLoopRun</code> 里面都 run 了哪些逻辑。这里删除了不少代码，只留下核心部分。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> retVal = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123; <span class=\"comment\">//真正的 RunLoop 循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) &#123;</span><br><span class=\"line\">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); <span class=\"comment\">//通知观察者，即将触发 Timers 回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) &#123;</span><br><span class=\"line\">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); <span class=\"comment\">//通知观察者，即将触发 Sources 回调</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm); <span class=\"comment\">//执行被加入 RunLoop 的 blocks</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle); <span class=\"comment\">//触发 Sources0 回调</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sourceHandledThisLoop) &#123;</span><br><span class=\"line\">            __CFRunLoopDoBlocks(rl, rlm); <span class=\"comment\">//执行被加入 RunLoop 的 blocks</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_OS_MAC</span></span><br><span class=\"line\">        msg = (<span class=\"keyword\">mach_msg_header_t</span> *)msg_buffer;</span><br><span class=\"line\">       \t<span class=\"keyword\">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, <span class=\"number\">0</span>, &amp;voucherState, <span class=\"literal\">NULL</span>, rl, rlm)) &#123; <span class=\"comment\">//如果是 macOS，处理 Source1</span></span><br><span class=\"line\">        \t<span class=\"keyword\">goto</span> handle_msg; <span class=\"comment\">//然后直接跳到 handle_msg</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); <span class=\"comment\">//通知观察者即将休眠</span></span><br><span class=\"line\">\t__CFRunLoopSetSleeping(rl); </span><br><span class=\"line\"></span><br><span class=\"line\">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class=\"keyword\">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class=\"number\">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy, rl, rlm); <span class=\"comment\">//休眠，直到被 Timer，基于 port 的事件，超时等事件唤醒</span></span><br><span class=\"line\"></span><br><span class=\"line\">        rl-&gt;_sleepTime += (poll ? <span class=\"number\">0.0</span> : (CFAbsoluteTimeGetCurrent() - sleepStart));</span><br><span class=\"line\"></span><br><span class=\"line\">\t__CFRunLoopUnsetSleeping(rl);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); <span class=\"comment\">//通知观察者结束休眠状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">        handle_msg:; <span class=\"comment\">//开始处理 msg</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class=\"line\">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class=\"line\">            cf_trace(KDEBUG_EVENT_CFRL_WAKEUP_FOR_TIMER, rl, rlm, livePort, <span class=\"number\">0</span>);</span><br><span class=\"line\">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time()) <span class=\"comment\">//处理 timers 事件</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); <span class=\"comment\">//执行 dispatch 到 main queue 的 block</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</span><br><span class=\"line\">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rls) &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> TARGET_OS_MAC</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">mach_msg_header_t</span> *reply = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\tsourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop; <span class=\"comment\">//处理 source1 事件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"literal\">NULL</span> != reply) &#123;</span><br><span class=\"line\">\t\t    (<span class=\"keyword\">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class=\"number\">0</span>, MACH_PORT_NULL, <span class=\"number\">0</span>, MACH_PORT_NULL);</span><br><span class=\"line\">\t\t    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t__CFRunLoopDoBlocks(rl, rlm); <span class=\"comment\">//处理被加入 RunLoop 的 block</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (<span class=\"number\">0</span> == retVal); <span class=\"comment\">//如果没超时，mode没空，也没被停止，则继续循环</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> retVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>根据苹果的文档，一次 RunLoop 中处理步骤如下：</p>\n<ol>\n<li>通知观察者进入 RunLoop</li>\n<li>通知观察者 ready 的计时器即将触发</li>\n<li>通知观察者不是基于 port 的 input sources 即将触发</li>\n<li>触发 ready 的非基于 port 的 sources</li>\n<li>如果有基于 port 的 sources 已经 ready，直接触发，goto 9</li>\n<li>通知观察者即将休眠</li>\n<li>让线程休眠，除非被一些事件唤醒</li>\n<li>通知观察者线程已经苏醒</li>\n<li>开始处理事件：<ol>\n<li>如果 timer ready 了，处理并继续循环，回到 2</li>\n<li>超时等情况退出循环</li>\n</ol>\n</li>\n<li>通知观察者 RunLoop 退出了。</li>\n</ol>\n<p><strong>关于 source0 和 source1</strong>：source1 是基于 port 的事件，是来自其他进程或系统内核的消息。source0 是其余的应用层事件。但有的时候，source1 事件会转交给 source0 来处理，比如触摸事件。当我们触摸屏幕时，会产生硬件中断；操作系统内核会把相关的消息通过 port 发送给应用程序，即 source1 事件；接着这些触摸事件会被丢到事件队列里，再交给 source0 处理。</p>\n<p>不出意外的话，后面还会有一篇 RunLoop 的使用～</p>\n<p>Ref:</p>\n<ol>\n<li><a href=\"https://blog.ibireme.com/2015/05/18/runloop/\">深入理解 RunLoop</a></li>\n<li><a href=\"https://www.jianshu.com/p/de752066d0ad\">iOS底层原理总结 - RunLoop</a></li>\n<li><a href=\"https://www.neroxie.com/2019/04/24/重拾RunLoop原理/\">重拾RunLoop原理</a></li>\n<li><a href=\"https://juejin.im/post/5aaa15d36fb9a028d82b7d83\">RunLoop 源码阅读</a></li>\n<li><a href=\"https://www.jianshu.com/p/61c2d33877f4\">线程特有数据</a></li>\n<li><a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23\">Run Loops</a> , Apple</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/62605958\">关于RunLoop你想知道的事</a></li>\n</ol>\n"},{"title":"Swift 多线程初步","date":"2017-06-23T03:04:07.000Z","_content":"\n# Swift 多线程初步\n\n### 多线程简介\n\n在 iOS 中，每个进程（应用程序）启动后，都拥有一个主线程（UI 线程）。这个线程是其他所有线程的父线程。其他线程都是独立于 CocoaTouch 框架的，因此只能在主线程更新 UI。在其他线程中虽然也可以更新 UI，但由于 UIKit 不是线程安全的，可能会导致出现问题，因此不推荐。当用户做网络操作、更新数据库等比较耗时的操作时，如果不使用多线程，而直接在主线程进行的话，就会导致整个应用卡住，用户体验很差。多线程就是在多个处理器中（或者单个处理器分时间片）同步地执行一些操作，从而提高效率。\n\n### 线程和进程\n\n一个应用程序可以看作是一个进程。线程是进程的基本执行单元，进程的所有任务都在线程中执行。一个进程一般可分为新建、就绪、运行、阻塞、终止等 5 个状态。\n\n### iOS 多线程程序开发\n\n在 iOS 中，我们有以下几种方式去开发多线程的程序，分别是：\n\n- pThread\n- NSThread\n- GCD\n- NSOperation\n\n### pThread\n\npThread 是一个 C 语言的跨平台多线程框架，可以运行在 Unix 、Linux 、macOS 等多种操作系统上，Windows 也有相应的移植版本，当然也可以运行在 iOS 上。在 obj-C 中，可以引入 pthread.h 头文件来使用。由于过于底层，不仅需要与 C 语言交互，还要手动管理线程的生命周期等事务，因此在开发中基本不会使用。\n\n### NSThread\n\nNSThread 是经过苹果封装的框架，完全面向对象，但线程的生命周期仍然需要手动管理。\n\n```swift\nimport UIKit\nimport PlaygroundSupport\n\nclass ViewController: UIViewController {\n    \n    override func viewDidLoad() {\n        //点击按钮，创建子线程\n        view.backgroundColor = UIColor.white\n        let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 30))\n        button.backgroundColor = UIColor.red\n        button.addTarget(self, action: #selector(ViewController.onClick), for: .touchUpInside)\n        \n        view.addSubview(button)\n    }\n    \n   \n    func onClick() {\n        NSLog(\"Main Thread\\n\")\n        let thread = Thread(target: self, selector: #selector(ViewController.runThread), object: nil) //创建线程\n        thread.start() //启动线程\n    }\n    \n    func runThread() {\n        for i in 0..<10 {\n            NSLog(\"%d\\n\", i)\n            sleep(1)\n        }\n    }\n    \n}\n\nPlaygroundPage.current.liveView = ViewController()\n```\n\n这个程序会创建一个新的线程。在这个线程中，每隔 1 秒钟输出一个数字。\n\n点击按钮后，控制台输出如下信息：\n\n```\n2017-06-22 22:53:43.704 test[7391:1122296] Main Thread\n2017-06-22 22:53:43.715 test[7391:1122434] 0\n2017-06-22 22:53:44.727 test[7391:1122434] 1\n2017-06-22 22:53:45.732 test[7391:1122434] 2\n2017-06-22 22:53:46.737 test[7391:1122434] 3\n2017-06-22 22:53:47.743 test[7391:1122434] 4\n2017-06-22 22:53:48.747 test[7391:1122434] 5\n2017-06-22 22:53:49.752 test[7391:1122434] 6\n2017-06-22 22:53:50.756 test[7391:1122434] 7\n2017-06-22 22:53:51.762 test[7391:1122434] 8\n2017-06-22 22:53:52.764 test[7391:1122434] 9\n```\n\n可以看到在主线程中，线程号是 1122296 ，而输出数字的线程号是 1122434 。可见确实新建了一个子线程。\n\n也可以使用其他的方法创建新的线程：\n\n```swift\nThread.detachNewThreadSelector(#selector(ViewController.runThread), toTarget: self, with: nil)\n```\n\n或者：\n\n```swift\nself.performSelector(inBackground: #selector(ViewController.runThread), with: nil)\n```\n\n但是这两种方法无法获得线程对象。⚠️注意第二个方法中是 self 的方法，而不是 Thread 的静态方法。\n\n### GCD\n\nGCD 全称 Grand Central Dispatch，是苹果为并发代码在多核心处理器上执行提供支持的一套 API，底层用 C 语言编写。GCD 管理着一个线程池（队列），根据系统资源自动对多线程进行管理，而不用程序员直接和线程打交道。\n\nGCD 有三种队列形式：\n\n|         名称          |                    简介                    |\n| :-----------------: | :--------------------------------------: |\n|       Serial        | 串行队列，队列和队列之间是并行执行的，但是队列里面的各个子线程是顺序执行的。事实上，队列里面是一个线程，而不是多个线程。唯一的一个线程保证了严格的串行执行。 |\n|     Concurrent      |   并发队列可以同步地执行多个任务，会由系统根据负载来选择并发执行的任务。    |\n| Main Dispatch Queue |   提交到此线程的任务会被放到主线程执行，可以在此进行更新 UI 的操作。    |\n\n**基本用法**\n\nasync 是异步；sync 是同步。\n\n```swift\nimport UIKit\nimport PlaygroundSupport\n\nclass ViewController: UIViewController {\n    \n    override func viewDidLoad() {\n        //点击按钮，创建子线程\n        view.backgroundColor = UIColor.white\n        let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 30))\n        button.backgroundColor = UIColor.red\n        button.addTarget(self, action: #selector(ViewController.onClick), for: .touchUpInside)\n        \n        view.addSubview(button)\n    }\n    \n   \n    func onClick() {\n        NSLog(\"Main Thread\\n\")\n        DispatchQueue.global().async {\n            self.runThread() //耗时操作\n            DispatchQueue.main.async {\n                NSLog(\"更新 UI\") //回到主线程更新 UI\n            }\n        }\n    }\n    \n    func runThread() {\n        for i in 0..<10 {\n            NSLog(\"%d\\n\", i)\n            sleep(1)\n        }\n    }\n    \n}\n\nPlaygroundPage.current.liveView = ViewController()\n```\n\n点击按钮后，控制台输出以下信息：\n\n```\n2017-06-23 09:24:47.665 test[790:34424] Main Thread\n2017-06-23 09:24:47.666 test[790:34456] 0\n2017-06-23 09:24:48.668 test[790:34456] 1\n2017-06-23 09:24:49.671 test[790:34456] 2\n2017-06-23 09:24:50.676 test[790:34456] 3\n2017-06-23 09:24:51.677 test[790:34456] 4\n2017-06-23 09:24:52.682 test[790:34456] 5\n2017-06-23 09:24:53.688 test[790:34456] 6\n2017-06-23 09:24:54.692 test[790:34456] 7\n2017-06-23 09:24:55.697 test[790:34456] 8\n2017-06-23 09:24:56.701 test[790:34456] 9\n2017-06-23 09:24:57.706 test[790:34424] 更新 UI\n```\n\n可以看到更新 UI 时，线程标号与主线程标号一致。说明耗时操作完成之后，确实回到了主线程执行更新 UI 的操作。\n\n**DispatchGroup**\n\n```swift\nlet group = DispatchGroup()\n        \nlet download1 = DispatchQueue(label: \"d1\")\ndownload1.async(group: group) {\n    self.runThread()\n}\n        \nlet download2 = DispatchQueue(label: \"d2\")\ndownload2.async(group: group) {\n    self.runThread()\n}\n        \ngroup.notify(queue: DispatchQueue.main, execute: {\n    NSLog(\"更新 UI\")\n})\n```\n\n在组里的任务都结束之后，会执行 notify。\n\n### NSOperation\n\nNSOperation 基于 GCD，封装了一些更为实用的功能。除了使用 BlockOperation 之外，还可以自定义子类继承 NSOperation。\n\n**基本用法**\n\n```swift\nlet queue = OperationQueue()\nqueue.maxConcurrentOperationCount = 2 //设置最大并发数\n        \nlet operation = BlockOperation(block: {\n    self.runThread()\n})\n        \nqueue.addOperation(operation)\n```\n\n**添加依赖**\n\n```swift\nlet queue = OperationQueue()\nqueue.maxConcurrentOperationCount = 2\n        \nlet operationA = BlockOperation(block: {\n    self.runThread()\n})\n        \nlet operationB = BlockOperation(block: {\n    self.runThread()\n})\n        \noperationB.addDependency(operationA) //添加依赖关系\n        \nqueue.addOperation(operationA)\nqueue.addOperation(operationB)\n```\n\n这里 B 依赖 A，所以 B 会等待 A 执行完之后再执行。和串行执行不同，A 和 B 是两个独立的线程。注意添加依赖的时候不要构成循环依赖，否则会导致死锁。\n\n### 同步锁\n\n多个线程访问同一个资源时，可能会因为“争抢”而出现数据错乱。比如经典的售票问题：\n\n```swift\nimport UIKit\nimport PlaygroundSupport\n\nclass ViewController: UIViewController {\n    \n    var ticketAmount = 20\n    \n    override func viewDidLoad() {\n        view.backgroundColor = UIColor.white\n        let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 30))\n        button.backgroundColor = UIColor.red\n        button.addTarget(self, action: #selector(ViewController.onClick), for: .touchUpInside)\n        \n        view.addSubview(button)\n    }\n    \n   \n    func onClick() {\n        NSLog(\"Main Thread\\n\")\n        let salerA = Thread(target: self, selector: #selector(ViewController.sale(name:)), object: \"A\")\n        let salerB = Thread(target: self, selector: #selector(ViewController.sale(name:)), object: \"B\")\n        salerA.start()\n        salerB.start()\n    }\n    \n    func sale(name: String) {\n        while ticketAmount > 0 {\n            ticketAmount -= 1\n            print(name + \"售出一张票，剩余\\(ticketAmount)张\")\n            sleep(1)\n        }\n    }\n    \n}\n\nPlaygroundPage.current.liveView = ViewController()\n```\n\n点击按钮后，控制台输出：\n\n```\nA售出一张票，剩余19张\nB售出一张票，剩余18张\nB售出一张票，剩余16张\nA售出一张票，剩余16张\nA售出一张票，剩余15张\nB售出一张票，剩余14张\nA售出一张票，剩余13张\nB售出一张票，剩余12张\nB售出一张票，剩余11张\nA售出一张票，剩余10张\nA售出一张票，剩余8张\nB售出一张票，剩余9张\nA售出一张票，剩余7张\nB售出一张票，剩余6张\nA售出一张票，剩余5张\nB售出一张票，剩余4张\nA售出一张票，剩余3张\nB售出一张票，剩余2张\nB售出一张票，剩余1张\nA售出一张票，剩余0张\n```\n\n不出意外地出现了数据错乱现象。为了解决这个问题，就需要对访问资源的代码部分加锁：\n\n```swift\nfunc sale(name: String) {\n    while ticketAmount > 0 {\n        objc_sync_enter(self) //加锁\n        ticketAmount -= 1\n        print(name + \"售出一张票，剩余\\(ticketAmount)张\")\n        sleep(1)\n        objc_sync_exit(self) //解锁\n    }\n}\n```\n\n再次运行，数据就正常了。","source":"_posts/Swift-多线程.md","raw":"---\ntitle: Swift 多线程初步\ndate: 2017-06-23 11:04:07\ntags: MultiThreading\n---\n\n# Swift 多线程初步\n\n### 多线程简介\n\n在 iOS 中，每个进程（应用程序）启动后，都拥有一个主线程（UI 线程）。这个线程是其他所有线程的父线程。其他线程都是独立于 CocoaTouch 框架的，因此只能在主线程更新 UI。在其他线程中虽然也可以更新 UI，但由于 UIKit 不是线程安全的，可能会导致出现问题，因此不推荐。当用户做网络操作、更新数据库等比较耗时的操作时，如果不使用多线程，而直接在主线程进行的话，就会导致整个应用卡住，用户体验很差。多线程就是在多个处理器中（或者单个处理器分时间片）同步地执行一些操作，从而提高效率。\n\n### 线程和进程\n\n一个应用程序可以看作是一个进程。线程是进程的基本执行单元，进程的所有任务都在线程中执行。一个进程一般可分为新建、就绪、运行、阻塞、终止等 5 个状态。\n\n### iOS 多线程程序开发\n\n在 iOS 中，我们有以下几种方式去开发多线程的程序，分别是：\n\n- pThread\n- NSThread\n- GCD\n- NSOperation\n\n### pThread\n\npThread 是一个 C 语言的跨平台多线程框架，可以运行在 Unix 、Linux 、macOS 等多种操作系统上，Windows 也有相应的移植版本，当然也可以运行在 iOS 上。在 obj-C 中，可以引入 pthread.h 头文件来使用。由于过于底层，不仅需要与 C 语言交互，还要手动管理线程的生命周期等事务，因此在开发中基本不会使用。\n\n### NSThread\n\nNSThread 是经过苹果封装的框架，完全面向对象，但线程的生命周期仍然需要手动管理。\n\n```swift\nimport UIKit\nimport PlaygroundSupport\n\nclass ViewController: UIViewController {\n    \n    override func viewDidLoad() {\n        //点击按钮，创建子线程\n        view.backgroundColor = UIColor.white\n        let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 30))\n        button.backgroundColor = UIColor.red\n        button.addTarget(self, action: #selector(ViewController.onClick), for: .touchUpInside)\n        \n        view.addSubview(button)\n    }\n    \n   \n    func onClick() {\n        NSLog(\"Main Thread\\n\")\n        let thread = Thread(target: self, selector: #selector(ViewController.runThread), object: nil) //创建线程\n        thread.start() //启动线程\n    }\n    \n    func runThread() {\n        for i in 0..<10 {\n            NSLog(\"%d\\n\", i)\n            sleep(1)\n        }\n    }\n    \n}\n\nPlaygroundPage.current.liveView = ViewController()\n```\n\n这个程序会创建一个新的线程。在这个线程中，每隔 1 秒钟输出一个数字。\n\n点击按钮后，控制台输出如下信息：\n\n```\n2017-06-22 22:53:43.704 test[7391:1122296] Main Thread\n2017-06-22 22:53:43.715 test[7391:1122434] 0\n2017-06-22 22:53:44.727 test[7391:1122434] 1\n2017-06-22 22:53:45.732 test[7391:1122434] 2\n2017-06-22 22:53:46.737 test[7391:1122434] 3\n2017-06-22 22:53:47.743 test[7391:1122434] 4\n2017-06-22 22:53:48.747 test[7391:1122434] 5\n2017-06-22 22:53:49.752 test[7391:1122434] 6\n2017-06-22 22:53:50.756 test[7391:1122434] 7\n2017-06-22 22:53:51.762 test[7391:1122434] 8\n2017-06-22 22:53:52.764 test[7391:1122434] 9\n```\n\n可以看到在主线程中，线程号是 1122296 ，而输出数字的线程号是 1122434 。可见确实新建了一个子线程。\n\n也可以使用其他的方法创建新的线程：\n\n```swift\nThread.detachNewThreadSelector(#selector(ViewController.runThread), toTarget: self, with: nil)\n```\n\n或者：\n\n```swift\nself.performSelector(inBackground: #selector(ViewController.runThread), with: nil)\n```\n\n但是这两种方法无法获得线程对象。⚠️注意第二个方法中是 self 的方法，而不是 Thread 的静态方法。\n\n### GCD\n\nGCD 全称 Grand Central Dispatch，是苹果为并发代码在多核心处理器上执行提供支持的一套 API，底层用 C 语言编写。GCD 管理着一个线程池（队列），根据系统资源自动对多线程进行管理，而不用程序员直接和线程打交道。\n\nGCD 有三种队列形式：\n\n|         名称          |                    简介                    |\n| :-----------------: | :--------------------------------------: |\n|       Serial        | 串行队列，队列和队列之间是并行执行的，但是队列里面的各个子线程是顺序执行的。事实上，队列里面是一个线程，而不是多个线程。唯一的一个线程保证了严格的串行执行。 |\n|     Concurrent      |   并发队列可以同步地执行多个任务，会由系统根据负载来选择并发执行的任务。    |\n| Main Dispatch Queue |   提交到此线程的任务会被放到主线程执行，可以在此进行更新 UI 的操作。    |\n\n**基本用法**\n\nasync 是异步；sync 是同步。\n\n```swift\nimport UIKit\nimport PlaygroundSupport\n\nclass ViewController: UIViewController {\n    \n    override func viewDidLoad() {\n        //点击按钮，创建子线程\n        view.backgroundColor = UIColor.white\n        let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 30))\n        button.backgroundColor = UIColor.red\n        button.addTarget(self, action: #selector(ViewController.onClick), for: .touchUpInside)\n        \n        view.addSubview(button)\n    }\n    \n   \n    func onClick() {\n        NSLog(\"Main Thread\\n\")\n        DispatchQueue.global().async {\n            self.runThread() //耗时操作\n            DispatchQueue.main.async {\n                NSLog(\"更新 UI\") //回到主线程更新 UI\n            }\n        }\n    }\n    \n    func runThread() {\n        for i in 0..<10 {\n            NSLog(\"%d\\n\", i)\n            sleep(1)\n        }\n    }\n    \n}\n\nPlaygroundPage.current.liveView = ViewController()\n```\n\n点击按钮后，控制台输出以下信息：\n\n```\n2017-06-23 09:24:47.665 test[790:34424] Main Thread\n2017-06-23 09:24:47.666 test[790:34456] 0\n2017-06-23 09:24:48.668 test[790:34456] 1\n2017-06-23 09:24:49.671 test[790:34456] 2\n2017-06-23 09:24:50.676 test[790:34456] 3\n2017-06-23 09:24:51.677 test[790:34456] 4\n2017-06-23 09:24:52.682 test[790:34456] 5\n2017-06-23 09:24:53.688 test[790:34456] 6\n2017-06-23 09:24:54.692 test[790:34456] 7\n2017-06-23 09:24:55.697 test[790:34456] 8\n2017-06-23 09:24:56.701 test[790:34456] 9\n2017-06-23 09:24:57.706 test[790:34424] 更新 UI\n```\n\n可以看到更新 UI 时，线程标号与主线程标号一致。说明耗时操作完成之后，确实回到了主线程执行更新 UI 的操作。\n\n**DispatchGroup**\n\n```swift\nlet group = DispatchGroup()\n        \nlet download1 = DispatchQueue(label: \"d1\")\ndownload1.async(group: group) {\n    self.runThread()\n}\n        \nlet download2 = DispatchQueue(label: \"d2\")\ndownload2.async(group: group) {\n    self.runThread()\n}\n        \ngroup.notify(queue: DispatchQueue.main, execute: {\n    NSLog(\"更新 UI\")\n})\n```\n\n在组里的任务都结束之后，会执行 notify。\n\n### NSOperation\n\nNSOperation 基于 GCD，封装了一些更为实用的功能。除了使用 BlockOperation 之外，还可以自定义子类继承 NSOperation。\n\n**基本用法**\n\n```swift\nlet queue = OperationQueue()\nqueue.maxConcurrentOperationCount = 2 //设置最大并发数\n        \nlet operation = BlockOperation(block: {\n    self.runThread()\n})\n        \nqueue.addOperation(operation)\n```\n\n**添加依赖**\n\n```swift\nlet queue = OperationQueue()\nqueue.maxConcurrentOperationCount = 2\n        \nlet operationA = BlockOperation(block: {\n    self.runThread()\n})\n        \nlet operationB = BlockOperation(block: {\n    self.runThread()\n})\n        \noperationB.addDependency(operationA) //添加依赖关系\n        \nqueue.addOperation(operationA)\nqueue.addOperation(operationB)\n```\n\n这里 B 依赖 A，所以 B 会等待 A 执行完之后再执行。和串行执行不同，A 和 B 是两个独立的线程。注意添加依赖的时候不要构成循环依赖，否则会导致死锁。\n\n### 同步锁\n\n多个线程访问同一个资源时，可能会因为“争抢”而出现数据错乱。比如经典的售票问题：\n\n```swift\nimport UIKit\nimport PlaygroundSupport\n\nclass ViewController: UIViewController {\n    \n    var ticketAmount = 20\n    \n    override func viewDidLoad() {\n        view.backgroundColor = UIColor.white\n        let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 30))\n        button.backgroundColor = UIColor.red\n        button.addTarget(self, action: #selector(ViewController.onClick), for: .touchUpInside)\n        \n        view.addSubview(button)\n    }\n    \n   \n    func onClick() {\n        NSLog(\"Main Thread\\n\")\n        let salerA = Thread(target: self, selector: #selector(ViewController.sale(name:)), object: \"A\")\n        let salerB = Thread(target: self, selector: #selector(ViewController.sale(name:)), object: \"B\")\n        salerA.start()\n        salerB.start()\n    }\n    \n    func sale(name: String) {\n        while ticketAmount > 0 {\n            ticketAmount -= 1\n            print(name + \"售出一张票，剩余\\(ticketAmount)张\")\n            sleep(1)\n        }\n    }\n    \n}\n\nPlaygroundPage.current.liveView = ViewController()\n```\n\n点击按钮后，控制台输出：\n\n```\nA售出一张票，剩余19张\nB售出一张票，剩余18张\nB售出一张票，剩余16张\nA售出一张票，剩余16张\nA售出一张票，剩余15张\nB售出一张票，剩余14张\nA售出一张票，剩余13张\nB售出一张票，剩余12张\nB售出一张票，剩余11张\nA售出一张票，剩余10张\nA售出一张票，剩余8张\nB售出一张票，剩余9张\nA售出一张票，剩余7张\nB售出一张票，剩余6张\nA售出一张票，剩余5张\nB售出一张票，剩余4张\nA售出一张票，剩余3张\nB售出一张票，剩余2张\nB售出一张票，剩余1张\nA售出一张票，剩余0张\n```\n\n不出意外地出现了数据错乱现象。为了解决这个问题，就需要对访问资源的代码部分加锁：\n\n```swift\nfunc sale(name: String) {\n    while ticketAmount > 0 {\n        objc_sync_enter(self) //加锁\n        ticketAmount -= 1\n        print(name + \"售出一张票，剩余\\(ticketAmount)张\")\n        sleep(1)\n        objc_sync_exit(self) //解锁\n    }\n}\n```\n\n再次运行，数据就正常了。","slug":"Swift-多线程","published":1,"updated":"2020-01-04T08:16:16.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3z0038ljc39wx6p6hx","content":"<h1 id=\"Swift-多线程初步\"><a href=\"#Swift-多线程初步\" class=\"headerlink\" title=\"Swift 多线程初步\"></a>Swift 多线程初步</h1><h3 id=\"多线程简介\"><a href=\"#多线程简介\" class=\"headerlink\" title=\"多线程简介\"></a>多线程简介</h3><p>在 iOS 中，每个进程（应用程序）启动后，都拥有一个主线程（UI 线程）。这个线程是其他所有线程的父线程。其他线程都是独立于 CocoaTouch 框架的，因此只能在主线程更新 UI。在其他线程中虽然也可以更新 UI，但由于 UIKit 不是线程安全的，可能会导致出现问题，因此不推荐。当用户做网络操作、更新数据库等比较耗时的操作时，如果不使用多线程，而直接在主线程进行的话，就会导致整个应用卡住，用户体验很差。多线程就是在多个处理器中（或者单个处理器分时间片）同步地执行一些操作，从而提高效率。</p>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><p>一个应用程序可以看作是一个进程。线程是进程的基本执行单元，进程的所有任务都在线程中执行。一个进程一般可分为新建、就绪、运行、阻塞、终止等 5 个状态。</p>\n<h3 id=\"iOS-多线程程序开发\"><a href=\"#iOS-多线程程序开发\" class=\"headerlink\" title=\"iOS 多线程程序开发\"></a>iOS 多线程程序开发</h3><p>在 iOS 中，我们有以下几种方式去开发多线程的程序，分别是：</p>\n<ul>\n<li>pThread</li>\n<li>NSThread</li>\n<li>GCD</li>\n<li>NSOperation</li>\n</ul>\n<h3 id=\"pThread\"><a href=\"#pThread\" class=\"headerlink\" title=\"pThread\"></a>pThread</h3><p>pThread 是一个 C 语言的跨平台多线程框架，可以运行在 Unix 、Linux 、macOS 等多种操作系统上，Windows 也有相应的移植版本，当然也可以运行在 iOS 上。在 obj-C 中，可以引入 pthread.h 头文件来使用。由于过于底层，不仅需要与 C 语言交互，还要手动管理线程的生命周期等事务，因此在开发中基本不会使用。</p>\n<h3 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h3><p>NSThread 是经过苹果封装的框架，完全面向对象，但线程的生命周期仍然需要手动管理。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//点击按钮，创建子线程</span></span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.white</span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = <span class=\"type\">UIButton</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">100</span>, y: <span class=\"number\">100</span>, width: <span class=\"number\">100</span>, height: <span class=\"number\">30</span>))</span><br><span class=\"line\">        button.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        button.addTarget(<span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">ViewController</span>.onClick), <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">        </span><br><span class=\"line\">        view.addSubview(button)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClick</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(<span class=\"string\">\"Main Thread\\n\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> thread = <span class=\"type\">Thread</span>(target: <span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">ViewController</span>.runThread), object: <span class=\"literal\">nil</span>) <span class=\"comment\">//创建线程</span></span><br><span class=\"line\">        thread.start() <span class=\"comment\">//启动线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">runThread</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">NSLog</span>(<span class=\"string\">\"%d\\n\"</span>, i)</span><br><span class=\"line\">            sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">ViewController</span>()</span><br></pre></td></tr></table></figure>\n<p>这个程序会创建一个新的线程。在这个线程中，每隔 1 秒钟输出一个数字。</p>\n<p>点击按钮后，控制台输出如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-06-22 22:53:43.704 test[7391:1122296] Main Thread</span><br><span class=\"line\">2017-06-22 22:53:43.715 test[7391:1122434] 0</span><br><span class=\"line\">2017-06-22 22:53:44.727 test[7391:1122434] 1</span><br><span class=\"line\">2017-06-22 22:53:45.732 test[7391:1122434] 2</span><br><span class=\"line\">2017-06-22 22:53:46.737 test[7391:1122434] 3</span><br><span class=\"line\">2017-06-22 22:53:47.743 test[7391:1122434] 4</span><br><span class=\"line\">2017-06-22 22:53:48.747 test[7391:1122434] 5</span><br><span class=\"line\">2017-06-22 22:53:49.752 test[7391:1122434] 6</span><br><span class=\"line\">2017-06-22 22:53:50.756 test[7391:1122434] 7</span><br><span class=\"line\">2017-06-22 22:53:51.762 test[7391:1122434] 8</span><br><span class=\"line\">2017-06-22 22:53:52.764 test[7391:1122434] 9</span><br></pre></td></tr></table></figure>\n<p>可以看到在主线程中，线程号是 1122296 ，而输出数字的线程号是 1122434 。可见确实新建了一个子线程。</p>\n<p>也可以使用其他的方法创建新的线程：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Thread</span>.detachNewThreadSelector(#selector(<span class=\"type\">ViewController</span>.runThread), toTarget: <span class=\"keyword\">self</span>, with: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.performSelector(inBackground: #selector(<span class=\"type\">ViewController</span>.runThread), with: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>但是这两种方法无法获得线程对象。⚠️注意第二个方法中是 self 的方法，而不是 Thread 的静态方法。</p>\n<h3 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h3><p>GCD 全称 Grand Central Dispatch，是苹果为并发代码在多核心处理器上执行提供支持的一套 API，底层用 C 语言编写。GCD 管理着一个线程池（队列），根据系统资源自动对多线程进行管理，而不用程序员直接和线程打交道。</p>\n<p>GCD 有三种队列形式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Serial</td>\n<td style=\"text-align:center\">串行队列，队列和队列之间是并行执行的，但是队列里面的各个子线程是顺序执行的。事实上，队列里面是一个线程，而不是多个线程。唯一的一个线程保证了严格的串行执行。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Concurrent</td>\n<td style=\"text-align:center\">并发队列可以同步地执行多个任务，会由系统根据负载来选择并发执行的任务。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Main Dispatch Queue</td>\n<td style=\"text-align:center\">提交到此线程的任务会被放到主线程执行，可以在此进行更新 UI 的操作。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>基本用法</strong></p>\n<p>async 是异步；sync 是同步。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//点击按钮，创建子线程</span></span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.white</span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = <span class=\"type\">UIButton</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">100</span>, y: <span class=\"number\">100</span>, width: <span class=\"number\">100</span>, height: <span class=\"number\">30</span>))</span><br><span class=\"line\">        button.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        button.addTarget(<span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">ViewController</span>.onClick), <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">        </span><br><span class=\"line\">        view.addSubview(button)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClick</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(<span class=\"string\">\"Main Thread\\n\"</span>)</span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.runThread() <span class=\"comment\">//耗时操作</span></span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                <span class=\"type\">NSLog</span>(<span class=\"string\">\"更新 UI\"</span>) <span class=\"comment\">//回到主线程更新 UI</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">runThread</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">NSLog</span>(<span class=\"string\">\"%d\\n\"</span>, i)</span><br><span class=\"line\">            sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">ViewController</span>()</span><br></pre></td></tr></table></figure>\n<p>点击按钮后，控制台输出以下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-06-23 09:24:47.665 test[790:34424] Main Thread</span><br><span class=\"line\">2017-06-23 09:24:47.666 test[790:34456] 0</span><br><span class=\"line\">2017-06-23 09:24:48.668 test[790:34456] 1</span><br><span class=\"line\">2017-06-23 09:24:49.671 test[790:34456] 2</span><br><span class=\"line\">2017-06-23 09:24:50.676 test[790:34456] 3</span><br><span class=\"line\">2017-06-23 09:24:51.677 test[790:34456] 4</span><br><span class=\"line\">2017-06-23 09:24:52.682 test[790:34456] 5</span><br><span class=\"line\">2017-06-23 09:24:53.688 test[790:34456] 6</span><br><span class=\"line\">2017-06-23 09:24:54.692 test[790:34456] 7</span><br><span class=\"line\">2017-06-23 09:24:55.697 test[790:34456] 8</span><br><span class=\"line\">2017-06-23 09:24:56.701 test[790:34456] 9</span><br><span class=\"line\">2017-06-23 09:24:57.706 test[790:34424] 更新 UI</span><br></pre></td></tr></table></figure>\n<p>可以看到更新 UI 时，线程标号与主线程标号一致。说明耗时操作完成之后，确实回到了主线程执行更新 UI 的操作。</p>\n<p><strong>DispatchGroup</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> group = <span class=\"type\">DispatchGroup</span>()</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> download1 = <span class=\"type\">DispatchQueue</span>(label: <span class=\"string\">\"d1\"</span>)</span><br><span class=\"line\">download1.async(group: group) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.runThread()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> download2 = <span class=\"type\">DispatchQueue</span>(label: <span class=\"string\">\"d2\"</span>)</span><br><span class=\"line\">download2.async(group: group) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.runThread()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">group.notify(queue: <span class=\"type\">DispatchQueue</span>.main, execute: &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLog</span>(<span class=\"string\">\"更新 UI\"</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在组里的任务都结束之后，会执行 notify。</p>\n<h3 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h3><p>NSOperation 基于 GCD，封装了一些更为实用的功能。除了使用 BlockOperation 之外，还可以自定义子类继承 NSOperation。</p>\n<p><strong>基本用法</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue = <span class=\"type\">OperationQueue</span>()</span><br><span class=\"line\">queue.maxConcurrentOperationCount = <span class=\"number\">2</span> <span class=\"comment\">//设置最大并发数</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> operation = <span class=\"type\">BlockOperation</span>(block: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.runThread()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">queue.addOperation(operation)</span><br></pre></td></tr></table></figure>\n<p><strong>添加依赖</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue = <span class=\"type\">OperationQueue</span>()</span><br><span class=\"line\">queue.maxConcurrentOperationCount = <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> operationA = <span class=\"type\">BlockOperation</span>(block: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.runThread()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> operationB = <span class=\"type\">BlockOperation</span>(block: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.runThread()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">operationB.addDependency(operationA) <span class=\"comment\">//添加依赖关系</span></span><br><span class=\"line\">        </span><br><span class=\"line\">queue.addOperation(operationA)</span><br><span class=\"line\">queue.addOperation(operationB)</span><br></pre></td></tr></table></figure>\n<p>这里 B 依赖 A，所以 B 会等待 A 执行完之后再执行。和串行执行不同，A 和 B 是两个独立的线程。注意添加依赖的时候不要构成循环依赖，否则会导致死锁。</p>\n<h3 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h3><p>多个线程访问同一个资源时，可能会因为“争抢”而出现数据错乱。比如经典的售票问题：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> ticketAmount = <span class=\"number\">20</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.white</span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = <span class=\"type\">UIButton</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">100</span>, y: <span class=\"number\">100</span>, width: <span class=\"number\">100</span>, height: <span class=\"number\">30</span>))</span><br><span class=\"line\">        button.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        button.addTarget(<span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">ViewController</span>.onClick), <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">        </span><br><span class=\"line\">        view.addSubview(button)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClick</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(<span class=\"string\">\"Main Thread\\n\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> salerA = <span class=\"type\">Thread</span>(target: <span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">ViewController</span>.sale(name:)), object: <span class=\"string\">\"A\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> salerB = <span class=\"type\">Thread</span>(target: <span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">ViewController</span>.sale(name:)), object: <span class=\"string\">\"B\"</span>)</span><br><span class=\"line\">        salerA.start()</span><br><span class=\"line\">        salerB.start()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sale</span><span class=\"params\">(name: String)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ticketAmount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            ticketAmount -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(name + <span class=\"string\">\"售出一张票，剩余\\(ticketAmount)张\"</span>)</span><br><span class=\"line\">            sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">ViewController</span>()</span><br></pre></td></tr></table></figure>\n<p>点击按钮后，控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A售出一张票，剩余19张</span><br><span class=\"line\">B售出一张票，剩余18张</span><br><span class=\"line\">B售出一张票，剩余16张</span><br><span class=\"line\">A售出一张票，剩余16张</span><br><span class=\"line\">A售出一张票，剩余15张</span><br><span class=\"line\">B售出一张票，剩余14张</span><br><span class=\"line\">A售出一张票，剩余13张</span><br><span class=\"line\">B售出一张票，剩余12张</span><br><span class=\"line\">B售出一张票，剩余11张</span><br><span class=\"line\">A售出一张票，剩余10张</span><br><span class=\"line\">A售出一张票，剩余8张</span><br><span class=\"line\">B售出一张票，剩余9张</span><br><span class=\"line\">A售出一张票，剩余7张</span><br><span class=\"line\">B售出一张票，剩余6张</span><br><span class=\"line\">A售出一张票，剩余5张</span><br><span class=\"line\">B售出一张票，剩余4张</span><br><span class=\"line\">A售出一张票，剩余3张</span><br><span class=\"line\">B售出一张票，剩余2张</span><br><span class=\"line\">B售出一张票，剩余1张</span><br><span class=\"line\">A售出一张票，剩余0张</span><br></pre></td></tr></table></figure>\n<p>不出意外地出现了数据错乱现象。为了解决这个问题，就需要对访问资源的代码部分加锁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sale</span><span class=\"params\">(name: String)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ticketAmount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        objc_sync_enter(<span class=\"keyword\">self</span>) <span class=\"comment\">//加锁</span></span><br><span class=\"line\">        ticketAmount -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(name + <span class=\"string\">\"售出一张票，剩余\\(ticketAmount)张\"</span>)</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        objc_sync_exit(<span class=\"keyword\">self</span>) <span class=\"comment\">//解锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次运行，数据就正常了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Swift-多线程初步\"><a href=\"#Swift-多线程初步\" class=\"headerlink\" title=\"Swift 多线程初步\"></a>Swift 多线程初步</h1><h3 id=\"多线程简介\"><a href=\"#多线程简介\" class=\"headerlink\" title=\"多线程简介\"></a>多线程简介</h3><p>在 iOS 中，每个进程（应用程序）启动后，都拥有一个主线程（UI 线程）。这个线程是其他所有线程的父线程。其他线程都是独立于 CocoaTouch 框架的，因此只能在主线程更新 UI。在其他线程中虽然也可以更新 UI，但由于 UIKit 不是线程安全的，可能会导致出现问题，因此不推荐。当用户做网络操作、更新数据库等比较耗时的操作时，如果不使用多线程，而直接在主线程进行的话，就会导致整个应用卡住，用户体验很差。多线程就是在多个处理器中（或者单个处理器分时间片）同步地执行一些操作，从而提高效率。</p>\n<h3 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h3><p>一个应用程序可以看作是一个进程。线程是进程的基本执行单元，进程的所有任务都在线程中执行。一个进程一般可分为新建、就绪、运行、阻塞、终止等 5 个状态。</p>\n<h3 id=\"iOS-多线程程序开发\"><a href=\"#iOS-多线程程序开发\" class=\"headerlink\" title=\"iOS 多线程程序开发\"></a>iOS 多线程程序开发</h3><p>在 iOS 中，我们有以下几种方式去开发多线程的程序，分别是：</p>\n<ul>\n<li>pThread</li>\n<li>NSThread</li>\n<li>GCD</li>\n<li>NSOperation</li>\n</ul>\n<h3 id=\"pThread\"><a href=\"#pThread\" class=\"headerlink\" title=\"pThread\"></a>pThread</h3><p>pThread 是一个 C 语言的跨平台多线程框架，可以运行在 Unix 、Linux 、macOS 等多种操作系统上，Windows 也有相应的移植版本，当然也可以运行在 iOS 上。在 obj-C 中，可以引入 pthread.h 头文件来使用。由于过于底层，不仅需要与 C 语言交互，还要手动管理线程的生命周期等事务，因此在开发中基本不会使用。</p>\n<h3 id=\"NSThread\"><a href=\"#NSThread\" class=\"headerlink\" title=\"NSThread\"></a>NSThread</h3><p>NSThread 是经过苹果封装的框架，完全面向对象，但线程的生命周期仍然需要手动管理。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//点击按钮，创建子线程</span></span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.white</span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = <span class=\"type\">UIButton</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">100</span>, y: <span class=\"number\">100</span>, width: <span class=\"number\">100</span>, height: <span class=\"number\">30</span>))</span><br><span class=\"line\">        button.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        button.addTarget(<span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">ViewController</span>.onClick), <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">        </span><br><span class=\"line\">        view.addSubview(button)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClick</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(<span class=\"string\">\"Main Thread\\n\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> thread = <span class=\"type\">Thread</span>(target: <span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">ViewController</span>.runThread), object: <span class=\"literal\">nil</span>) <span class=\"comment\">//创建线程</span></span><br><span class=\"line\">        thread.start() <span class=\"comment\">//启动线程</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">runThread</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">NSLog</span>(<span class=\"string\">\"%d\\n\"</span>, i)</span><br><span class=\"line\">            sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">ViewController</span>()</span><br></pre></td></tr></table></figure>\n<p>这个程序会创建一个新的线程。在这个线程中，每隔 1 秒钟输出一个数字。</p>\n<p>点击按钮后，控制台输出如下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-06-22 22:53:43.704 test[7391:1122296] Main Thread</span><br><span class=\"line\">2017-06-22 22:53:43.715 test[7391:1122434] 0</span><br><span class=\"line\">2017-06-22 22:53:44.727 test[7391:1122434] 1</span><br><span class=\"line\">2017-06-22 22:53:45.732 test[7391:1122434] 2</span><br><span class=\"line\">2017-06-22 22:53:46.737 test[7391:1122434] 3</span><br><span class=\"line\">2017-06-22 22:53:47.743 test[7391:1122434] 4</span><br><span class=\"line\">2017-06-22 22:53:48.747 test[7391:1122434] 5</span><br><span class=\"line\">2017-06-22 22:53:49.752 test[7391:1122434] 6</span><br><span class=\"line\">2017-06-22 22:53:50.756 test[7391:1122434] 7</span><br><span class=\"line\">2017-06-22 22:53:51.762 test[7391:1122434] 8</span><br><span class=\"line\">2017-06-22 22:53:52.764 test[7391:1122434] 9</span><br></pre></td></tr></table></figure>\n<p>可以看到在主线程中，线程号是 1122296 ，而输出数字的线程号是 1122434 。可见确实新建了一个子线程。</p>\n<p>也可以使用其他的方法创建新的线程：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Thread</span>.detachNewThreadSelector(#selector(<span class=\"type\">ViewController</span>.runThread), toTarget: <span class=\"keyword\">self</span>, with: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.performSelector(inBackground: #selector(<span class=\"type\">ViewController</span>.runThread), with: <span class=\"literal\">nil</span>)</span><br></pre></td></tr></table></figure>\n<p>但是这两种方法无法获得线程对象。⚠️注意第二个方法中是 self 的方法，而不是 Thread 的静态方法。</p>\n<h3 id=\"GCD\"><a href=\"#GCD\" class=\"headerlink\" title=\"GCD\"></a>GCD</h3><p>GCD 全称 Grand Central Dispatch，是苹果为并发代码在多核心处理器上执行提供支持的一套 API，底层用 C 语言编写。GCD 管理着一个线程池（队列），根据系统资源自动对多线程进行管理，而不用程序员直接和线程打交道。</p>\n<p>GCD 有三种队列形式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Serial</td>\n<td style=\"text-align:center\">串行队列，队列和队列之间是并行执行的，但是队列里面的各个子线程是顺序执行的。事实上，队列里面是一个线程，而不是多个线程。唯一的一个线程保证了严格的串行执行。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Concurrent</td>\n<td style=\"text-align:center\">并发队列可以同步地执行多个任务，会由系统根据负载来选择并发执行的任务。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Main Dispatch Queue</td>\n<td style=\"text-align:center\">提交到此线程的任务会被放到主线程执行，可以在此进行更新 UI 的操作。</td>\n</tr>\n</tbody>\n</table>\n<p><strong>基本用法</strong></p>\n<p>async 是异步；sync 是同步。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//点击按钮，创建子线程</span></span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.white</span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = <span class=\"type\">UIButton</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">100</span>, y: <span class=\"number\">100</span>, width: <span class=\"number\">100</span>, height: <span class=\"number\">30</span>))</span><br><span class=\"line\">        button.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        button.addTarget(<span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">ViewController</span>.onClick), <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">        </span><br><span class=\"line\">        view.addSubview(button)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClick</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(<span class=\"string\">\"Main Thread\\n\"</span>)</span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">            <span class=\"keyword\">self</span>.runThread() <span class=\"comment\">//耗时操作</span></span><br><span class=\"line\">            <span class=\"type\">DispatchQueue</span>.main.async &#123;</span><br><span class=\"line\">                <span class=\"type\">NSLog</span>(<span class=\"string\">\"更新 UI\"</span>) <span class=\"comment\">//回到主线程更新 UI</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">runThread</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span>..&lt;<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">NSLog</span>(<span class=\"string\">\"%d\\n\"</span>, i)</span><br><span class=\"line\">            sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">ViewController</span>()</span><br></pre></td></tr></table></figure>\n<p>点击按钮后，控制台输出以下信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2017-06-23 09:24:47.665 test[790:34424] Main Thread</span><br><span class=\"line\">2017-06-23 09:24:47.666 test[790:34456] 0</span><br><span class=\"line\">2017-06-23 09:24:48.668 test[790:34456] 1</span><br><span class=\"line\">2017-06-23 09:24:49.671 test[790:34456] 2</span><br><span class=\"line\">2017-06-23 09:24:50.676 test[790:34456] 3</span><br><span class=\"line\">2017-06-23 09:24:51.677 test[790:34456] 4</span><br><span class=\"line\">2017-06-23 09:24:52.682 test[790:34456] 5</span><br><span class=\"line\">2017-06-23 09:24:53.688 test[790:34456] 6</span><br><span class=\"line\">2017-06-23 09:24:54.692 test[790:34456] 7</span><br><span class=\"line\">2017-06-23 09:24:55.697 test[790:34456] 8</span><br><span class=\"line\">2017-06-23 09:24:56.701 test[790:34456] 9</span><br><span class=\"line\">2017-06-23 09:24:57.706 test[790:34424] 更新 UI</span><br></pre></td></tr></table></figure>\n<p>可以看到更新 UI 时，线程标号与主线程标号一致。说明耗时操作完成之后，确实回到了主线程执行更新 UI 的操作。</p>\n<p><strong>DispatchGroup</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> group = <span class=\"type\">DispatchGroup</span>()</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> download1 = <span class=\"type\">DispatchQueue</span>(label: <span class=\"string\">\"d1\"</span>)</span><br><span class=\"line\">download1.async(group: group) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.runThread()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> download2 = <span class=\"type\">DispatchQueue</span>(label: <span class=\"string\">\"d2\"</span>)</span><br><span class=\"line\">download2.async(group: group) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.runThread()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">group.notify(queue: <span class=\"type\">DispatchQueue</span>.main, execute: &#123;</span><br><span class=\"line\">    <span class=\"type\">NSLog</span>(<span class=\"string\">\"更新 UI\"</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在组里的任务都结束之后，会执行 notify。</p>\n<h3 id=\"NSOperation\"><a href=\"#NSOperation\" class=\"headerlink\" title=\"NSOperation\"></a>NSOperation</h3><p>NSOperation 基于 GCD，封装了一些更为实用的功能。除了使用 BlockOperation 之外，还可以自定义子类继承 NSOperation。</p>\n<p><strong>基本用法</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue = <span class=\"type\">OperationQueue</span>()</span><br><span class=\"line\">queue.maxConcurrentOperationCount = <span class=\"number\">2</span> <span class=\"comment\">//设置最大并发数</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> operation = <span class=\"type\">BlockOperation</span>(block: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.runThread()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">queue.addOperation(operation)</span><br></pre></td></tr></table></figure>\n<p><strong>添加依赖</strong></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> queue = <span class=\"type\">OperationQueue</span>()</span><br><span class=\"line\">queue.maxConcurrentOperationCount = <span class=\"number\">2</span></span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> operationA = <span class=\"type\">BlockOperation</span>(block: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.runThread()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\"><span class=\"keyword\">let</span> operationB = <span class=\"type\">BlockOperation</span>(block: &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.runThread()</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">        </span><br><span class=\"line\">operationB.addDependency(operationA) <span class=\"comment\">//添加依赖关系</span></span><br><span class=\"line\">        </span><br><span class=\"line\">queue.addOperation(operationA)</span><br><span class=\"line\">queue.addOperation(operationB)</span><br></pre></td></tr></table></figure>\n<p>这里 B 依赖 A，所以 B 会等待 A 执行完之后再执行。和串行执行不同，A 和 B 是两个独立的线程。注意添加依赖的时候不要构成循环依赖，否则会导致死锁。</p>\n<h3 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h3><p>多个线程访问同一个资源时，可能会因为“争抢”而出现数据错乱。比如经典的售票问题：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> ticketAmount = <span class=\"number\">20</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.white</span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = <span class=\"type\">UIButton</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">100</span>, y: <span class=\"number\">100</span>, width: <span class=\"number\">100</span>, height: <span class=\"number\">30</span>))</span><br><span class=\"line\">        button.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        button.addTarget(<span class=\"keyword\">self</span>, action: #selector(<span class=\"type\">ViewController</span>.onClick), <span class=\"keyword\">for</span>: .touchUpInside)</span><br><span class=\"line\">        </span><br><span class=\"line\">        view.addSubview(button)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">onClick</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(<span class=\"string\">\"Main Thread\\n\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> salerA = <span class=\"type\">Thread</span>(target: <span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">ViewController</span>.sale(name:)), object: <span class=\"string\">\"A\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> salerB = <span class=\"type\">Thread</span>(target: <span class=\"keyword\">self</span>, selector: #selector(<span class=\"type\">ViewController</span>.sale(name:)), object: <span class=\"string\">\"B\"</span>)</span><br><span class=\"line\">        salerA.start()</span><br><span class=\"line\">        salerB.start()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sale</span><span class=\"params\">(name: String)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ticketAmount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">            ticketAmount -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(name + <span class=\"string\">\"售出一张票，剩余\\(ticketAmount)张\"</span>)</span><br><span class=\"line\">            sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView = <span class=\"type\">ViewController</span>()</span><br></pre></td></tr></table></figure>\n<p>点击按钮后，控制台输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A售出一张票，剩余19张</span><br><span class=\"line\">B售出一张票，剩余18张</span><br><span class=\"line\">B售出一张票，剩余16张</span><br><span class=\"line\">A售出一张票，剩余16张</span><br><span class=\"line\">A售出一张票，剩余15张</span><br><span class=\"line\">B售出一张票，剩余14张</span><br><span class=\"line\">A售出一张票，剩余13张</span><br><span class=\"line\">B售出一张票，剩余12张</span><br><span class=\"line\">B售出一张票，剩余11张</span><br><span class=\"line\">A售出一张票，剩余10张</span><br><span class=\"line\">A售出一张票，剩余8张</span><br><span class=\"line\">B售出一张票，剩余9张</span><br><span class=\"line\">A售出一张票，剩余7张</span><br><span class=\"line\">B售出一张票，剩余6张</span><br><span class=\"line\">A售出一张票，剩余5张</span><br><span class=\"line\">B售出一张票，剩余4张</span><br><span class=\"line\">A售出一张票，剩余3张</span><br><span class=\"line\">B售出一张票，剩余2张</span><br><span class=\"line\">B售出一张票，剩余1张</span><br><span class=\"line\">A售出一张票，剩余0张</span><br></pre></td></tr></table></figure>\n<p>不出意外地出现了数据错乱现象。为了解决这个问题，就需要对访问资源的代码部分加锁：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">sale</span><span class=\"params\">(name: String)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ticketAmount &gt; <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        objc_sync_enter(<span class=\"keyword\">self</span>) <span class=\"comment\">//加锁</span></span><br><span class=\"line\">        ticketAmount -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(name + <span class=\"string\">\"售出一张票，剩余\\(ticketAmount)张\"</span>)</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        objc_sync_exit(<span class=\"keyword\">self</span>) <span class=\"comment\">//解锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再次运行，数据就正常了。</p>\n"},{"title":"iOS-Layout学习笔记","date":"2018-05-02T06:48:50.000Z","_content":"\n# iOS Layout 学习笔记\n\n关于 iOS 布局系统的一些知识在我之前的博客中已经写过了，这里再补充一些。\n\n### 优先级\n\n每个约束都有优先级，范围从 1 到 1000。优先级为 1000 的约束是必须的，小于 1000 的约束是可选的。Auto Layout 会优先满足高优先级的约束，如果一个可选的约束得不到满足，Auto Layout 会跳过它。\n\n**应用：**左右两个 View A 和 B，当我们让 view A 消失时，view B 向左平移。\n\n这是京东的一道面试题。面试官举出的应用场景是：左边是一个 loading indicator，在网络请求时一致播放加载动画，右边是一个 label。当请求完成后，需要把 indicator 移除，让 label 平移过来。\n\n我们当然有很多种方法来实现这个需求，但显然通过合理设置约束的优先级能够更优雅地解决这个问题。只需要给 View B 添加一个到 A 一段距离的必须的约束，再给 B 添加一个到屏幕边缘的可选约束就好了。当 A 还在画面中时，可选的约束和必须的约束产生冲突得不到满足，因此 B 距离 A 一段距离。当我们把 A remove 掉之后，与 A 相关的约束也就不在了，那么可选的约束就可以满足，B 因此变为距离屏幕边缘一段距离。\n\n通过设置优先级，我们不再需要更新约束，而只要简单的调用 removeFromSuperview 把 A 移除就可以了。\n\n![twoViews](/img/layoutStudy/twoViews.gif)\n\n```objective-c\n_leftView.backgroundColor = UIColor.blueColor;\n[_leftView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.left.equalTo(self.view).with.mas_offset(20);\n    make.top.equalTo(self.rightView);\n    make.width.mas_equalTo(50);\n    make.height.mas_equalTo(50);\n}];\n    \n_rightView.backgroundColor = UIColor.greenColor;\n[_rightView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.left.equalTo(self.leftView.mas_right).with.mas_offset(40); //required\n    make.left.equalTo(self.view).with.mas_offset(20).priority(800); //optional\n    make.top.equalTo(self.view).with.mas_offset(100);\n    make.width.mas_equalTo(50);\n    make.height.mas_equalTo(50);\n}];\n```\n\n### Autoresizing\n\nAutoresizing 是苹果在 iOS2 时引入的技术，用于描述父控件的 Frame 变化时，子控件应如何跟随变化。但它不能描述同级的 view 之间的关系。因此在 iOS6 之后有了 AutoLayout 技术，一般情况下就没必要再使用 AutoResizing 了。\n\n查看一下 Autoresizing 的定义，发现是一些枚举值：\n\n```objective-c\ntypedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {\n    UIViewAutoresizingNone                 = 0,\n    UIViewAutoresizingFlexibleLeftMargin   = 1 << 0,\n    UIViewAutoresizingFlexibleWidth        = 1 << 1,\n    UIViewAutoresizingFlexibleRightMargin  = 1 << 2,\n    UIViewAutoresizingFlexibleTopMargin    = 1 << 3,\n    UIViewAutoresizingFlexibleHeight       = 1 << 4,\n    UIViewAutoresizingFlexibleBottomMargin = 1 << 5\n};\n```\n\n我们可以发现，苹果通过把 1 左移不同的位数，构造出了掩码（mask）。在使用时，不同的 Autoresizing 类型只要按位或一下，就可以表示多个值的叠加。如 0010 与 0001 按位或，可以得到 0011，这样使用起来非常方便。\n\n还有一点需要了解的就是，有时 Autoresizing 会和 AutoLayout 发生冲突而导致程序崩溃。这是因为 view 中有一个 Bool 类型的属性是 `translatesAutoresizingMaskIntoConstraints` ，顾名思义，它表示是否要把 Autoresizing 的设置翻译成等价的 AutoLayout。如果值为 true，又含有 Autoresizing 的信息，翻译过来的约束就可能和我们自己添加的约束产生冲突。这个时候只要把它设置为 false 就可以了。\n\n### sizeToFit VS sizeThatFits\n\n想要根据 label 文字长度改变 frame 时，还有在设置 toolBar 的一些设置中，都可以使用 sizeToFit 来让系统自动计算合理的 frame。事实上，sizeToFit 是 UIView 的方法，很多 view 都可以让系统来帮我们布局。\n\n这两个方法的区别其实通过名字就很容易区分。sizeToFit 就是算出合理的尺寸后，改变自己的 size。而 sizeThatFits 就是算出合理的尺寸后，返回这个值，但不修改自己的 size，把决定权交给程序员。\n\n### Size Classes\n\n苹果为各种不同的设备、以及各个设备横屏、竖屏时的长宽分了三个等级：Compact，Regular，Any。我们在 Story Board 中可以看到 `(w C h R)` 的字样，改变设备和朝向后，这个值会跟着变化。Size Classes 可以说是对不同屏幕尺寸的一种抽象，让我们脱离开具体的尺寸数值。不过它只是对屏幕的分类，而不是布局方法，布局本身还是要通过 AutoLayout 来做。\n\n使用 Size Classes 的好处是显而易见的：iPhone 横屏竖屏、iPad 各种 MultiTasking 状态、plus 机型横屏……众多情况都可以轻松解决。\n\n在 Xcode9 的 Story Board 中怎么设置呢？首先我们要点击屏幕下方的 Vary For Traits 按钮，选中相应的 width 或 height。这个时候会进入 Size Classes 的编辑模式（底部变蓝）。选中之前 Any 状态设置的约束，把 installed 选项框取消选中。这个时候再添加约束，就是当前的 Size Classes 的约束了。之前的约束并没有被删掉，只是在当前状态下不加载了而已。完成后点击 Done 即可。可见通过 Story Board 拖动控件进行布局还是非常方便的。\n\n如果这个时候你说：老板！我就想纯代码布局！可不可以嘛！\n\n当然可以！可以这样用：\n\n```objective-c\nUITraitCollection *collection = self.traitCollection;\nif(collection.horizontalSizeClass == UIUserInterfaceSizeClassCompact && collection.verticalSizeClass == UIUserInterfaceSizeClassRegular) {\n    //set your constrains\n}\n```\n\n在屏幕旋转等情况下，还会调用代理方法：\n\n```objective-c\n- (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection withTransitionCoordinator:(id<UIViewControllerTransitionCoordinator>)coordinator;\n```\n\n在这个代理方法中还要实现 Size Classes 改变后的约束。\n\n可见，使用代码来完成 Size Classes 还是有些繁琐的。如果要同时适配 iPhone 和 iPad 的各种情况，就要啰啰嗦嗦写一大堆判断各种情况的代码，这点不如直接用 sb 布局方便。\n\n### UIStackView\n\nUIStackView 是用于水平或垂直布局的控件，用以替换手工书写 AutoLayout。它的 subviews 的位置是根据对齐、间距、大小等属性决定的，并根据屏幕大小、方向动态进行调整。\n\nUIStackView 的原理就是 AutoLayout，只不过是又抽象出了一层，让布局变得更加容易。我们还可以嵌套 UIStackView 来获得更精细的布局。和 Size Classes 类似，在 Story Board 中布局会比较方便，纯代码编写就显得冗长。\n\n腾讯的一道面试题是：用 UIStackView 做布局有什么问题？答案是它是 iOS9 才引入的新控件，而大公司可能要支持的 iOS 版本比较多，就有兼容性的问题。我们平时做开发一般不必支持这么多个版本（而且随着 iOS12 即将在今年 6 月 WWDC 发布，这个问题将会进一步淡化），如果一定要支持早期版本，也有支持更多 iOS 版本的第三方的开源控件供我们使用。\n\n关于 UIStackView 更详细的教程，可以参考[Ray Wenderlich](https://www.raywenderlich.com/160646/uistackview-tutorial-introducing-stack-views-2)。\n\n### 性能\n\n首先我们要谈一下**屏幕显示原理**。\n\n![ios_screen_display](/img/layoutStudy/ios_screen_display.png)\n\nCPU 把计算好要显示的内容提交给 GPU。GPU 会根据这些信息进行渲染，把渲染结果写入帧缓冲区。通常来讲，屏幕是一行一行刷新的，因此需要水平同步信号 HSync 和 垂直同步信号 VSync。每次刷新，屏幕都会从缓冲区取出数据进行绘制。这里的帧缓冲区（Frame Buffer）也就是我们通常所说的显存。\n\n如果只有一个缓冲区，就会发生屏幕的闪烁。当屏幕去显存中去数据时，CPU 还没有完成全部的计算，也就是说缓存区的数据不完整，如果屏幕按照这个值来绘制，就会出现问题。下面的动图是我大二的时候利用 FPGA 制作视频小游戏时的情景，由于只使用了一个缓冲区，可以看到即使我没有完整的刷新屏幕（而是只刷新产生变化的部分），也存在明显的闪烁：\n\n![screen](/img/layoutStudy/screen.gif)\n\n双缓存的原理是，GPU 向缓存区 A 提交数据，而显示器从已经有数据的缓存区 B 取数据绘制。只有在缓存区 A 写入完成后，显示器才切换至 A 取数据，同时 GPU 再向 B 区写数据。上面的例子中，如果当时使用了双缓存技术，运行效果将非常平滑（我当时没有在自己的项目中运用，但是却指导了其他小组的同学=.=）。可见有时产生性能问题不是说板子或者设备的性能不够，而是使用者没有完全发挥出它们的能力。同时我们再次验证了一句名言：“很多性能问题都可以通过缓存解决”。\n\niOS 设备是使用了双缓存的，安卓设备采用了三缓存。当 VSync 信号到来时，iOS 会通过 CADisplayLink 来通知 App。如果计算量过大，CPU 或者 GPU 没有在规定的时间提交数据，那么此帧就得不到刷新，画面将静止不动。这也就是我们所说的掉帧、卡顿的产生根本原因。\n\n造成性能问题的原因有很多。在布局时，如果界面很复杂，又采用了 AutoLayout 技术，那么解这个多元方程组的时间将呈指数上升，占用大量的 CPU 时间。\n\n### ASDK (Texture)\n\nAsyncDisplayKit，现在更名为 Texture，是由 FaceBook 开源的异步渲染框架。由于 UIKit 不是线程安全的（为什么不做成线程安全的？一个是开发成本巨大，另一个是线程安全本身又会造成性能下降），ASDK 的思路就是能放在后台的，放在后台去做；实在不行的，尽量优化性能。\n\n在布局方面，ASDK 同样支持手动布局，但是会做一些异步预加载的优化来提高性能。ASDK 还拥有 Automatic Layout （区别于 Auto Layout）来做自动布局。Automatic Layout 其实是制定了一套布局规则，通过 ASLayoutable 来松散耦合，不关心具体是 node 还是其他什么，因此可以复用这套布局逻辑。通过组合多个 Layout Specs 如 stack / inset 等完成复杂的布局，有点类似前端的 CSS。事实上，stack 和 UIStackView 也是类似的，但是 Layout Specs 本身不是依附于 UIView 的，而是单独存在的数据结构，因此它可以进行缓存、可以在后台计算，降低耦合的同时也提高了效率。由此来看，iOS 本身的布局系统其实并不先进，有很多值得向 CSS 等其他布局技术借鉴的地方。\n\n参考自[即刻技术团队的文章](https://juejin.im/post/58f0812a0ce463006b9fc403)\n\n\n\n\n\n","source":"_posts/iOS-Layout学习笔记.md","raw":"---\ntitle: iOS-Layout学习笔记\ndate: 2018-05-02 14:48:50\ntags: Layout\n---\n\n# iOS Layout 学习笔记\n\n关于 iOS 布局系统的一些知识在我之前的博客中已经写过了，这里再补充一些。\n\n### 优先级\n\n每个约束都有优先级，范围从 1 到 1000。优先级为 1000 的约束是必须的，小于 1000 的约束是可选的。Auto Layout 会优先满足高优先级的约束，如果一个可选的约束得不到满足，Auto Layout 会跳过它。\n\n**应用：**左右两个 View A 和 B，当我们让 view A 消失时，view B 向左平移。\n\n这是京东的一道面试题。面试官举出的应用场景是：左边是一个 loading indicator，在网络请求时一致播放加载动画，右边是一个 label。当请求完成后，需要把 indicator 移除，让 label 平移过来。\n\n我们当然有很多种方法来实现这个需求，但显然通过合理设置约束的优先级能够更优雅地解决这个问题。只需要给 View B 添加一个到 A 一段距离的必须的约束，再给 B 添加一个到屏幕边缘的可选约束就好了。当 A 还在画面中时，可选的约束和必须的约束产生冲突得不到满足，因此 B 距离 A 一段距离。当我们把 A remove 掉之后，与 A 相关的约束也就不在了，那么可选的约束就可以满足，B 因此变为距离屏幕边缘一段距离。\n\n通过设置优先级，我们不再需要更新约束，而只要简单的调用 removeFromSuperview 把 A 移除就可以了。\n\n![twoViews](/img/layoutStudy/twoViews.gif)\n\n```objective-c\n_leftView.backgroundColor = UIColor.blueColor;\n[_leftView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.left.equalTo(self.view).with.mas_offset(20);\n    make.top.equalTo(self.rightView);\n    make.width.mas_equalTo(50);\n    make.height.mas_equalTo(50);\n}];\n    \n_rightView.backgroundColor = UIColor.greenColor;\n[_rightView mas_makeConstraints:^(MASConstraintMaker *make) {\n    make.left.equalTo(self.leftView.mas_right).with.mas_offset(40); //required\n    make.left.equalTo(self.view).with.mas_offset(20).priority(800); //optional\n    make.top.equalTo(self.view).with.mas_offset(100);\n    make.width.mas_equalTo(50);\n    make.height.mas_equalTo(50);\n}];\n```\n\n### Autoresizing\n\nAutoresizing 是苹果在 iOS2 时引入的技术，用于描述父控件的 Frame 变化时，子控件应如何跟随变化。但它不能描述同级的 view 之间的关系。因此在 iOS6 之后有了 AutoLayout 技术，一般情况下就没必要再使用 AutoResizing 了。\n\n查看一下 Autoresizing 的定义，发现是一些枚举值：\n\n```objective-c\ntypedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {\n    UIViewAutoresizingNone                 = 0,\n    UIViewAutoresizingFlexibleLeftMargin   = 1 << 0,\n    UIViewAutoresizingFlexibleWidth        = 1 << 1,\n    UIViewAutoresizingFlexibleRightMargin  = 1 << 2,\n    UIViewAutoresizingFlexibleTopMargin    = 1 << 3,\n    UIViewAutoresizingFlexibleHeight       = 1 << 4,\n    UIViewAutoresizingFlexibleBottomMargin = 1 << 5\n};\n```\n\n我们可以发现，苹果通过把 1 左移不同的位数，构造出了掩码（mask）。在使用时，不同的 Autoresizing 类型只要按位或一下，就可以表示多个值的叠加。如 0010 与 0001 按位或，可以得到 0011，这样使用起来非常方便。\n\n还有一点需要了解的就是，有时 Autoresizing 会和 AutoLayout 发生冲突而导致程序崩溃。这是因为 view 中有一个 Bool 类型的属性是 `translatesAutoresizingMaskIntoConstraints` ，顾名思义，它表示是否要把 Autoresizing 的设置翻译成等价的 AutoLayout。如果值为 true，又含有 Autoresizing 的信息，翻译过来的约束就可能和我们自己添加的约束产生冲突。这个时候只要把它设置为 false 就可以了。\n\n### sizeToFit VS sizeThatFits\n\n想要根据 label 文字长度改变 frame 时，还有在设置 toolBar 的一些设置中，都可以使用 sizeToFit 来让系统自动计算合理的 frame。事实上，sizeToFit 是 UIView 的方法，很多 view 都可以让系统来帮我们布局。\n\n这两个方法的区别其实通过名字就很容易区分。sizeToFit 就是算出合理的尺寸后，改变自己的 size。而 sizeThatFits 就是算出合理的尺寸后，返回这个值，但不修改自己的 size，把决定权交给程序员。\n\n### Size Classes\n\n苹果为各种不同的设备、以及各个设备横屏、竖屏时的长宽分了三个等级：Compact，Regular，Any。我们在 Story Board 中可以看到 `(w C h R)` 的字样，改变设备和朝向后，这个值会跟着变化。Size Classes 可以说是对不同屏幕尺寸的一种抽象，让我们脱离开具体的尺寸数值。不过它只是对屏幕的分类，而不是布局方法，布局本身还是要通过 AutoLayout 来做。\n\n使用 Size Classes 的好处是显而易见的：iPhone 横屏竖屏、iPad 各种 MultiTasking 状态、plus 机型横屏……众多情况都可以轻松解决。\n\n在 Xcode9 的 Story Board 中怎么设置呢？首先我们要点击屏幕下方的 Vary For Traits 按钮，选中相应的 width 或 height。这个时候会进入 Size Classes 的编辑模式（底部变蓝）。选中之前 Any 状态设置的约束，把 installed 选项框取消选中。这个时候再添加约束，就是当前的 Size Classes 的约束了。之前的约束并没有被删掉，只是在当前状态下不加载了而已。完成后点击 Done 即可。可见通过 Story Board 拖动控件进行布局还是非常方便的。\n\n如果这个时候你说：老板！我就想纯代码布局！可不可以嘛！\n\n当然可以！可以这样用：\n\n```objective-c\nUITraitCollection *collection = self.traitCollection;\nif(collection.horizontalSizeClass == UIUserInterfaceSizeClassCompact && collection.verticalSizeClass == UIUserInterfaceSizeClassRegular) {\n    //set your constrains\n}\n```\n\n在屏幕旋转等情况下，还会调用代理方法：\n\n```objective-c\n- (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection withTransitionCoordinator:(id<UIViewControllerTransitionCoordinator>)coordinator;\n```\n\n在这个代理方法中还要实现 Size Classes 改变后的约束。\n\n可见，使用代码来完成 Size Classes 还是有些繁琐的。如果要同时适配 iPhone 和 iPad 的各种情况，就要啰啰嗦嗦写一大堆判断各种情况的代码，这点不如直接用 sb 布局方便。\n\n### UIStackView\n\nUIStackView 是用于水平或垂直布局的控件，用以替换手工书写 AutoLayout。它的 subviews 的位置是根据对齐、间距、大小等属性决定的，并根据屏幕大小、方向动态进行调整。\n\nUIStackView 的原理就是 AutoLayout，只不过是又抽象出了一层，让布局变得更加容易。我们还可以嵌套 UIStackView 来获得更精细的布局。和 Size Classes 类似，在 Story Board 中布局会比较方便，纯代码编写就显得冗长。\n\n腾讯的一道面试题是：用 UIStackView 做布局有什么问题？答案是它是 iOS9 才引入的新控件，而大公司可能要支持的 iOS 版本比较多，就有兼容性的问题。我们平时做开发一般不必支持这么多个版本（而且随着 iOS12 即将在今年 6 月 WWDC 发布，这个问题将会进一步淡化），如果一定要支持早期版本，也有支持更多 iOS 版本的第三方的开源控件供我们使用。\n\n关于 UIStackView 更详细的教程，可以参考[Ray Wenderlich](https://www.raywenderlich.com/160646/uistackview-tutorial-introducing-stack-views-2)。\n\n### 性能\n\n首先我们要谈一下**屏幕显示原理**。\n\n![ios_screen_display](/img/layoutStudy/ios_screen_display.png)\n\nCPU 把计算好要显示的内容提交给 GPU。GPU 会根据这些信息进行渲染，把渲染结果写入帧缓冲区。通常来讲，屏幕是一行一行刷新的，因此需要水平同步信号 HSync 和 垂直同步信号 VSync。每次刷新，屏幕都会从缓冲区取出数据进行绘制。这里的帧缓冲区（Frame Buffer）也就是我们通常所说的显存。\n\n如果只有一个缓冲区，就会发生屏幕的闪烁。当屏幕去显存中去数据时，CPU 还没有完成全部的计算，也就是说缓存区的数据不完整，如果屏幕按照这个值来绘制，就会出现问题。下面的动图是我大二的时候利用 FPGA 制作视频小游戏时的情景，由于只使用了一个缓冲区，可以看到即使我没有完整的刷新屏幕（而是只刷新产生变化的部分），也存在明显的闪烁：\n\n![screen](/img/layoutStudy/screen.gif)\n\n双缓存的原理是，GPU 向缓存区 A 提交数据，而显示器从已经有数据的缓存区 B 取数据绘制。只有在缓存区 A 写入完成后，显示器才切换至 A 取数据，同时 GPU 再向 B 区写数据。上面的例子中，如果当时使用了双缓存技术，运行效果将非常平滑（我当时没有在自己的项目中运用，但是却指导了其他小组的同学=.=）。可见有时产生性能问题不是说板子或者设备的性能不够，而是使用者没有完全发挥出它们的能力。同时我们再次验证了一句名言：“很多性能问题都可以通过缓存解决”。\n\niOS 设备是使用了双缓存的，安卓设备采用了三缓存。当 VSync 信号到来时，iOS 会通过 CADisplayLink 来通知 App。如果计算量过大，CPU 或者 GPU 没有在规定的时间提交数据，那么此帧就得不到刷新，画面将静止不动。这也就是我们所说的掉帧、卡顿的产生根本原因。\n\n造成性能问题的原因有很多。在布局时，如果界面很复杂，又采用了 AutoLayout 技术，那么解这个多元方程组的时间将呈指数上升，占用大量的 CPU 时间。\n\n### ASDK (Texture)\n\nAsyncDisplayKit，现在更名为 Texture，是由 FaceBook 开源的异步渲染框架。由于 UIKit 不是线程安全的（为什么不做成线程安全的？一个是开发成本巨大，另一个是线程安全本身又会造成性能下降），ASDK 的思路就是能放在后台的，放在后台去做；实在不行的，尽量优化性能。\n\n在布局方面，ASDK 同样支持手动布局，但是会做一些异步预加载的优化来提高性能。ASDK 还拥有 Automatic Layout （区别于 Auto Layout）来做自动布局。Automatic Layout 其实是制定了一套布局规则，通过 ASLayoutable 来松散耦合，不关心具体是 node 还是其他什么，因此可以复用这套布局逻辑。通过组合多个 Layout Specs 如 stack / inset 等完成复杂的布局，有点类似前端的 CSS。事实上，stack 和 UIStackView 也是类似的，但是 Layout Specs 本身不是依附于 UIView 的，而是单独存在的数据结构，因此它可以进行缓存、可以在后台计算，降低耦合的同时也提高了效率。由此来看，iOS 本身的布局系统其实并不先进，有很多值得向 CSS 等其他布局技术借鉴的地方。\n\n参考自[即刻技术团队的文章](https://juejin.im/post/58f0812a0ce463006b9fc403)\n\n\n\n\n\n","slug":"iOS-Layout学习笔记","published":1,"updated":"2020-01-04T08:16:16.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv3z0039ljc3fth9w34q","content":"<h1 id=\"iOS-Layout-学习笔记\"><a href=\"#iOS-Layout-学习笔记\" class=\"headerlink\" title=\"iOS Layout 学习笔记\"></a>iOS Layout 学习笔记</h1><p>关于 iOS 布局系统的一些知识在我之前的博客中已经写过了，这里再补充一些。</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>每个约束都有优先级，范围从 1 到 1000。优先级为 1000 的约束是必须的，小于 1000 的约束是可选的。Auto Layout 会优先满足高优先级的约束，如果一个可选的约束得不到满足，Auto Layout 会跳过它。</p>\n<p><strong>应用：</strong>左右两个 View A 和 B，当我们让 view A 消失时，view B 向左平移。</p>\n<p>这是京东的一道面试题。面试官举出的应用场景是：左边是一个 loading indicator，在网络请求时一致播放加载动画，右边是一个 label。当请求完成后，需要把 indicator 移除，让 label 平移过来。</p>\n<p>我们当然有很多种方法来实现这个需求，但显然通过合理设置约束的优先级能够更优雅地解决这个问题。只需要给 View B 添加一个到 A 一段距离的必须的约束，再给 B 添加一个到屏幕边缘的可选约束就好了。当 A 还在画面中时，可选的约束和必须的约束产生冲突得不到满足，因此 B 距离 A 一段距离。当我们把 A remove 掉之后，与 A 相关的约束也就不在了，那么可选的约束就可以满足，B 因此变为距离屏幕边缘一段距离。</p>\n<p>通过设置优先级，我们不再需要更新约束，而只要简单的调用 removeFromSuperview 把 A 移除就可以了。</p>\n<p><img src=\"/img/layoutStudy/twoViews.gif\" alt=\"twoViews\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_leftView.backgroundColor = UIColor.blueColor;</span><br><span class=\"line\">[_leftView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.left.equalTo(self.view).with.mas_offset(20);</span><br><span class=\"line\">    make.top.equalTo(self.rightView);</span><br><span class=\"line\">    make.width.mas_equalTo(50);</span><br><span class=\"line\">    make.height.mas_equalTo(50);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">_rightView.backgroundColor = UIColor.greenColor;</span><br><span class=\"line\">[_rightView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.left.equalTo(self.leftView.mas_right).with.mas_offset(40); //required</span><br><span class=\"line\">    make.left.equalTo(self.view).with.mas_offset(20).priority(800); //optional</span><br><span class=\"line\">    make.top.equalTo(self.view).with.mas_offset(100);</span><br><span class=\"line\">    make.width.mas_equalTo(50);</span><br><span class=\"line\">    make.height.mas_equalTo(50);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"Autoresizing\"><a href=\"#Autoresizing\" class=\"headerlink\" title=\"Autoresizing\"></a>Autoresizing</h3><p>Autoresizing 是苹果在 iOS2 时引入的技术，用于描述父控件的 Frame 变化时，子控件应如何跟随变化。但它不能描述同级的 view 之间的关系。因此在 iOS6 之后有了 AutoLayout 技术，一般情况下就没必要再使用 AutoResizing 了。</p>\n<p>查看一下 Autoresizing 的定义，发现是一些枚举值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;</span><br><span class=\"line\">    UIViewAutoresizingNone                 = 0,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们可以发现，苹果通过把 1 左移不同的位数，构造出了掩码（mask）。在使用时，不同的 Autoresizing 类型只要按位或一下，就可以表示多个值的叠加。如 0010 与 0001 按位或，可以得到 0011，这样使用起来非常方便。</p>\n<p>还有一点需要了解的就是，有时 Autoresizing 会和 AutoLayout 发生冲突而导致程序崩溃。这是因为 view 中有一个 Bool 类型的属性是 <code>translatesAutoresizingMaskIntoConstraints</code> ，顾名思义，它表示是否要把 Autoresizing 的设置翻译成等价的 AutoLayout。如果值为 true，又含有 Autoresizing 的信息，翻译过来的约束就可能和我们自己添加的约束产生冲突。这个时候只要把它设置为 false 就可以了。</p>\n<h3 id=\"sizeToFit-VS-sizeThatFits\"><a href=\"#sizeToFit-VS-sizeThatFits\" class=\"headerlink\" title=\"sizeToFit VS sizeThatFits\"></a>sizeToFit VS sizeThatFits</h3><p>想要根据 label 文字长度改变 frame 时，还有在设置 toolBar 的一些设置中，都可以使用 sizeToFit 来让系统自动计算合理的 frame。事实上，sizeToFit 是 UIView 的方法，很多 view 都可以让系统来帮我们布局。</p>\n<p>这两个方法的区别其实通过名字就很容易区分。sizeToFit 就是算出合理的尺寸后，改变自己的 size。而 sizeThatFits 就是算出合理的尺寸后，返回这个值，但不修改自己的 size，把决定权交给程序员。</p>\n<h3 id=\"Size-Classes\"><a href=\"#Size-Classes\" class=\"headerlink\" title=\"Size Classes\"></a>Size Classes</h3><p>苹果为各种不同的设备、以及各个设备横屏、竖屏时的长宽分了三个等级：Compact，Regular，Any。我们在 Story Board 中可以看到 <code>(w C h R)</code> 的字样，改变设备和朝向后，这个值会跟着变化。Size Classes 可以说是对不同屏幕尺寸的一种抽象，让我们脱离开具体的尺寸数值。不过它只是对屏幕的分类，而不是布局方法，布局本身还是要通过 AutoLayout 来做。</p>\n<p>使用 Size Classes 的好处是显而易见的：iPhone 横屏竖屏、iPad 各种 MultiTasking 状态、plus 机型横屏……众多情况都可以轻松解决。</p>\n<p>在 Xcode9 的 Story Board 中怎么设置呢？首先我们要点击屏幕下方的 Vary For Traits 按钮，选中相应的 width 或 height。这个时候会进入 Size Classes 的编辑模式（底部变蓝）。选中之前 Any 状态设置的约束，把 installed 选项框取消选中。这个时候再添加约束，就是当前的 Size Classes 的约束了。之前的约束并没有被删掉，只是在当前状态下不加载了而已。完成后点击 Done 即可。可见通过 Story Board 拖动控件进行布局还是非常方便的。</p>\n<p>如果这个时候你说：老板！我就想纯代码布局！可不可以嘛！</p>\n<p>当然可以！可以这样用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UITraitCollection *collection = self.traitCollection;</span><br><span class=\"line\">if(collection.horizontalSizeClass == UIUserInterfaceSizeClassCompact &amp;&amp; collection.verticalSizeClass == UIUserInterfaceSizeClassRegular) &#123;</span><br><span class=\"line\">    //set your constrains</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在屏幕旋转等情况下，还会调用代理方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator;</span><br></pre></td></tr></table></figure>\n<p>在这个代理方法中还要实现 Size Classes 改变后的约束。</p>\n<p>可见，使用代码来完成 Size Classes 还是有些繁琐的。如果要同时适配 iPhone 和 iPad 的各种情况，就要啰啰嗦嗦写一大堆判断各种情况的代码，这点不如直接用 sb 布局方便。</p>\n<h3 id=\"UIStackView\"><a href=\"#UIStackView\" class=\"headerlink\" title=\"UIStackView\"></a>UIStackView</h3><p>UIStackView 是用于水平或垂直布局的控件，用以替换手工书写 AutoLayout。它的 subviews 的位置是根据对齐、间距、大小等属性决定的，并根据屏幕大小、方向动态进行调整。</p>\n<p>UIStackView 的原理就是 AutoLayout，只不过是又抽象出了一层，让布局变得更加容易。我们还可以嵌套 UIStackView 来获得更精细的布局。和 Size Classes 类似，在 Story Board 中布局会比较方便，纯代码编写就显得冗长。</p>\n<p>腾讯的一道面试题是：用 UIStackView 做布局有什么问题？答案是它是 iOS9 才引入的新控件，而大公司可能要支持的 iOS 版本比较多，就有兼容性的问题。我们平时做开发一般不必支持这么多个版本（而且随着 iOS12 即将在今年 6 月 WWDC 发布，这个问题将会进一步淡化），如果一定要支持早期版本，也有支持更多 iOS 版本的第三方的开源控件供我们使用。</p>\n<p>关于 UIStackView 更详细的教程，可以参考<a href=\"https://www.raywenderlich.com/160646/uistackview-tutorial-introducing-stack-views-2\">Ray Wenderlich</a>。</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>首先我们要谈一下<strong>屏幕显示原理</strong>。</p>\n<p><img src=\"/img/layoutStudy/ios_screen_display.png\" alt=\"ios_screen_display\"></p>\n<p>CPU 把计算好要显示的内容提交给 GPU。GPU 会根据这些信息进行渲染，把渲染结果写入帧缓冲区。通常来讲，屏幕是一行一行刷新的，因此需要水平同步信号 HSync 和 垂直同步信号 VSync。每次刷新，屏幕都会从缓冲区取出数据进行绘制。这里的帧缓冲区（Frame Buffer）也就是我们通常所说的显存。</p>\n<p>如果只有一个缓冲区，就会发生屏幕的闪烁。当屏幕去显存中去数据时，CPU 还没有完成全部的计算，也就是说缓存区的数据不完整，如果屏幕按照这个值来绘制，就会出现问题。下面的动图是我大二的时候利用 FPGA 制作视频小游戏时的情景，由于只使用了一个缓冲区，可以看到即使我没有完整的刷新屏幕（而是只刷新产生变化的部分），也存在明显的闪烁：</p>\n<p><img src=\"/img/layoutStudy/screen.gif\" alt=\"screen\"></p>\n<p>双缓存的原理是，GPU 向缓存区 A 提交数据，而显示器从已经有数据的缓存区 B 取数据绘制。只有在缓存区 A 写入完成后，显示器才切换至 A 取数据，同时 GPU 再向 B 区写数据。上面的例子中，如果当时使用了双缓存技术，运行效果将非常平滑（我当时没有在自己的项目中运用，但是却指导了其他小组的同学=.=）。可见有时产生性能问题不是说板子或者设备的性能不够，而是使用者没有完全发挥出它们的能力。同时我们再次验证了一句名言：“很多性能问题都可以通过缓存解决”。</p>\n<p>iOS 设备是使用了双缓存的，安卓设备采用了三缓存。当 VSync 信号到来时，iOS 会通过 CADisplayLink 来通知 App。如果计算量过大，CPU 或者 GPU 没有在规定的时间提交数据，那么此帧就得不到刷新，画面将静止不动。这也就是我们所说的掉帧、卡顿的产生根本原因。</p>\n<p>造成性能问题的原因有很多。在布局时，如果界面很复杂，又采用了 AutoLayout 技术，那么解这个多元方程组的时间将呈指数上升，占用大量的 CPU 时间。</p>\n<h3 id=\"ASDK-Texture\"><a href=\"#ASDK-Texture\" class=\"headerlink\" title=\"ASDK (Texture)\"></a>ASDK (Texture)</h3><p>AsyncDisplayKit，现在更名为 Texture，是由 FaceBook 开源的异步渲染框架。由于 UIKit 不是线程安全的（为什么不做成线程安全的？一个是开发成本巨大，另一个是线程安全本身又会造成性能下降），ASDK 的思路就是能放在后台的，放在后台去做；实在不行的，尽量优化性能。</p>\n<p>在布局方面，ASDK 同样支持手动布局，但是会做一些异步预加载的优化来提高性能。ASDK 还拥有 Automatic Layout （区别于 Auto Layout）来做自动布局。Automatic Layout 其实是制定了一套布局规则，通过 ASLayoutable 来松散耦合，不关心具体是 node 还是其他什么，因此可以复用这套布局逻辑。通过组合多个 Layout Specs 如 stack / inset 等完成复杂的布局，有点类似前端的 CSS。事实上，stack 和 UIStackView 也是类似的，但是 Layout Specs 本身不是依附于 UIView 的，而是单独存在的数据结构，因此它可以进行缓存、可以在后台计算，降低耦合的同时也提高了效率。由此来看，iOS 本身的布局系统其实并不先进，有很多值得向 CSS 等其他布局技术借鉴的地方。</p>\n<p>参考自<a href=\"https://juejin.im/post/58f0812a0ce463006b9fc403\">即刻技术团队的文章</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-Layout-学习笔记\"><a href=\"#iOS-Layout-学习笔记\" class=\"headerlink\" title=\"iOS Layout 学习笔记\"></a>iOS Layout 学习笔记</h1><p>关于 iOS 布局系统的一些知识在我之前的博客中已经写过了，这里再补充一些。</p>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p>每个约束都有优先级，范围从 1 到 1000。优先级为 1000 的约束是必须的，小于 1000 的约束是可选的。Auto Layout 会优先满足高优先级的约束，如果一个可选的约束得不到满足，Auto Layout 会跳过它。</p>\n<p><strong>应用：</strong>左右两个 View A 和 B，当我们让 view A 消失时，view B 向左平移。</p>\n<p>这是京东的一道面试题。面试官举出的应用场景是：左边是一个 loading indicator，在网络请求时一致播放加载动画，右边是一个 label。当请求完成后，需要把 indicator 移除，让 label 平移过来。</p>\n<p>我们当然有很多种方法来实现这个需求，但显然通过合理设置约束的优先级能够更优雅地解决这个问题。只需要给 View B 添加一个到 A 一段距离的必须的约束，再给 B 添加一个到屏幕边缘的可选约束就好了。当 A 还在画面中时，可选的约束和必须的约束产生冲突得不到满足，因此 B 距离 A 一段距离。当我们把 A remove 掉之后，与 A 相关的约束也就不在了，那么可选的约束就可以满足，B 因此变为距离屏幕边缘一段距离。</p>\n<p>通过设置优先级，我们不再需要更新约束，而只要简单的调用 removeFromSuperview 把 A 移除就可以了。</p>\n<p><img src=\"/img/layoutStudy/twoViews.gif\" alt=\"twoViews\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_leftView.backgroundColor = UIColor.blueColor;</span><br><span class=\"line\">[_leftView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.left.equalTo(self.view).with.mas_offset(20);</span><br><span class=\"line\">    make.top.equalTo(self.rightView);</span><br><span class=\"line\">    make.width.mas_equalTo(50);</span><br><span class=\"line\">    make.height.mas_equalTo(50);</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">    </span><br><span class=\"line\">_rightView.backgroundColor = UIColor.greenColor;</span><br><span class=\"line\">[_rightView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class=\"line\">    make.left.equalTo(self.leftView.mas_right).with.mas_offset(40); //required</span><br><span class=\"line\">    make.left.equalTo(self.view).with.mas_offset(20).priority(800); //optional</span><br><span class=\"line\">    make.top.equalTo(self.view).with.mas_offset(100);</span><br><span class=\"line\">    make.width.mas_equalTo(50);</span><br><span class=\"line\">    make.height.mas_equalTo(50);</span><br><span class=\"line\">&#125;];</span><br></pre></td></tr></table></figure>\n<h3 id=\"Autoresizing\"><a href=\"#Autoresizing\" class=\"headerlink\" title=\"Autoresizing\"></a>Autoresizing</h3><p>Autoresizing 是苹果在 iOS2 时引入的技术，用于描述父控件的 Frame 变化时，子控件应如何跟随变化。但它不能描述同级的 view 之间的关系。因此在 iOS6 之后有了 AutoLayout 技术，一般情况下就没必要再使用 AutoResizing 了。</p>\n<p>查看一下 Autoresizing 的定义，发现是一些枚举值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;</span><br><span class=\"line\">    UIViewAutoresizingNone                 = 0,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,</span><br><span class=\"line\">    UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们可以发现，苹果通过把 1 左移不同的位数，构造出了掩码（mask）。在使用时，不同的 Autoresizing 类型只要按位或一下，就可以表示多个值的叠加。如 0010 与 0001 按位或，可以得到 0011，这样使用起来非常方便。</p>\n<p>还有一点需要了解的就是，有时 Autoresizing 会和 AutoLayout 发生冲突而导致程序崩溃。这是因为 view 中有一个 Bool 类型的属性是 <code>translatesAutoresizingMaskIntoConstraints</code> ，顾名思义，它表示是否要把 Autoresizing 的设置翻译成等价的 AutoLayout。如果值为 true，又含有 Autoresizing 的信息，翻译过来的约束就可能和我们自己添加的约束产生冲突。这个时候只要把它设置为 false 就可以了。</p>\n<h3 id=\"sizeToFit-VS-sizeThatFits\"><a href=\"#sizeToFit-VS-sizeThatFits\" class=\"headerlink\" title=\"sizeToFit VS sizeThatFits\"></a>sizeToFit VS sizeThatFits</h3><p>想要根据 label 文字长度改变 frame 时，还有在设置 toolBar 的一些设置中，都可以使用 sizeToFit 来让系统自动计算合理的 frame。事实上，sizeToFit 是 UIView 的方法，很多 view 都可以让系统来帮我们布局。</p>\n<p>这两个方法的区别其实通过名字就很容易区分。sizeToFit 就是算出合理的尺寸后，改变自己的 size。而 sizeThatFits 就是算出合理的尺寸后，返回这个值，但不修改自己的 size，把决定权交给程序员。</p>\n<h3 id=\"Size-Classes\"><a href=\"#Size-Classes\" class=\"headerlink\" title=\"Size Classes\"></a>Size Classes</h3><p>苹果为各种不同的设备、以及各个设备横屏、竖屏时的长宽分了三个等级：Compact，Regular，Any。我们在 Story Board 中可以看到 <code>(w C h R)</code> 的字样，改变设备和朝向后，这个值会跟着变化。Size Classes 可以说是对不同屏幕尺寸的一种抽象，让我们脱离开具体的尺寸数值。不过它只是对屏幕的分类，而不是布局方法，布局本身还是要通过 AutoLayout 来做。</p>\n<p>使用 Size Classes 的好处是显而易见的：iPhone 横屏竖屏、iPad 各种 MultiTasking 状态、plus 机型横屏……众多情况都可以轻松解决。</p>\n<p>在 Xcode9 的 Story Board 中怎么设置呢？首先我们要点击屏幕下方的 Vary For Traits 按钮，选中相应的 width 或 height。这个时候会进入 Size Classes 的编辑模式（底部变蓝）。选中之前 Any 状态设置的约束，把 installed 选项框取消选中。这个时候再添加约束，就是当前的 Size Classes 的约束了。之前的约束并没有被删掉，只是在当前状态下不加载了而已。完成后点击 Done 即可。可见通过 Story Board 拖动控件进行布局还是非常方便的。</p>\n<p>如果这个时候你说：老板！我就想纯代码布局！可不可以嘛！</p>\n<p>当然可以！可以这样用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UITraitCollection *collection = self.traitCollection;</span><br><span class=\"line\">if(collection.horizontalSizeClass == UIUserInterfaceSizeClassCompact &amp;&amp; collection.verticalSizeClass == UIUserInterfaceSizeClassRegular) &#123;</span><br><span class=\"line\">    //set your constrains</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在屏幕旋转等情况下，还会调用代理方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (void)willTransitionToTraitCollection:(UITraitCollection *)newCollection withTransitionCoordinator:(id&lt;UIViewControllerTransitionCoordinator&gt;)coordinator;</span><br></pre></td></tr></table></figure>\n<p>在这个代理方法中还要实现 Size Classes 改变后的约束。</p>\n<p>可见，使用代码来完成 Size Classes 还是有些繁琐的。如果要同时适配 iPhone 和 iPad 的各种情况，就要啰啰嗦嗦写一大堆判断各种情况的代码，这点不如直接用 sb 布局方便。</p>\n<h3 id=\"UIStackView\"><a href=\"#UIStackView\" class=\"headerlink\" title=\"UIStackView\"></a>UIStackView</h3><p>UIStackView 是用于水平或垂直布局的控件，用以替换手工书写 AutoLayout。它的 subviews 的位置是根据对齐、间距、大小等属性决定的，并根据屏幕大小、方向动态进行调整。</p>\n<p>UIStackView 的原理就是 AutoLayout，只不过是又抽象出了一层，让布局变得更加容易。我们还可以嵌套 UIStackView 来获得更精细的布局。和 Size Classes 类似，在 Story Board 中布局会比较方便，纯代码编写就显得冗长。</p>\n<p>腾讯的一道面试题是：用 UIStackView 做布局有什么问题？答案是它是 iOS9 才引入的新控件，而大公司可能要支持的 iOS 版本比较多，就有兼容性的问题。我们平时做开发一般不必支持这么多个版本（而且随着 iOS12 即将在今年 6 月 WWDC 发布，这个问题将会进一步淡化），如果一定要支持早期版本，也有支持更多 iOS 版本的第三方的开源控件供我们使用。</p>\n<p>关于 UIStackView 更详细的教程，可以参考<a href=\"https://www.raywenderlich.com/160646/uistackview-tutorial-introducing-stack-views-2\">Ray Wenderlich</a>。</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>首先我们要谈一下<strong>屏幕显示原理</strong>。</p>\n<p><img src=\"/img/layoutStudy/ios_screen_display.png\" alt=\"ios_screen_display\"></p>\n<p>CPU 把计算好要显示的内容提交给 GPU。GPU 会根据这些信息进行渲染，把渲染结果写入帧缓冲区。通常来讲，屏幕是一行一行刷新的，因此需要水平同步信号 HSync 和 垂直同步信号 VSync。每次刷新，屏幕都会从缓冲区取出数据进行绘制。这里的帧缓冲区（Frame Buffer）也就是我们通常所说的显存。</p>\n<p>如果只有一个缓冲区，就会发生屏幕的闪烁。当屏幕去显存中去数据时，CPU 还没有完成全部的计算，也就是说缓存区的数据不完整，如果屏幕按照这个值来绘制，就会出现问题。下面的动图是我大二的时候利用 FPGA 制作视频小游戏时的情景，由于只使用了一个缓冲区，可以看到即使我没有完整的刷新屏幕（而是只刷新产生变化的部分），也存在明显的闪烁：</p>\n<p><img src=\"/img/layoutStudy/screen.gif\" alt=\"screen\"></p>\n<p>双缓存的原理是，GPU 向缓存区 A 提交数据，而显示器从已经有数据的缓存区 B 取数据绘制。只有在缓存区 A 写入完成后，显示器才切换至 A 取数据，同时 GPU 再向 B 区写数据。上面的例子中，如果当时使用了双缓存技术，运行效果将非常平滑（我当时没有在自己的项目中运用，但是却指导了其他小组的同学=.=）。可见有时产生性能问题不是说板子或者设备的性能不够，而是使用者没有完全发挥出它们的能力。同时我们再次验证了一句名言：“很多性能问题都可以通过缓存解决”。</p>\n<p>iOS 设备是使用了双缓存的，安卓设备采用了三缓存。当 VSync 信号到来时，iOS 会通过 CADisplayLink 来通知 App。如果计算量过大，CPU 或者 GPU 没有在规定的时间提交数据，那么此帧就得不到刷新，画面将静止不动。这也就是我们所说的掉帧、卡顿的产生根本原因。</p>\n<p>造成性能问题的原因有很多。在布局时，如果界面很复杂，又采用了 AutoLayout 技术，那么解这个多元方程组的时间将呈指数上升，占用大量的 CPU 时间。</p>\n<h3 id=\"ASDK-Texture\"><a href=\"#ASDK-Texture\" class=\"headerlink\" title=\"ASDK (Texture)\"></a>ASDK (Texture)</h3><p>AsyncDisplayKit，现在更名为 Texture，是由 FaceBook 开源的异步渲染框架。由于 UIKit 不是线程安全的（为什么不做成线程安全的？一个是开发成本巨大，另一个是线程安全本身又会造成性能下降），ASDK 的思路就是能放在后台的，放在后台去做；实在不行的，尽量优化性能。</p>\n<p>在布局方面，ASDK 同样支持手动布局，但是会做一些异步预加载的优化来提高性能。ASDK 还拥有 Automatic Layout （区别于 Auto Layout）来做自动布局。Automatic Layout 其实是制定了一套布局规则，通过 ASLayoutable 来松散耦合，不关心具体是 node 还是其他什么，因此可以复用这套布局逻辑。通过组合多个 Layout Specs 如 stack / inset 等完成复杂的布局，有点类似前端的 CSS。事实上，stack 和 UIStackView 也是类似的，但是 Layout Specs 本身不是依附于 UIView 的，而是单独存在的数据结构，因此它可以进行缓存、可以在后台计算，降低耦合的同时也提高了效率。由此来看，iOS 本身的布局系统其实并不先进，有很多值得向 CSS 等其他布局技术借鉴的地方。</p>\n<p>参考自<a href=\"https://juejin.im/post/58f0812a0ce463006b9fc403\">即刻技术团队的文章</a></p>\n"},{"title":"iOS 布局与自动布局","date":"2017-04-25T03:36:55.000Z","_content":"\n# iOS 布局与自动布局\n\n关于AutoLayout的苹果[官方教程](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1)\n\n### Key Points\n\n#### Layout Process 布局过程\n\n参见 [Core Layout Runtime](https://developer.apple.com/library/content/releasenotes/UserExperience/RNAutomaticLayout/index.html#//apple_ref/doc/uid/TP40010631-CH1-SW14)\n\n相比于 Frame 布局，Cocoa Auto Layout 除去显示（display）以外，还在之前增加了两个更多的过程：`updateConstraintsIfNeeded` 和 `layoutIfNeeded` 。这些过程按顺序进行：更新约束、布局、显示。如果你手动唤起显示，那么显示会唤起布局，布局会唤起更新约束（显示依赖布局，布局依赖约束）。\n\n你可以认为更新约束的传递就像是测量的传递。例如，如果你改变了一个按钮的标题，那么文字会被测量，并且约束会被设置以向布局系统通知信息。\n\n详细过程：\n\n1. 更新约束，被称为测量阶段。这个过程自下而上（从子视图到父视图），为下一步的布局做准备。可以调用 `setNeedsUpdateConstraints()` 去触发此步骤，约束发生改变时亦会自动触发。但是当自定义 view 的时候，如果一些改变会影响布局，需要用 `updateConstraintsIfNeeded()` 手动通知AutoLayout。自定义 view 通常需要重写 `updateConstraints` 方法，在其中添加 view 需要的局部约束。SnapKit 的示例代码中，约束就是在这个方法中添加的。注意⚠️：`updateConstraints()`  方法不应该手动直接调用。\n2. 布局，自上而下（从父视图到子视图）。应用上一步的信息去设置 view 的 center 和 bounds 。可以通过 `setNeedsLayout()` 方法去触发此步骤，但此方法不会立即触发布局过程。想要立即更新布局，可以调用 `layoutIfNeeded()` 方法。自定义的 view 可以重写 `layoutSubviews()` 方法获得更多自定义效果。该方法会被 `layoutIfNeeded()` 方法自动触发，不要手动直接调用。\n3. 显示，此过程将 view 渲染到屏幕，此过程与是否使用 AutoLayout 无关，自上而下（父视图到子视图），通过调用 `setNeedsDisplay()` 方法触发。\n\n以上三个过程不是单向的。如果在 layout 的过程中改变了 constraints，那么 update constraints 过程又会被再次触发。如果 `layoutSubview()` 方法中唤起了另外的布局过程，那么有陷入死循环的风险。\n\n死循环举例：\n\n```swift\nclass myView: UIView {\n    override func layoutSubviews() {\n        print(\"layoutSubviews\")\n        self.constraints.first?.constant += 5 //修改约束，会再次唤醒更新约束过程；之后又会唤起布局过程，无限循环\n    }\n}\n\nclass ViewController: UIViewController {\n    let myview = myView() \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        view.addSubview(myview)\n        myview.translatesAutoresizingMaskIntoConstraints = false\n        myview.backgroundColor = UIColor.red\n            }   \n    override func viewDidAppear(_ animated: Bool) {\n        myview.addConstraint(NSLayoutConstraint(item: myview, attribute: NSLayoutAttribute.width, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: .notAnAttribute, multiplier: 0.0, constant: 10))\n        myview.addConstraint(NSLayoutConstraint(item: myview, attribute: NSLayoutAttribute.height, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: .notAnAttribute, multiplier: 0.0, constant: 10))\n        view.addConstraint(NSLayoutConstraint(item: myview, attribute: NSLayoutAttribute.centerX, relatedBy: NSLayoutRelation.equal, toItem: self.view, attribute: .centerX, multiplier: 1.0, constant: 0))\n        view.addConstraint(NSLayoutConstraint(item: myview, attribute: NSLayoutAttribute.centerY, relatedBy: NSLayoutRelation.equal, toItem: self.view, attribute: .centerY, multiplier: 1.0, constant: 0))\n        view.layoutIfNeeded()\n    }\n}\n```\n\n#### Content Hugging Priority & Content Compression Resistance Priority 控件的两个优先级参数\n\n像 ImageView，Label，Button 这样的控件可以根据内容计算出大小。比如 Label 中的文字越多，Label 也就越长。这个大小被称为固有值。如果设置了约束，比如设置 label 的左边距屏幕边界100，右边距边界100，则 label 可能会被拉长。\n\nContent Hugging Priority 表示控件抗拉伸的优先级。数字越大，控件越不容易被拉伸。默认值是251。\n\nContent Compression Resistance Priority 表示控件抗压缩的优先级。数字越大越不容易被压缩。默认值是750。\n\n![](https://ooo.0o0.ooo/2017/04/22/58fae76214f9d.png)\n\n这里两边的约束都是100，label 本应该被拉长以满足约束的要求。如果把右边的约束优先级修改为10，左边优先级不变，为默认的1000，Content Hugging Priority 为默认的251，高于10。所以优先满足左边的约束和 label 的固有大小，因此右边的约束无效了。\n\n#### Frame & Alignment Rect 两个不同的矩形\n\n自动布局参照的是 Alignment Rectangle 而不是 Frame。比如一个控件的阴影并不会影响到自动布局。应该牢记在自动布局中，Frame 没有视觉大小重要。\n\n![](https://ooo.0o0.ooo/2017/04/24/58fdfed66497a.png)\n\n#### AutoLayout Constraints 自动布局的约束\n\n视图的布局体系由一系列线性方程所确定，每个约束都可看作是一个方程的表示。\n\n![](https://ooo.0o0.ooo/2017/04/23/58fc7e1582b9f.png)\n\n多数的约束都由两项组成，但是当你设置一个视图的长度、宽度为一个常数时，第二个属性（attribute）会被设为`Not An Attribute`，比例系数会变成0.0。\n\n#### Cassowary 布局算法\n\nCassowary 是上世纪 90 年代的一个布局算法，它通过将布局问题抽象成线形等式和不等式约束，求解这个多元方程组来算出 x，y，width 和 height。AutoLayout 就是对 Cassowary 的一个实现。\n\n![](https://ooo.0o0.ooo/2017/04/24/58fe029e44f4d.png)\n\n#### AutoLayout Performance 自动布局的性能\n\nAutoLayout 的性能瓶颈就是 Cassowary 求解多个方程组的效率问题。因此有人建议在 TableView 中不要用 AutoLayout 设置动态高度的 Cell，而是自己手动计算。\n\n![](https://ooo.0o0.ooo/2017/04/24/58fe058303e42.png)\n\n网上有人对 AutoLayout 和 Frame 做了性能对比测试，可见当 view 很多时，AutoLayout 的速度会慢很多。\n\n#### Masonry & SnapKit 自动布局库\n\n一个简单易用的 AutoLayout 库，可以告别系统自带 api 冗长的代码。Masonry is for Obj-C, SnapKit is for Swift.\n\nGitHub地址：<https://github.com/SnapKit>\n\n#### ComponentKit and its layout 视图框架\n\nComponentKit 是 FaceBook 开源的响应式视图框架，不支持 Swift。\n\nGitHub地址：<https://github.com/facebook/componentkit>\n\n#### Constraints Priority 约束优先级\n\n每个约束都有优先级（Priority），范围从1～1000。优先级为1000的约束为必须的（required），其余的为可选的（optional）优先级的绝对大小没有意义，重要的是相对大小。Auto-Layout 会优先满足优先级高的约束。如果一个可选的约束不能被满足，Auto-Layout 会跳过它转而计算下一个约束。\n\n即使可选的约束可能会不被满足，但它依然对布局有影响。系统会选择最接近这个约束的解决方案，不被满足的约束可以看作是一股将视图拉向它的力。\n\n可选的约束经常和不等式配合工作：\n\n```swift\n// A single equal relationship\n\nBlue.leading = 1.0 * Red.trailing + 8.0\n\n// Can be replaced with two inequality relationships\n\nBlue.leading >= 1.0 * Red.trailing + 8.0\n\nBlue.leading <= 1.0 * Red.trailing + 8.0\n```\n\n你可以对上面的两个不等式设置不同的优先级。大于等于不等式的优先级可以设为必须的（1000），小于等于可以设置得低一些（250）。这意味着蓝色的视图与红色视图的距离不能小于8，但是其他的约束可能把它拉得更远。当时可选的约束会把蓝色视图拉向红色视图，保证它尽可能地逼近 8 个点的距离。\n\n#### AutoLayout with hidden UIViews layouts 隐藏的视图的自动布局\n\n如果一个 view 被隐藏了，只是试图上看不到了，但是其他的视图距它的约束没有变。如果想让其他的视图跟着变化，可能要修改约束的值，或移除约束，这样代码会过于繁琐。\n\n如下图，如果我们隐藏第一个 Button，第二个 Button 的位置不会改变。而很多情况下我们希望让第二个 Button 位置往左平移，就像第一个按钮真的不存在一样。\n\n![](https://ooo.0o0.ooo/2017/04/24/58fe1cd895059.png)\n\n![](https://ooo.0o0.ooo/2017/04/24/58fe1cd897b3d.png)\n\n#### Variable row heights (iOS7 & iOS8) 变化的行高\n\niOS7 和 iOS8 下代理方法调用顺序不同。iOS7 先调用 heightForRowAtIndexPath 方法，后调用 cellForRowAtIndexPath 方法；而 iOS8 与之相反。\n\n#### AutoLayout in UITableView for dynamic cell 表格视图中动态的 Cell\n\nTableViewCell可以自适应高度，但这个功能不是默认实现的。只有当以下的两个属性被设置后，系统才会使用AutoLayout计算每行的实际高度。\n\n```swift\ntableView.estimatedRowHeight = 85.0\n\ntableView.rowHeight = UITableViewAutomaticDimension\n```\n\n注意：你不能改变预先定义好的部分的布局，如 textLabel , detailTextLabel, imageView。\n\n------\n\n### Questions & Answers\n\n#### Pros and cons of AutoLayout & Frame Layout 不同布局方式的优缺点分析\n\nUI 布局有以下三种主要方法：\n\n1. Frame layout：直接用代码设置每个控件的 Frame。\n2. 使用 auto-resizing masks：可以自动调整子视图与父视图之间的位置关系。\n3. 使用 auto-layout。\n\n使用 frame layout 最直接，最灵活。当需要发生变化的时候，所有的改变都有你自己来控制。它带来的问题就是过于繁杂。即使一个很简单的界面，为了适配各种可能的情况，都要花费大量的精力去设计、调试、维持。Frame 的性能高。\n\n使用 auto-resizing masks 可以部分地解决上述问题。但它只是完整的解决方案中的一个子集，无法适应所有可能的情况。而且它只能应对来自外部的改变，如 macOS 中用户调整了窗口大小、iOS中的横屏和分屏。而内部的改变如本地化、app 展示的内容改变这类的问题无法解决。\n\n使用 auto-layout 可以动态地解决内部改变和外部改变。它不直接设置控件的大小和位置，而是通过约束去考虑控件之间的相对关系。功能强大，但可能有点抽象，跟传统的方法不太一致。 AutoLayout 性能低，而且代码冗长蹩脚。\n\n#### How to get real frame after AutoLayout 自动布局之后怎样获得控件真实的 Frame\n\n在 `layoutSubviews()` 中对子视图设置约束，首次获取的 frame 不会是自动布局后真实的尺寸，而是一开始默认的值。也就是说在 `layoutSubviews()` 方法中获取 frame 时，布局还没有完成：\n\n```swift\nclass myView: UIView {\n    var mysubview = UIView()\n    override func layoutSubviews() {\n        print(\"layoutSubviews\")\n        self.addSubview(mysubview)\n        mysubview.translatesAutoresizingMaskIntoConstraints = false\n        mysubview.backgroundColor = UIColor.green\n        mysubview.addConstraint(NSLayoutConstraint(item: mysubview, attribute: NSLayoutAttribute.width, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: NSLayoutAttribute.notAnAttribute, multiplier: 0.0, constant: 20))\n        mysubview.addConstraint(NSLayoutConstraint(item: mysubview, attribute: NSLayoutAttribute.height, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: NSLayoutAttribute.notAnAttribute, multiplier: 0.0, constant: 20))\n        self.addConstraint(NSLayoutConstraint(item: mysubview, attribute: NSLayoutAttribute.centerX, relatedBy: NSLayoutRelation.equal, toItem: self, attribute: NSLayoutAttribute.centerX, multiplier: 1, constant: 0.0))\n        self.addConstraint(NSLayoutConstraint(item: mysubview, attribute: NSLayoutAttribute.centerY, relatedBy: NSLayoutRelation.equal, toItem: self, attribute: NSLayoutAttribute.centerY, multiplier: 1, constant: 0.0))\n        print(mysubview.frame.height)\n        print(mysubview.frame.width)\n    }\n}\n```\n\n但是这个方法实际上是多次调用的，在最后一次调用时 frame 就是真实的了。\n\n在 ViewController 中，假设约束是在 viewDidLoad 中设置的，若在 viewDidLoad 中获取 frame，那么 frame 不是真实的。在 viewDidAppear 中获取 frame，是真实的。但是在 `viewDidLayoutSubviews()` 中获取，仍然不是真实的，这是因为此时 **AutoLayout** 还没有完成。需要在前面加一句 `view.layoutIfNeeded()` ，再获取就是真实的了。\n\n#### Using AutoLayout to create equal width spacing 使用自动布局构建等间距效果\n\n最简单的方法（无需添加约束）就是在 Interface Builder 中创建一个 StackView，并设置它的 spacing 参数。\n\n![](https://ooo.0o0.ooo/2017/04/22/58fb29843456d.png)\n\n也可以添加约束来实现，设置约束值相同就可以了。当然也可以在代码中设置约束大小相同。\n\n#### Some reasons for application crash when updating the constraints after removing the views which has some mutual constraints relationship 移除具有共同约束关系的控件后更新约束导致的应用崩溃的一些原因\n\n暂时没有发现应用崩溃。移除约束依赖的视图后，相应的约束也自动被移除了，而使用默认的 Frame 值在屏幕上绘制。","source":"_posts/iOS-布局与自动布局.md","raw":"---\ntitle: iOS 布局与自动布局\ndate: 2017-04-25 11:36:55\ntags: AutoLayout\n---\n\n# iOS 布局与自动布局\n\n关于AutoLayout的苹果[官方教程](https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1)\n\n### Key Points\n\n#### Layout Process 布局过程\n\n参见 [Core Layout Runtime](https://developer.apple.com/library/content/releasenotes/UserExperience/RNAutomaticLayout/index.html#//apple_ref/doc/uid/TP40010631-CH1-SW14)\n\n相比于 Frame 布局，Cocoa Auto Layout 除去显示（display）以外，还在之前增加了两个更多的过程：`updateConstraintsIfNeeded` 和 `layoutIfNeeded` 。这些过程按顺序进行：更新约束、布局、显示。如果你手动唤起显示，那么显示会唤起布局，布局会唤起更新约束（显示依赖布局，布局依赖约束）。\n\n你可以认为更新约束的传递就像是测量的传递。例如，如果你改变了一个按钮的标题，那么文字会被测量，并且约束会被设置以向布局系统通知信息。\n\n详细过程：\n\n1. 更新约束，被称为测量阶段。这个过程自下而上（从子视图到父视图），为下一步的布局做准备。可以调用 `setNeedsUpdateConstraints()` 去触发此步骤，约束发生改变时亦会自动触发。但是当自定义 view 的时候，如果一些改变会影响布局，需要用 `updateConstraintsIfNeeded()` 手动通知AutoLayout。自定义 view 通常需要重写 `updateConstraints` 方法，在其中添加 view 需要的局部约束。SnapKit 的示例代码中，约束就是在这个方法中添加的。注意⚠️：`updateConstraints()`  方法不应该手动直接调用。\n2. 布局，自上而下（从父视图到子视图）。应用上一步的信息去设置 view 的 center 和 bounds 。可以通过 `setNeedsLayout()` 方法去触发此步骤，但此方法不会立即触发布局过程。想要立即更新布局，可以调用 `layoutIfNeeded()` 方法。自定义的 view 可以重写 `layoutSubviews()` 方法获得更多自定义效果。该方法会被 `layoutIfNeeded()` 方法自动触发，不要手动直接调用。\n3. 显示，此过程将 view 渲染到屏幕，此过程与是否使用 AutoLayout 无关，自上而下（父视图到子视图），通过调用 `setNeedsDisplay()` 方法触发。\n\n以上三个过程不是单向的。如果在 layout 的过程中改变了 constraints，那么 update constraints 过程又会被再次触发。如果 `layoutSubview()` 方法中唤起了另外的布局过程，那么有陷入死循环的风险。\n\n死循环举例：\n\n```swift\nclass myView: UIView {\n    override func layoutSubviews() {\n        print(\"layoutSubviews\")\n        self.constraints.first?.constant += 5 //修改约束，会再次唤醒更新约束过程；之后又会唤起布局过程，无限循环\n    }\n}\n\nclass ViewController: UIViewController {\n    let myview = myView() \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        view.addSubview(myview)\n        myview.translatesAutoresizingMaskIntoConstraints = false\n        myview.backgroundColor = UIColor.red\n            }   \n    override func viewDidAppear(_ animated: Bool) {\n        myview.addConstraint(NSLayoutConstraint(item: myview, attribute: NSLayoutAttribute.width, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: .notAnAttribute, multiplier: 0.0, constant: 10))\n        myview.addConstraint(NSLayoutConstraint(item: myview, attribute: NSLayoutAttribute.height, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: .notAnAttribute, multiplier: 0.0, constant: 10))\n        view.addConstraint(NSLayoutConstraint(item: myview, attribute: NSLayoutAttribute.centerX, relatedBy: NSLayoutRelation.equal, toItem: self.view, attribute: .centerX, multiplier: 1.0, constant: 0))\n        view.addConstraint(NSLayoutConstraint(item: myview, attribute: NSLayoutAttribute.centerY, relatedBy: NSLayoutRelation.equal, toItem: self.view, attribute: .centerY, multiplier: 1.0, constant: 0))\n        view.layoutIfNeeded()\n    }\n}\n```\n\n#### Content Hugging Priority & Content Compression Resistance Priority 控件的两个优先级参数\n\n像 ImageView，Label，Button 这样的控件可以根据内容计算出大小。比如 Label 中的文字越多，Label 也就越长。这个大小被称为固有值。如果设置了约束，比如设置 label 的左边距屏幕边界100，右边距边界100，则 label 可能会被拉长。\n\nContent Hugging Priority 表示控件抗拉伸的优先级。数字越大，控件越不容易被拉伸。默认值是251。\n\nContent Compression Resistance Priority 表示控件抗压缩的优先级。数字越大越不容易被压缩。默认值是750。\n\n![](https://ooo.0o0.ooo/2017/04/22/58fae76214f9d.png)\n\n这里两边的约束都是100，label 本应该被拉长以满足约束的要求。如果把右边的约束优先级修改为10，左边优先级不变，为默认的1000，Content Hugging Priority 为默认的251，高于10。所以优先满足左边的约束和 label 的固有大小，因此右边的约束无效了。\n\n#### Frame & Alignment Rect 两个不同的矩形\n\n自动布局参照的是 Alignment Rectangle 而不是 Frame。比如一个控件的阴影并不会影响到自动布局。应该牢记在自动布局中，Frame 没有视觉大小重要。\n\n![](https://ooo.0o0.ooo/2017/04/24/58fdfed66497a.png)\n\n#### AutoLayout Constraints 自动布局的约束\n\n视图的布局体系由一系列线性方程所确定，每个约束都可看作是一个方程的表示。\n\n![](https://ooo.0o0.ooo/2017/04/23/58fc7e1582b9f.png)\n\n多数的约束都由两项组成，但是当你设置一个视图的长度、宽度为一个常数时，第二个属性（attribute）会被设为`Not An Attribute`，比例系数会变成0.0。\n\n#### Cassowary 布局算法\n\nCassowary 是上世纪 90 年代的一个布局算法，它通过将布局问题抽象成线形等式和不等式约束，求解这个多元方程组来算出 x，y，width 和 height。AutoLayout 就是对 Cassowary 的一个实现。\n\n![](https://ooo.0o0.ooo/2017/04/24/58fe029e44f4d.png)\n\n#### AutoLayout Performance 自动布局的性能\n\nAutoLayout 的性能瓶颈就是 Cassowary 求解多个方程组的效率问题。因此有人建议在 TableView 中不要用 AutoLayout 设置动态高度的 Cell，而是自己手动计算。\n\n![](https://ooo.0o0.ooo/2017/04/24/58fe058303e42.png)\n\n网上有人对 AutoLayout 和 Frame 做了性能对比测试，可见当 view 很多时，AutoLayout 的速度会慢很多。\n\n#### Masonry & SnapKit 自动布局库\n\n一个简单易用的 AutoLayout 库，可以告别系统自带 api 冗长的代码。Masonry is for Obj-C, SnapKit is for Swift.\n\nGitHub地址：<https://github.com/SnapKit>\n\n#### ComponentKit and its layout 视图框架\n\nComponentKit 是 FaceBook 开源的响应式视图框架，不支持 Swift。\n\nGitHub地址：<https://github.com/facebook/componentkit>\n\n#### Constraints Priority 约束优先级\n\n每个约束都有优先级（Priority），范围从1～1000。优先级为1000的约束为必须的（required），其余的为可选的（optional）优先级的绝对大小没有意义，重要的是相对大小。Auto-Layout 会优先满足优先级高的约束。如果一个可选的约束不能被满足，Auto-Layout 会跳过它转而计算下一个约束。\n\n即使可选的约束可能会不被满足，但它依然对布局有影响。系统会选择最接近这个约束的解决方案，不被满足的约束可以看作是一股将视图拉向它的力。\n\n可选的约束经常和不等式配合工作：\n\n```swift\n// A single equal relationship\n\nBlue.leading = 1.0 * Red.trailing + 8.0\n\n// Can be replaced with two inequality relationships\n\nBlue.leading >= 1.0 * Red.trailing + 8.0\n\nBlue.leading <= 1.0 * Red.trailing + 8.0\n```\n\n你可以对上面的两个不等式设置不同的优先级。大于等于不等式的优先级可以设为必须的（1000），小于等于可以设置得低一些（250）。这意味着蓝色的视图与红色视图的距离不能小于8，但是其他的约束可能把它拉得更远。当时可选的约束会把蓝色视图拉向红色视图，保证它尽可能地逼近 8 个点的距离。\n\n#### AutoLayout with hidden UIViews layouts 隐藏的视图的自动布局\n\n如果一个 view 被隐藏了，只是试图上看不到了，但是其他的视图距它的约束没有变。如果想让其他的视图跟着变化，可能要修改约束的值，或移除约束，这样代码会过于繁琐。\n\n如下图，如果我们隐藏第一个 Button，第二个 Button 的位置不会改变。而很多情况下我们希望让第二个 Button 位置往左平移，就像第一个按钮真的不存在一样。\n\n![](https://ooo.0o0.ooo/2017/04/24/58fe1cd895059.png)\n\n![](https://ooo.0o0.ooo/2017/04/24/58fe1cd897b3d.png)\n\n#### Variable row heights (iOS7 & iOS8) 变化的行高\n\niOS7 和 iOS8 下代理方法调用顺序不同。iOS7 先调用 heightForRowAtIndexPath 方法，后调用 cellForRowAtIndexPath 方法；而 iOS8 与之相反。\n\n#### AutoLayout in UITableView for dynamic cell 表格视图中动态的 Cell\n\nTableViewCell可以自适应高度，但这个功能不是默认实现的。只有当以下的两个属性被设置后，系统才会使用AutoLayout计算每行的实际高度。\n\n```swift\ntableView.estimatedRowHeight = 85.0\n\ntableView.rowHeight = UITableViewAutomaticDimension\n```\n\n注意：你不能改变预先定义好的部分的布局，如 textLabel , detailTextLabel, imageView。\n\n------\n\n### Questions & Answers\n\n#### Pros and cons of AutoLayout & Frame Layout 不同布局方式的优缺点分析\n\nUI 布局有以下三种主要方法：\n\n1. Frame layout：直接用代码设置每个控件的 Frame。\n2. 使用 auto-resizing masks：可以自动调整子视图与父视图之间的位置关系。\n3. 使用 auto-layout。\n\n使用 frame layout 最直接，最灵活。当需要发生变化的时候，所有的改变都有你自己来控制。它带来的问题就是过于繁杂。即使一个很简单的界面，为了适配各种可能的情况，都要花费大量的精力去设计、调试、维持。Frame 的性能高。\n\n使用 auto-resizing masks 可以部分地解决上述问题。但它只是完整的解决方案中的一个子集，无法适应所有可能的情况。而且它只能应对来自外部的改变，如 macOS 中用户调整了窗口大小、iOS中的横屏和分屏。而内部的改变如本地化、app 展示的内容改变这类的问题无法解决。\n\n使用 auto-layout 可以动态地解决内部改变和外部改变。它不直接设置控件的大小和位置，而是通过约束去考虑控件之间的相对关系。功能强大，但可能有点抽象，跟传统的方法不太一致。 AutoLayout 性能低，而且代码冗长蹩脚。\n\n#### How to get real frame after AutoLayout 自动布局之后怎样获得控件真实的 Frame\n\n在 `layoutSubviews()` 中对子视图设置约束，首次获取的 frame 不会是自动布局后真实的尺寸，而是一开始默认的值。也就是说在 `layoutSubviews()` 方法中获取 frame 时，布局还没有完成：\n\n```swift\nclass myView: UIView {\n    var mysubview = UIView()\n    override func layoutSubviews() {\n        print(\"layoutSubviews\")\n        self.addSubview(mysubview)\n        mysubview.translatesAutoresizingMaskIntoConstraints = false\n        mysubview.backgroundColor = UIColor.green\n        mysubview.addConstraint(NSLayoutConstraint(item: mysubview, attribute: NSLayoutAttribute.width, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: NSLayoutAttribute.notAnAttribute, multiplier: 0.0, constant: 20))\n        mysubview.addConstraint(NSLayoutConstraint(item: mysubview, attribute: NSLayoutAttribute.height, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: NSLayoutAttribute.notAnAttribute, multiplier: 0.0, constant: 20))\n        self.addConstraint(NSLayoutConstraint(item: mysubview, attribute: NSLayoutAttribute.centerX, relatedBy: NSLayoutRelation.equal, toItem: self, attribute: NSLayoutAttribute.centerX, multiplier: 1, constant: 0.0))\n        self.addConstraint(NSLayoutConstraint(item: mysubview, attribute: NSLayoutAttribute.centerY, relatedBy: NSLayoutRelation.equal, toItem: self, attribute: NSLayoutAttribute.centerY, multiplier: 1, constant: 0.0))\n        print(mysubview.frame.height)\n        print(mysubview.frame.width)\n    }\n}\n```\n\n但是这个方法实际上是多次调用的，在最后一次调用时 frame 就是真实的了。\n\n在 ViewController 中，假设约束是在 viewDidLoad 中设置的，若在 viewDidLoad 中获取 frame，那么 frame 不是真实的。在 viewDidAppear 中获取 frame，是真实的。但是在 `viewDidLayoutSubviews()` 中获取，仍然不是真实的，这是因为此时 **AutoLayout** 还没有完成。需要在前面加一句 `view.layoutIfNeeded()` ，再获取就是真实的了。\n\n#### Using AutoLayout to create equal width spacing 使用自动布局构建等间距效果\n\n最简单的方法（无需添加约束）就是在 Interface Builder 中创建一个 StackView，并设置它的 spacing 参数。\n\n![](https://ooo.0o0.ooo/2017/04/22/58fb29843456d.png)\n\n也可以添加约束来实现，设置约束值相同就可以了。当然也可以在代码中设置约束大小相同。\n\n#### Some reasons for application crash when updating the constraints after removing the views which has some mutual constraints relationship 移除具有共同约束关系的控件后更新约束导致的应用崩溃的一些原因\n\n暂时没有发现应用崩溃。移除约束依赖的视图后，相应的约束也自动被移除了，而使用默认的 Frame 值在屏幕上绘制。","slug":"iOS-布局与自动布局","published":1,"updated":"2020-01-04T08:16:16.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv40003aljc3lf4jzap3","content":"<h1 id=\"iOS-布局与自动布局\"><a href=\"#iOS-布局与自动布局\" class=\"headerlink\" title=\"iOS 布局与自动布局\"></a>iOS 布局与自动布局</h1><p>关于AutoLayout的苹果<a href=\"https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1\">官方教程</a></p>\n<h3 id=\"Key-Points\"><a href=\"#Key-Points\" class=\"headerlink\" title=\"Key Points\"></a>Key Points</h3><h4 id=\"Layout-Process-布局过程\"><a href=\"#Layout-Process-布局过程\" class=\"headerlink\" title=\"Layout Process 布局过程\"></a>Layout Process 布局过程</h4><p>参见 <a href=\"https://developer.apple.com/library/content/releasenotes/UserExperience/RNAutomaticLayout/index.html#//apple_ref/doc/uid/TP40010631-CH1-SW14\">Core Layout Runtime</a></p>\n<p>相比于 Frame 布局，Cocoa Auto Layout 除去显示（display）以外，还在之前增加了两个更多的过程：<code>updateConstraintsIfNeeded</code> 和 <code>layoutIfNeeded</code> 。这些过程按顺序进行：更新约束、布局、显示。如果你手动唤起显示，那么显示会唤起布局，布局会唤起更新约束（显示依赖布局，布局依赖约束）。</p>\n<p>你可以认为更新约束的传递就像是测量的传递。例如，如果你改变了一个按钮的标题，那么文字会被测量，并且约束会被设置以向布局系统通知信息。</p>\n<p>详细过程：</p>\n<ol>\n<li>更新约束，被称为测量阶段。这个过程自下而上（从子视图到父视图），为下一步的布局做准备。可以调用 <code>setNeedsUpdateConstraints()</code> 去触发此步骤，约束发生改变时亦会自动触发。但是当自定义 view 的时候，如果一些改变会影响布局，需要用 <code>updateConstraintsIfNeeded()</code> 手动通知AutoLayout。自定义 view 通常需要重写 <code>updateConstraints</code> 方法，在其中添加 view 需要的局部约束。SnapKit 的示例代码中，约束就是在这个方法中添加的。注意⚠️：<code>updateConstraints()</code>  方法不应该手动直接调用。</li>\n<li>布局，自上而下（从父视图到子视图）。应用上一步的信息去设置 view 的 center 和 bounds 。可以通过 <code>setNeedsLayout()</code> 方法去触发此步骤，但此方法不会立即触发布局过程。想要立即更新布局，可以调用 <code>layoutIfNeeded()</code> 方法。自定义的 view 可以重写 <code>layoutSubviews()</code> 方法获得更多自定义效果。该方法会被 <code>layoutIfNeeded()</code> 方法自动触发，不要手动直接调用。</li>\n<li>显示，此过程将 view 渲染到屏幕，此过程与是否使用 AutoLayout 无关，自上而下（父视图到子视图），通过调用 <code>setNeedsDisplay()</code> 方法触发。</li>\n</ol>\n<p>以上三个过程不是单向的。如果在 layout 的过程中改变了 constraints，那么 update constraints 过程又会被再次触发。如果 <code>layoutSubview()</code> 方法中唤起了另外的布局过程，那么有陷入死循环的风险。</p>\n<p>死循环举例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myView</span>: <span class=\"title\">UIView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layoutSubviews</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"layoutSubviews\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.constraints.first?.constant += <span class=\"number\">5</span> <span class=\"comment\">//修改约束，会再次唤醒更新约束过程；之后又会唤起布局过程，无限循环</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> myview = myView() </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        view.addSubview(myview)</span><br><span class=\"line\">        myview.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">false</span></span><br><span class=\"line\">        myview.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidAppear</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> &#123;</span><br><span class=\"line\">        myview.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: myview, attribute: <span class=\"type\">NSLayoutAttribute</span>.width, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"literal\">nil</span>, attribute: .notAnAttribute, multiplier: <span class=\"number\">0.0</span>, constant: <span class=\"number\">10</span>))</span><br><span class=\"line\">        myview.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: myview, attribute: <span class=\"type\">NSLayoutAttribute</span>.height, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"literal\">nil</span>, attribute: .notAnAttribute, multiplier: <span class=\"number\">0.0</span>, constant: <span class=\"number\">10</span>))</span><br><span class=\"line\">        view.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: myview, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerX, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"keyword\">self</span>.view, attribute: .centerX, multiplier: <span class=\"number\">1.0</span>, constant: <span class=\"number\">0</span>))</span><br><span class=\"line\">        view.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: myview, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerY, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"keyword\">self</span>.view, attribute: .centerY, multiplier: <span class=\"number\">1.0</span>, constant: <span class=\"number\">0</span>))</span><br><span class=\"line\">        view.layoutIfNeeded()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Content-Hugging-Priority-amp-Content-Compression-Resistance-Priority-控件的两个优先级参数\"><a href=\"#Content-Hugging-Priority-amp-Content-Compression-Resistance-Priority-控件的两个优先级参数\" class=\"headerlink\" title=\"Content Hugging Priority &amp; Content Compression Resistance Priority 控件的两个优先级参数\"></a>Content Hugging Priority &amp; Content Compression Resistance Priority 控件的两个优先级参数</h4><p>像 ImageView，Label，Button 这样的控件可以根据内容计算出大小。比如 Label 中的文字越多，Label 也就越长。这个大小被称为固有值。如果设置了约束，比如设置 label 的左边距屏幕边界100，右边距边界100，则 label 可能会被拉长。</p>\n<p>Content Hugging Priority 表示控件抗拉伸的优先级。数字越大，控件越不容易被拉伸。默认值是251。</p>\n<p>Content Compression Resistance Priority 表示控件抗压缩的优先级。数字越大越不容易被压缩。默认值是750。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/22/58fae76214f9d.png\" alt=\"\"></p>\n<p>这里两边的约束都是100，label 本应该被拉长以满足约束的要求。如果把右边的约束优先级修改为10，左边优先级不变，为默认的1000，Content Hugging Priority 为默认的251，高于10。所以优先满足左边的约束和 label 的固有大小，因此右边的约束无效了。</p>\n<h4 id=\"Frame-amp-Alignment-Rect-两个不同的矩形\"><a href=\"#Frame-amp-Alignment-Rect-两个不同的矩形\" class=\"headerlink\" title=\"Frame &amp; Alignment Rect 两个不同的矩形\"></a>Frame &amp; Alignment Rect 两个不同的矩形</h4><p>自动布局参照的是 Alignment Rectangle 而不是 Frame。比如一个控件的阴影并不会影响到自动布局。应该牢记在自动布局中，Frame 没有视觉大小重要。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/24/58fdfed66497a.png\" alt=\"\"></p>\n<h4 id=\"AutoLayout-Constraints-自动布局的约束\"><a href=\"#AutoLayout-Constraints-自动布局的约束\" class=\"headerlink\" title=\"AutoLayout Constraints 自动布局的约束\"></a>AutoLayout Constraints 自动布局的约束</h4><p>视图的布局体系由一系列线性方程所确定，每个约束都可看作是一个方程的表示。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/23/58fc7e1582b9f.png\" alt=\"\"></p>\n<p>多数的约束都由两项组成，但是当你设置一个视图的长度、宽度为一个常数时，第二个属性（attribute）会被设为<code>Not An Attribute</code>，比例系数会变成0.0。</p>\n<h4 id=\"Cassowary-布局算法\"><a href=\"#Cassowary-布局算法\" class=\"headerlink\" title=\"Cassowary 布局算法\"></a>Cassowary 布局算法</h4><p>Cassowary 是上世纪 90 年代的一个布局算法，它通过将布局问题抽象成线形等式和不等式约束，求解这个多元方程组来算出 x，y，width 和 height。AutoLayout 就是对 Cassowary 的一个实现。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/24/58fe029e44f4d.png\" alt=\"\"></p>\n<h4 id=\"AutoLayout-Performance-自动布局的性能\"><a href=\"#AutoLayout-Performance-自动布局的性能\" class=\"headerlink\" title=\"AutoLayout Performance 自动布局的性能\"></a>AutoLayout Performance 自动布局的性能</h4><p>AutoLayout 的性能瓶颈就是 Cassowary 求解多个方程组的效率问题。因此有人建议在 TableView 中不要用 AutoLayout 设置动态高度的 Cell，而是自己手动计算。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/24/58fe058303e42.png\" alt=\"\"></p>\n<p>网上有人对 AutoLayout 和 Frame 做了性能对比测试，可见当 view 很多时，AutoLayout 的速度会慢很多。</p>\n<h4 id=\"Masonry-amp-SnapKit-自动布局库\"><a href=\"#Masonry-amp-SnapKit-自动布局库\" class=\"headerlink\" title=\"Masonry &amp; SnapKit 自动布局库\"></a>Masonry &amp; SnapKit 自动布局库</h4><p>一个简单易用的 AutoLayout 库，可以告别系统自带 api 冗长的代码。Masonry is for Obj-C, SnapKit is for Swift.</p>\n<p>GitHub地址：<a href=\"https://github.com/SnapKit\">https://github.com/SnapKit</a></p>\n<h4 id=\"ComponentKit-and-its-layout-视图框架\"><a href=\"#ComponentKit-and-its-layout-视图框架\" class=\"headerlink\" title=\"ComponentKit and its layout 视图框架\"></a>ComponentKit and its layout 视图框架</h4><p>ComponentKit 是 FaceBook 开源的响应式视图框架，不支持 Swift。</p>\n<p>GitHub地址：<a href=\"https://github.com/facebook/componentkit\">https://github.com/facebook/componentkit</a></p>\n<h4 id=\"Constraints-Priority-约束优先级\"><a href=\"#Constraints-Priority-约束优先级\" class=\"headerlink\" title=\"Constraints Priority 约束优先级\"></a>Constraints Priority 约束优先级</h4><p>每个约束都有优先级（Priority），范围从1～1000。优先级为1000的约束为必须的（required），其余的为可选的（optional）优先级的绝对大小没有意义，重要的是相对大小。Auto-Layout 会优先满足优先级高的约束。如果一个可选的约束不能被满足，Auto-Layout 会跳过它转而计算下一个约束。</p>\n<p>即使可选的约束可能会不被满足，但它依然对布局有影响。系统会选择最接近这个约束的解决方案，不被满足的约束可以看作是一股将视图拉向它的力。</p>\n<p>可选的约束经常和不等式配合工作：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A single equal relationship</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Blue</span>.leading = <span class=\"number\">1.0</span> * <span class=\"type\">Red</span>.trailing + <span class=\"number\">8.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Can be replaced with two inequality relationships</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Blue</span>.leading &gt;= <span class=\"number\">1.0</span> * <span class=\"type\">Red</span>.trailing + <span class=\"number\">8.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Blue</span>.leading &lt;= <span class=\"number\">1.0</span> * <span class=\"type\">Red</span>.trailing + <span class=\"number\">8.0</span></span><br></pre></td></tr></table></figure>\n<p>你可以对上面的两个不等式设置不同的优先级。大于等于不等式的优先级可以设为必须的（1000），小于等于可以设置得低一些（250）。这意味着蓝色的视图与红色视图的距离不能小于8，但是其他的约束可能把它拉得更远。当时可选的约束会把蓝色视图拉向红色视图，保证它尽可能地逼近 8 个点的距离。</p>\n<h4 id=\"AutoLayout-with-hidden-UIViews-layouts-隐藏的视图的自动布局\"><a href=\"#AutoLayout-with-hidden-UIViews-layouts-隐藏的视图的自动布局\" class=\"headerlink\" title=\"AutoLayout with hidden UIViews layouts 隐藏的视图的自动布局\"></a>AutoLayout with hidden UIViews layouts 隐藏的视图的自动布局</h4><p>如果一个 view 被隐藏了，只是试图上看不到了，但是其他的视图距它的约束没有变。如果想让其他的视图跟着变化，可能要修改约束的值，或移除约束，这样代码会过于繁琐。</p>\n<p>如下图，如果我们隐藏第一个 Button，第二个 Button 的位置不会改变。而很多情况下我们希望让第二个 Button 位置往左平移，就像第一个按钮真的不存在一样。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/24/58fe1cd895059.png\" alt=\"\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/24/58fe1cd897b3d.png\" alt=\"\"></p>\n<h4 id=\"Variable-row-heights-iOS7-amp-iOS8-变化的行高\"><a href=\"#Variable-row-heights-iOS7-amp-iOS8-变化的行高\" class=\"headerlink\" title=\"Variable row heights (iOS7 &amp; iOS8) 变化的行高\"></a>Variable row heights (iOS7 &amp; iOS8) 变化的行高</h4><p>iOS7 和 iOS8 下代理方法调用顺序不同。iOS7 先调用 heightForRowAtIndexPath 方法，后调用 cellForRowAtIndexPath 方法；而 iOS8 与之相反。</p>\n<h4 id=\"AutoLayout-in-UITableView-for-dynamic-cell-表格视图中动态的-Cell\"><a href=\"#AutoLayout-in-UITableView-for-dynamic-cell-表格视图中动态的-Cell\" class=\"headerlink\" title=\"AutoLayout in UITableView for dynamic cell 表格视图中动态的 Cell\"></a>AutoLayout in UITableView for dynamic cell 表格视图中动态的 Cell</h4><p>TableViewCell可以自适应高度，但这个功能不是默认实现的。只有当以下的两个属性被设置后，系统才会使用AutoLayout计算每行的实际高度。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tableView.estimatedRowHeight = <span class=\"number\">85.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">tableView.rowHeight = <span class=\"type\">UITableViewAutomaticDimension</span></span><br></pre></td></tr></table></figure>\n<p>注意：你不能改变预先定义好的部分的布局，如 textLabel , detailTextLabel, imageView。</p>\n<hr>\n<h3 id=\"Questions-amp-Answers\"><a href=\"#Questions-amp-Answers\" class=\"headerlink\" title=\"Questions &amp; Answers\"></a>Questions &amp; Answers</h3><h4 id=\"Pros-and-cons-of-AutoLayout-amp-Frame-Layout-不同布局方式的优缺点分析\"><a href=\"#Pros-and-cons-of-AutoLayout-amp-Frame-Layout-不同布局方式的优缺点分析\" class=\"headerlink\" title=\"Pros and cons of AutoLayout &amp; Frame Layout 不同布局方式的优缺点分析\"></a>Pros and cons of AutoLayout &amp; Frame Layout 不同布局方式的优缺点分析</h4><p>UI 布局有以下三种主要方法：</p>\n<ol>\n<li>Frame layout：直接用代码设置每个控件的 Frame。</li>\n<li>使用 auto-resizing masks：可以自动调整子视图与父视图之间的位置关系。</li>\n<li>使用 auto-layout。</li>\n</ol>\n<p>使用 frame layout 最直接，最灵活。当需要发生变化的时候，所有的改变都有你自己来控制。它带来的问题就是过于繁杂。即使一个很简单的界面，为了适配各种可能的情况，都要花费大量的精力去设计、调试、维持。Frame 的性能高。</p>\n<p>使用 auto-resizing masks 可以部分地解决上述问题。但它只是完整的解决方案中的一个子集，无法适应所有可能的情况。而且它只能应对来自外部的改变，如 macOS 中用户调整了窗口大小、iOS中的横屏和分屏。而内部的改变如本地化、app 展示的内容改变这类的问题无法解决。</p>\n<p>使用 auto-layout 可以动态地解决内部改变和外部改变。它不直接设置控件的大小和位置，而是通过约束去考虑控件之间的相对关系。功能强大，但可能有点抽象，跟传统的方法不太一致。 AutoLayout 性能低，而且代码冗长蹩脚。</p>\n<h4 id=\"How-to-get-real-frame-after-AutoLayout-自动布局之后怎样获得控件真实的-Frame\"><a href=\"#How-to-get-real-frame-after-AutoLayout-自动布局之后怎样获得控件真实的-Frame\" class=\"headerlink\" title=\"How to get real frame after AutoLayout 自动布局之后怎样获得控件真实的 Frame\"></a>How to get real frame after AutoLayout 自动布局之后怎样获得控件真实的 Frame</h4><p>在 <code>layoutSubviews()</code> 中对子视图设置约束，首次获取的 frame 不会是自动布局后真实的尺寸，而是一开始默认的值。也就是说在 <code>layoutSubviews()</code> 方法中获取 frame 时，布局还没有完成：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myView</span>: <span class=\"title\">UIView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mysubview = <span class=\"type\">UIView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layoutSubviews</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"layoutSubviews\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.addSubview(mysubview)</span><br><span class=\"line\">        mysubview.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">false</span></span><br><span class=\"line\">        mysubview.backgroundColor = <span class=\"type\">UIColor</span>.green</span><br><span class=\"line\">        mysubview.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: mysubview, attribute: <span class=\"type\">NSLayoutAttribute</span>.width, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"literal\">nil</span>, attribute: <span class=\"type\">NSLayoutAttribute</span>.notAnAttribute, multiplier: <span class=\"number\">0.0</span>, constant: <span class=\"number\">20</span>))</span><br><span class=\"line\">        mysubview.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: mysubview, attribute: <span class=\"type\">NSLayoutAttribute</span>.height, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"literal\">nil</span>, attribute: <span class=\"type\">NSLayoutAttribute</span>.notAnAttribute, multiplier: <span class=\"number\">0.0</span>, constant: <span class=\"number\">20</span>))</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: mysubview, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerX, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"keyword\">self</span>, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerX, multiplier: <span class=\"number\">1</span>, constant: <span class=\"number\">0.0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: mysubview, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerY, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"keyword\">self</span>, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerY, multiplier: <span class=\"number\">1</span>, constant: <span class=\"number\">0.0</span>))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(mysubview.frame.height)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(mysubview.frame.width)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这个方法实际上是多次调用的，在最后一次调用时 frame 就是真实的了。</p>\n<p>在 ViewController 中，假设约束是在 viewDidLoad 中设置的，若在 viewDidLoad 中获取 frame，那么 frame 不是真实的。在 viewDidAppear 中获取 frame，是真实的。但是在 <code>viewDidLayoutSubviews()</code> 中获取，仍然不是真实的，这是因为此时 <strong>AutoLayout</strong> 还没有完成。需要在前面加一句 <code>view.layoutIfNeeded()</code> ，再获取就是真实的了。</p>\n<h4 id=\"Using-AutoLayout-to-create-equal-width-spacing-使用自动布局构建等间距效果\"><a href=\"#Using-AutoLayout-to-create-equal-width-spacing-使用自动布局构建等间距效果\" class=\"headerlink\" title=\"Using AutoLayout to create equal width spacing 使用自动布局构建等间距效果\"></a>Using AutoLayout to create equal width spacing 使用自动布局构建等间距效果</h4><p>最简单的方法（无需添加约束）就是在 Interface Builder 中创建一个 StackView，并设置它的 spacing 参数。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/22/58fb29843456d.png\" alt=\"\"></p>\n<p>也可以添加约束来实现，设置约束值相同就可以了。当然也可以在代码中设置约束大小相同。</p>\n<h4 id=\"Some-reasons-for-application-crash-when-updating-the-constraints-after-removing-the-views-which-has-some-mutual-constraints-relationship-移除具有共同约束关系的控件后更新约束导致的应用崩溃的一些原因\"><a href=\"#Some-reasons-for-application-crash-when-updating-the-constraints-after-removing-the-views-which-has-some-mutual-constraints-relationship-移除具有共同约束关系的控件后更新约束导致的应用崩溃的一些原因\" class=\"headerlink\" title=\"Some reasons for application crash when updating the constraints after removing the views which has some mutual constraints relationship 移除具有共同约束关系的控件后更新约束导致的应用崩溃的一些原因\"></a>Some reasons for application crash when updating the constraints after removing the views which has some mutual constraints relationship 移除具有共同约束关系的控件后更新约束导致的应用崩溃的一些原因</h4><p>暂时没有发现应用崩溃。移除约束依赖的视图后，相应的约束也自动被移除了，而使用默认的 Frame 值在屏幕上绘制。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-布局与自动布局\"><a href=\"#iOS-布局与自动布局\" class=\"headerlink\" title=\"iOS 布局与自动布局\"></a>iOS 布局与自动布局</h1><p>关于AutoLayout的苹果<a href=\"https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1\">官方教程</a></p>\n<h3 id=\"Key-Points\"><a href=\"#Key-Points\" class=\"headerlink\" title=\"Key Points\"></a>Key Points</h3><h4 id=\"Layout-Process-布局过程\"><a href=\"#Layout-Process-布局过程\" class=\"headerlink\" title=\"Layout Process 布局过程\"></a>Layout Process 布局过程</h4><p>参见 <a href=\"https://developer.apple.com/library/content/releasenotes/UserExperience/RNAutomaticLayout/index.html#//apple_ref/doc/uid/TP40010631-CH1-SW14\">Core Layout Runtime</a></p>\n<p>相比于 Frame 布局，Cocoa Auto Layout 除去显示（display）以外，还在之前增加了两个更多的过程：<code>updateConstraintsIfNeeded</code> 和 <code>layoutIfNeeded</code> 。这些过程按顺序进行：更新约束、布局、显示。如果你手动唤起显示，那么显示会唤起布局，布局会唤起更新约束（显示依赖布局，布局依赖约束）。</p>\n<p>你可以认为更新约束的传递就像是测量的传递。例如，如果你改变了一个按钮的标题，那么文字会被测量，并且约束会被设置以向布局系统通知信息。</p>\n<p>详细过程：</p>\n<ol>\n<li>更新约束，被称为测量阶段。这个过程自下而上（从子视图到父视图），为下一步的布局做准备。可以调用 <code>setNeedsUpdateConstraints()</code> 去触发此步骤，约束发生改变时亦会自动触发。但是当自定义 view 的时候，如果一些改变会影响布局，需要用 <code>updateConstraintsIfNeeded()</code> 手动通知AutoLayout。自定义 view 通常需要重写 <code>updateConstraints</code> 方法，在其中添加 view 需要的局部约束。SnapKit 的示例代码中，约束就是在这个方法中添加的。注意⚠️：<code>updateConstraints()</code>  方法不应该手动直接调用。</li>\n<li>布局，自上而下（从父视图到子视图）。应用上一步的信息去设置 view 的 center 和 bounds 。可以通过 <code>setNeedsLayout()</code> 方法去触发此步骤，但此方法不会立即触发布局过程。想要立即更新布局，可以调用 <code>layoutIfNeeded()</code> 方法。自定义的 view 可以重写 <code>layoutSubviews()</code> 方法获得更多自定义效果。该方法会被 <code>layoutIfNeeded()</code> 方法自动触发，不要手动直接调用。</li>\n<li>显示，此过程将 view 渲染到屏幕，此过程与是否使用 AutoLayout 无关，自上而下（父视图到子视图），通过调用 <code>setNeedsDisplay()</code> 方法触发。</li>\n</ol>\n<p>以上三个过程不是单向的。如果在 layout 的过程中改变了 constraints，那么 update constraints 过程又会被再次触发。如果 <code>layoutSubview()</code> 方法中唤起了另外的布局过程，那么有陷入死循环的风险。</p>\n<p>死循环举例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myView</span>: <span class=\"title\">UIView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layoutSubviews</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"layoutSubviews\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.constraints.first?.constant += <span class=\"number\">5</span> <span class=\"comment\">//修改约束，会再次唤醒更新约束过程；之后又会唤起布局过程，无限循环</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewController</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> myview = myView() </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        view.addSubview(myview)</span><br><span class=\"line\">        myview.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">false</span></span><br><span class=\"line\">        myview.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidAppear</span><span class=\"params\">(<span class=\"number\">_</span> animated: Bool)</span></span> &#123;</span><br><span class=\"line\">        myview.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: myview, attribute: <span class=\"type\">NSLayoutAttribute</span>.width, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"literal\">nil</span>, attribute: .notAnAttribute, multiplier: <span class=\"number\">0.0</span>, constant: <span class=\"number\">10</span>))</span><br><span class=\"line\">        myview.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: myview, attribute: <span class=\"type\">NSLayoutAttribute</span>.height, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"literal\">nil</span>, attribute: .notAnAttribute, multiplier: <span class=\"number\">0.0</span>, constant: <span class=\"number\">10</span>))</span><br><span class=\"line\">        view.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: myview, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerX, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"keyword\">self</span>.view, attribute: .centerX, multiplier: <span class=\"number\">1.0</span>, constant: <span class=\"number\">0</span>))</span><br><span class=\"line\">        view.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: myview, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerY, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"keyword\">self</span>.view, attribute: .centerY, multiplier: <span class=\"number\">1.0</span>, constant: <span class=\"number\">0</span>))</span><br><span class=\"line\">        view.layoutIfNeeded()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Content-Hugging-Priority-amp-Content-Compression-Resistance-Priority-控件的两个优先级参数\"><a href=\"#Content-Hugging-Priority-amp-Content-Compression-Resistance-Priority-控件的两个优先级参数\" class=\"headerlink\" title=\"Content Hugging Priority &amp; Content Compression Resistance Priority 控件的两个优先级参数\"></a>Content Hugging Priority &amp; Content Compression Resistance Priority 控件的两个优先级参数</h4><p>像 ImageView，Label，Button 这样的控件可以根据内容计算出大小。比如 Label 中的文字越多，Label 也就越长。这个大小被称为固有值。如果设置了约束，比如设置 label 的左边距屏幕边界100，右边距边界100，则 label 可能会被拉长。</p>\n<p>Content Hugging Priority 表示控件抗拉伸的优先级。数字越大，控件越不容易被拉伸。默认值是251。</p>\n<p>Content Compression Resistance Priority 表示控件抗压缩的优先级。数字越大越不容易被压缩。默认值是750。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/22/58fae76214f9d.png\" alt=\"\"></p>\n<p>这里两边的约束都是100，label 本应该被拉长以满足约束的要求。如果把右边的约束优先级修改为10，左边优先级不变，为默认的1000，Content Hugging Priority 为默认的251，高于10。所以优先满足左边的约束和 label 的固有大小，因此右边的约束无效了。</p>\n<h4 id=\"Frame-amp-Alignment-Rect-两个不同的矩形\"><a href=\"#Frame-amp-Alignment-Rect-两个不同的矩形\" class=\"headerlink\" title=\"Frame &amp; Alignment Rect 两个不同的矩形\"></a>Frame &amp; Alignment Rect 两个不同的矩形</h4><p>自动布局参照的是 Alignment Rectangle 而不是 Frame。比如一个控件的阴影并不会影响到自动布局。应该牢记在自动布局中，Frame 没有视觉大小重要。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/24/58fdfed66497a.png\" alt=\"\"></p>\n<h4 id=\"AutoLayout-Constraints-自动布局的约束\"><a href=\"#AutoLayout-Constraints-自动布局的约束\" class=\"headerlink\" title=\"AutoLayout Constraints 自动布局的约束\"></a>AutoLayout Constraints 自动布局的约束</h4><p>视图的布局体系由一系列线性方程所确定，每个约束都可看作是一个方程的表示。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/23/58fc7e1582b9f.png\" alt=\"\"></p>\n<p>多数的约束都由两项组成，但是当你设置一个视图的长度、宽度为一个常数时，第二个属性（attribute）会被设为<code>Not An Attribute</code>，比例系数会变成0.0。</p>\n<h4 id=\"Cassowary-布局算法\"><a href=\"#Cassowary-布局算法\" class=\"headerlink\" title=\"Cassowary 布局算法\"></a>Cassowary 布局算法</h4><p>Cassowary 是上世纪 90 年代的一个布局算法，它通过将布局问题抽象成线形等式和不等式约束，求解这个多元方程组来算出 x，y，width 和 height。AutoLayout 就是对 Cassowary 的一个实现。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/24/58fe029e44f4d.png\" alt=\"\"></p>\n<h4 id=\"AutoLayout-Performance-自动布局的性能\"><a href=\"#AutoLayout-Performance-自动布局的性能\" class=\"headerlink\" title=\"AutoLayout Performance 自动布局的性能\"></a>AutoLayout Performance 自动布局的性能</h4><p>AutoLayout 的性能瓶颈就是 Cassowary 求解多个方程组的效率问题。因此有人建议在 TableView 中不要用 AutoLayout 设置动态高度的 Cell，而是自己手动计算。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/24/58fe058303e42.png\" alt=\"\"></p>\n<p>网上有人对 AutoLayout 和 Frame 做了性能对比测试，可见当 view 很多时，AutoLayout 的速度会慢很多。</p>\n<h4 id=\"Masonry-amp-SnapKit-自动布局库\"><a href=\"#Masonry-amp-SnapKit-自动布局库\" class=\"headerlink\" title=\"Masonry &amp; SnapKit 自动布局库\"></a>Masonry &amp; SnapKit 自动布局库</h4><p>一个简单易用的 AutoLayout 库，可以告别系统自带 api 冗长的代码。Masonry is for Obj-C, SnapKit is for Swift.</p>\n<p>GitHub地址：<a href=\"https://github.com/SnapKit\">https://github.com/SnapKit</a></p>\n<h4 id=\"ComponentKit-and-its-layout-视图框架\"><a href=\"#ComponentKit-and-its-layout-视图框架\" class=\"headerlink\" title=\"ComponentKit and its layout 视图框架\"></a>ComponentKit and its layout 视图框架</h4><p>ComponentKit 是 FaceBook 开源的响应式视图框架，不支持 Swift。</p>\n<p>GitHub地址：<a href=\"https://github.com/facebook/componentkit\">https://github.com/facebook/componentkit</a></p>\n<h4 id=\"Constraints-Priority-约束优先级\"><a href=\"#Constraints-Priority-约束优先级\" class=\"headerlink\" title=\"Constraints Priority 约束优先级\"></a>Constraints Priority 约束优先级</h4><p>每个约束都有优先级（Priority），范围从1～1000。优先级为1000的约束为必须的（required），其余的为可选的（optional）优先级的绝对大小没有意义，重要的是相对大小。Auto-Layout 会优先满足优先级高的约束。如果一个可选的约束不能被满足，Auto-Layout 会跳过它转而计算下一个约束。</p>\n<p>即使可选的约束可能会不被满足，但它依然对布局有影响。系统会选择最接近这个约束的解决方案，不被满足的约束可以看作是一股将视图拉向它的力。</p>\n<p>可选的约束经常和不等式配合工作：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A single equal relationship</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Blue</span>.leading = <span class=\"number\">1.0</span> * <span class=\"type\">Red</span>.trailing + <span class=\"number\">8.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Can be replaced with two inequality relationships</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Blue</span>.leading &gt;= <span class=\"number\">1.0</span> * <span class=\"type\">Red</span>.trailing + <span class=\"number\">8.0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">Blue</span>.leading &lt;= <span class=\"number\">1.0</span> * <span class=\"type\">Red</span>.trailing + <span class=\"number\">8.0</span></span><br></pre></td></tr></table></figure>\n<p>你可以对上面的两个不等式设置不同的优先级。大于等于不等式的优先级可以设为必须的（1000），小于等于可以设置得低一些（250）。这意味着蓝色的视图与红色视图的距离不能小于8，但是其他的约束可能把它拉得更远。当时可选的约束会把蓝色视图拉向红色视图，保证它尽可能地逼近 8 个点的距离。</p>\n<h4 id=\"AutoLayout-with-hidden-UIViews-layouts-隐藏的视图的自动布局\"><a href=\"#AutoLayout-with-hidden-UIViews-layouts-隐藏的视图的自动布局\" class=\"headerlink\" title=\"AutoLayout with hidden UIViews layouts 隐藏的视图的自动布局\"></a>AutoLayout with hidden UIViews layouts 隐藏的视图的自动布局</h4><p>如果一个 view 被隐藏了，只是试图上看不到了，但是其他的视图距它的约束没有变。如果想让其他的视图跟着变化，可能要修改约束的值，或移除约束，这样代码会过于繁琐。</p>\n<p>如下图，如果我们隐藏第一个 Button，第二个 Button 的位置不会改变。而很多情况下我们希望让第二个 Button 位置往左平移，就像第一个按钮真的不存在一样。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/24/58fe1cd895059.png\" alt=\"\"></p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/24/58fe1cd897b3d.png\" alt=\"\"></p>\n<h4 id=\"Variable-row-heights-iOS7-amp-iOS8-变化的行高\"><a href=\"#Variable-row-heights-iOS7-amp-iOS8-变化的行高\" class=\"headerlink\" title=\"Variable row heights (iOS7 &amp; iOS8) 变化的行高\"></a>Variable row heights (iOS7 &amp; iOS8) 变化的行高</h4><p>iOS7 和 iOS8 下代理方法调用顺序不同。iOS7 先调用 heightForRowAtIndexPath 方法，后调用 cellForRowAtIndexPath 方法；而 iOS8 与之相反。</p>\n<h4 id=\"AutoLayout-in-UITableView-for-dynamic-cell-表格视图中动态的-Cell\"><a href=\"#AutoLayout-in-UITableView-for-dynamic-cell-表格视图中动态的-Cell\" class=\"headerlink\" title=\"AutoLayout in UITableView for dynamic cell 表格视图中动态的 Cell\"></a>AutoLayout in UITableView for dynamic cell 表格视图中动态的 Cell</h4><p>TableViewCell可以自适应高度，但这个功能不是默认实现的。只有当以下的两个属性被设置后，系统才会使用AutoLayout计算每行的实际高度。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tableView.estimatedRowHeight = <span class=\"number\">85.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">tableView.rowHeight = <span class=\"type\">UITableViewAutomaticDimension</span></span><br></pre></td></tr></table></figure>\n<p>注意：你不能改变预先定义好的部分的布局，如 textLabel , detailTextLabel, imageView。</p>\n<hr>\n<h3 id=\"Questions-amp-Answers\"><a href=\"#Questions-amp-Answers\" class=\"headerlink\" title=\"Questions &amp; Answers\"></a>Questions &amp; Answers</h3><h4 id=\"Pros-and-cons-of-AutoLayout-amp-Frame-Layout-不同布局方式的优缺点分析\"><a href=\"#Pros-and-cons-of-AutoLayout-amp-Frame-Layout-不同布局方式的优缺点分析\" class=\"headerlink\" title=\"Pros and cons of AutoLayout &amp; Frame Layout 不同布局方式的优缺点分析\"></a>Pros and cons of AutoLayout &amp; Frame Layout 不同布局方式的优缺点分析</h4><p>UI 布局有以下三种主要方法：</p>\n<ol>\n<li>Frame layout：直接用代码设置每个控件的 Frame。</li>\n<li>使用 auto-resizing masks：可以自动调整子视图与父视图之间的位置关系。</li>\n<li>使用 auto-layout。</li>\n</ol>\n<p>使用 frame layout 最直接，最灵活。当需要发生变化的时候，所有的改变都有你自己来控制。它带来的问题就是过于繁杂。即使一个很简单的界面，为了适配各种可能的情况，都要花费大量的精力去设计、调试、维持。Frame 的性能高。</p>\n<p>使用 auto-resizing masks 可以部分地解决上述问题。但它只是完整的解决方案中的一个子集，无法适应所有可能的情况。而且它只能应对来自外部的改变，如 macOS 中用户调整了窗口大小、iOS中的横屏和分屏。而内部的改变如本地化、app 展示的内容改变这类的问题无法解决。</p>\n<p>使用 auto-layout 可以动态地解决内部改变和外部改变。它不直接设置控件的大小和位置，而是通过约束去考虑控件之间的相对关系。功能强大，但可能有点抽象，跟传统的方法不太一致。 AutoLayout 性能低，而且代码冗长蹩脚。</p>\n<h4 id=\"How-to-get-real-frame-after-AutoLayout-自动布局之后怎样获得控件真实的-Frame\"><a href=\"#How-to-get-real-frame-after-AutoLayout-自动布局之后怎样获得控件真实的-Frame\" class=\"headerlink\" title=\"How to get real frame after AutoLayout 自动布局之后怎样获得控件真实的 Frame\"></a>How to get real frame after AutoLayout 自动布局之后怎样获得控件真实的 Frame</h4><p>在 <code>layoutSubviews()</code> 中对子视图设置约束，首次获取的 frame 不会是自动布局后真实的尺寸，而是一开始默认的值。也就是说在 <code>layoutSubviews()</code> 方法中获取 frame 时，布局还没有完成：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myView</span>: <span class=\"title\">UIView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mysubview = <span class=\"type\">UIView</span>()</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">layoutSubviews</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"layoutSubviews\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.addSubview(mysubview)</span><br><span class=\"line\">        mysubview.translatesAutoresizingMaskIntoConstraints = <span class=\"literal\">false</span></span><br><span class=\"line\">        mysubview.backgroundColor = <span class=\"type\">UIColor</span>.green</span><br><span class=\"line\">        mysubview.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: mysubview, attribute: <span class=\"type\">NSLayoutAttribute</span>.width, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"literal\">nil</span>, attribute: <span class=\"type\">NSLayoutAttribute</span>.notAnAttribute, multiplier: <span class=\"number\">0.0</span>, constant: <span class=\"number\">20</span>))</span><br><span class=\"line\">        mysubview.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: mysubview, attribute: <span class=\"type\">NSLayoutAttribute</span>.height, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"literal\">nil</span>, attribute: <span class=\"type\">NSLayoutAttribute</span>.notAnAttribute, multiplier: <span class=\"number\">0.0</span>, constant: <span class=\"number\">20</span>))</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: mysubview, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerX, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"keyword\">self</span>, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerX, multiplier: <span class=\"number\">1</span>, constant: <span class=\"number\">0.0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.addConstraint(<span class=\"type\">NSLayoutConstraint</span>(item: mysubview, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerY, relatedBy: <span class=\"type\">NSLayoutRelation</span>.<span class=\"built_in\">equal</span>, toItem: <span class=\"keyword\">self</span>, attribute: <span class=\"type\">NSLayoutAttribute</span>.centerY, multiplier: <span class=\"number\">1</span>, constant: <span class=\"number\">0.0</span>))</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(mysubview.frame.height)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(mysubview.frame.width)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是这个方法实际上是多次调用的，在最后一次调用时 frame 就是真实的了。</p>\n<p>在 ViewController 中，假设约束是在 viewDidLoad 中设置的，若在 viewDidLoad 中获取 frame，那么 frame 不是真实的。在 viewDidAppear 中获取 frame，是真实的。但是在 <code>viewDidLayoutSubviews()</code> 中获取，仍然不是真实的，这是因为此时 <strong>AutoLayout</strong> 还没有完成。需要在前面加一句 <code>view.layoutIfNeeded()</code> ，再获取就是真实的了。</p>\n<h4 id=\"Using-AutoLayout-to-create-equal-width-spacing-使用自动布局构建等间距效果\"><a href=\"#Using-AutoLayout-to-create-equal-width-spacing-使用自动布局构建等间距效果\" class=\"headerlink\" title=\"Using AutoLayout to create equal width spacing 使用自动布局构建等间距效果\"></a>Using AutoLayout to create equal width spacing 使用自动布局构建等间距效果</h4><p>最简单的方法（无需添加约束）就是在 Interface Builder 中创建一个 StackView，并设置它的 spacing 参数。</p>\n<p><img src=\"https://ooo.0o0.ooo/2017/04/22/58fb29843456d.png\" alt=\"\"></p>\n<p>也可以添加约束来实现，设置约束值相同就可以了。当然也可以在代码中设置约束大小相同。</p>\n<h4 id=\"Some-reasons-for-application-crash-when-updating-the-constraints-after-removing-the-views-which-has-some-mutual-constraints-relationship-移除具有共同约束关系的控件后更新约束导致的应用崩溃的一些原因\"><a href=\"#Some-reasons-for-application-crash-when-updating-the-constraints-after-removing-the-views-which-has-some-mutual-constraints-relationship-移除具有共同约束关系的控件后更新约束导致的应用崩溃的一些原因\" class=\"headerlink\" title=\"Some reasons for application crash when updating the constraints after removing the views which has some mutual constraints relationship 移除具有共同约束关系的控件后更新约束导致的应用崩溃的一些原因\"></a>Some reasons for application crash when updating the constraints after removing the views which has some mutual constraints relationship 移除具有共同约束关系的控件后更新约束导致的应用崩溃的一些原因</h4><p>暂时没有发现应用崩溃。移除约束依赖的视图后，相应的约束也自动被移除了，而使用默认的 Frame 值在屏幕上绘制。</p>\n"},{"title":"iOS 蓝牙开发初步","date":"2017-07-04T05:48:45.000Z","_content":"\n# iOS 蓝牙开发初步\n\n注意：CoreBluetooth 是基于 BLE 4.0 版本的。\n\n官方教程：[Core Bluetooth Programming Guide](https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257-CH1-SW1)\n\n### CoreBluetooth 简介\n\n低功耗蓝牙技术是基于蓝牙 4.0 版本的，它在低功耗设备之间定义了一系列通信协议。CoreBluetooth 框架是低功耗蓝牙通信协议的一个抽象：它帮开发者隐藏了许多底层技术的细节，使得开发能与低功耗蓝牙设备交互的 App 变得更容易。\n\n**中心设备和外围设备**是 CoreBluetooth 里最重要的两个角色。不同角色有不同的任务：外围设备拥有其他设备所需要的数据；中心设备用外围设备提供的信息去完成某些任务。举例来说：一个装备了低功耗蓝牙技术的心率探测器为一个 iOS App 提供了房间的温度，而 App 将这些数据用用户友好的方式呈现出来——就像传统的服务器-客户端结构那样。\n\n![CBDevices1_2x](/img/CBDevices1_2x.png)\n\n### 外围设备的数据结构\n\n外设可能会包含多个服务（services），或者提供一些关于连接信号强度的信息。一个服务是指为了完成某种功能所需要的数据和行为的集合。\n\n服务本身由特征（characteristics）或者包含的服务（其他服务的引用）组成。一个 characteristic 提供了外设服务的更多细节。举例来说，心率监视器的服务只描述了它可能含有一个描述身体传感器位置的特征，和一个心律测量值的特征。![CBPeripheralData_Example_2x](/img/CBPeripheralData_Example_2x.png)\n\n当中心设备成功建立了和外设的连接之后，它就可以发现外设提供的所有服务和特征。中心设备也可以通过读或者写特征的值来与外设交互。比如你的 App 会从温度控制器中获得一个温度，也会提供一个温度值给控制器，使它调节室温。\n\n### 中心设备、外设和外设数据的表现方式\n\n除非特别设置，多数情况下本地设备会以中心设备的方式工作。中心设备是一个 `CBCentralManager` 对象。这个对象用来管理已发现或已连接的远程外围设备。包括扫描、发现和连接正在广播的外设。外设用 `CBPeripheral` 对象表示，外设的服务用 `CBService` 表示。类似的，服务的特征用 `CBCharacteristic` 对象表示。\n\n![TreeOfServicesAndCharacteristics_Remote_2x](/img/TreeOfServicesAndCharacteristics_Remote_2x.png)\n\n在 macOS 10.9 和 iOS 6 之后，Mac 和 iOS 设备也可以用作低功耗蓝牙外设，向其他设备提供数据。本地设备作为外设时，用 `CBPeripheralManager` 表示。这些对象涌来管理发布的服务。远程中心设备用 `CBCentral` 表示。Peripheral Manager 也涌来读或写中心设备发出的请求。\n\n可以看到，本地设备作为中心设备和外围设备时，使用的类和类的作用是对偶的。\n\n### 简单应用\n\n#### 构建外围设备\n\n由于模拟器上不能操作蓝牙，所以必须使用真机进行调试。因此可能需要两部 iOS 设备，一台用来做中心设备，另外一台做外设。如果不想自己写外设的代码，也可以使用 LightBlue 软件模拟外设。这里我用了 Arduino Uno 单片机，配合蓝牙 4.0 模块作为外设。\n\n![arduinoWithBluetooth](/img/arduinoWithBluetooth.JPG)\n\n使用时，需要给蓝牙模块 Vcc 引脚接 5V 的电压，Gnd 引脚接 Arduino 的“接地”。蓝牙模块的 Rx 接 Arduino 的Tx，Tx 接 Rx。\n\n用 Arduino 操作蓝牙通信非常简单，因为 Arduino 屏蔽了底层的细节，将蓝牙看作普通的串口。因此直接操作串口既可以了。打开 Arduino IDE，将下面的代码下载到单片机。\n\n```c\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(9600);\n}\n\nint i = 0;\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  Serial.println(i);\n  i++;\n  delay(2000);\n}\n```\n\n这里波特率设为 9600 符号／秒。在 loop 中，每间隔 2 秒发送一个数字，同时数字加一。需要注意的是，由于 Arduino 下载程序也需要使用串口，所以会和蓝牙模块连接的串口冲突。下载程序时，需要暂时断开 Rx 和 Tx 引脚。\n\n#### 构建中心设备\n\n需要以下几个属性：\n\n```swift\nvar manager: CBCentralManager!\nvar peripherals = [CBPeripheral]()\nvar connectedPeripheral: CBPeripheral?\n```\n\nperipherals 用来存放扫描到的设备，connectedPeripheral 代表需要操作的外设。\n\n在 `viewDidLoad()` 中，对 manager 初始化：\n\n```swift\nmanager = CBCentralManager(delegate: self, queue: DispatchQueue.main)\n```\n\n代理选择 self，线程选择主线程。为了设置代理，需要遵守 `CBCentralManagerDelegate` 协议，并实现该协议的 required 方法：\n\n```swift\nfunc centralManagerDidUpdateState(_ central: CBCentralManager) {\n    switch central.state {\n    case .poweredOn:\n        manager.scanForPeripherals(withServices: nil, options: nil)\n    default:\n        print(\"未开启蓝牙\")\n    }\n}\n```\n\n用 manager 的方法，必须保证蓝牙状态处于 poweredOn。如果蓝牙已开启，则开始扫描外围设备。填 nil 表示不做过滤，扫描一切外围设备。扫描到外设会自动调用下面的方法：\n\n```swift\nfunc centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { \n    if peripheral.name! == \"BT05\" {\n        peripherals.append(peripheral)\n        manager.connect(peripheral, options: nil)\n    }\n}\n```\n\n利用外设的名字判断我要连接的设备。我的蓝牙模块名称默认是“BT05”。如果发现了该设备，进行连接。注意，必须持有该外设对象的引用，否则会报错。所以将它添加到数组中。使用数组是因为在一般的应用中，可能不止需要一个外设，这里并不是必须的。\n\n连接到外设后，会调用下面的方法：\n\n```swift\nfunc centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {\n    connectedPeripheral = peripheral\n    peripheral.discoverServices(nil)\n        \n    peripheral.delegate = self\n    print(peripheral.name!)\n    manager.stopScan()\n}\n```\n\n去查看已连接外设的服务。参数传 nil 同样是查看所有服务，不加过滤。将连接的外设的代理设为 self，因此需要遵守 `CBPeripheralDelegate` 协议。\n\n发现了外设的服务，会调用下面的方法：\n\n```swift\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {\n    for each in peripheral.services! {\n        if each.uuid.uuidString == \"FFE0\" {\n            peripheral.discoverCharacteristics(nil, for: each)\n        }\n    }\n}\n```\n\n遍历外设的所有服务，用 uuid 来判断感兴趣的服务。注意这里的 uuid 是服务的 uuid 而不是外设的 uuid。可以通过下载软件 LightBlue 查看服务的 uuid 码，这里是 FFE0。一旦发现，就去获取该服务的特性（characteristic）。\n\n发现了特性会调用下面的方法：\n\n```swift\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {\n    for each in service.characteristics! {\n        peripheral.readValue(for: each)\n        peripheral.setNotifyValue(true, for: each)\n    }\n}\n```\n\n遍历所有的 characteristic，读取它的值并允许接受广播。这样每次 characteristic 的值变化后，都会调用下面的方法：\n\n```swift\nfunc peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {\n    let str = String(data: characteristic.value!, encoding: .utf8)\n    print(str!)\n}\n```\n\n这里把接收到的值转换为字符串，并用 UTF-8 编码。之后把收到的字符串打印出来。\n\n#### 测试\n\n用面包线把单片机和蓝牙模块连接好，上电。把程序放到真机上调试，在控制台输出：\n\n![screenshotBluetooth](/img/screenshotBluetooth.png)\n\n每隔两秒，输出一个数字，且每次加一。这里没有从 0 开始是因为单片机一上电，就自动开始工作了，不会等到蓝牙连接好再往串口上写数据。测试成功。\n\n今天学习了 CoreBluetooth 的基本概念，并了解了基本的操作流程。可以看到使用 CoreBluetooth 流程比较多，如果不了解基本的概念可能会比较懵。不过总体来说逻辑一层套一层非常严谨，不难理解。接下来我会尝试用蓝牙构建稍复杂的应用。","source":"_posts/iOS-蓝牙开发初步.md","raw":"---\ntitle: iOS 蓝牙开发初步\ndate: 2017-07-04 13:48:45\ntags: CoreBluetooth\n---\n\n# iOS 蓝牙开发初步\n\n注意：CoreBluetooth 是基于 BLE 4.0 版本的。\n\n官方教程：[Core Bluetooth Programming Guide](https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257-CH1-SW1)\n\n### CoreBluetooth 简介\n\n低功耗蓝牙技术是基于蓝牙 4.0 版本的，它在低功耗设备之间定义了一系列通信协议。CoreBluetooth 框架是低功耗蓝牙通信协议的一个抽象：它帮开发者隐藏了许多底层技术的细节，使得开发能与低功耗蓝牙设备交互的 App 变得更容易。\n\n**中心设备和外围设备**是 CoreBluetooth 里最重要的两个角色。不同角色有不同的任务：外围设备拥有其他设备所需要的数据；中心设备用外围设备提供的信息去完成某些任务。举例来说：一个装备了低功耗蓝牙技术的心率探测器为一个 iOS App 提供了房间的温度，而 App 将这些数据用用户友好的方式呈现出来——就像传统的服务器-客户端结构那样。\n\n![CBDevices1_2x](/img/CBDevices1_2x.png)\n\n### 外围设备的数据结构\n\n外设可能会包含多个服务（services），或者提供一些关于连接信号强度的信息。一个服务是指为了完成某种功能所需要的数据和行为的集合。\n\n服务本身由特征（characteristics）或者包含的服务（其他服务的引用）组成。一个 characteristic 提供了外设服务的更多细节。举例来说，心率监视器的服务只描述了它可能含有一个描述身体传感器位置的特征，和一个心律测量值的特征。![CBPeripheralData_Example_2x](/img/CBPeripheralData_Example_2x.png)\n\n当中心设备成功建立了和外设的连接之后，它就可以发现外设提供的所有服务和特征。中心设备也可以通过读或者写特征的值来与外设交互。比如你的 App 会从温度控制器中获得一个温度，也会提供一个温度值给控制器，使它调节室温。\n\n### 中心设备、外设和外设数据的表现方式\n\n除非特别设置，多数情况下本地设备会以中心设备的方式工作。中心设备是一个 `CBCentralManager` 对象。这个对象用来管理已发现或已连接的远程外围设备。包括扫描、发现和连接正在广播的外设。外设用 `CBPeripheral` 对象表示，外设的服务用 `CBService` 表示。类似的，服务的特征用 `CBCharacteristic` 对象表示。\n\n![TreeOfServicesAndCharacteristics_Remote_2x](/img/TreeOfServicesAndCharacteristics_Remote_2x.png)\n\n在 macOS 10.9 和 iOS 6 之后，Mac 和 iOS 设备也可以用作低功耗蓝牙外设，向其他设备提供数据。本地设备作为外设时，用 `CBPeripheralManager` 表示。这些对象涌来管理发布的服务。远程中心设备用 `CBCentral` 表示。Peripheral Manager 也涌来读或写中心设备发出的请求。\n\n可以看到，本地设备作为中心设备和外围设备时，使用的类和类的作用是对偶的。\n\n### 简单应用\n\n#### 构建外围设备\n\n由于模拟器上不能操作蓝牙，所以必须使用真机进行调试。因此可能需要两部 iOS 设备，一台用来做中心设备，另外一台做外设。如果不想自己写外设的代码，也可以使用 LightBlue 软件模拟外设。这里我用了 Arduino Uno 单片机，配合蓝牙 4.0 模块作为外设。\n\n![arduinoWithBluetooth](/img/arduinoWithBluetooth.JPG)\n\n使用时，需要给蓝牙模块 Vcc 引脚接 5V 的电压，Gnd 引脚接 Arduino 的“接地”。蓝牙模块的 Rx 接 Arduino 的Tx，Tx 接 Rx。\n\n用 Arduino 操作蓝牙通信非常简单，因为 Arduino 屏蔽了底层的细节，将蓝牙看作普通的串口。因此直接操作串口既可以了。打开 Arduino IDE，将下面的代码下载到单片机。\n\n```c\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(9600);\n}\n\nint i = 0;\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  Serial.println(i);\n  i++;\n  delay(2000);\n}\n```\n\n这里波特率设为 9600 符号／秒。在 loop 中，每间隔 2 秒发送一个数字，同时数字加一。需要注意的是，由于 Arduino 下载程序也需要使用串口，所以会和蓝牙模块连接的串口冲突。下载程序时，需要暂时断开 Rx 和 Tx 引脚。\n\n#### 构建中心设备\n\n需要以下几个属性：\n\n```swift\nvar manager: CBCentralManager!\nvar peripherals = [CBPeripheral]()\nvar connectedPeripheral: CBPeripheral?\n```\n\nperipherals 用来存放扫描到的设备，connectedPeripheral 代表需要操作的外设。\n\n在 `viewDidLoad()` 中，对 manager 初始化：\n\n```swift\nmanager = CBCentralManager(delegate: self, queue: DispatchQueue.main)\n```\n\n代理选择 self，线程选择主线程。为了设置代理，需要遵守 `CBCentralManagerDelegate` 协议，并实现该协议的 required 方法：\n\n```swift\nfunc centralManagerDidUpdateState(_ central: CBCentralManager) {\n    switch central.state {\n    case .poweredOn:\n        manager.scanForPeripherals(withServices: nil, options: nil)\n    default:\n        print(\"未开启蓝牙\")\n    }\n}\n```\n\n用 manager 的方法，必须保证蓝牙状态处于 poweredOn。如果蓝牙已开启，则开始扫描外围设备。填 nil 表示不做过滤，扫描一切外围设备。扫描到外设会自动调用下面的方法：\n\n```swift\nfunc centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) { \n    if peripheral.name! == \"BT05\" {\n        peripherals.append(peripheral)\n        manager.connect(peripheral, options: nil)\n    }\n}\n```\n\n利用外设的名字判断我要连接的设备。我的蓝牙模块名称默认是“BT05”。如果发现了该设备，进行连接。注意，必须持有该外设对象的引用，否则会报错。所以将它添加到数组中。使用数组是因为在一般的应用中，可能不止需要一个外设，这里并不是必须的。\n\n连接到外设后，会调用下面的方法：\n\n```swift\nfunc centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {\n    connectedPeripheral = peripheral\n    peripheral.discoverServices(nil)\n        \n    peripheral.delegate = self\n    print(peripheral.name!)\n    manager.stopScan()\n}\n```\n\n去查看已连接外设的服务。参数传 nil 同样是查看所有服务，不加过滤。将连接的外设的代理设为 self，因此需要遵守 `CBPeripheralDelegate` 协议。\n\n发现了外设的服务，会调用下面的方法：\n\n```swift\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {\n    for each in peripheral.services! {\n        if each.uuid.uuidString == \"FFE0\" {\n            peripheral.discoverCharacteristics(nil, for: each)\n        }\n    }\n}\n```\n\n遍历外设的所有服务，用 uuid 来判断感兴趣的服务。注意这里的 uuid 是服务的 uuid 而不是外设的 uuid。可以通过下载软件 LightBlue 查看服务的 uuid 码，这里是 FFE0。一旦发现，就去获取该服务的特性（characteristic）。\n\n发现了特性会调用下面的方法：\n\n```swift\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {\n    for each in service.characteristics! {\n        peripheral.readValue(for: each)\n        peripheral.setNotifyValue(true, for: each)\n    }\n}\n```\n\n遍历所有的 characteristic，读取它的值并允许接受广播。这样每次 characteristic 的值变化后，都会调用下面的方法：\n\n```swift\nfunc peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {\n    let str = String(data: characteristic.value!, encoding: .utf8)\n    print(str!)\n}\n```\n\n这里把接收到的值转换为字符串，并用 UTF-8 编码。之后把收到的字符串打印出来。\n\n#### 测试\n\n用面包线把单片机和蓝牙模块连接好，上电。把程序放到真机上调试，在控制台输出：\n\n![screenshotBluetooth](/img/screenshotBluetooth.png)\n\n每隔两秒，输出一个数字，且每次加一。这里没有从 0 开始是因为单片机一上电，就自动开始工作了，不会等到蓝牙连接好再往串口上写数据。测试成功。\n\n今天学习了 CoreBluetooth 的基本概念，并了解了基本的操作流程。可以看到使用 CoreBluetooth 流程比较多，如果不了解基本的概念可能会比较懵。不过总体来说逻辑一层套一层非常严谨，不难理解。接下来我会尝试用蓝牙构建稍复杂的应用。","slug":"iOS-蓝牙开发初步","published":1,"updated":"2020-01-04T08:16:16.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv41003dljc38jz5ni4m","content":"<h1 id=\"iOS-蓝牙开发初步\"><a href=\"#iOS-蓝牙开发初步\" class=\"headerlink\" title=\"iOS 蓝牙开发初步\"></a>iOS 蓝牙开发初步</h1><p>注意：CoreBluetooth 是基于 BLE 4.0 版本的。</p>\n<p>官方教程：<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257-CH1-SW1\">Core Bluetooth Programming Guide</a></p>\n<h3 id=\"CoreBluetooth-简介\"><a href=\"#CoreBluetooth-简介\" class=\"headerlink\" title=\"CoreBluetooth 简介\"></a>CoreBluetooth 简介</h3><p>低功耗蓝牙技术是基于蓝牙 4.0 版本的，它在低功耗设备之间定义了一系列通信协议。CoreBluetooth 框架是低功耗蓝牙通信协议的一个抽象：它帮开发者隐藏了许多底层技术的细节，使得开发能与低功耗蓝牙设备交互的 App 变得更容易。</p>\n<p><strong>中心设备和外围设备</strong>是 CoreBluetooth 里最重要的两个角色。不同角色有不同的任务：外围设备拥有其他设备所需要的数据；中心设备用外围设备提供的信息去完成某些任务。举例来说：一个装备了低功耗蓝牙技术的心率探测器为一个 iOS App 提供了房间的温度，而 App 将这些数据用用户友好的方式呈现出来——就像传统的服务器-客户端结构那样。</p>\n<p><img src=\"/img/CBDevices1_2x.png\" alt=\"CBDevices1_2x\"></p>\n<h3 id=\"外围设备的数据结构\"><a href=\"#外围设备的数据结构\" class=\"headerlink\" title=\"外围设备的数据结构\"></a>外围设备的数据结构</h3><p>外设可能会包含多个服务（services），或者提供一些关于连接信号强度的信息。一个服务是指为了完成某种功能所需要的数据和行为的集合。</p>\n<p>服务本身由特征（characteristics）或者包含的服务（其他服务的引用）组成。一个 characteristic 提供了外设服务的更多细节。举例来说，心率监视器的服务只描述了它可能含有一个描述身体传感器位置的特征，和一个心律测量值的特征。<img src=\"/img/CBPeripheralData_Example_2x.png\" alt=\"CBPeripheralData_Example_2x\"></p>\n<p>当中心设备成功建立了和外设的连接之后，它就可以发现外设提供的所有服务和特征。中心设备也可以通过读或者写特征的值来与外设交互。比如你的 App 会从温度控制器中获得一个温度，也会提供一个温度值给控制器，使它调节室温。</p>\n<h3 id=\"中心设备、外设和外设数据的表现方式\"><a href=\"#中心设备、外设和外设数据的表现方式\" class=\"headerlink\" title=\"中心设备、外设和外设数据的表现方式\"></a>中心设备、外设和外设数据的表现方式</h3><p>除非特别设置，多数情况下本地设备会以中心设备的方式工作。中心设备是一个 <code>CBCentralManager</code> 对象。这个对象用来管理已发现或已连接的远程外围设备。包括扫描、发现和连接正在广播的外设。外设用 <code>CBPeripheral</code> 对象表示，外设的服务用 <code>CBService</code> 表示。类似的，服务的特征用 <code>CBCharacteristic</code> 对象表示。</p>\n<p><img src=\"/img/TreeOfServicesAndCharacteristics_Remote_2x.png\" alt=\"TreeOfServicesAndCharacteristics_Remote_2x\"></p>\n<p>在 macOS 10.9 和 iOS 6 之后，Mac 和 iOS 设备也可以用作低功耗蓝牙外设，向其他设备提供数据。本地设备作为外设时，用 <code>CBPeripheralManager</code> 表示。这些对象涌来管理发布的服务。远程中心设备用 <code>CBCentral</code> 表示。Peripheral Manager 也涌来读或写中心设备发出的请求。</p>\n<p>可以看到，本地设备作为中心设备和外围设备时，使用的类和类的作用是对偶的。</p>\n<h3 id=\"简单应用\"><a href=\"#简单应用\" class=\"headerlink\" title=\"简单应用\"></a>简单应用</h3><h4 id=\"构建外围设备\"><a href=\"#构建外围设备\" class=\"headerlink\" title=\"构建外围设备\"></a>构建外围设备</h4><p>由于模拟器上不能操作蓝牙，所以必须使用真机进行调试。因此可能需要两部 iOS 设备，一台用来做中心设备，另外一台做外设。如果不想自己写外设的代码，也可以使用 LightBlue 软件模拟外设。这里我用了 Arduino Uno 单片机，配合蓝牙 4.0 模块作为外设。</p>\n<p><img src=\"/img/arduinoWithBluetooth.JPG\" alt=\"arduinoWithBluetooth\"></p>\n<p>使用时，需要给蓝牙模块 Vcc 引脚接 5V 的电压，Gnd 引脚接 Arduino 的“接地”。蓝牙模块的 Rx 接 Arduino 的Tx，Tx 接 Rx。</p>\n<p>用 Arduino 操作蓝牙通信非常简单，因为 Arduino 屏蔽了底层的细节，将蓝牙看作普通的串口。因此直接操作串口既可以了。打开 Arduino IDE，将下面的代码下载到单片机。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// put your setup code here, to run once:</span></span><br><span class=\"line\">  Serial.begin(<span class=\"number\">9600</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// put your main code here, to run repeatedly:</span></span><br><span class=\"line\">  Serial.println(i);</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">  delay(<span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里波特率设为 9600 符号／秒。在 loop 中，每间隔 2 秒发送一个数字，同时数字加一。需要注意的是，由于 Arduino 下载程序也需要使用串口，所以会和蓝牙模块连接的串口冲突。下载程序时，需要暂时断开 Rx 和 Tx 引脚。</p>\n<h4 id=\"构建中心设备\"><a href=\"#构建中心设备\" class=\"headerlink\" title=\"构建中心设备\"></a>构建中心设备</h4><p>需要以下几个属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> manager: <span class=\"type\">CBCentralManager!</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> peripherals = [<span class=\"type\">CBPeripheral</span>]()</span><br><span class=\"line\"><span class=\"keyword\">var</span> connectedPeripheral: <span class=\"type\">CBPeripheral?</span></span><br></pre></td></tr></table></figure>\n<p>peripherals 用来存放扫描到的设备，connectedPeripheral 代表需要操作的外设。</p>\n<p>在 <code>viewDidLoad()</code> 中，对 manager 初始化：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">manager = <span class=\"type\">CBCentralManager</span>(delegate: <span class=\"keyword\">self</span>, queue: <span class=\"type\">DispatchQueue</span>.main)</span><br></pre></td></tr></table></figure>\n<p>代理选择 self，线程选择主线程。为了设置代理，需要遵守 <code>CBCentralManagerDelegate</code> 协议，并实现该协议的 required 方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">centralManagerDidUpdateState</span><span class=\"params\">(<span class=\"number\">_</span> central: CBCentralManager)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> central.state &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .poweredOn:</span><br><span class=\"line\">        manager.scanForPeripherals(withServices: <span class=\"literal\">nil</span>, options: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"未开启蓝牙\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 manager 的方法，必须保证蓝牙状态处于 poweredOn。如果蓝牙已开启，则开始扫描外围设备。填 nil 表示不做过滤，扫描一切外围设备。扫描到外设会自动调用下面的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">centralManager</span><span class=\"params\">(<span class=\"number\">_</span> central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : <span class=\"keyword\">Any</span>], rssi RSSI: NSNumber)</span></span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> peripheral.name! == <span class=\"string\">\"BT05\"</span> &#123;</span><br><span class=\"line\">        peripherals.append(peripheral)</span><br><span class=\"line\">        manager.connect(peripheral, options: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>利用外设的名字判断我要连接的设备。我的蓝牙模块名称默认是“BT05”。如果发现了该设备，进行连接。注意，必须持有该外设对象的引用，否则会报错。所以将它添加到数组中。使用数组是因为在一般的应用中，可能不止需要一个外设，这里并不是必须的。</p>\n<p>连接到外设后，会调用下面的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">centralManager</span><span class=\"params\">(<span class=\"number\">_</span> central: CBCentralManager, didConnect peripheral: CBPeripheral)</span></span> &#123;</span><br><span class=\"line\">    connectedPeripheral = peripheral</span><br><span class=\"line\">    peripheral.discoverServices(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    peripheral.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(peripheral.name!)</span><br><span class=\"line\">    manager.stopScan()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>去查看已连接外设的服务。参数传 nil 同样是查看所有服务，不加过滤。将连接的外设的代理设为 self，因此需要遵守 <code>CBPeripheralDelegate</code> 协议。</p>\n<p>发现了外设的服务，会调用下面的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">peripheral</span><span class=\"params\">(<span class=\"number\">_</span> peripheral: CBPeripheral, didDiscoverServices error: Error?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> peripheral.services! &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> each.uuid.uuidString == <span class=\"string\">\"FFE0\"</span> &#123;</span><br><span class=\"line\">            peripheral.discoverCharacteristics(<span class=\"literal\">nil</span>, <span class=\"keyword\">for</span>: each)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>遍历外设的所有服务，用 uuid 来判断感兴趣的服务。注意这里的 uuid 是服务的 uuid 而不是外设的 uuid。可以通过下载软件 LightBlue 查看服务的 uuid 码，这里是 FFE0。一旦发现，就去获取该服务的特性（characteristic）。</p>\n<p>发现了特性会调用下面的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">peripheral</span><span class=\"params\">(<span class=\"number\">_</span> peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> service.characteristics! &#123;</span><br><span class=\"line\">        peripheral.readValue(<span class=\"keyword\">for</span>: each)</span><br><span class=\"line\">        peripheral.setNotifyValue(<span class=\"literal\">true</span>, <span class=\"keyword\">for</span>: each)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>遍历所有的 characteristic，读取它的值并允许接受广播。这样每次 characteristic 的值变化后，都会调用下面的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">peripheral</span><span class=\"params\">(<span class=\"number\">_</span> peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> str = <span class=\"type\">String</span>(data: characteristic.value!, encoding: .utf8)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(str!)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里把接收到的值转换为字符串，并用 UTF-8 编码。之后把收到的字符串打印出来。</p>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>用面包线把单片机和蓝牙模块连接好，上电。把程序放到真机上调试，在控制台输出：</p>\n<p><img src=\"/img/screenshotBluetooth.png\" alt=\"screenshotBluetooth\"></p>\n<p>每隔两秒，输出一个数字，且每次加一。这里没有从 0 开始是因为单片机一上电，就自动开始工作了，不会等到蓝牙连接好再往串口上写数据。测试成功。</p>\n<p>今天学习了 CoreBluetooth 的基本概念，并了解了基本的操作流程。可以看到使用 CoreBluetooth 流程比较多，如果不了解基本的概念可能会比较懵。不过总体来说逻辑一层套一层非常严谨，不难理解。接下来我会尝试用蓝牙构建稍复杂的应用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-蓝牙开发初步\"><a href=\"#iOS-蓝牙开发初步\" class=\"headerlink\" title=\"iOS 蓝牙开发初步\"></a>iOS 蓝牙开发初步</h1><p>注意：CoreBluetooth 是基于 BLE 4.0 版本的。</p>\n<p>官方教程：<a href=\"https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html#//apple_ref/doc/uid/TP40013257-CH1-SW1\">Core Bluetooth Programming Guide</a></p>\n<h3 id=\"CoreBluetooth-简介\"><a href=\"#CoreBluetooth-简介\" class=\"headerlink\" title=\"CoreBluetooth 简介\"></a>CoreBluetooth 简介</h3><p>低功耗蓝牙技术是基于蓝牙 4.0 版本的，它在低功耗设备之间定义了一系列通信协议。CoreBluetooth 框架是低功耗蓝牙通信协议的一个抽象：它帮开发者隐藏了许多底层技术的细节，使得开发能与低功耗蓝牙设备交互的 App 变得更容易。</p>\n<p><strong>中心设备和外围设备</strong>是 CoreBluetooth 里最重要的两个角色。不同角色有不同的任务：外围设备拥有其他设备所需要的数据；中心设备用外围设备提供的信息去完成某些任务。举例来说：一个装备了低功耗蓝牙技术的心率探测器为一个 iOS App 提供了房间的温度，而 App 将这些数据用用户友好的方式呈现出来——就像传统的服务器-客户端结构那样。</p>\n<p><img src=\"/img/CBDevices1_2x.png\" alt=\"CBDevices1_2x\"></p>\n<h3 id=\"外围设备的数据结构\"><a href=\"#外围设备的数据结构\" class=\"headerlink\" title=\"外围设备的数据结构\"></a>外围设备的数据结构</h3><p>外设可能会包含多个服务（services），或者提供一些关于连接信号强度的信息。一个服务是指为了完成某种功能所需要的数据和行为的集合。</p>\n<p>服务本身由特征（characteristics）或者包含的服务（其他服务的引用）组成。一个 characteristic 提供了外设服务的更多细节。举例来说，心率监视器的服务只描述了它可能含有一个描述身体传感器位置的特征，和一个心律测量值的特征。<img src=\"/img/CBPeripheralData_Example_2x.png\" alt=\"CBPeripheralData_Example_2x\"></p>\n<p>当中心设备成功建立了和外设的连接之后，它就可以发现外设提供的所有服务和特征。中心设备也可以通过读或者写特征的值来与外设交互。比如你的 App 会从温度控制器中获得一个温度，也会提供一个温度值给控制器，使它调节室温。</p>\n<h3 id=\"中心设备、外设和外设数据的表现方式\"><a href=\"#中心设备、外设和外设数据的表现方式\" class=\"headerlink\" title=\"中心设备、外设和外设数据的表现方式\"></a>中心设备、外设和外设数据的表现方式</h3><p>除非特别设置，多数情况下本地设备会以中心设备的方式工作。中心设备是一个 <code>CBCentralManager</code> 对象。这个对象用来管理已发现或已连接的远程外围设备。包括扫描、发现和连接正在广播的外设。外设用 <code>CBPeripheral</code> 对象表示，外设的服务用 <code>CBService</code> 表示。类似的，服务的特征用 <code>CBCharacteristic</code> 对象表示。</p>\n<p><img src=\"/img/TreeOfServicesAndCharacteristics_Remote_2x.png\" alt=\"TreeOfServicesAndCharacteristics_Remote_2x\"></p>\n<p>在 macOS 10.9 和 iOS 6 之后，Mac 和 iOS 设备也可以用作低功耗蓝牙外设，向其他设备提供数据。本地设备作为外设时，用 <code>CBPeripheralManager</code> 表示。这些对象涌来管理发布的服务。远程中心设备用 <code>CBCentral</code> 表示。Peripheral Manager 也涌来读或写中心设备发出的请求。</p>\n<p>可以看到，本地设备作为中心设备和外围设备时，使用的类和类的作用是对偶的。</p>\n<h3 id=\"简单应用\"><a href=\"#简单应用\" class=\"headerlink\" title=\"简单应用\"></a>简单应用</h3><h4 id=\"构建外围设备\"><a href=\"#构建外围设备\" class=\"headerlink\" title=\"构建外围设备\"></a>构建外围设备</h4><p>由于模拟器上不能操作蓝牙，所以必须使用真机进行调试。因此可能需要两部 iOS 设备，一台用来做中心设备，另外一台做外设。如果不想自己写外设的代码，也可以使用 LightBlue 软件模拟外设。这里我用了 Arduino Uno 单片机，配合蓝牙 4.0 模块作为外设。</p>\n<p><img src=\"/img/arduinoWithBluetooth.JPG\" alt=\"arduinoWithBluetooth\"></p>\n<p>使用时，需要给蓝牙模块 Vcc 引脚接 5V 的电压，Gnd 引脚接 Arduino 的“接地”。蓝牙模块的 Rx 接 Arduino 的Tx，Tx 接 Rx。</p>\n<p>用 Arduino 操作蓝牙通信非常简单，因为 Arduino 屏蔽了底层的细节，将蓝牙看作普通的串口。因此直接操作串口既可以了。打开 Arduino IDE，将下面的代码下载到单片机。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// put your setup code here, to run once:</span></span><br><span class=\"line\">  Serial.begin(<span class=\"number\">9600</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// put your main code here, to run repeatedly:</span></span><br><span class=\"line\">  Serial.println(i);</span><br><span class=\"line\">  i++;</span><br><span class=\"line\">  delay(<span class=\"number\">2000</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里波特率设为 9600 符号／秒。在 loop 中，每间隔 2 秒发送一个数字，同时数字加一。需要注意的是，由于 Arduino 下载程序也需要使用串口，所以会和蓝牙模块连接的串口冲突。下载程序时，需要暂时断开 Rx 和 Tx 引脚。</p>\n<h4 id=\"构建中心设备\"><a href=\"#构建中心设备\" class=\"headerlink\" title=\"构建中心设备\"></a>构建中心设备</h4><p>需要以下几个属性：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> manager: <span class=\"type\">CBCentralManager!</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> peripherals = [<span class=\"type\">CBPeripheral</span>]()</span><br><span class=\"line\"><span class=\"keyword\">var</span> connectedPeripheral: <span class=\"type\">CBPeripheral?</span></span><br></pre></td></tr></table></figure>\n<p>peripherals 用来存放扫描到的设备，connectedPeripheral 代表需要操作的外设。</p>\n<p>在 <code>viewDidLoad()</code> 中，对 manager 初始化：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">manager = <span class=\"type\">CBCentralManager</span>(delegate: <span class=\"keyword\">self</span>, queue: <span class=\"type\">DispatchQueue</span>.main)</span><br></pre></td></tr></table></figure>\n<p>代理选择 self，线程选择主线程。为了设置代理，需要遵守 <code>CBCentralManagerDelegate</code> 协议，并实现该协议的 required 方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">centralManagerDidUpdateState</span><span class=\"params\">(<span class=\"number\">_</span> central: CBCentralManager)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> central.state &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> .poweredOn:</span><br><span class=\"line\">        manager.scanForPeripherals(withServices: <span class=\"literal\">nil</span>, options: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">\"未开启蓝牙\"</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用 manager 的方法，必须保证蓝牙状态处于 poweredOn。如果蓝牙已开启，则开始扫描外围设备。填 nil 表示不做过滤，扫描一切外围设备。扫描到外设会自动调用下面的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">centralManager</span><span class=\"params\">(<span class=\"number\">_</span> central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : <span class=\"keyword\">Any</span>], rssi RSSI: NSNumber)</span></span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">if</span> peripheral.name! == <span class=\"string\">\"BT05\"</span> &#123;</span><br><span class=\"line\">        peripherals.append(peripheral)</span><br><span class=\"line\">        manager.connect(peripheral, options: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>利用外设的名字判断我要连接的设备。我的蓝牙模块名称默认是“BT05”。如果发现了该设备，进行连接。注意，必须持有该外设对象的引用，否则会报错。所以将它添加到数组中。使用数组是因为在一般的应用中，可能不止需要一个外设，这里并不是必须的。</p>\n<p>连接到外设后，会调用下面的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">centralManager</span><span class=\"params\">(<span class=\"number\">_</span> central: CBCentralManager, didConnect peripheral: CBPeripheral)</span></span> &#123;</span><br><span class=\"line\">    connectedPeripheral = peripheral</span><br><span class=\"line\">    peripheral.discoverServices(<span class=\"literal\">nil</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    peripheral.delegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(peripheral.name!)</span><br><span class=\"line\">    manager.stopScan()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>去查看已连接外设的服务。参数传 nil 同样是查看所有服务，不加过滤。将连接的外设的代理设为 self，因此需要遵守 <code>CBPeripheralDelegate</code> 协议。</p>\n<p>发现了外设的服务，会调用下面的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">peripheral</span><span class=\"params\">(<span class=\"number\">_</span> peripheral: CBPeripheral, didDiscoverServices error: Error?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> peripheral.services! &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> each.uuid.uuidString == <span class=\"string\">\"FFE0\"</span> &#123;</span><br><span class=\"line\">            peripheral.discoverCharacteristics(<span class=\"literal\">nil</span>, <span class=\"keyword\">for</span>: each)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>遍历外设的所有服务，用 uuid 来判断感兴趣的服务。注意这里的 uuid 是服务的 uuid 而不是外设的 uuid。可以通过下载软件 LightBlue 查看服务的 uuid 码，这里是 FFE0。一旦发现，就去获取该服务的特性（characteristic）。</p>\n<p>发现了特性会调用下面的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">peripheral</span><span class=\"params\">(<span class=\"number\">_</span> peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> each <span class=\"keyword\">in</span> service.characteristics! &#123;</span><br><span class=\"line\">        peripheral.readValue(<span class=\"keyword\">for</span>: each)</span><br><span class=\"line\">        peripheral.setNotifyValue(<span class=\"literal\">true</span>, <span class=\"keyword\">for</span>: each)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>遍历所有的 characteristic，读取它的值并允许接受广播。这样每次 characteristic 的值变化后，都会调用下面的方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">peripheral</span><span class=\"params\">(<span class=\"number\">_</span> peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> str = <span class=\"type\">String</span>(data: characteristic.value!, encoding: .utf8)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(str!)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里把接收到的值转换为字符串，并用 UTF-8 编码。之后把收到的字符串打印出来。</p>\n<h4 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h4><p>用面包线把单片机和蓝牙模块连接好，上电。把程序放到真机上调试，在控制台输出：</p>\n<p><img src=\"/img/screenshotBluetooth.png\" alt=\"screenshotBluetooth\"></p>\n<p>每隔两秒，输出一个数字，且每次加一。这里没有从 0 开始是因为单片机一上电，就自动开始工作了，不会等到蓝牙连接好再往串口上写数据。测试成功。</p>\n<p>今天学习了 CoreBluetooth 的基本概念，并了解了基本的操作流程。可以看到使用 CoreBluetooth 流程比较多，如果不了解基本的概念可能会比较懵。不过总体来说逻辑一层套一层非常严谨，不难理解。接下来我会尝试用蓝牙构建稍复杂的应用。</p>\n"},{"title":"iOS动画学习笔记","date":"2018-05-28T14:51:24.000Z","_content":"\n# iOS 动画学习笔记\n\n这次的主题还有一项是关于一些高级点的动画。\n\n### 转场动画\n\n在这个例子中，我们实现一个通过轻扫手势控制的转场动画。呈现新界面时，会从底部滑动上来；返回时会滑动下去。\n\n```swift\nimport UIKit\n\nclass TransitionAnimator: NSObject, UIViewControllerAnimatedTransitioning {\n    \n    let duration = 0.5\n    \n    var isPresenting = false\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {\n        return duration\n    }\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n        let container = transitionContext.containerView\n        let fromView = transitionContext.view(forKey: .from)!\n        let toView = transitionContext.view(forKey: .to)!\n        container.addSubview(toView)\n        \n        var animation = {}\n       \n        if isPresenting {\n            toView.frame = CGRect(x: 0, y: toView.bounds.height, width: toView.bounds.width, height: toView.bounds.height)\n            animation = {\n                toView.frame = CGRect(x: 0, y: 0, width: toView.bounds.width, height: toView.bounds.height)\n            }\n        } else {\n            toView.frame = CGRect(x: 0, y: -toView.bounds.height, width: toView.bounds.width, height: toView.bounds.height)\n            animation = {\n                toView.frame = CGRect(x: 0, y: 0, width: toView.bounds.width, height: toView.bounds.height)\n            }\n        }\n        \n        UIView.animate(withDuration: duration, animations: {\n            animation()\n        }) { _ in\n            //⚠️注意，这里一定要通知动画完成，否则动画不结束，第二个VC将失去响应。\n            transitionContext.completeTransition(true) \n        }\n        \n    }\n}\n\n\nclass TransViewController: UIViewController, UIViewControllerTransitioningDelegate {\n    \n    let animator = TransitionAnimator()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        view.backgroundColor = UIColor.red\n        \n        \n        let swipe = UISwipeGestureRecognizer(target: self, action: #selector(handleSwipe(sender:)))\n        swipe.direction = .up\n        view.addGestureRecognizer(swipe)\n        \n    }\n\n    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        animator.isPresenting = false\n        return animator\n    }\n    \n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        animator.isPresenting = true\n        return animator\n    }\n    \n    @objc func handleSwipe(sender: UISwipeGestureRecognizer) {\n        let vc = SecondVC()\n        vc.transitioningDelegate = self\n        present(vc, animated: true, completion: nil)\n        \n    }\n\n}\n\nclass SecondVC: UIViewController {\n    \n    override func viewDidLoad() {\n        view.backgroundColor = UIColor.yellow\n        \n        let swipe = UISwipeGestureRecognizer(target: self, action: #selector(handleSwipe(sender:)))\n        swipe.direction = .down\n        view.addGestureRecognizer(swipe)\n    }\n    \n    @objc func handleSwipe(sender: UISwipeGestureRecognizer) {\n        dismiss(animated: true, completion: nil)\n    }\n}\n```\n\n这个例子比较简单，由于是 swipe 手势，因此是不支持交互式转场的。不过苹果也为我们提供了交互式转场动画的 API，可以参见[唐巧大大的博客](https://blog.devtang.com/2016/03/13/iOS-transition-guide/)，或苹果的[官方教程](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1)。\n\n### UIKit 力学\n\n苹果在 iOS7 中将一个轻量级 2D 物理引擎引入到了 UIKit 中，因此我们在 UIKit 中也可以很方便地去实现一些物理效果，而不必使用游戏引擎。\n\nUIDynamic 提供了几种基本的规则：重力、碰撞、锚定、链接等。可以很方便的实现一些用其他方法难以实现的特效。它同样可以和 CollectionView 配合起来，实现一些炫酷的效果。\n\n不过我在使用 UIDynamic 的时候遇到了一点问题：我试图去实现一个弹球的小游戏——用户通过手势拖动底部的横杆，小球碰到横杆会反弹，碰到屏幕边缘同样反弹（就像打砖块那样）。小球一开始可以受到一个方向随机的瞬时推力，产生初始速度。之后，可以通过 override `collisionBoundingPath` 属性来指定小球的碰撞边界是圆形，而不是默认的方形。但是：如何让小球无损地反弹？\n\n```swift\ncollision.translatesReferenceBoundsIntoBoundary = true\n\nlet itemBehavior = UIDynamicItemBehavior(items: [ball])\nitemBehavior.elasticity = 1.0\nanimator.addBehavior(itemBehavior)\n```\n\n我们先让小球遇到 view 的四壁全部反弹，之后，指定碰撞为完全弹性碰撞。这个时候，小球不应该损失任何能量，但是我们可以看到小球还是在碰撞几次之后，速度逐渐减慢了下来。\n\n或许是设置 boundary 的问题？毕竟我们没有给 boundary 设置 elasticity 属性。那我们转变一个思路，使用另一个物体当作边界，并把它锚定：\n\n```swift\nlet floorBehavior = UIDynamicItemBehavior(items: [floor])\nfloorBehavior.elasticity = 1.0\nfloorBehavior.isAnchored = true\nanimator.addBehavior(floorBehavior)\n```\n\n然而效果还是一样的。\n\n这个问题导致我的想法最终失败了。查了一圈，也没有发现解决方案或类似问题。我不知道是还有什么隐藏的 API 我没有发现，或是我的思路是错误的，还是说 UIDynamic 并不支持这样的操作。看来做游戏（哪怕是如此简单的小游戏），还是乖乖用游戏引擎吧！\n\n### 小任务：水波纹进度条\n\n先来看一下效果：\n\n![screenshot](/img/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/screenshot.gif)\n\n过于细节的地方无需赘述，主要讲述一下思路：\n\n首先，我们用 sin 函数来模拟水波纹的形状。我们通过贝塞尔曲线画出几个周期的 sin 函数，这里 dx 取的 0.5，因为步长越小，结果会越精确，但是别忘了屏幕像素是有限的，太过精确只会浪费性能而没有意义：\n\n```swift\nfunc generateWaveLayer() -> CAShapeLayer {\n    let width = self.bounds.width\n    let height = self.bounds.height\n        \n    var currentX: CGFloat = 0.0\n    let dx: CGFloat = 0.5\n    let totalLength = width * 2.0\n        \n    let wavePath = UIBezierPath()\n    wavePath.move(to: CGPoint(x: 0, y: 0))\n    while currentX <= totalLength {\n        let y = 5.0 * sin(currentX * (8.0 * CGFloat.pi / totalLength))\n        wavePath.addLine(to: CGPoint(x: currentX, y: y))\n        currentX += dx\n    }\n        \n    wavePath.addLine(to: CGPoint(x: totalLength, y: height))\n    wavePath.addLine(to: CGPoint(x: 0, y: height))\n    wavePath.close()\n        \n    let waveLayer = CAShapeLayer()\n    waveLayer.path = wavePath.cgPath\n    waveLayer.fillColor = UIColor(red: 30.0/255.0, green: 144.0/255.0, blue: 255.0/255.0, alpha: 1.0).cgColor\n        \n    return waveLayer\n        \n}\n```\n\n我们可以看到，这里的 layer 是比自己的 view 要宽的。这是因为对它做一个无限循环的平移动画就可以模拟水面的波动效果了。由于 sin 是周期函数，所以动画结束瞬间回到原点重复动画在用户看来就是连续的：\n\n```swift\nfunc addWaveAnimation(to animateLayer: CAShapeLayer) {\n    let animation = CABasicAnimation(keyPath: \"position.x\")\n    animation.duration = 3.0\n    animation.fromValue = 0.0\n    animation.toValue = self.bounds.width\n    animation.repeatCount = MAXFLOAT\n        \n    animateLayer.add(animation, forKey: nil)\n}\n```\n\n修改水平面，其实就是在调节 frame.y。但是 layer 是在播放动画的，为了修改 frame 和动画本身产生冲突，我们给这个 layer 单独一个 view ：\n\n```swift\nself.addSubview(visibleView)\nvisibleView.frame = self.bounds\n        \nwaveLayer = generateWaveLayer()\nwaveLayer.frame = CGRect(x: -self.bounds.width, y: 0, width: self.bounds.width * 2.0, height: self.bounds.height)\n        \nvisibleView.layer.addSublayer(waveLayer)\naddWaveAnimation(to: waveLayer)\n```\n\n然后调节 visibleView 的 frame：\n\n```swift\nfunc changeWaterLevel(to relativeLevel: CGFloat) {\n    visibleView.frame = CGRect(x: 0, y: (1.0 - relativeLevel) * self.bounds.height, width: self.bounds.width, height: self.bounds.height)\n}\n```\n\n","source":"_posts/iOS动画学习笔记.md","raw":"---\ntitle: iOS动画学习笔记\ndate: 2018-05-28 22:51:24\ntags: Animation\n---\n\n# iOS 动画学习笔记\n\n这次的主题还有一项是关于一些高级点的动画。\n\n### 转场动画\n\n在这个例子中，我们实现一个通过轻扫手势控制的转场动画。呈现新界面时，会从底部滑动上来；返回时会滑动下去。\n\n```swift\nimport UIKit\n\nclass TransitionAnimator: NSObject, UIViewControllerAnimatedTransitioning {\n    \n    let duration = 0.5\n    \n    var isPresenting = false\n    \n    func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {\n        return duration\n    }\n    \n    func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {\n        let container = transitionContext.containerView\n        let fromView = transitionContext.view(forKey: .from)!\n        let toView = transitionContext.view(forKey: .to)!\n        container.addSubview(toView)\n        \n        var animation = {}\n       \n        if isPresenting {\n            toView.frame = CGRect(x: 0, y: toView.bounds.height, width: toView.bounds.width, height: toView.bounds.height)\n            animation = {\n                toView.frame = CGRect(x: 0, y: 0, width: toView.bounds.width, height: toView.bounds.height)\n            }\n        } else {\n            toView.frame = CGRect(x: 0, y: -toView.bounds.height, width: toView.bounds.width, height: toView.bounds.height)\n            animation = {\n                toView.frame = CGRect(x: 0, y: 0, width: toView.bounds.width, height: toView.bounds.height)\n            }\n        }\n        \n        UIView.animate(withDuration: duration, animations: {\n            animation()\n        }) { _ in\n            //⚠️注意，这里一定要通知动画完成，否则动画不结束，第二个VC将失去响应。\n            transitionContext.completeTransition(true) \n        }\n        \n    }\n}\n\n\nclass TransViewController: UIViewController, UIViewControllerTransitioningDelegate {\n    \n    let animator = TransitionAnimator()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        view.backgroundColor = UIColor.red\n        \n        \n        let swipe = UISwipeGestureRecognizer(target: self, action: #selector(handleSwipe(sender:)))\n        swipe.direction = .up\n        view.addGestureRecognizer(swipe)\n        \n    }\n\n    func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        animator.isPresenting = false\n        return animator\n    }\n    \n    func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {\n        animator.isPresenting = true\n        return animator\n    }\n    \n    @objc func handleSwipe(sender: UISwipeGestureRecognizer) {\n        let vc = SecondVC()\n        vc.transitioningDelegate = self\n        present(vc, animated: true, completion: nil)\n        \n    }\n\n}\n\nclass SecondVC: UIViewController {\n    \n    override func viewDidLoad() {\n        view.backgroundColor = UIColor.yellow\n        \n        let swipe = UISwipeGestureRecognizer(target: self, action: #selector(handleSwipe(sender:)))\n        swipe.direction = .down\n        view.addGestureRecognizer(swipe)\n    }\n    \n    @objc func handleSwipe(sender: UISwipeGestureRecognizer) {\n        dismiss(animated: true, completion: nil)\n    }\n}\n```\n\n这个例子比较简单，由于是 swipe 手势，因此是不支持交互式转场的。不过苹果也为我们提供了交互式转场动画的 API，可以参见[唐巧大大的博客](https://blog.devtang.com/2016/03/13/iOS-transition-guide/)，或苹果的[官方教程](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1)。\n\n### UIKit 力学\n\n苹果在 iOS7 中将一个轻量级 2D 物理引擎引入到了 UIKit 中，因此我们在 UIKit 中也可以很方便地去实现一些物理效果，而不必使用游戏引擎。\n\nUIDynamic 提供了几种基本的规则：重力、碰撞、锚定、链接等。可以很方便的实现一些用其他方法难以实现的特效。它同样可以和 CollectionView 配合起来，实现一些炫酷的效果。\n\n不过我在使用 UIDynamic 的时候遇到了一点问题：我试图去实现一个弹球的小游戏——用户通过手势拖动底部的横杆，小球碰到横杆会反弹，碰到屏幕边缘同样反弹（就像打砖块那样）。小球一开始可以受到一个方向随机的瞬时推力，产生初始速度。之后，可以通过 override `collisionBoundingPath` 属性来指定小球的碰撞边界是圆形，而不是默认的方形。但是：如何让小球无损地反弹？\n\n```swift\ncollision.translatesReferenceBoundsIntoBoundary = true\n\nlet itemBehavior = UIDynamicItemBehavior(items: [ball])\nitemBehavior.elasticity = 1.0\nanimator.addBehavior(itemBehavior)\n```\n\n我们先让小球遇到 view 的四壁全部反弹，之后，指定碰撞为完全弹性碰撞。这个时候，小球不应该损失任何能量，但是我们可以看到小球还是在碰撞几次之后，速度逐渐减慢了下来。\n\n或许是设置 boundary 的问题？毕竟我们没有给 boundary 设置 elasticity 属性。那我们转变一个思路，使用另一个物体当作边界，并把它锚定：\n\n```swift\nlet floorBehavior = UIDynamicItemBehavior(items: [floor])\nfloorBehavior.elasticity = 1.0\nfloorBehavior.isAnchored = true\nanimator.addBehavior(floorBehavior)\n```\n\n然而效果还是一样的。\n\n这个问题导致我的想法最终失败了。查了一圈，也没有发现解决方案或类似问题。我不知道是还有什么隐藏的 API 我没有发现，或是我的思路是错误的，还是说 UIDynamic 并不支持这样的操作。看来做游戏（哪怕是如此简单的小游戏），还是乖乖用游戏引擎吧！\n\n### 小任务：水波纹进度条\n\n先来看一下效果：\n\n![screenshot](/img/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/screenshot.gif)\n\n过于细节的地方无需赘述，主要讲述一下思路：\n\n首先，我们用 sin 函数来模拟水波纹的形状。我们通过贝塞尔曲线画出几个周期的 sin 函数，这里 dx 取的 0.5，因为步长越小，结果会越精确，但是别忘了屏幕像素是有限的，太过精确只会浪费性能而没有意义：\n\n```swift\nfunc generateWaveLayer() -> CAShapeLayer {\n    let width = self.bounds.width\n    let height = self.bounds.height\n        \n    var currentX: CGFloat = 0.0\n    let dx: CGFloat = 0.5\n    let totalLength = width * 2.0\n        \n    let wavePath = UIBezierPath()\n    wavePath.move(to: CGPoint(x: 0, y: 0))\n    while currentX <= totalLength {\n        let y = 5.0 * sin(currentX * (8.0 * CGFloat.pi / totalLength))\n        wavePath.addLine(to: CGPoint(x: currentX, y: y))\n        currentX += dx\n    }\n        \n    wavePath.addLine(to: CGPoint(x: totalLength, y: height))\n    wavePath.addLine(to: CGPoint(x: 0, y: height))\n    wavePath.close()\n        \n    let waveLayer = CAShapeLayer()\n    waveLayer.path = wavePath.cgPath\n    waveLayer.fillColor = UIColor(red: 30.0/255.0, green: 144.0/255.0, blue: 255.0/255.0, alpha: 1.0).cgColor\n        \n    return waveLayer\n        \n}\n```\n\n我们可以看到，这里的 layer 是比自己的 view 要宽的。这是因为对它做一个无限循环的平移动画就可以模拟水面的波动效果了。由于 sin 是周期函数，所以动画结束瞬间回到原点重复动画在用户看来就是连续的：\n\n```swift\nfunc addWaveAnimation(to animateLayer: CAShapeLayer) {\n    let animation = CABasicAnimation(keyPath: \"position.x\")\n    animation.duration = 3.0\n    animation.fromValue = 0.0\n    animation.toValue = self.bounds.width\n    animation.repeatCount = MAXFLOAT\n        \n    animateLayer.add(animation, forKey: nil)\n}\n```\n\n修改水平面，其实就是在调节 frame.y。但是 layer 是在播放动画的，为了修改 frame 和动画本身产生冲突，我们给这个 layer 单独一个 view ：\n\n```swift\nself.addSubview(visibleView)\nvisibleView.frame = self.bounds\n        \nwaveLayer = generateWaveLayer()\nwaveLayer.frame = CGRect(x: -self.bounds.width, y: 0, width: self.bounds.width * 2.0, height: self.bounds.height)\n        \nvisibleView.layer.addSublayer(waveLayer)\naddWaveAnimation(to: waveLayer)\n```\n\n然后调节 visibleView 的 frame：\n\n```swift\nfunc changeWaterLevel(to relativeLevel: CGFloat) {\n    visibleView.frame = CGRect(x: 0, y: (1.0 - relativeLevel) * self.bounds.height, width: self.bounds.width, height: self.bounds.height)\n}\n```\n\n","slug":"iOS动画学习笔记","published":1,"updated":"2020-01-04T08:16:16.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv42003eljc307ygwkrq","content":"<h1 id=\"iOS-动画学习笔记\"><a href=\"#iOS-动画学习笔记\" class=\"headerlink\" title=\"iOS 动画学习笔记\"></a>iOS 动画学习笔记</h1><p>这次的主题还有一项是关于一些高级点的动画。</p>\n<h3 id=\"转场动画\"><a href=\"#转场动画\" class=\"headerlink\" title=\"转场动画\"></a>转场动画</h3><p>在这个例子中，我们实现一个通过轻扫手势控制的转场动画。呈现新界面时，会从底部滑动上来；返回时会滑动下去。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransitionAnimator</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> duration = <span class=\"number\">0.5</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> isPresenting = <span class=\"literal\">false</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transitionDuration</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class=\"type\">TimeInterval</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> duration</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animateTransition</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> container = transitionContext.containerView</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fromView = transitionContext.view(forKey: .from)!</span><br><span class=\"line\">        <span class=\"keyword\">let</span> toView = transitionContext.view(forKey: .to)!</span><br><span class=\"line\">        container.addSubview(toView)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> animation = &#123;&#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> isPresenting &#123;</span><br><span class=\"line\">            toView.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: toView.bounds.height, width: toView.bounds.width, height: toView.bounds.height)</span><br><span class=\"line\">            animation = &#123;</span><br><span class=\"line\">                toView.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: toView.bounds.width, height: toView.bounds.height)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            toView.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: -toView.bounds.height, width: toView.bounds.width, height: toView.bounds.height)</span><br><span class=\"line\">            animation = &#123;</span><br><span class=\"line\">                toView.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: toView.bounds.width, height: toView.bounds.height)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class=\"line\">            animation()</span><br><span class=\"line\">        &#125;) &#123; <span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"comment\">//⚠️注意，这里一定要通知动画完成，否则动画不结束，第二个VC将失去响应。</span></span><br><span class=\"line\">            transitionContext.completeTransition(<span class=\"literal\">true</span>) </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> animator = <span class=\"type\">TransitionAnimator</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> swipe = <span class=\"type\">UISwipeGestureRecognizer</span>(target: <span class=\"keyword\">self</span>, action: #selector(handleSwipe(sender:)))</span><br><span class=\"line\">        swipe.direction = .up</span><br><span class=\"line\">        view.addGestureRecognizer(swipe)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class=\"line\">        animator.isPresenting = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> animator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class=\"line\">        animator.isPresenting = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> animator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleSwipe</span><span class=\"params\">(sender: UISwipeGestureRecognizer)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> vc = <span class=\"type\">SecondVC</span>()</span><br><span class=\"line\">        vc.transitioningDelegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">        present(vc, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondVC</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.yellow</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> swipe = <span class=\"type\">UISwipeGestureRecognizer</span>(target: <span class=\"keyword\">self</span>, action: #selector(handleSwipe(sender:)))</span><br><span class=\"line\">        swipe.direction = .down</span><br><span class=\"line\">        view.addGestureRecognizer(swipe)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleSwipe</span><span class=\"params\">(sender: UISwipeGestureRecognizer)</span></span> &#123;</span><br><span class=\"line\">        dismiss(animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子比较简单，由于是 swipe 手势，因此是不支持交互式转场的。不过苹果也为我们提供了交互式转场动画的 API，可以参见<a href=\"https://blog.devtang.com/2016/03/13/iOS-transition-guide/\">唐巧大大的博客</a>，或苹果的<a href=\"https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1\">官方教程</a>。</p>\n<h3 id=\"UIKit-力学\"><a href=\"#UIKit-力学\" class=\"headerlink\" title=\"UIKit 力学\"></a>UIKit 力学</h3><p>苹果在 iOS7 中将一个轻量级 2D 物理引擎引入到了 UIKit 中，因此我们在 UIKit 中也可以很方便地去实现一些物理效果，而不必使用游戏引擎。</p>\n<p>UIDynamic 提供了几种基本的规则：重力、碰撞、锚定、链接等。可以很方便的实现一些用其他方法难以实现的特效。它同样可以和 CollectionView 配合起来，实现一些炫酷的效果。</p>\n<p>不过我在使用 UIDynamic 的时候遇到了一点问题：我试图去实现一个弹球的小游戏——用户通过手势拖动底部的横杆，小球碰到横杆会反弹，碰到屏幕边缘同样反弹（就像打砖块那样）。小球一开始可以受到一个方向随机的瞬时推力，产生初始速度。之后，可以通过 override <code>collisionBoundingPath</code> 属性来指定小球的碰撞边界是圆形，而不是默认的方形。但是：如何让小球无损地反弹？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collision.translatesReferenceBoundsIntoBoundary = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> itemBehavior = <span class=\"type\">UIDynamicItemBehavior</span>(items: [ball])</span><br><span class=\"line\">itemBehavior.elasticity = <span class=\"number\">1.0</span></span><br><span class=\"line\">animator.addBehavior(itemBehavior)</span><br></pre></td></tr></table></figure>\n<p>我们先让小球遇到 view 的四壁全部反弹，之后，指定碰撞为完全弹性碰撞。这个时候，小球不应该损失任何能量，但是我们可以看到小球还是在碰撞几次之后，速度逐渐减慢了下来。</p>\n<p>或许是设置 boundary 的问题？毕竟我们没有给 boundary 设置 elasticity 属性。那我们转变一个思路，使用另一个物体当作边界，并把它锚定：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> floorBehavior = <span class=\"type\">UIDynamicItemBehavior</span>(items: [floor])</span><br><span class=\"line\">floorBehavior.elasticity = <span class=\"number\">1.0</span></span><br><span class=\"line\">floorBehavior.isAnchored = <span class=\"literal\">true</span></span><br><span class=\"line\">animator.addBehavior(floorBehavior)</span><br></pre></td></tr></table></figure>\n<p>然而效果还是一样的。</p>\n<p>这个问题导致我的想法最终失败了。查了一圈，也没有发现解决方案或类似问题。我不知道是还有什么隐藏的 API 我没有发现，或是我的思路是错误的，还是说 UIDynamic 并不支持这样的操作。看来做游戏（哪怕是如此简单的小游戏），还是乖乖用游戏引擎吧！</p>\n<h3 id=\"小任务：水波纹进度条\"><a href=\"#小任务：水波纹进度条\" class=\"headerlink\" title=\"小任务：水波纹进度条\"></a>小任务：水波纹进度条</h3><p>先来看一下效果：</p>\n<p><img src=\"/img/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/screenshot.gif\" alt=\"screenshot\"></p>\n<p>过于细节的地方无需赘述，主要讲述一下思路：</p>\n<p>首先，我们用 sin 函数来模拟水波纹的形状。我们通过贝塞尔曲线画出几个周期的 sin 函数，这里 dx 取的 0.5，因为步长越小，结果会越精确，但是别忘了屏幕像素是有限的，太过精确只会浪费性能而没有意义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateWaveLayer</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">CAShapeLayer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> width = <span class=\"keyword\">self</span>.bounds.width</span><br><span class=\"line\">    <span class=\"keyword\">let</span> height = <span class=\"keyword\">self</span>.bounds.height</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentX: <span class=\"type\">CGFloat</span> = <span class=\"number\">0.0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> dx: <span class=\"type\">CGFloat</span> = <span class=\"number\">0.5</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> totalLength = width * <span class=\"number\">2.0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">let</span> wavePath = <span class=\"type\">UIBezierPath</span>()</span><br><span class=\"line\">    wavePath.move(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> currentX &lt;= totalLength &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> y = <span class=\"number\">5.0</span> * sin(currentX * (<span class=\"number\">8.0</span> * <span class=\"type\">CGFloat</span>.pi / totalLength))</span><br><span class=\"line\">        wavePath.addLine(to: <span class=\"type\">CGPoint</span>(x: currentX, y: y))</span><br><span class=\"line\">        currentX += dx</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    wavePath.addLine(to: <span class=\"type\">CGPoint</span>(x: totalLength, y: height))</span><br><span class=\"line\">    wavePath.addLine(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">0</span>, y: height))</span><br><span class=\"line\">    wavePath.close()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">let</span> waveLayer = <span class=\"type\">CAShapeLayer</span>()</span><br><span class=\"line\">    waveLayer.path = wavePath.cgPath</span><br><span class=\"line\">    waveLayer.fillColor = <span class=\"type\">UIColor</span>(red: <span class=\"number\">30.0</span>/<span class=\"number\">255.0</span>, green: <span class=\"number\">144.0</span>/<span class=\"number\">255.0</span>, blue: <span class=\"number\">255.0</span>/<span class=\"number\">255.0</span>, alpha: <span class=\"number\">1.0</span>).cgColor</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> waveLayer</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，这里的 layer 是比自己的 view 要宽的。这是因为对它做一个无限循环的平移动画就可以模拟水面的波动效果了。由于 sin 是周期函数，所以动画结束瞬间回到原点重复动画在用户看来就是连续的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addWaveAnimation</span><span class=\"params\">(to animateLayer: CAShapeLayer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> animation = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.x\"</span>)</span><br><span class=\"line\">    animation.duration = <span class=\"number\">3.0</span></span><br><span class=\"line\">    animation.fromValue = <span class=\"number\">0.0</span></span><br><span class=\"line\">    animation.toValue = <span class=\"keyword\">self</span>.bounds.width</span><br><span class=\"line\">    animation.repeatCount = <span class=\"type\">MAXFLOAT</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    animateLayer.add(animation, forKey: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改水平面，其实就是在调节 frame.y。但是 layer 是在播放动画的，为了修改 frame 和动画本身产生冲突，我们给这个 layer 单独一个 view ：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.addSubview(visibleView)</span><br><span class=\"line\">visibleView.frame = <span class=\"keyword\">self</span>.bounds</span><br><span class=\"line\">        </span><br><span class=\"line\">waveLayer = generateWaveLayer()</span><br><span class=\"line\">waveLayer.frame = <span class=\"type\">CGRect</span>(x: -<span class=\"keyword\">self</span>.bounds.width, y: <span class=\"number\">0</span>, width: <span class=\"keyword\">self</span>.bounds.width * <span class=\"number\">2.0</span>, height: <span class=\"keyword\">self</span>.bounds.height)</span><br><span class=\"line\">        </span><br><span class=\"line\">visibleView.layer.addSublayer(waveLayer)</span><br><span class=\"line\">addWaveAnimation(to: waveLayer)</span><br></pre></td></tr></table></figure>\n<p>然后调节 visibleView 的 frame：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">changeWaterLevel</span><span class=\"params\">(to relativeLevel: CGFloat)</span></span> &#123;</span><br><span class=\"line\">    visibleView.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: (<span class=\"number\">1.0</span> - relativeLevel) * <span class=\"keyword\">self</span>.bounds.height, width: <span class=\"keyword\">self</span>.bounds.width, height: <span class=\"keyword\">self</span>.bounds.height)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-动画学习笔记\"><a href=\"#iOS-动画学习笔记\" class=\"headerlink\" title=\"iOS 动画学习笔记\"></a>iOS 动画学习笔记</h1><p>这次的主题还有一项是关于一些高级点的动画。</p>\n<h3 id=\"转场动画\"><a href=\"#转场动画\" class=\"headerlink\" title=\"转场动画\"></a>转场动画</h3><p>在这个例子中，我们实现一个通过轻扫手势控制的转场动画。呈现新界面时，会从底部滑动上来；返回时会滑动下去。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransitionAnimator</span>: <span class=\"title\">NSObject</span>, <span class=\"title\">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> duration = <span class=\"number\">0.5</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> isPresenting = <span class=\"literal\">false</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">transitionDuration</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class=\"type\">TimeInterval</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> duration</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animateTransition</span><span class=\"params\">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> container = transitionContext.containerView</span><br><span class=\"line\">        <span class=\"keyword\">let</span> fromView = transitionContext.view(forKey: .from)!</span><br><span class=\"line\">        <span class=\"keyword\">let</span> toView = transitionContext.view(forKey: .to)!</span><br><span class=\"line\">        container.addSubview(toView)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> animation = &#123;&#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">if</span> isPresenting &#123;</span><br><span class=\"line\">            toView.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: toView.bounds.height, width: toView.bounds.width, height: toView.bounds.height)</span><br><span class=\"line\">            animation = &#123;</span><br><span class=\"line\">                toView.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: toView.bounds.width, height: toView.bounds.height)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            toView.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: -toView.bounds.height, width: toView.bounds.width, height: toView.bounds.height)</span><br><span class=\"line\">            animation = &#123;</span><br><span class=\"line\">                toView.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: toView.bounds.width, height: toView.bounds.height)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">UIView</span>.animate(withDuration: duration, animations: &#123;</span><br><span class=\"line\">            animation()</span><br><span class=\"line\">        &#125;) &#123; <span class=\"number\">_</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"comment\">//⚠️注意，这里一定要通知动画完成，否则动画不结束，第二个VC将失去响应。</span></span><br><span class=\"line\">            transitionContext.completeTransition(<span class=\"literal\">true</span>) </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TransViewController</span>: <span class=\"title\">UIViewController</span>, <span class=\"title\">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">let</span> animator = <span class=\"type\">TransitionAnimator</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.viewDidLoad()</span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.red</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> swipe = <span class=\"type\">UISwipeGestureRecognizer</span>(target: <span class=\"keyword\">self</span>, action: #selector(handleSwipe(sender:)))</span><br><span class=\"line\">        swipe.direction = .up</span><br><span class=\"line\">        view.addGestureRecognizer(swipe)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forDismissed dismissed: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class=\"line\">        animator.isPresenting = <span class=\"literal\">false</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> animator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">animationController</span><span class=\"params\">(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController)</span></span> -&gt; <span class=\"type\">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class=\"line\">        animator.isPresenting = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> animator</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleSwipe</span><span class=\"params\">(sender: UISwipeGestureRecognizer)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> vc = <span class=\"type\">SecondVC</span>()</span><br><span class=\"line\">        vc.transitioningDelegate = <span class=\"keyword\">self</span></span><br><span class=\"line\">        present(vc, animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondVC</span>: <span class=\"title\">UIViewController</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">viewDidLoad</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        view.backgroundColor = <span class=\"type\">UIColor</span>.yellow</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> swipe = <span class=\"type\">UISwipeGestureRecognizer</span>(target: <span class=\"keyword\">self</span>, action: #selector(handleSwipe(sender:)))</span><br><span class=\"line\">        swipe.direction = .down</span><br><span class=\"line\">        view.addGestureRecognizer(swipe)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">handleSwipe</span><span class=\"params\">(sender: UISwipeGestureRecognizer)</span></span> &#123;</span><br><span class=\"line\">        dismiss(animated: <span class=\"literal\">true</span>, completion: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个例子比较简单，由于是 swipe 手势，因此是不支持交互式转场的。不过苹果也为我们提供了交互式转场动画的 API，可以参见<a href=\"https://blog.devtang.com/2016/03/13/iOS-transition-guide/\">唐巧大大的博客</a>，或苹果的<a href=\"https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1\">官方教程</a>。</p>\n<h3 id=\"UIKit-力学\"><a href=\"#UIKit-力学\" class=\"headerlink\" title=\"UIKit 力学\"></a>UIKit 力学</h3><p>苹果在 iOS7 中将一个轻量级 2D 物理引擎引入到了 UIKit 中，因此我们在 UIKit 中也可以很方便地去实现一些物理效果，而不必使用游戏引擎。</p>\n<p>UIDynamic 提供了几种基本的规则：重力、碰撞、锚定、链接等。可以很方便的实现一些用其他方法难以实现的特效。它同样可以和 CollectionView 配合起来，实现一些炫酷的效果。</p>\n<p>不过我在使用 UIDynamic 的时候遇到了一点问题：我试图去实现一个弹球的小游戏——用户通过手势拖动底部的横杆，小球碰到横杆会反弹，碰到屏幕边缘同样反弹（就像打砖块那样）。小球一开始可以受到一个方向随机的瞬时推力，产生初始速度。之后，可以通过 override <code>collisionBoundingPath</code> 属性来指定小球的碰撞边界是圆形，而不是默认的方形。但是：如何让小球无损地反弹？</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collision.translatesReferenceBoundsIntoBoundary = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> itemBehavior = <span class=\"type\">UIDynamicItemBehavior</span>(items: [ball])</span><br><span class=\"line\">itemBehavior.elasticity = <span class=\"number\">1.0</span></span><br><span class=\"line\">animator.addBehavior(itemBehavior)</span><br></pre></td></tr></table></figure>\n<p>我们先让小球遇到 view 的四壁全部反弹，之后，指定碰撞为完全弹性碰撞。这个时候，小球不应该损失任何能量，但是我们可以看到小球还是在碰撞几次之后，速度逐渐减慢了下来。</p>\n<p>或许是设置 boundary 的问题？毕竟我们没有给 boundary 设置 elasticity 属性。那我们转变一个思路，使用另一个物体当作边界，并把它锚定：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> floorBehavior = <span class=\"type\">UIDynamicItemBehavior</span>(items: [floor])</span><br><span class=\"line\">floorBehavior.elasticity = <span class=\"number\">1.0</span></span><br><span class=\"line\">floorBehavior.isAnchored = <span class=\"literal\">true</span></span><br><span class=\"line\">animator.addBehavior(floorBehavior)</span><br></pre></td></tr></table></figure>\n<p>然而效果还是一样的。</p>\n<p>这个问题导致我的想法最终失败了。查了一圈，也没有发现解决方案或类似问题。我不知道是还有什么隐藏的 API 我没有发现，或是我的思路是错误的，还是说 UIDynamic 并不支持这样的操作。看来做游戏（哪怕是如此简单的小游戏），还是乖乖用游戏引擎吧！</p>\n<h3 id=\"小任务：水波纹进度条\"><a href=\"#小任务：水波纹进度条\" class=\"headerlink\" title=\"小任务：水波纹进度条\"></a>小任务：水波纹进度条</h3><p>先来看一下效果：</p>\n<p><img src=\"/img/iOS%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/screenshot.gif\" alt=\"screenshot\"></p>\n<p>过于细节的地方无需赘述，主要讲述一下思路：</p>\n<p>首先，我们用 sin 函数来模拟水波纹的形状。我们通过贝塞尔曲线画出几个周期的 sin 函数，这里 dx 取的 0.5，因为步长越小，结果会越精确，但是别忘了屏幕像素是有限的，太过精确只会浪费性能而没有意义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">generateWaveLayer</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">CAShapeLayer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> width = <span class=\"keyword\">self</span>.bounds.width</span><br><span class=\"line\">    <span class=\"keyword\">let</span> height = <span class=\"keyword\">self</span>.bounds.height</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentX: <span class=\"type\">CGFloat</span> = <span class=\"number\">0.0</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> dx: <span class=\"type\">CGFloat</span> = <span class=\"number\">0.5</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> totalLength = width * <span class=\"number\">2.0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">let</span> wavePath = <span class=\"type\">UIBezierPath</span>()</span><br><span class=\"line\">    wavePath.move(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> currentX &lt;= totalLength &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> y = <span class=\"number\">5.0</span> * sin(currentX * (<span class=\"number\">8.0</span> * <span class=\"type\">CGFloat</span>.pi / totalLength))</span><br><span class=\"line\">        wavePath.addLine(to: <span class=\"type\">CGPoint</span>(x: currentX, y: y))</span><br><span class=\"line\">        currentX += dx</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    wavePath.addLine(to: <span class=\"type\">CGPoint</span>(x: totalLength, y: height))</span><br><span class=\"line\">    wavePath.addLine(to: <span class=\"type\">CGPoint</span>(x: <span class=\"number\">0</span>, y: height))</span><br><span class=\"line\">    wavePath.close()</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">let</span> waveLayer = <span class=\"type\">CAShapeLayer</span>()</span><br><span class=\"line\">    waveLayer.path = wavePath.cgPath</span><br><span class=\"line\">    waveLayer.fillColor = <span class=\"type\">UIColor</span>(red: <span class=\"number\">30.0</span>/<span class=\"number\">255.0</span>, green: <span class=\"number\">144.0</span>/<span class=\"number\">255.0</span>, blue: <span class=\"number\">255.0</span>/<span class=\"number\">255.0</span>, alpha: <span class=\"number\">1.0</span>).cgColor</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">return</span> waveLayer</span><br><span class=\"line\">        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们可以看到，这里的 layer 是比自己的 view 要宽的。这是因为对它做一个无限循环的平移动画就可以模拟水面的波动效果了。由于 sin 是周期函数，所以动画结束瞬间回到原点重复动画在用户看来就是连续的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addWaveAnimation</span><span class=\"params\">(to animateLayer: CAShapeLayer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> animation = <span class=\"type\">CABasicAnimation</span>(keyPath: <span class=\"string\">\"position.x\"</span>)</span><br><span class=\"line\">    animation.duration = <span class=\"number\">3.0</span></span><br><span class=\"line\">    animation.fromValue = <span class=\"number\">0.0</span></span><br><span class=\"line\">    animation.toValue = <span class=\"keyword\">self</span>.bounds.width</span><br><span class=\"line\">    animation.repeatCount = <span class=\"type\">MAXFLOAT</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    animateLayer.add(animation, forKey: <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改水平面，其实就是在调节 frame.y。但是 layer 是在播放动画的，为了修改 frame 和动画本身产生冲突，我们给这个 layer 单独一个 view ：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">self</span>.addSubview(visibleView)</span><br><span class=\"line\">visibleView.frame = <span class=\"keyword\">self</span>.bounds</span><br><span class=\"line\">        </span><br><span class=\"line\">waveLayer = generateWaveLayer()</span><br><span class=\"line\">waveLayer.frame = <span class=\"type\">CGRect</span>(x: -<span class=\"keyword\">self</span>.bounds.width, y: <span class=\"number\">0</span>, width: <span class=\"keyword\">self</span>.bounds.width * <span class=\"number\">2.0</span>, height: <span class=\"keyword\">self</span>.bounds.height)</span><br><span class=\"line\">        </span><br><span class=\"line\">visibleView.layer.addSublayer(waveLayer)</span><br><span class=\"line\">addWaveAnimation(to: waveLayer)</span><br></pre></td></tr></table></figure>\n<p>然后调节 visibleView 的 frame：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">changeWaterLevel</span><span class=\"params\">(to relativeLevel: CGFloat)</span></span> &#123;</span><br><span class=\"line\">    visibleView.frame = <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: (<span class=\"number\">1.0</span> - relativeLevel) * <span class=\"keyword\">self</span>.bounds.height, width: <span class=\"keyword\">self</span>.bounds.width, height: <span class=\"keyword\">self</span>.bounds.height)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"iOS手势学习笔记","date":"2018-05-23T08:20:07.000Z","_content":"\n# iOS 手势学习笔记\n\n这次的主题是手势稍微高级一点的用法。\n\n### GestureRecognizer 的代理方法\n\n`UIGestureRecognizerDelegate ` 中定义了以下方法：\n\n```swift\noptional public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool\n```\n\n当手势识别器的状态试图转换到 `UIGestureRecognizerStatePossible ` 状态时调用，如果 return 了 false，则手势的状态会被转换到失败。\n\n手势识别器的状态机如下图：\n\n![stateMachine](/img/iOS%E6%89%8B%E5%8A%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/stateMachine.png)\n\n```swift\noptional public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool\n```\n\n当两个手势可能会互相阻塞时会调用这个方法。如果返回 true，则两个手势可以同时响应。这个方法默认返回 false，即一般情况下响应了一个手势就不会响应另一个手势了。\n\n需要注意，返回 true 会保证两个手势能被同时响应，而返回 false 不能保证两个手势不能被同时响应。因为另一个手势的代理方法可能会返回 true，即“一真即真”。\n\n```swift\noptional public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer) -> Bool\n```\n\n每次试图去识别的时候都会调用，因此失败依赖可以惰性确定，并且可以设置给跨视图层级的识别器。\n\n与上面的方法类似，因为牵扯到两个识别器，因此还是一真即真。\n\n```swift\noptional public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool\n```\n\n与上面的方法对称。如果返回 true，则在自己 fail 之前，otherGestureRecognizer 不能识别手势，要等待 gestureRecognizer fail 之后才可以。\n\n```swift\noptional public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool\n```\n\n在 `touchesBegan` 之前就会调用，如果返回 false，则会阻止识别器接收 UITouch。\n\n```swift\noptional public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive press: UIPress) -> Bool\n```\n\n与上面类似，会阻止识别器接受 UIPress。\n\n那么 UIPress 是什么？直接 Google UIPress 并没有获得什么有用的资料，说明 UIPress 其实并不常用。苹果自己的文档写得也是让人看不懂，后来是看到了微软 Xamarin 的文档才稍微明白过来……原来它代表了远程控制器或游戏手柄上物理按钮按下的事件。UITouch - 屏幕触摸；UIPress - 按钮按下，名字起得还是可以的。\n\n### 手势冲突怎么办\n\n手势冲突确实是比较棘手的问题，最根本的方法还是尽量避免多个手势叠加在一起。\n\n如果真的有很多相似的手势要同时使用，我们可以使用上面的代理方法，优先识别一些手势，让另外的手势 fail 掉。\n\n还有，如果界面上有非常非常多的 view 需要响应手势，那么与其在每个 view 上都添加手势识别器，不如把要用的几种识别器添加到最底层的 view 上。之后我们自己根据 view 的层级来分发手势，不过要多写一些判断响应者的代码。\n\n### 自定义手势识别器\n\n首先需要注意的是，当你编写一个 UIGestureRecognizer 的子类时，是需要 import 头文件 `UIGestureRecognizerSubclass.h` 的。这个头文件中定义了很可能需要覆写的属性和方法。如果是 Swift：\n\n```swift\nimport UIKit\nimport UIKit.UIGestureRecognizerSubclass\n```\n\n接下来我们需要重写 touchesBegan 等方法，并设置 state 的属性，来控制状态机状态的跳转。下面是实现一个识别画圈的手势识别器的例子：\n\n```swift\nclass CircleGestureRecognizer: UIGestureRecognizer {\n    \n    private var touchSamples = [CGPoint]()\n    private var isCircle = false\n    \n    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {\n        super.touchesBegan(touches, with: event)\n        guard touches.count == 1 else {\n            state = .failed\n            return\n        }\n        state = .began\n    }\n    \n    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent) {\n        super.touchesMoved(touches, with: event)\n        if state == .failed {\n            return\n        }\n        \n        let window = view?.window\n        \n        if let loc = touches.first?.location(in: window) {\n            touchSamples.append(loc)\n            state = .changed\n        }\n        \n    }\n    \n    override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent) {\n        super.touchesEnded(touches, with: event)\n        \n        isCircle = checkCircle()\n        print(isCircle)\n        \n        state = isCircle ? .ended : .failed\n    }\n    \n    override func reset() {\n        super.reset()\n        isCircle = false\n        touchSamples = []\n    }\n    \n    private func checkCircle() -> Bool {\n        guard touchSamples.count > 4 else {\n            return false\n        }\n        let p1 = touchSamples.first!\n        let p2 = touchSamples[touchSamples.count / 4]\n        let p3 = touchSamples[touchSamples.count * 2 / 4]\n        let p4 = touchSamples[touchSamples.count * 3 / 4]\n        \n        let centerX = (p1.x + p2.x + p3.x + p4.x) / 4.0\n        let centerY = (p1.y + p2.y + p3.y + p4.y) / 4.0\n        let center = CGPoint(x: centerX, y: centerY)\n        let radius = (getDistance(from: p1, to: center) + getDistance(from: p2, to: center) + getDistance(from: p3, to: center) + getDistance(from: p4, to: center)) / 4.0\n        \n        var count = 0\n        for point in touchSamples {\n            if abs(getDistance(from: point, to: center) - radius) < 30 {\n                count += 1\n            }\n        }\n\n        return Double(count) / Double(touchSamples.count) > 0.8\n    }\n    \n    private func getDistance(from point: CGPoint, to otherPoint: CGPoint) -> CGFloat {\n        return sqrt((point.x - otherPoint.x) * (point.x - otherPoint.x) + (point.y - otherPoint.y) * (point.y - otherPoint.y))\n    }\n    \n}\n```\n\n这里判定是否是一个圆圈的算法比较简单。只是取了 4 个点，求出它们的平均坐标作为圆心，再求出它们到圆心的平均距离作为半径。接着，检查是否有足够多（大于 80% ）的点到圆心的距离误差小于某个值。当然这样的判断非常粗糙，如果想要达到比较精确的识别效果，应该使用更复杂的算法来做拟合。\n\n### 小任务1：两个ScrollView 联动\n\n最简单的想法肯定是在一个 scrollView 的 didScroll 方法里，把另一个 scrollView 的 offset 设置为和自己一样的值。\n\n```swift\nfunc scrollViewDidScroll(_ scrollView: UIScrollView) {\n    if scrollView == leftScrollView {\n        rightScrollView.contentOffset = leftScrollView.contentOffset\n    }\n}\n```\n\n这当然是一种可行的方法。但是当两个 scrollView 里面的内容不一样多时，就会出现一边还没滑完，另一边已经全部滑出去呈现一片空白的情况。如果需求不允许这样，当然就不行。仅仅是在 didScroll 里面再做限制的话，就会丧失回弹效果。虽然我感觉一般没有这么变态的需求……\n\n但接下来是开脑洞的时间：我们有没有别的方法呢？这里我想说的是，能不能把一个手势同时传递给两个 view 呢？\n\n我的第一反应是，既然触摸事件会从 superView 传递到 subView，那么我只要把第二个 scrollView 作为第一个 scrollView 的子视图，再允许两个手势同时响应就可以了。经过确认，两个 scrollView 确实可以同时响应手势，但由于把 scrollView 添加到另一个 scrollView 上了，它就也会跟着滚动。即它一边自己滚动，一边跟着底部的 scrollView 滚动。那如果我们想把它固定住，就要在 didScroll 方法里修改它的 frame…而且，scrollView 默认是 clipsToBounds 的，如果要让两个 scrollView 平行放置，还要自己去遮挡露出来的 content。这个想法似乎不是很好。\n\n**第二个想法**是，我们还是让两个 scrollView 处于平行层级，利用 OC 强大的动态特性把手势传递过去。\n\n首先，我们要修改右边的 scrollView 的 hitTest 方法，让手指在左边的 scrollView 上滑动时，也能响应手势：\n\n```swift\noverride func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {\n    return self\n}\n```\n\n好了，现在无论在哪里滑动，右边的 scrollView 都能响应了。但是有视图响应手势，手势就不会继续派发给平行的视图了。我们就需要自己传递过去。\n\n我们知道 ScrollView 里面是内置了一个 panGestureRecognizer 的。ScrollView 这些滑动，包括滑动的各种物理效果，肯定也是在这个内置的 panGestureRecognizer 的 target 方法实现的。那么我们把这个 recognizer dump 出来看一下：\n\n```\n- <UIScrollViewPanGestureRecognizer: 0x7ff5df417700; state = Possible; delaysTouchesEnded = NO; view = <GestureAnimation.MyView 0x7ff5e081a400>; target= <(action=handlePan:, target=<GestureAnimation.MyView 0x7ff5e081a400>)>> #0\n  - super: UIPanGestureRecognizer\n    - super: UIGestureRecognizer\n      - super: NSObject\n\n```\n\n可以看到，内置的这个 panGestureRecognizer 的 target 是一个签名为 `handlePan:` 的方法。但这个方法是私有的，因此我们没有办法更改它的逻辑。但是不怕，我们可以通过 method swizzling 把这个方法替换成我们自己的方法。首先由于我们必须要保证方法只被替换一次，因此在 ViewController 里面写，而不要在 ScrollView 的子类 的 init 方法里写，因为替换的是整个类的实例方法，我们的程序中有两个 scrollView，会 init 两次：\n\n```swift\nlet m1 = class_getInstanceMethod(MyView.self, Selector(\"handlePan:\"))\nlet m2 = class_getInstanceMethod(MyView.self, #selector(MyView.myHandlePan(gesture:)))\nmethod_exchangeImplementations(m1!, m2!)\n```\n\n这里的 MyView 是我写的 UITextView 的子类。现在，我们已经把 MyView 的父类 UITextView 的父类 UIScrollView 的 handlePan 方法和我们自己的 myHandlePan 方法替换了。这时如果去滑动 scrollView，会发现它开始调用我们自己的方法了！\n\nUIScrollView 的回弹效果、减速效果等等是非常完美的，我们肯定不希望自己去实现这些效果，因此我们要做的是在我们的 myHandlePan 方法里再去调用原来的 handlePan 方法。这不过，这次我们又要调用右边的 scrollView 的 handlePan，又要调用左边的 handlePan，这样两个 scrollView 就能联动了。\n\n```swift\n@objc func myHandlePan(gesture: UIPanGestureRecognizer) {\n    self.myHandlePan(gesture: gesture)\n    other?.myHandlePan(gesture: gesture) //other 是左边的 scrollView 的引用\n}\n```\n\n诶，这里为什么调用的是 myHandlePan 呢？不应该是通过 performSelector 方法调用 handlePan 吗？这样不会递归吗？别忘了，我们可是交换了 myHandlePan 和 handlePan 的，调用 myHandlePan 其实是在调用原来的 handlePan。\n\n但是这样写是不行的，我们会发现程序 crash 掉了，且完全没有报错信息！这是为什么呢？原来，仅仅标记了 @objc 的函数和属性并不能保证在运行时被调用，因为 swift 会做静态优化。现在，我们通过 dynamic 关键字来让它变成完全动态的：\n\n```swift\n@objc dynamic func myHandlePan(gesture: UIPanGestureRecognizer) {\n    self.myHandlePan(gesture: gesture)\n    other?.myHandlePan(gesture: gesture)\n}\n```\n\n运行程序，我们会发现右边的 scrollView 正常的在滑动，而左边的一动不动！我们费了半天劲却又回到了原点。这是为什么呢？\n\n是因为 other 是 nil 吗？毕竟向 nil 发送消息不会有反应。但我们 print 一下发现 other 并不是 nil。这时，我**猜测**是苹果在实现 handlePan 的时候，做了判断，检查传入的参数是不是与自己内置的 panGestureRecoginzer 一致：\n\n```objective-c\n//我瞎猜的苹果的实现\n- (void)handlePan:(UIPanGestureRecognizer *)sender {\n    if (sender != _panGestureRecognizer) {\n        return;\n    }\n    //...\n}\n```\n\n嗯…苹果爸爸的代码还真是严谨呢。但是没关系，我们把左边的 panGestureRecognizer 属性也换掉就好了，即使它是 get-only 的又何妨，我们有 runtime：\n\n```swift\nleftScrollView.setValue(rightScrollView.panGestureRecognizer, forKey: \"panGestureRecognizer\")\n```\n\n好了，现在运行程序——大功告成！两个 scrollView 完美地联动了！这也说明我上面瞎猜的应该是正确的。用这种方法也算是费尽周折，足足花了我大半天的事件各种调试。不过这波操作还比较骚，我喜欢。\n\n由此可见，OC 的动态特性确实是一件大杀器。不过，调用私有方法确实是不推荐的，除非万不得已，一般不要这样。当未来，UIKit 全部用 Swift 重写后，我们也可能会丧失这把利器吧！看 Swift 自己的 Runtime 怎么实现了。\n\n","source":"_posts/iOS手势学习笔记.md","raw":"---\ntitle: iOS手势学习笔记\ndate: 2018-05-23 16:20:07\ntags: Gesture\n---\n\n# iOS 手势学习笔记\n\n这次的主题是手势稍微高级一点的用法。\n\n### GestureRecognizer 的代理方法\n\n`UIGestureRecognizerDelegate ` 中定义了以下方法：\n\n```swift\noptional public func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -> Bool\n```\n\n当手势识别器的状态试图转换到 `UIGestureRecognizerStatePossible ` 状态时调用，如果 return 了 false，则手势的状态会被转换到失败。\n\n手势识别器的状态机如下图：\n\n![stateMachine](/img/iOS%E6%89%8B%E5%8A%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/stateMachine.png)\n\n```swift\noptional public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -> Bool\n```\n\n当两个手势可能会互相阻塞时会调用这个方法。如果返回 true，则两个手势可以同时响应。这个方法默认返回 false，即一般情况下响应了一个手势就不会响应另一个手势了。\n\n需要注意，返回 true 会保证两个手势能被同时响应，而返回 false 不能保证两个手势不能被同时响应。因为另一个手势的代理方法可能会返回 true，即“一真即真”。\n\n```swift\noptional public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer) -> Bool\n```\n\n每次试图去识别的时候都会调用，因此失败依赖可以惰性确定，并且可以设置给跨视图层级的识别器。\n\n与上面的方法类似，因为牵扯到两个识别器，因此还是一真即真。\n\n```swift\noptional public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -> Bool\n```\n\n与上面的方法对称。如果返回 true，则在自己 fail 之前，otherGestureRecognizer 不能识别手势，要等待 gestureRecognizer fail 之后才可以。\n\n```swift\noptional public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch) -> Bool\n```\n\n在 `touchesBegan` 之前就会调用，如果返回 false，则会阻止识别器接收 UITouch。\n\n```swift\noptional public func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldReceive press: UIPress) -> Bool\n```\n\n与上面类似，会阻止识别器接受 UIPress。\n\n那么 UIPress 是什么？直接 Google UIPress 并没有获得什么有用的资料，说明 UIPress 其实并不常用。苹果自己的文档写得也是让人看不懂，后来是看到了微软 Xamarin 的文档才稍微明白过来……原来它代表了远程控制器或游戏手柄上物理按钮按下的事件。UITouch - 屏幕触摸；UIPress - 按钮按下，名字起得还是可以的。\n\n### 手势冲突怎么办\n\n手势冲突确实是比较棘手的问题，最根本的方法还是尽量避免多个手势叠加在一起。\n\n如果真的有很多相似的手势要同时使用，我们可以使用上面的代理方法，优先识别一些手势，让另外的手势 fail 掉。\n\n还有，如果界面上有非常非常多的 view 需要响应手势，那么与其在每个 view 上都添加手势识别器，不如把要用的几种识别器添加到最底层的 view 上。之后我们自己根据 view 的层级来分发手势，不过要多写一些判断响应者的代码。\n\n### 自定义手势识别器\n\n首先需要注意的是，当你编写一个 UIGestureRecognizer 的子类时，是需要 import 头文件 `UIGestureRecognizerSubclass.h` 的。这个头文件中定义了很可能需要覆写的属性和方法。如果是 Swift：\n\n```swift\nimport UIKit\nimport UIKit.UIGestureRecognizerSubclass\n```\n\n接下来我们需要重写 touchesBegan 等方法，并设置 state 的属性，来控制状态机状态的跳转。下面是实现一个识别画圈的手势识别器的例子：\n\n```swift\nclass CircleGestureRecognizer: UIGestureRecognizer {\n    \n    private var touchSamples = [CGPoint]()\n    private var isCircle = false\n    \n    override func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent) {\n        super.touchesBegan(touches, with: event)\n        guard touches.count == 1 else {\n            state = .failed\n            return\n        }\n        state = .began\n    }\n    \n    override func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent) {\n        super.touchesMoved(touches, with: event)\n        if state == .failed {\n            return\n        }\n        \n        let window = view?.window\n        \n        if let loc = touches.first?.location(in: window) {\n            touchSamples.append(loc)\n            state = .changed\n        }\n        \n    }\n    \n    override func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent) {\n        super.touchesEnded(touches, with: event)\n        \n        isCircle = checkCircle()\n        print(isCircle)\n        \n        state = isCircle ? .ended : .failed\n    }\n    \n    override func reset() {\n        super.reset()\n        isCircle = false\n        touchSamples = []\n    }\n    \n    private func checkCircle() -> Bool {\n        guard touchSamples.count > 4 else {\n            return false\n        }\n        let p1 = touchSamples.first!\n        let p2 = touchSamples[touchSamples.count / 4]\n        let p3 = touchSamples[touchSamples.count * 2 / 4]\n        let p4 = touchSamples[touchSamples.count * 3 / 4]\n        \n        let centerX = (p1.x + p2.x + p3.x + p4.x) / 4.0\n        let centerY = (p1.y + p2.y + p3.y + p4.y) / 4.0\n        let center = CGPoint(x: centerX, y: centerY)\n        let radius = (getDistance(from: p1, to: center) + getDistance(from: p2, to: center) + getDistance(from: p3, to: center) + getDistance(from: p4, to: center)) / 4.0\n        \n        var count = 0\n        for point in touchSamples {\n            if abs(getDistance(from: point, to: center) - radius) < 30 {\n                count += 1\n            }\n        }\n\n        return Double(count) / Double(touchSamples.count) > 0.8\n    }\n    \n    private func getDistance(from point: CGPoint, to otherPoint: CGPoint) -> CGFloat {\n        return sqrt((point.x - otherPoint.x) * (point.x - otherPoint.x) + (point.y - otherPoint.y) * (point.y - otherPoint.y))\n    }\n    \n}\n```\n\n这里判定是否是一个圆圈的算法比较简单。只是取了 4 个点，求出它们的平均坐标作为圆心，再求出它们到圆心的平均距离作为半径。接着，检查是否有足够多（大于 80% ）的点到圆心的距离误差小于某个值。当然这样的判断非常粗糙，如果想要达到比较精确的识别效果，应该使用更复杂的算法来做拟合。\n\n### 小任务1：两个ScrollView 联动\n\n最简单的想法肯定是在一个 scrollView 的 didScroll 方法里，把另一个 scrollView 的 offset 设置为和自己一样的值。\n\n```swift\nfunc scrollViewDidScroll(_ scrollView: UIScrollView) {\n    if scrollView == leftScrollView {\n        rightScrollView.contentOffset = leftScrollView.contentOffset\n    }\n}\n```\n\n这当然是一种可行的方法。但是当两个 scrollView 里面的内容不一样多时，就会出现一边还没滑完，另一边已经全部滑出去呈现一片空白的情况。如果需求不允许这样，当然就不行。仅仅是在 didScroll 里面再做限制的话，就会丧失回弹效果。虽然我感觉一般没有这么变态的需求……\n\n但接下来是开脑洞的时间：我们有没有别的方法呢？这里我想说的是，能不能把一个手势同时传递给两个 view 呢？\n\n我的第一反应是，既然触摸事件会从 superView 传递到 subView，那么我只要把第二个 scrollView 作为第一个 scrollView 的子视图，再允许两个手势同时响应就可以了。经过确认，两个 scrollView 确实可以同时响应手势，但由于把 scrollView 添加到另一个 scrollView 上了，它就也会跟着滚动。即它一边自己滚动，一边跟着底部的 scrollView 滚动。那如果我们想把它固定住，就要在 didScroll 方法里修改它的 frame…而且，scrollView 默认是 clipsToBounds 的，如果要让两个 scrollView 平行放置，还要自己去遮挡露出来的 content。这个想法似乎不是很好。\n\n**第二个想法**是，我们还是让两个 scrollView 处于平行层级，利用 OC 强大的动态特性把手势传递过去。\n\n首先，我们要修改右边的 scrollView 的 hitTest 方法，让手指在左边的 scrollView 上滑动时，也能响应手势：\n\n```swift\noverride func hitTest(_ point: CGPoint, with event: UIEvent?) -> UIView? {\n    return self\n}\n```\n\n好了，现在无论在哪里滑动，右边的 scrollView 都能响应了。但是有视图响应手势，手势就不会继续派发给平行的视图了。我们就需要自己传递过去。\n\n我们知道 ScrollView 里面是内置了一个 panGestureRecognizer 的。ScrollView 这些滑动，包括滑动的各种物理效果，肯定也是在这个内置的 panGestureRecognizer 的 target 方法实现的。那么我们把这个 recognizer dump 出来看一下：\n\n```\n- <UIScrollViewPanGestureRecognizer: 0x7ff5df417700; state = Possible; delaysTouchesEnded = NO; view = <GestureAnimation.MyView 0x7ff5e081a400>; target= <(action=handlePan:, target=<GestureAnimation.MyView 0x7ff5e081a400>)>> #0\n  - super: UIPanGestureRecognizer\n    - super: UIGestureRecognizer\n      - super: NSObject\n\n```\n\n可以看到，内置的这个 panGestureRecognizer 的 target 是一个签名为 `handlePan:` 的方法。但这个方法是私有的，因此我们没有办法更改它的逻辑。但是不怕，我们可以通过 method swizzling 把这个方法替换成我们自己的方法。首先由于我们必须要保证方法只被替换一次，因此在 ViewController 里面写，而不要在 ScrollView 的子类 的 init 方法里写，因为替换的是整个类的实例方法，我们的程序中有两个 scrollView，会 init 两次：\n\n```swift\nlet m1 = class_getInstanceMethod(MyView.self, Selector(\"handlePan:\"))\nlet m2 = class_getInstanceMethod(MyView.self, #selector(MyView.myHandlePan(gesture:)))\nmethod_exchangeImplementations(m1!, m2!)\n```\n\n这里的 MyView 是我写的 UITextView 的子类。现在，我们已经把 MyView 的父类 UITextView 的父类 UIScrollView 的 handlePan 方法和我们自己的 myHandlePan 方法替换了。这时如果去滑动 scrollView，会发现它开始调用我们自己的方法了！\n\nUIScrollView 的回弹效果、减速效果等等是非常完美的，我们肯定不希望自己去实现这些效果，因此我们要做的是在我们的 myHandlePan 方法里再去调用原来的 handlePan 方法。这不过，这次我们又要调用右边的 scrollView 的 handlePan，又要调用左边的 handlePan，这样两个 scrollView 就能联动了。\n\n```swift\n@objc func myHandlePan(gesture: UIPanGestureRecognizer) {\n    self.myHandlePan(gesture: gesture)\n    other?.myHandlePan(gesture: gesture) //other 是左边的 scrollView 的引用\n}\n```\n\n诶，这里为什么调用的是 myHandlePan 呢？不应该是通过 performSelector 方法调用 handlePan 吗？这样不会递归吗？别忘了，我们可是交换了 myHandlePan 和 handlePan 的，调用 myHandlePan 其实是在调用原来的 handlePan。\n\n但是这样写是不行的，我们会发现程序 crash 掉了，且完全没有报错信息！这是为什么呢？原来，仅仅标记了 @objc 的函数和属性并不能保证在运行时被调用，因为 swift 会做静态优化。现在，我们通过 dynamic 关键字来让它变成完全动态的：\n\n```swift\n@objc dynamic func myHandlePan(gesture: UIPanGestureRecognizer) {\n    self.myHandlePan(gesture: gesture)\n    other?.myHandlePan(gesture: gesture)\n}\n```\n\n运行程序，我们会发现右边的 scrollView 正常的在滑动，而左边的一动不动！我们费了半天劲却又回到了原点。这是为什么呢？\n\n是因为 other 是 nil 吗？毕竟向 nil 发送消息不会有反应。但我们 print 一下发现 other 并不是 nil。这时，我**猜测**是苹果在实现 handlePan 的时候，做了判断，检查传入的参数是不是与自己内置的 panGestureRecoginzer 一致：\n\n```objective-c\n//我瞎猜的苹果的实现\n- (void)handlePan:(UIPanGestureRecognizer *)sender {\n    if (sender != _panGestureRecognizer) {\n        return;\n    }\n    //...\n}\n```\n\n嗯…苹果爸爸的代码还真是严谨呢。但是没关系，我们把左边的 panGestureRecognizer 属性也换掉就好了，即使它是 get-only 的又何妨，我们有 runtime：\n\n```swift\nleftScrollView.setValue(rightScrollView.panGestureRecognizer, forKey: \"panGestureRecognizer\")\n```\n\n好了，现在运行程序——大功告成！两个 scrollView 完美地联动了！这也说明我上面瞎猜的应该是正确的。用这种方法也算是费尽周折，足足花了我大半天的事件各种调试。不过这波操作还比较骚，我喜欢。\n\n由此可见，OC 的动态特性确实是一件大杀器。不过，调用私有方法确实是不推荐的，除非万不得已，一般不要这样。当未来，UIKit 全部用 Swift 重写后，我们也可能会丧失这把利器吧！看 Swift 自己的 Runtime 怎么实现了。\n\n","slug":"iOS手势学习笔记","published":1,"updated":"2020-01-04T08:16:16.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv43003hljc3yumtu57y","content":"<h1 id=\"iOS-手势学习笔记\"><a href=\"#iOS-手势学习笔记\" class=\"headerlink\" title=\"iOS 手势学习笔记\"></a>iOS 手势学习笔记</h1><p>这次的主题是手势稍微高级一点的用法。</p>\n<h3 id=\"GestureRecognizer-的代理方法\"><a href=\"#GestureRecognizer-的代理方法\" class=\"headerlink\" title=\"GestureRecognizer 的代理方法\"></a>GestureRecognizer 的代理方法</h3><p><code>UIGestureRecognizerDelegate</code> 中定义了以下方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizerShouldBegin</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>当手势识别器的状态试图转换到 <code>UIGestureRecognizerStatePossible</code> 状态时调用，如果 return 了 false，则手势的状态会被转换到失败。</p>\n<p>手势识别器的状态机如下图：</p>\n<p><img src=\"/img/iOS%E6%89%8B%E5%8A%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/stateMachine.png\" alt=\"stateMachine\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>当两个手势可能会互相阻塞时会调用这个方法。如果返回 true，则两个手势可以同时响应。这个方法默认返回 false，即一般情况下响应了一个手势就不会响应另一个手势了。</p>\n<p>需要注意，返回 true 会保证两个手势能被同时响应，而返回 false 不能保证两个手势不能被同时响应。因为另一个手势的代理方法可能会返回 true，即“一真即真”。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>每次试图去识别的时候都会调用，因此失败依赖可以惰性确定，并且可以设置给跨视图层级的识别器。</p>\n<p>与上面的方法类似，因为牵扯到两个识别器，因此还是一真即真。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>与上面的方法对称。如果返回 true，则在自己 fail 之前，otherGestureRecognizer 不能识别手势，要等待 gestureRecognizer fail 之后才可以。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>在 <code>touchesBegan</code> 之前就会调用，如果返回 false，则会阻止识别器接收 UITouch。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldReceive press: UIPress)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>与上面类似，会阻止识别器接受 UIPress。</p>\n<p>那么 UIPress 是什么？直接 Google UIPress 并没有获得什么有用的资料，说明 UIPress 其实并不常用。苹果自己的文档写得也是让人看不懂，后来是看到了微软 Xamarin 的文档才稍微明白过来……原来它代表了远程控制器或游戏手柄上物理按钮按下的事件。UITouch - 屏幕触摸；UIPress - 按钮按下，名字起得还是可以的。</p>\n<h3 id=\"手势冲突怎么办\"><a href=\"#手势冲突怎么办\" class=\"headerlink\" title=\"手势冲突怎么办\"></a>手势冲突怎么办</h3><p>手势冲突确实是比较棘手的问题，最根本的方法还是尽量避免多个手势叠加在一起。</p>\n<p>如果真的有很多相似的手势要同时使用，我们可以使用上面的代理方法，优先识别一些手势，让另外的手势 fail 掉。</p>\n<p>还有，如果界面上有非常非常多的 view 需要响应手势，那么与其在每个 view 上都添加手势识别器，不如把要用的几种识别器添加到最底层的 view 上。之后我们自己根据 view 的层级来分发手势，不过要多写一些判断响应者的代码。</p>\n<h3 id=\"自定义手势识别器\"><a href=\"#自定义手势识别器\" class=\"headerlink\" title=\"自定义手势识别器\"></a>自定义手势识别器</h3><p>首先需要注意的是，当你编写一个 UIGestureRecognizer 的子类时，是需要 import 头文件 <code>UIGestureRecognizerSubclass.h</code> 的。这个头文件中定义了很可能需要覆写的属性和方法。如果是 Swift：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit.UIGestureRecognizerSubclass</span><br></pre></td></tr></table></figure>\n<p>接下来我们需要重写 touchesBegan 等方法，并设置 state 的属性，来控制状态机状态的跳转。下面是实现一个识别画圈的手势识别器的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CircleGestureRecognizer</span>: <span class=\"title\">UIGestureRecognizer</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> touchSamples = [<span class=\"type\">CGPoint</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> isCircle = <span class=\"literal\">false</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.touchesBegan(touches, with: event)</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> touches.<span class=\"built_in\">count</span> == <span class=\"number\">1</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = .failed</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        state = .began</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesMoved</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.touchesMoved(touches, with: event)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> state == .failed &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> window = view?.window</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> loc = touches.first?.location(<span class=\"keyword\">in</span>: window) &#123;</span><br><span class=\"line\">            touchSamples.append(loc)</span><br><span class=\"line\">            state = .changed</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesEnded</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.touchesEnded(touches, with: event)</span><br><span class=\"line\">        </span><br><span class=\"line\">        isCircle = checkCircle()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(isCircle)</span><br><span class=\"line\">        </span><br><span class=\"line\">        state = isCircle ? .ended : .failed</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reset</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.reset()</span><br><span class=\"line\">        isCircle = <span class=\"literal\">false</span></span><br><span class=\"line\">        touchSamples = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkCircle</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> touchSamples.<span class=\"built_in\">count</span> &gt; <span class=\"number\">4</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p1 = touchSamples.first!</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p2 = touchSamples[touchSamples.<span class=\"built_in\">count</span> / <span class=\"number\">4</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p3 = touchSamples[touchSamples.<span class=\"built_in\">count</span> * <span class=\"number\">2</span> / <span class=\"number\">4</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p4 = touchSamples[touchSamples.<span class=\"built_in\">count</span> * <span class=\"number\">3</span> / <span class=\"number\">4</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> centerX = (p1.x + p2.x + p3.x + p4.x) / <span class=\"number\">4.0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> centerY = (p1.y + p2.y + p3.y + p4.y) / <span class=\"number\">4.0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> center = <span class=\"type\">CGPoint</span>(x: centerX, y: centerY)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> radius = (getDistance(from: p1, to: center) + getDistance(from: p2, to: center) + getDistance(from: p3, to: center) + getDistance(from: p4, to: center)) / <span class=\"number\">4.0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> point <span class=\"keyword\">in</span> touchSamples &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">abs</span>(getDistance(from: point, to: center) - radius) &lt; <span class=\"number\">30</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">count</span> += <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Double</span>(<span class=\"built_in\">count</span>) / <span class=\"type\">Double</span>(touchSamples.<span class=\"built_in\">count</span>) &gt; <span class=\"number\">0.8</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getDistance</span><span class=\"params\">(from point: CGPoint, to otherPoint: CGPoint)</span></span> -&gt; <span class=\"type\">CGFloat</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sqrt((point.x - otherPoint.x) * (point.x - otherPoint.x) + (point.y - otherPoint.y) * (point.y - otherPoint.y))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里判定是否是一个圆圈的算法比较简单。只是取了 4 个点，求出它们的平均坐标作为圆心，再求出它们到圆心的平均距离作为半径。接着，检查是否有足够多（大于 80% ）的点到圆心的距离误差小于某个值。当然这样的判断非常粗糙，如果想要达到比较精确的识别效果，应该使用更复杂的算法来做拟合。</p>\n<h3 id=\"小任务1：两个ScrollView-联动\"><a href=\"#小任务1：两个ScrollView-联动\" class=\"headerlink\" title=\"小任务1：两个ScrollView 联动\"></a>小任务1：两个ScrollView 联动</h3><p>最简单的想法肯定是在一个 scrollView 的 didScroll 方法里，把另一个 scrollView 的 offset 设置为和自己一样的值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">scrollViewDidScroll</span><span class=\"params\">(<span class=\"number\">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> scrollView == leftScrollView &#123;</span><br><span class=\"line\">        rightScrollView.contentOffset = leftScrollView.contentOffset</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这当然是一种可行的方法。但是当两个 scrollView 里面的内容不一样多时，就会出现一边还没滑完，另一边已经全部滑出去呈现一片空白的情况。如果需求不允许这样，当然就不行。仅仅是在 didScroll 里面再做限制的话，就会丧失回弹效果。虽然我感觉一般没有这么变态的需求……</p>\n<p>但接下来是开脑洞的时间：我们有没有别的方法呢？这里我想说的是，能不能把一个手势同时传递给两个 view 呢？</p>\n<p>我的第一反应是，既然触摸事件会从 superView 传递到 subView，那么我只要把第二个 scrollView 作为第一个 scrollView 的子视图，再允许两个手势同时响应就可以了。经过确认，两个 scrollView 确实可以同时响应手势，但由于把 scrollView 添加到另一个 scrollView 上了，它就也会跟着滚动。即它一边自己滚动，一边跟着底部的 scrollView 滚动。那如果我们想把它固定住，就要在 didScroll 方法里修改它的 frame…而且，scrollView 默认是 clipsToBounds 的，如果要让两个 scrollView 平行放置，还要自己去遮挡露出来的 content。这个想法似乎不是很好。</p>\n<p><strong>第二个想法</strong>是，我们还是让两个 scrollView 处于平行层级，利用 OC 强大的动态特性把手势传递过去。</p>\n<p>首先，我们要修改右边的 scrollView 的 hitTest 方法，让手指在左边的 scrollView 上滑动时，也能响应手势：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hitTest</span><span class=\"params\">(<span class=\"number\">_</span> point: CGPoint, with event: UIEvent?)</span></span> -&gt; <span class=\"type\">UIView?</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，现在无论在哪里滑动，右边的 scrollView 都能响应了。但是有视图响应手势，手势就不会继续派发给平行的视图了。我们就需要自己传递过去。</p>\n<p>我们知道 ScrollView 里面是内置了一个 panGestureRecognizer 的。ScrollView 这些滑动，包括滑动的各种物理效果，肯定也是在这个内置的 panGestureRecognizer 的 target 方法实现的。那么我们把这个 recognizer dump 出来看一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- &lt;UIScrollViewPanGestureRecognizer: 0x7ff5df417700; state = Possible; delaysTouchesEnded = NO; view = &lt;GestureAnimation.MyView 0x7ff5e081a400&gt;; target= &lt;(action=handlePan:, target=&lt;GestureAnimation.MyView 0x7ff5e081a400&gt;)&gt;&gt; #0</span><br><span class=\"line\">  - super: UIPanGestureRecognizer</span><br><span class=\"line\">    - super: UIGestureRecognizer</span><br><span class=\"line\">      - super: NSObject</span><br></pre></td></tr></table></figure>\n<p>可以看到，内置的这个 panGestureRecognizer 的 target 是一个签名为 <code>handlePan:</code> 的方法。但这个方法是私有的，因此我们没有办法更改它的逻辑。但是不怕，我们可以通过 method swizzling 把这个方法替换成我们自己的方法。首先由于我们必须要保证方法只被替换一次，因此在 ViewController 里面写，而不要在 ScrollView 的子类 的 init 方法里写，因为替换的是整个类的实例方法，我们的程序中有两个 scrollView，会 init 两次：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> m1 = class_getInstanceMethod(<span class=\"type\">MyView</span>.<span class=\"keyword\">self</span>, <span class=\"type\">Selector</span>(<span class=\"string\">\"handlePan:\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">let</span> m2 = class_getInstanceMethod(<span class=\"type\">MyView</span>.<span class=\"keyword\">self</span>, #selector(<span class=\"type\">MyView</span>.myHandlePan(gesture:)))</span><br><span class=\"line\">method_exchangeImplementations(m1!, m2!)</span><br></pre></td></tr></table></figure>\n<p>这里的 MyView 是我写的 UITextView 的子类。现在，我们已经把 MyView 的父类 UITextView 的父类 UIScrollView 的 handlePan 方法和我们自己的 myHandlePan 方法替换了。这时如果去滑动 scrollView，会发现它开始调用我们自己的方法了！</p>\n<p>UIScrollView 的回弹效果、减速效果等等是非常完美的，我们肯定不希望自己去实现这些效果，因此我们要做的是在我们的 myHandlePan 方法里再去调用原来的 handlePan 方法。这不过，这次我们又要调用右边的 scrollView 的 handlePan，又要调用左边的 handlePan，这样两个 scrollView 就能联动了。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myHandlePan</span><span class=\"params\">(gesture: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.myHandlePan(gesture: gesture)</span><br><span class=\"line\">    other?.myHandlePan(gesture: gesture) <span class=\"comment\">//other 是左边的 scrollView 的引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>诶，这里为什么调用的是 myHandlePan 呢？不应该是通过 performSelector 方法调用 handlePan 吗？这样不会递归吗？别忘了，我们可是交换了 myHandlePan 和 handlePan 的，调用 myHandlePan 其实是在调用原来的 handlePan。</p>\n<p>但是这样写是不行的，我们会发现程序 crash 掉了，且完全没有报错信息！这是为什么呢？原来，仅仅标记了 @objc 的函数和属性并不能保证在运行时被调用，因为 swift 会做静态优化。现在，我们通过 dynamic 关键字来让它变成完全动态的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"keyword\">dynamic</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myHandlePan</span><span class=\"params\">(gesture: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.myHandlePan(gesture: gesture)</span><br><span class=\"line\">    other?.myHandlePan(gesture: gesture)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行程序，我们会发现右边的 scrollView 正常的在滑动，而左边的一动不动！我们费了半天劲却又回到了原点。这是为什么呢？</p>\n<p>是因为 other 是 nil 吗？毕竟向 nil 发送消息不会有反应。但我们 print 一下发现 other 并不是 nil。这时，我<strong>猜测</strong>是苹果在实现 handlePan 的时候，做了判断，检查传入的参数是不是与自己内置的 panGestureRecoginzer 一致：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//我瞎猜的苹果的实现</span><br><span class=\"line\">- (void)handlePan:(UIPanGestureRecognizer *)sender &#123;</span><br><span class=\"line\">    if (sender != _panGestureRecognizer) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嗯…苹果爸爸的代码还真是严谨呢。但是没关系，我们把左边的 panGestureRecognizer 属性也换掉就好了，即使它是 get-only 的又何妨，我们有 runtime：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">leftScrollView.setValue(rightScrollView.panGestureRecognizer, forKey: <span class=\"string\">\"panGestureRecognizer\"</span>)</span><br></pre></td></tr></table></figure>\n<p>好了，现在运行程序——大功告成！两个 scrollView 完美地联动了！这也说明我上面瞎猜的应该是正确的。用这种方法也算是费尽周折，足足花了我大半天的事件各种调试。不过这波操作还比较骚，我喜欢。</p>\n<p>由此可见，OC 的动态特性确实是一件大杀器。不过，调用私有方法确实是不推荐的，除非万不得已，一般不要这样。当未来，UIKit 全部用 Swift 重写后，我们也可能会丧失这把利器吧！看 Swift 自己的 Runtime 怎么实现了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-手势学习笔记\"><a href=\"#iOS-手势学习笔记\" class=\"headerlink\" title=\"iOS 手势学习笔记\"></a>iOS 手势学习笔记</h1><p>这次的主题是手势稍微高级一点的用法。</p>\n<h3 id=\"GestureRecognizer-的代理方法\"><a href=\"#GestureRecognizer-的代理方法\" class=\"headerlink\" title=\"GestureRecognizer 的代理方法\"></a>GestureRecognizer 的代理方法</h3><p><code>UIGestureRecognizerDelegate</code> 中定义了以下方法：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizerShouldBegin</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>当手势识别器的状态试图转换到 <code>UIGestureRecognizerStatePossible</code> 状态时调用，如果 return 了 false，则手势的状态会被转换到失败。</p>\n<p>手势识别器的状态机如下图：</p>\n<p><img src=\"/img/iOS%E6%89%8B%E5%8A%BF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/stateMachine.png\" alt=\"stateMachine\"></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>当两个手势可能会互相阻塞时会调用这个方法。如果返回 true，则两个手势可以同时响应。这个方法默认返回 false，即一般情况下响应了一个手势就不会响应另一个手势了。</p>\n<p>需要注意，返回 true 会保证两个手势能被同时响应，而返回 false 不能保证两个手势不能被同时响应。因为另一个手势的代理方法可能会返回 true，即“一真即真”。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>每次试图去识别的时候都会调用，因此失败依赖可以惰性确定，并且可以设置给跨视图层级的识别器。</p>\n<p>与上面的方法类似，因为牵扯到两个识别器，因此还是一真即真。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>与上面的方法对称。如果返回 true，则在自己 fail 之前，otherGestureRecognizer 不能识别手势，要等待 gestureRecognizer fail 之后才可以。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldReceive touch: UITouch)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>在 <code>touchesBegan</code> 之前就会调用，如果返回 false，则会阻止识别器接收 UITouch。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">optional</span> <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">gestureRecognizer</span><span class=\"params\">(<span class=\"number\">_</span> gestureRecognizer: UIGestureRecognizer, shouldReceive press: UIPress)</span></span> -&gt; <span class=\"type\">Bool</span></span><br></pre></td></tr></table></figure>\n<p>与上面类似，会阻止识别器接受 UIPress。</p>\n<p>那么 UIPress 是什么？直接 Google UIPress 并没有获得什么有用的资料，说明 UIPress 其实并不常用。苹果自己的文档写得也是让人看不懂，后来是看到了微软 Xamarin 的文档才稍微明白过来……原来它代表了远程控制器或游戏手柄上物理按钮按下的事件。UITouch - 屏幕触摸；UIPress - 按钮按下，名字起得还是可以的。</p>\n<h3 id=\"手势冲突怎么办\"><a href=\"#手势冲突怎么办\" class=\"headerlink\" title=\"手势冲突怎么办\"></a>手势冲突怎么办</h3><p>手势冲突确实是比较棘手的问题，最根本的方法还是尽量避免多个手势叠加在一起。</p>\n<p>如果真的有很多相似的手势要同时使用，我们可以使用上面的代理方法，优先识别一些手势，让另外的手势 fail 掉。</p>\n<p>还有，如果界面上有非常非常多的 view 需要响应手势，那么与其在每个 view 上都添加手势识别器，不如把要用的几种识别器添加到最底层的 view 上。之后我们自己根据 view 的层级来分发手势，不过要多写一些判断响应者的代码。</p>\n<h3 id=\"自定义手势识别器\"><a href=\"#自定义手势识别器\" class=\"headerlink\" title=\"自定义手势识别器\"></a>自定义手势识别器</h3><p>首先需要注意的是，当你编写一个 UIGestureRecognizer 的子类时，是需要 import 头文件 <code>UIGestureRecognizerSubclass.h</code> 的。这个头文件中定义了很可能需要覆写的属性和方法。如果是 Swift：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> UIKit.UIGestureRecognizerSubclass</span><br></pre></td></tr></table></figure>\n<p>接下来我们需要重写 touchesBegan 等方法，并设置 state 的属性，来控制状态机状态的跳转。下面是实现一个识别画圈的手势识别器的例子：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CircleGestureRecognizer</span>: <span class=\"title\">UIGestureRecognizer</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> touchSamples = [<span class=\"type\">CGPoint</span>]()</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> isCircle = <span class=\"literal\">false</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesBegan</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.touchesBegan(touches, with: event)</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> touches.<span class=\"built_in\">count</span> == <span class=\"number\">1</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            state = .failed</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        state = .began</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesMoved</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.touchesMoved(touches, with: event)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> state == .failed &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> window = view?.window</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">let</span> loc = touches.first?.location(<span class=\"keyword\">in</span>: window) &#123;</span><br><span class=\"line\">            touchSamples.append(loc)</span><br><span class=\"line\">            state = .changed</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">touchesEnded</span><span class=\"params\">(<span class=\"number\">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent)</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.touchesEnded(touches, with: event)</span><br><span class=\"line\">        </span><br><span class=\"line\">        isCircle = checkCircle()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(isCircle)</span><br><span class=\"line\">        </span><br><span class=\"line\">        state = isCircle ? .ended : .failed</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">reset</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.reset()</span><br><span class=\"line\">        isCircle = <span class=\"literal\">false</span></span><br><span class=\"line\">        touchSamples = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">checkCircle</span><span class=\"params\">()</span></span> -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> touchSamples.<span class=\"built_in\">count</span> &gt; <span class=\"number\">4</span> <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p1 = touchSamples.first!</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p2 = touchSamples[touchSamples.<span class=\"built_in\">count</span> / <span class=\"number\">4</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p3 = touchSamples[touchSamples.<span class=\"built_in\">count</span> * <span class=\"number\">2</span> / <span class=\"number\">4</span>]</span><br><span class=\"line\">        <span class=\"keyword\">let</span> p4 = touchSamples[touchSamples.<span class=\"built_in\">count</span> * <span class=\"number\">3</span> / <span class=\"number\">4</span>]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> centerX = (p1.x + p2.x + p3.x + p4.x) / <span class=\"number\">4.0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> centerY = (p1.y + p2.y + p3.y + p4.y) / <span class=\"number\">4.0</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> center = <span class=\"type\">CGPoint</span>(x: centerX, y: centerY)</span><br><span class=\"line\">        <span class=\"keyword\">let</span> radius = (getDistance(from: p1, to: center) + getDistance(from: p2, to: center) + getDistance(from: p3, to: center) + getDistance(from: p4, to: center)) / <span class=\"number\">4.0</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">count</span> = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> point <span class=\"keyword\">in</span> touchSamples &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">abs</span>(getDistance(from: point, to: center) - radius) &lt; <span class=\"number\">30</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">count</span> += <span class=\"number\">1</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"type\">Double</span>(<span class=\"built_in\">count</span>) / <span class=\"type\">Double</span>(touchSamples.<span class=\"built_in\">count</span>) &gt; <span class=\"number\">0.8</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">getDistance</span><span class=\"params\">(from point: CGPoint, to otherPoint: CGPoint)</span></span> -&gt; <span class=\"type\">CGFloat</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sqrt((point.x - otherPoint.x) * (point.x - otherPoint.x) + (point.y - otherPoint.y) * (point.y - otherPoint.y))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里判定是否是一个圆圈的算法比较简单。只是取了 4 个点，求出它们的平均坐标作为圆心，再求出它们到圆心的平均距离作为半径。接着，检查是否有足够多（大于 80% ）的点到圆心的距离误差小于某个值。当然这样的判断非常粗糙，如果想要达到比较精确的识别效果，应该使用更复杂的算法来做拟合。</p>\n<h3 id=\"小任务1：两个ScrollView-联动\"><a href=\"#小任务1：两个ScrollView-联动\" class=\"headerlink\" title=\"小任务1：两个ScrollView 联动\"></a>小任务1：两个ScrollView 联动</h3><p>最简单的想法肯定是在一个 scrollView 的 didScroll 方法里，把另一个 scrollView 的 offset 设置为和自己一样的值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">scrollViewDidScroll</span><span class=\"params\">(<span class=\"number\">_</span> scrollView: UIScrollView)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> scrollView == leftScrollView &#123;</span><br><span class=\"line\">        rightScrollView.contentOffset = leftScrollView.contentOffset</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这当然是一种可行的方法。但是当两个 scrollView 里面的内容不一样多时，就会出现一边还没滑完，另一边已经全部滑出去呈现一片空白的情况。如果需求不允许这样，当然就不行。仅仅是在 didScroll 里面再做限制的话，就会丧失回弹效果。虽然我感觉一般没有这么变态的需求……</p>\n<p>但接下来是开脑洞的时间：我们有没有别的方法呢？这里我想说的是，能不能把一个手势同时传递给两个 view 呢？</p>\n<p>我的第一反应是，既然触摸事件会从 superView 传递到 subView，那么我只要把第二个 scrollView 作为第一个 scrollView 的子视图，再允许两个手势同时响应就可以了。经过确认，两个 scrollView 确实可以同时响应手势，但由于把 scrollView 添加到另一个 scrollView 上了，它就也会跟着滚动。即它一边自己滚动，一边跟着底部的 scrollView 滚动。那如果我们想把它固定住，就要在 didScroll 方法里修改它的 frame…而且，scrollView 默认是 clipsToBounds 的，如果要让两个 scrollView 平行放置，还要自己去遮挡露出来的 content。这个想法似乎不是很好。</p>\n<p><strong>第二个想法</strong>是，我们还是让两个 scrollView 处于平行层级，利用 OC 强大的动态特性把手势传递过去。</p>\n<p>首先，我们要修改右边的 scrollView 的 hitTest 方法，让手指在左边的 scrollView 上滑动时，也能响应手势：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hitTest</span><span class=\"params\">(<span class=\"number\">_</span> point: CGPoint, with event: UIEvent?)</span></span> -&gt; <span class=\"type\">UIView?</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，现在无论在哪里滑动，右边的 scrollView 都能响应了。但是有视图响应手势，手势就不会继续派发给平行的视图了。我们就需要自己传递过去。</p>\n<p>我们知道 ScrollView 里面是内置了一个 panGestureRecognizer 的。ScrollView 这些滑动，包括滑动的各种物理效果，肯定也是在这个内置的 panGestureRecognizer 的 target 方法实现的。那么我们把这个 recognizer dump 出来看一下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- &lt;UIScrollViewPanGestureRecognizer: 0x7ff5df417700; state = Possible; delaysTouchesEnded = NO; view = &lt;GestureAnimation.MyView 0x7ff5e081a400&gt;; target= &lt;(action=handlePan:, target=&lt;GestureAnimation.MyView 0x7ff5e081a400&gt;)&gt;&gt; #0</span><br><span class=\"line\">  - super: UIPanGestureRecognizer</span><br><span class=\"line\">    - super: UIGestureRecognizer</span><br><span class=\"line\">      - super: NSObject</span><br></pre></td></tr></table></figure>\n<p>可以看到，内置的这个 panGestureRecognizer 的 target 是一个签名为 <code>handlePan:</code> 的方法。但这个方法是私有的，因此我们没有办法更改它的逻辑。但是不怕，我们可以通过 method swizzling 把这个方法替换成我们自己的方法。首先由于我们必须要保证方法只被替换一次，因此在 ViewController 里面写，而不要在 ScrollView 的子类 的 init 方法里写，因为替换的是整个类的实例方法，我们的程序中有两个 scrollView，会 init 两次：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> m1 = class_getInstanceMethod(<span class=\"type\">MyView</span>.<span class=\"keyword\">self</span>, <span class=\"type\">Selector</span>(<span class=\"string\">\"handlePan:\"</span>))</span><br><span class=\"line\"><span class=\"keyword\">let</span> m2 = class_getInstanceMethod(<span class=\"type\">MyView</span>.<span class=\"keyword\">self</span>, #selector(<span class=\"type\">MyView</span>.myHandlePan(gesture:)))</span><br><span class=\"line\">method_exchangeImplementations(m1!, m2!)</span><br></pre></td></tr></table></figure>\n<p>这里的 MyView 是我写的 UITextView 的子类。现在，我们已经把 MyView 的父类 UITextView 的父类 UIScrollView 的 handlePan 方法和我们自己的 myHandlePan 方法替换了。这时如果去滑动 scrollView，会发现它开始调用我们自己的方法了！</p>\n<p>UIScrollView 的回弹效果、减速效果等等是非常完美的，我们肯定不希望自己去实现这些效果，因此我们要做的是在我们的 myHandlePan 方法里再去调用原来的 handlePan 方法。这不过，这次我们又要调用右边的 scrollView 的 handlePan，又要调用左边的 handlePan，这样两个 scrollView 就能联动了。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myHandlePan</span><span class=\"params\">(gesture: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.myHandlePan(gesture: gesture)</span><br><span class=\"line\">    other?.myHandlePan(gesture: gesture) <span class=\"comment\">//other 是左边的 scrollView 的引用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>诶，这里为什么调用的是 myHandlePan 呢？不应该是通过 performSelector 方法调用 handlePan 吗？这样不会递归吗？别忘了，我们可是交换了 myHandlePan 和 handlePan 的，调用 myHandlePan 其实是在调用原来的 handlePan。</p>\n<p>但是这样写是不行的，我们会发现程序 crash 掉了，且完全没有报错信息！这是为什么呢？原来，仅仅标记了 @objc 的函数和属性并不能保证在运行时被调用，因为 swift 会做静态优化。现在，我们通过 dynamic 关键字来让它变成完全动态的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@objc</span> <span class=\"keyword\">dynamic</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myHandlePan</span><span class=\"params\">(gesture: UIPanGestureRecognizer)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.myHandlePan(gesture: gesture)</span><br><span class=\"line\">    other?.myHandlePan(gesture: gesture)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行程序，我们会发现右边的 scrollView 正常的在滑动，而左边的一动不动！我们费了半天劲却又回到了原点。这是为什么呢？</p>\n<p>是因为 other 是 nil 吗？毕竟向 nil 发送消息不会有反应。但我们 print 一下发现 other 并不是 nil。这时，我<strong>猜测</strong>是苹果在实现 handlePan 的时候，做了判断，检查传入的参数是不是与自己内置的 panGestureRecoginzer 一致：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//我瞎猜的苹果的实现</span><br><span class=\"line\">- (void)handlePan:(UIPanGestureRecognizer *)sender &#123;</span><br><span class=\"line\">    if (sender != _panGestureRecognizer) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嗯…苹果爸爸的代码还真是严谨呢。但是没关系，我们把左边的 panGestureRecognizer 属性也换掉就好了，即使它是 get-only 的又何妨，我们有 runtime：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">leftScrollView.setValue(rightScrollView.panGestureRecognizer, forKey: <span class=\"string\">\"panGestureRecognizer\"</span>)</span><br></pre></td></tr></table></figure>\n<p>好了，现在运行程序——大功告成！两个 scrollView 完美地联动了！这也说明我上面瞎猜的应该是正确的。用这种方法也算是费尽周折，足足花了我大半天的事件各种调试。不过这波操作还比较骚，我喜欢。</p>\n<p>由此可见，OC 的动态特性确实是一件大杀器。不过，调用私有方法确实是不推荐的，除非万不得已，一般不要这样。当未来，UIKit 全部用 Swift 重写后，我们也可能会丧失这把利器吧！看 Swift 自己的 Runtime 怎么实现了。</p>\n"},{"title":"iOS多线程学习笔记","date":"2018-04-14T07:44:03.000Z","_content":"\n# iOS 多线程学习笔记\n\n### 线程 vs 进程\n\n线程又被称为轻量进程，是进程中执行运算的最小单位。进程是资源费配的基本单位。一个程序至少拥有一个进程，一个进程至少拥有一个线程。线程拥有自己的堆栈和局部变量，但没有单独的地址空间，而进程的内存是独立的。一个线程崩溃，整个进程都会崩溃。但在操作系统的保护模式下，一个进程崩溃不影响其他进程，因此多进程的程序比多线程的程序及健壮。但是进程上下文切换比线程上下文切换更消耗资源。\n\n为什么会有多线程/多进程呢？因为 CPU 的速度和内存或是其他挂在总线上的设备的速度严重不匹配，CPU 要快得多。人们想要提高资源利用率，于是可以让 CPU 轮流处理多个任务（分时间片）。由于切换速度很快，在用户看来就是并行执行了。只有在 CPU 具有多个核心时，才可能实现真正的多线程。事实上，由于线程数量要远远多于 CPU 核心数（在写这篇文章时，我的电脑运行着 356 个进程，1289 个线程，而我的处理器只有两个核心），实际上还是要轮流处理😉\n\n在 iOS 中，一个正在运行的应用程序就是一个进程。每个程序中可以开启多个线程，以防止阻塞 UI 线程造成卡顿。\n\n### 线程的状态 & 生命周期\n\n当一个线程被 new 出来之后，对它发送 start 信号就会进入就绪（Runnable）状态。线程开启（start）后会被放入可调度线程池中。\n\n当 CPU 调度当前线程时，它会进入运行（Running）状态；当 CPU 转而去调度其他线程，它就又返回就绪状态等待调度。\n\n当调用了 sleep 方法是在等待同步锁时，就进入阻塞（Blocked）状态。阻塞状态时，线程对象会被移出线程池，不可调度。而一旦 sleep 时间到，或者得到同步锁，就又返回就绪状态。\n\n当线程执行完毕，或是出现错误而强制退出时，就进入死亡（Dead）状态。线程对象会被销毁。\n\n### 线程安全\n\n当多个线程对数据进行写操作时，有可能会出现数据不一致的情况。一般来说，我们通过添加同步锁来对数据进行保护，保证每个时刻只有一个线程在操作数据。如果在多线程下，运行结果仍和单线程下一致（或者说符合预期），那么我们就说这是线程安全的。\n\n如果加锁不当，或者是出现了循环依赖、资源竞争等情况，就会出现线程永久阻塞的死锁状态。如果没有外力作用，这些线程永远无法执行下去，在实际使用中一定要避免死锁产生。我们也可以监控死锁，不如设置时限，超时后采取措施解脱死锁状态。\n\niOS 中，有最基本的互斥锁，保证一个线程在访问对象时，其他线程不能访问。还有递归锁，可以解决对一个线程加两次锁时的死锁问题。此外还有根据条件来加锁的条件锁。\n\n```swift\n//对一个线程加两次互斥锁导致的死锁问题\nlet lock = NSLock()\nDispatchQueue.global().async {\n    lock.lock()\n    lock.lock()\n    print(\"deadlock\")\n    lock.unlock()\n    lock.unlock()\n}\n```\n\n这里简单解释下为什么 lock 两次就会死锁。假设这里的互斥锁是用信号量实现的，每次 lock 都会把信号量减一。如果一开始信号量是 1，那么 lock 一次信号量就降低到 0，其他线程就无法执行了。如果再 lock 一次，本线程就又把信号量减 1，同时发现信号量不再大于 0，于是自己也不能执行了。\n\n**多线程引用计数**\n\n由于对象可能在不同的线程被访问，所以引用计数必须是线程安全的。为了保证引用计数的读写操作是原子性的，retain / release / retainCount 都要被加锁。\n\n**atomic**\n\n`atomic` 是 Objective-C 中的一个修饰属性的关键字，意思是原子性的。所谓原子，就是指不可继续划分的最小操作单位。被 atomic 修饰的属性的 getter 和 setter 会被加锁，从而保证了线程安全。\n\natomic 一定是线程安全的吗？可以这么说，但也不能这么说😜首先，atomic 是修饰属性的关键字。如果你的属性是一个指针，比如一个 `NSMutableArray *array` ，它可以保证这个指针的线程安全，但是无法保证指针指向的内存块（数组本身）的线程安全。因为你给指针指向的地址赋值，是和指针自身的 getter 和 setter 没关系的。\n\n还有，就是 `a = a + 1` 这种情况。即使 a 是 int 类型的变量，并且也通过 atomic 关键字给它的 getter 和 setter 加锁。当你在进行 set 时，get 操作也会被阻塞（反之亦然），但是，仍会出现线程不安全的情况。比如，先安全地 get 到了 a，例如 a 的值为 1。之后进行加法运算，即运算 a + 1 = 2。如果在此时其他线程对 a 进行写操作，时不会被阻塞的。而运算完成之后，本线程又回对 a 进行一次写操作，就会出现数据不一致的情况。不过，单纯的对小于 64 位的基本类型数据做读写操作时，即使不加锁也是原子性的。因为 64 位机器的地址总线也是 64 位，读写可以在一次操作中完成。如果大于 64 位，就要分步来完成操作，有可能出现 A 线程写到一半，轮转给 B 线程操作的情况。\n\n既然 atomic 可以一定程度上保证线程安全，那要不要把所有的属性都声明为 atomic 的呢？当然不要，要知道加锁和解锁操作是需要消耗更多资源的，在手机这样性能较弱的嵌入式设备中，除非必要，不然不要声明为 atomic 的。而在 Mac 上面就问题不大了。\n\n**如何封装一个线程安全的字典**\n\n这是大疆的一道面试题。首先我们要知道，字典不是线程安全的：\n\n```swift\nvar dic = [String: Int]()\n\nDispatchQueue.global().async {\n    for _ in 1...10 {\n        dic[\"\\(dic.count)\"] = dic.count\n        NSLog(dic.description)\n    }\n}\n\nDispatchQueue.global().async {\n    for _ in 1...10 {\n        dic[\"\\(dic.count)\"] = dic.count\n        NSLog(dic.description)\n    }\n}\n```\n\n控制台打印的前几行：\n\n```swift\n2018-04-13 15:03:24.053788+0800 test[24651:2363511] [\"0\": 0]\n2018-04-13 15:03:24.053790+0800 test[24651:2363512] [\"0\": 0] \n2018-04-13 15:03:24.054146+0800 test[24651:2363512] [\"0\": 0, \"2\": 2] //缺少1\n2018-04-13 15:03:24.054184+0800 test[24651:2363512] [\"2\": 2, \"0\": 0, \"3\": 3]\n2018-04-13 15:03:24.054245+0800 test[24651:2363512] [\"4\": 4, \"2\": 2, \"0\": 0, \"3\": 3]\n2018-04-13 15:03:24.054254+0800 test[24651:2363511] [\"4\": 4, \"2\": 2, \"0\": 0, \"3\": 3] \n2018-04-13 15:03:24.054281+0800 test[24651:2363512] [\"2\": 2, \"6\": 6, \"4\": 4, \"3\": 3, \"0\": 0] //缺少5\n```\n\n可以看到数据是紊乱的。我们可以通过给 getter 和 setter 加锁或者利用串行队列的方式来封装一个线程安全的字典，下面是一个简单的示例：\n\n```swift\nstruct SafeDictionary<Key, Element> where Key: Hashable {\n    \n    var dictionary = Dictionary<Key, Element>()\n    var lock = NSLock()\n    \n    subscript(keyword: Key) -> Element? {\n        get {\n            lock.lock()\n            let value = dictionary[keyword]\n            lock.unlock()\n            return value\n        }\n        set {\n            guard let newValue = newValue else { return }\n            lock.lock()\n            dictionary[keyword] = newValue\n            lock.unlock()\n        }\n    }\n    \n}\n\nextension SafeDictionary {\n    var count: Int {\n        lock.lock()\n        let value = self.dictionary.count\n        lock.unlock()\n        return value\n    }\n    \n    var description: String {\n        lock.lock()\n        let value = self.dictionary.description\n        lock.unlock()\n        return value\n    }\n}\n```\n\n控制台打印：\n\n```swift\n2018-04-13 15:37:51.041003+0800 test[24761:2390589] [\"0\": 0]\n2018-04-13 15:37:51.041003+0800 test[24761:2390590] [\"0\": 0]\n2018-04-13 15:37:51.041580+0800 test[24761:2390590] [\"0\": 0, \"1\": 1]\n2018-04-13 15:37:51.041620+0800 test[24761:2390590] [\"0\": 0, \"1\": 1, \"2\": 2]\n2018-04-13 15:37:51.041748+0800 test[24761:2390589] [\"4\": 4, \"2\": 2, \"1\": 1, \"0\": 0, \"3\": 3]\n2018-04-13 15:37:51.041791+0800 test[24761:2390589] [\"4\": 4, \"2\": 2, \"1\": 1, \"5\": 5, \"0\": 0, \"3\": 3] //不再缺少某一项\n```\n\n### 线程间通信\n\n再使用多线程时，我们有时希望线程之间能互相传递数据，或是在一个线程中执行完毕任务后，跳到另外一个线程继续执行任务，比如在子线程完成耗时操作后，回到主线程更新 UI。\n\n除了使用 GCD 切换到 main 队列以外，我们也可以通过函数：\n\n```swift\nfunc perform(_ aSelector: Selector, on thr: Thread, with arg: Any?, waitUntilDone wait: Bool, modes array: [String]?)\n```\n\n来让指定的线程执行某个方法。\n\n或者使用 NSMachPort （Mach 音 `mak`）或是 Pipe 来传递消息。如果有更高级的需求，可以使用 socket 来通信。\n\n### MainThreadChecker\n\n检查主线程是否卡顿有多种方法，比如监测 RunLoop 的状态，或是定时向主线程发送 ping 消息，检查主线程是否能及时返回 pong 消息等。我采用了监测主线程 RunLoop 状态变化的方法，思路如下：\n\n我们开启一个子线程，实时读取主线程的 RunLoop 状态。如果当前任务很轻，没有卡顿，那 RunLoop 的状态应该是频繁跳动的。如果没有触发事件，也可能长时间处于休眠状态。我们检测 RunLoop 是否长时间处于 `beforeSources` 或是 `afterWaiting` 状态，如果很长时间都处于这两个状态而得不到更新，就意味着主线程正在处理很繁重的任务，即卡顿了。\n\n下面是一个初步的 demo，有些地方还需要进一步优化：\n\n```swift\nenum BYRunLoopState {\n    case beforeSources\n    case afterWaiting\n    case others\n}\n\nclass BYMainThreadChecker {\n    \n    var runLoopState = BYRunLoopState.others\n    var isChecking = false\n    \n    var runLoopObserver: CFRunLoopObserver?\n    \n    func start() {\n        addObserver()\n        isChecking = true\n        DispatchQueue.global().async {\n            var lastTime = NSDate().timeIntervalSince1970 * 1000\n            while self.isChecking {\n                \n                let currentTime = NSDate().timeIntervalSince1970 * 1000\n                \n                if self.runLoopState == .afterWaiting || self.runLoopState == .beforeSources {\n                    lastTime = currentTime\n                } else {\n                    let dt = currentTime - lastTime\n                    if dt > 50 {\n                        NSLog(\"卡了一下\") \n                        //可以在此时拿到调用栈信息，方便调试。当前发生卡顿会打印消息多次，后期可以做一个优化，单次卡顿只收集一次信息。\n                    }\n                }\n                \n            }\n        }\n    }\n    \n    func stop() {\n        isChecking = false\n        removeObserver()\n    }\n    \n    private func addObserver() {\n        let runLoop = CFRunLoopGetCurrent()\n        \n        let observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, CFRunLoopActivity.allActivities.rawValue, true, 0) { (observer, activity) in\n            if activity == CFRunLoopActivity.beforeSources {\n                self.runLoopState = .beforeSources\n            } else if activity == CFRunLoopActivity.afterWaiting {\n                self.runLoopState = .afterWaiting\n            } else {\n                self.runLoopState = .others\n            }\n        }\n        \n        CFRunLoopAddObserver(runLoop, observer, .commonModes)\n        \n        runLoopObserver = observer\n        \n    }\n    \n    private func removeObserver() {\n        let runLoop = CFRunLoopGetCurrent()\n        CFRunLoopRemoveObserver(runLoop, runLoopObserver, .commonModes)\n    }\n    \n}\n```\n\n\n\n","source":"_posts/iOS多线程学习笔记.md","raw":"---\ntitle: iOS多线程学习笔记\ndate: 2018-04-14 15:44:03\ntags: MultiThreading\n---\n\n# iOS 多线程学习笔记\n\n### 线程 vs 进程\n\n线程又被称为轻量进程，是进程中执行运算的最小单位。进程是资源费配的基本单位。一个程序至少拥有一个进程，一个进程至少拥有一个线程。线程拥有自己的堆栈和局部变量，但没有单独的地址空间，而进程的内存是独立的。一个线程崩溃，整个进程都会崩溃。但在操作系统的保护模式下，一个进程崩溃不影响其他进程，因此多进程的程序比多线程的程序及健壮。但是进程上下文切换比线程上下文切换更消耗资源。\n\n为什么会有多线程/多进程呢？因为 CPU 的速度和内存或是其他挂在总线上的设备的速度严重不匹配，CPU 要快得多。人们想要提高资源利用率，于是可以让 CPU 轮流处理多个任务（分时间片）。由于切换速度很快，在用户看来就是并行执行了。只有在 CPU 具有多个核心时，才可能实现真正的多线程。事实上，由于线程数量要远远多于 CPU 核心数（在写这篇文章时，我的电脑运行着 356 个进程，1289 个线程，而我的处理器只有两个核心），实际上还是要轮流处理😉\n\n在 iOS 中，一个正在运行的应用程序就是一个进程。每个程序中可以开启多个线程，以防止阻塞 UI 线程造成卡顿。\n\n### 线程的状态 & 生命周期\n\n当一个线程被 new 出来之后，对它发送 start 信号就会进入就绪（Runnable）状态。线程开启（start）后会被放入可调度线程池中。\n\n当 CPU 调度当前线程时，它会进入运行（Running）状态；当 CPU 转而去调度其他线程，它就又返回就绪状态等待调度。\n\n当调用了 sleep 方法是在等待同步锁时，就进入阻塞（Blocked）状态。阻塞状态时，线程对象会被移出线程池，不可调度。而一旦 sleep 时间到，或者得到同步锁，就又返回就绪状态。\n\n当线程执行完毕，或是出现错误而强制退出时，就进入死亡（Dead）状态。线程对象会被销毁。\n\n### 线程安全\n\n当多个线程对数据进行写操作时，有可能会出现数据不一致的情况。一般来说，我们通过添加同步锁来对数据进行保护，保证每个时刻只有一个线程在操作数据。如果在多线程下，运行结果仍和单线程下一致（或者说符合预期），那么我们就说这是线程安全的。\n\n如果加锁不当，或者是出现了循环依赖、资源竞争等情况，就会出现线程永久阻塞的死锁状态。如果没有外力作用，这些线程永远无法执行下去，在实际使用中一定要避免死锁产生。我们也可以监控死锁，不如设置时限，超时后采取措施解脱死锁状态。\n\niOS 中，有最基本的互斥锁，保证一个线程在访问对象时，其他线程不能访问。还有递归锁，可以解决对一个线程加两次锁时的死锁问题。此外还有根据条件来加锁的条件锁。\n\n```swift\n//对一个线程加两次互斥锁导致的死锁问题\nlet lock = NSLock()\nDispatchQueue.global().async {\n    lock.lock()\n    lock.lock()\n    print(\"deadlock\")\n    lock.unlock()\n    lock.unlock()\n}\n```\n\n这里简单解释下为什么 lock 两次就会死锁。假设这里的互斥锁是用信号量实现的，每次 lock 都会把信号量减一。如果一开始信号量是 1，那么 lock 一次信号量就降低到 0，其他线程就无法执行了。如果再 lock 一次，本线程就又把信号量减 1，同时发现信号量不再大于 0，于是自己也不能执行了。\n\n**多线程引用计数**\n\n由于对象可能在不同的线程被访问，所以引用计数必须是线程安全的。为了保证引用计数的读写操作是原子性的，retain / release / retainCount 都要被加锁。\n\n**atomic**\n\n`atomic` 是 Objective-C 中的一个修饰属性的关键字，意思是原子性的。所谓原子，就是指不可继续划分的最小操作单位。被 atomic 修饰的属性的 getter 和 setter 会被加锁，从而保证了线程安全。\n\natomic 一定是线程安全的吗？可以这么说，但也不能这么说😜首先，atomic 是修饰属性的关键字。如果你的属性是一个指针，比如一个 `NSMutableArray *array` ，它可以保证这个指针的线程安全，但是无法保证指针指向的内存块（数组本身）的线程安全。因为你给指针指向的地址赋值，是和指针自身的 getter 和 setter 没关系的。\n\n还有，就是 `a = a + 1` 这种情况。即使 a 是 int 类型的变量，并且也通过 atomic 关键字给它的 getter 和 setter 加锁。当你在进行 set 时，get 操作也会被阻塞（反之亦然），但是，仍会出现线程不安全的情况。比如，先安全地 get 到了 a，例如 a 的值为 1。之后进行加法运算，即运算 a + 1 = 2。如果在此时其他线程对 a 进行写操作，时不会被阻塞的。而运算完成之后，本线程又回对 a 进行一次写操作，就会出现数据不一致的情况。不过，单纯的对小于 64 位的基本类型数据做读写操作时，即使不加锁也是原子性的。因为 64 位机器的地址总线也是 64 位，读写可以在一次操作中完成。如果大于 64 位，就要分步来完成操作，有可能出现 A 线程写到一半，轮转给 B 线程操作的情况。\n\n既然 atomic 可以一定程度上保证线程安全，那要不要把所有的属性都声明为 atomic 的呢？当然不要，要知道加锁和解锁操作是需要消耗更多资源的，在手机这样性能较弱的嵌入式设备中，除非必要，不然不要声明为 atomic 的。而在 Mac 上面就问题不大了。\n\n**如何封装一个线程安全的字典**\n\n这是大疆的一道面试题。首先我们要知道，字典不是线程安全的：\n\n```swift\nvar dic = [String: Int]()\n\nDispatchQueue.global().async {\n    for _ in 1...10 {\n        dic[\"\\(dic.count)\"] = dic.count\n        NSLog(dic.description)\n    }\n}\n\nDispatchQueue.global().async {\n    for _ in 1...10 {\n        dic[\"\\(dic.count)\"] = dic.count\n        NSLog(dic.description)\n    }\n}\n```\n\n控制台打印的前几行：\n\n```swift\n2018-04-13 15:03:24.053788+0800 test[24651:2363511] [\"0\": 0]\n2018-04-13 15:03:24.053790+0800 test[24651:2363512] [\"0\": 0] \n2018-04-13 15:03:24.054146+0800 test[24651:2363512] [\"0\": 0, \"2\": 2] //缺少1\n2018-04-13 15:03:24.054184+0800 test[24651:2363512] [\"2\": 2, \"0\": 0, \"3\": 3]\n2018-04-13 15:03:24.054245+0800 test[24651:2363512] [\"4\": 4, \"2\": 2, \"0\": 0, \"3\": 3]\n2018-04-13 15:03:24.054254+0800 test[24651:2363511] [\"4\": 4, \"2\": 2, \"0\": 0, \"3\": 3] \n2018-04-13 15:03:24.054281+0800 test[24651:2363512] [\"2\": 2, \"6\": 6, \"4\": 4, \"3\": 3, \"0\": 0] //缺少5\n```\n\n可以看到数据是紊乱的。我们可以通过给 getter 和 setter 加锁或者利用串行队列的方式来封装一个线程安全的字典，下面是一个简单的示例：\n\n```swift\nstruct SafeDictionary<Key, Element> where Key: Hashable {\n    \n    var dictionary = Dictionary<Key, Element>()\n    var lock = NSLock()\n    \n    subscript(keyword: Key) -> Element? {\n        get {\n            lock.lock()\n            let value = dictionary[keyword]\n            lock.unlock()\n            return value\n        }\n        set {\n            guard let newValue = newValue else { return }\n            lock.lock()\n            dictionary[keyword] = newValue\n            lock.unlock()\n        }\n    }\n    \n}\n\nextension SafeDictionary {\n    var count: Int {\n        lock.lock()\n        let value = self.dictionary.count\n        lock.unlock()\n        return value\n    }\n    \n    var description: String {\n        lock.lock()\n        let value = self.dictionary.description\n        lock.unlock()\n        return value\n    }\n}\n```\n\n控制台打印：\n\n```swift\n2018-04-13 15:37:51.041003+0800 test[24761:2390589] [\"0\": 0]\n2018-04-13 15:37:51.041003+0800 test[24761:2390590] [\"0\": 0]\n2018-04-13 15:37:51.041580+0800 test[24761:2390590] [\"0\": 0, \"1\": 1]\n2018-04-13 15:37:51.041620+0800 test[24761:2390590] [\"0\": 0, \"1\": 1, \"2\": 2]\n2018-04-13 15:37:51.041748+0800 test[24761:2390589] [\"4\": 4, \"2\": 2, \"1\": 1, \"0\": 0, \"3\": 3]\n2018-04-13 15:37:51.041791+0800 test[24761:2390589] [\"4\": 4, \"2\": 2, \"1\": 1, \"5\": 5, \"0\": 0, \"3\": 3] //不再缺少某一项\n```\n\n### 线程间通信\n\n再使用多线程时，我们有时希望线程之间能互相传递数据，或是在一个线程中执行完毕任务后，跳到另外一个线程继续执行任务，比如在子线程完成耗时操作后，回到主线程更新 UI。\n\n除了使用 GCD 切换到 main 队列以外，我们也可以通过函数：\n\n```swift\nfunc perform(_ aSelector: Selector, on thr: Thread, with arg: Any?, waitUntilDone wait: Bool, modes array: [String]?)\n```\n\n来让指定的线程执行某个方法。\n\n或者使用 NSMachPort （Mach 音 `mak`）或是 Pipe 来传递消息。如果有更高级的需求，可以使用 socket 来通信。\n\n### MainThreadChecker\n\n检查主线程是否卡顿有多种方法，比如监测 RunLoop 的状态，或是定时向主线程发送 ping 消息，检查主线程是否能及时返回 pong 消息等。我采用了监测主线程 RunLoop 状态变化的方法，思路如下：\n\n我们开启一个子线程，实时读取主线程的 RunLoop 状态。如果当前任务很轻，没有卡顿，那 RunLoop 的状态应该是频繁跳动的。如果没有触发事件，也可能长时间处于休眠状态。我们检测 RunLoop 是否长时间处于 `beforeSources` 或是 `afterWaiting` 状态，如果很长时间都处于这两个状态而得不到更新，就意味着主线程正在处理很繁重的任务，即卡顿了。\n\n下面是一个初步的 demo，有些地方还需要进一步优化：\n\n```swift\nenum BYRunLoopState {\n    case beforeSources\n    case afterWaiting\n    case others\n}\n\nclass BYMainThreadChecker {\n    \n    var runLoopState = BYRunLoopState.others\n    var isChecking = false\n    \n    var runLoopObserver: CFRunLoopObserver?\n    \n    func start() {\n        addObserver()\n        isChecking = true\n        DispatchQueue.global().async {\n            var lastTime = NSDate().timeIntervalSince1970 * 1000\n            while self.isChecking {\n                \n                let currentTime = NSDate().timeIntervalSince1970 * 1000\n                \n                if self.runLoopState == .afterWaiting || self.runLoopState == .beforeSources {\n                    lastTime = currentTime\n                } else {\n                    let dt = currentTime - lastTime\n                    if dt > 50 {\n                        NSLog(\"卡了一下\") \n                        //可以在此时拿到调用栈信息，方便调试。当前发生卡顿会打印消息多次，后期可以做一个优化，单次卡顿只收集一次信息。\n                    }\n                }\n                \n            }\n        }\n    }\n    \n    func stop() {\n        isChecking = false\n        removeObserver()\n    }\n    \n    private func addObserver() {\n        let runLoop = CFRunLoopGetCurrent()\n        \n        let observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, CFRunLoopActivity.allActivities.rawValue, true, 0) { (observer, activity) in\n            if activity == CFRunLoopActivity.beforeSources {\n                self.runLoopState = .beforeSources\n            } else if activity == CFRunLoopActivity.afterWaiting {\n                self.runLoopState = .afterWaiting\n            } else {\n                self.runLoopState = .others\n            }\n        }\n        \n        CFRunLoopAddObserver(runLoop, observer, .commonModes)\n        \n        runLoopObserver = observer\n        \n    }\n    \n    private func removeObserver() {\n        let runLoop = CFRunLoopGetCurrent()\n        CFRunLoopRemoveObserver(runLoop, runLoopObserver, .commonModes)\n    }\n    \n}\n```\n\n\n\n","slug":"iOS多线程学习笔记","published":1,"updated":"2020-01-04T08:16:16.919Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv44003jljc32m4s4kvk","content":"<h1 id=\"iOS-多线程学习笔记\"><a href=\"#iOS-多线程学习笔记\" class=\"headerlink\" title=\"iOS 多线程学习笔记\"></a>iOS 多线程学习笔记</h1><h3 id=\"线程-vs-进程\"><a href=\"#线程-vs-进程\" class=\"headerlink\" title=\"线程 vs 进程\"></a>线程 vs 进程</h3><p>线程又被称为轻量进程，是进程中执行运算的最小单位。进程是资源费配的基本单位。一个程序至少拥有一个进程，一个进程至少拥有一个线程。线程拥有自己的堆栈和局部变量，但没有单独的地址空间，而进程的内存是独立的。一个线程崩溃，整个进程都会崩溃。但在操作系统的保护模式下，一个进程崩溃不影响其他进程，因此多进程的程序比多线程的程序及健壮。但是进程上下文切换比线程上下文切换更消耗资源。</p>\n<p>为什么会有多线程/多进程呢？因为 CPU 的速度和内存或是其他挂在总线上的设备的速度严重不匹配，CPU 要快得多。人们想要提高资源利用率，于是可以让 CPU 轮流处理多个任务（分时间片）。由于切换速度很快，在用户看来就是并行执行了。只有在 CPU 具有多个核心时，才可能实现真正的多线程。事实上，由于线程数量要远远多于 CPU 核心数（在写这篇文章时，我的电脑运行着 356 个进程，1289 个线程，而我的处理器只有两个核心），实际上还是要轮流处理😉</p>\n<p>在 iOS 中，一个正在运行的应用程序就是一个进程。每个程序中可以开启多个线程，以防止阻塞 UI 线程造成卡顿。</p>\n<h3 id=\"线程的状态-amp-生命周期\"><a href=\"#线程的状态-amp-生命周期\" class=\"headerlink\" title=\"线程的状态 &amp; 生命周期\"></a>线程的状态 &amp; 生命周期</h3><p>当一个线程被 new 出来之后，对它发送 start 信号就会进入就绪（Runnable）状态。线程开启（start）后会被放入可调度线程池中。</p>\n<p>当 CPU 调度当前线程时，它会进入运行（Running）状态；当 CPU 转而去调度其他线程，它就又返回就绪状态等待调度。</p>\n<p>当调用了 sleep 方法是在等待同步锁时，就进入阻塞（Blocked）状态。阻塞状态时，线程对象会被移出线程池，不可调度。而一旦 sleep 时间到，或者得到同步锁，就又返回就绪状态。</p>\n<p>当线程执行完毕，或是出现错误而强制退出时，就进入死亡（Dead）状态。线程对象会被销毁。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>当多个线程对数据进行写操作时，有可能会出现数据不一致的情况。一般来说，我们通过添加同步锁来对数据进行保护，保证每个时刻只有一个线程在操作数据。如果在多线程下，运行结果仍和单线程下一致（或者说符合预期），那么我们就说这是线程安全的。</p>\n<p>如果加锁不当，或者是出现了循环依赖、资源竞争等情况，就会出现线程永久阻塞的死锁状态。如果没有外力作用，这些线程永远无法执行下去，在实际使用中一定要避免死锁产生。我们也可以监控死锁，不如设置时限，超时后采取措施解脱死锁状态。</p>\n<p>iOS 中，有最基本的互斥锁，保证一个线程在访问对象时，其他线程不能访问。还有递归锁，可以解决对一个线程加两次锁时的死锁问题。此外还有根据条件来加锁的条件锁。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对一个线程加两次互斥锁导致的死锁问题</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> lock = <span class=\"type\">NSLock</span>()</span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    lock.lock()</span><br><span class=\"line\">    lock.lock()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"deadlock\"</span>)</span><br><span class=\"line\">    lock.unlock()</span><br><span class=\"line\">    lock.unlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里简单解释下为什么 lock 两次就会死锁。假设这里的互斥锁是用信号量实现的，每次 lock 都会把信号量减一。如果一开始信号量是 1，那么 lock 一次信号量就降低到 0，其他线程就无法执行了。如果再 lock 一次，本线程就又把信号量减 1，同时发现信号量不再大于 0，于是自己也不能执行了。</p>\n<p><strong>多线程引用计数</strong></p>\n<p>由于对象可能在不同的线程被访问，所以引用计数必须是线程安全的。为了保证引用计数的读写操作是原子性的，retain / release / retainCount 都要被加锁。</p>\n<p><strong>atomic</strong></p>\n<p><code>atomic</code> 是 Objective-C 中的一个修饰属性的关键字，意思是原子性的。所谓原子，就是指不可继续划分的最小操作单位。被 atomic 修饰的属性的 getter 和 setter 会被加锁，从而保证了线程安全。</p>\n<p>atomic 一定是线程安全的吗？可以这么说，但也不能这么说😜首先，atomic 是修饰属性的关键字。如果你的属性是一个指针，比如一个 <code>NSMutableArray *array</code> ，它可以保证这个指针的线程安全，但是无法保证指针指向的内存块（数组本身）的线程安全。因为你给指针指向的地址赋值，是和指针自身的 getter 和 setter 没关系的。</p>\n<p>还有，就是 <code>a = a + 1</code> 这种情况。即使 a 是 int 类型的变量，并且也通过 atomic 关键字给它的 getter 和 setter 加锁。当你在进行 set 时，get 操作也会被阻塞（反之亦然），但是，仍会出现线程不安全的情况。比如，先安全地 get 到了 a，例如 a 的值为 1。之后进行加法运算，即运算 a + 1 = 2。如果在此时其他线程对 a 进行写操作，时不会被阻塞的。而运算完成之后，本线程又回对 a 进行一次写操作，就会出现数据不一致的情况。不过，单纯的对小于 64 位的基本类型数据做读写操作时，即使不加锁也是原子性的。因为 64 位机器的地址总线也是 64 位，读写可以在一次操作中完成。如果大于 64 位，就要分步来完成操作，有可能出现 A 线程写到一半，轮转给 B 线程操作的情况。</p>\n<p>既然 atomic 可以一定程度上保证线程安全，那要不要把所有的属性都声明为 atomic 的呢？当然不要，要知道加锁和解锁操作是需要消耗更多资源的，在手机这样性能较弱的嵌入式设备中，除非必要，不然不要声明为 atomic 的。而在 Mac 上面就问题不大了。</p>\n<p><strong>如何封装一个线程安全的字典</strong></p>\n<p>这是大疆的一道面试题。首先我们要知道，字典不是线程安全的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dic = [<span class=\"type\">String</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">        dic[<span class=\"string\">\"\\(dic.count)\"</span>] = dic.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(dic.description)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">        dic[<span class=\"string\">\"\\(dic.count)\"</span>] = dic.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(dic.description)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台打印的前几行：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.053788</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363511</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.053790</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363512</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>] </span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.054146</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363512</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>] <span class=\"comment\">//缺少1</span></span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.054184</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363512</span>] [<span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.054245</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363512</span>] [<span class=\"string\">\"4\"</span>: <span class=\"number\">4</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.054254</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363511</span>] [<span class=\"string\">\"4\"</span>: <span class=\"number\">4</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>] </span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.054281</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363512</span>] [<span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"6\"</span>: <span class=\"number\">6</span>, <span class=\"string\">\"4\"</span>: <span class=\"number\">4</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>] <span class=\"comment\">//缺少5</span></span><br></pre></td></tr></table></figure>\n<p>可以看到数据是紊乱的。我们可以通过给 getter 和 setter 加锁或者利用串行队列的方式来封装一个线程安全的字典，下面是一个简单的示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SafeDictionary</span>&lt;<span class=\"title\">Key</span>, <span class=\"title\">Element</span>&gt; <span class=\"title\">where</span> <span class=\"title\">Key</span>: <span class=\"title\">Hashable</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> dictionary = <span class=\"type\">Dictionary</span>&lt;<span class=\"type\">Key</span>, <span class=\"type\">Element</span>&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lock = <span class=\"type\">NSLock</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">subscript</span>(keyword: <span class=\"type\">Key</span>) -&gt; <span class=\"type\">Element?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            lock.lock()</span><br><span class=\"line\">            <span class=\"keyword\">let</span> value = dictionary[keyword]</span><br><span class=\"line\">            lock.unlock()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> newValue = newValue <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\">            lock.lock()</span><br><span class=\"line\">            dictionary[keyword] = newValue</span><br><span class=\"line\">            lock.unlock()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">SafeDictionary</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        lock.lock()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = <span class=\"keyword\">self</span>.dictionary.<span class=\"built_in\">count</span></span><br><span class=\"line\">        lock.unlock()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        lock.lock()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = <span class=\"keyword\">self</span>.dictionary.description</span><br><span class=\"line\">        lock.unlock()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台打印：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041003</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390589</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041003</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390590</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041580</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390590</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"1\"</span>: <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041620</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390590</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"1\"</span>: <span class=\"number\">1</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041748</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390589</span>] [<span class=\"string\">\"4\"</span>: <span class=\"number\">4</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"1\"</span>: <span class=\"number\">1</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041791</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390589</span>] [<span class=\"string\">\"4\"</span>: <span class=\"number\">4</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"1\"</span>: <span class=\"number\">1</span>, <span class=\"string\">\"5\"</span>: <span class=\"number\">5</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>] <span class=\"comment\">//不再缺少某一项</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h3><p>再使用多线程时，我们有时希望线程之间能互相传递数据，或是在一个线程中执行完毕任务后，跳到另外一个线程继续执行任务，比如在子线程完成耗时操作后，回到主线程更新 UI。</p>\n<p>除了使用 GCD 切换到 main 队列以外，我们也可以通过函数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">perform</span><span class=\"params\">(<span class=\"number\">_</span> aSelector: Selector, on thr: Thread, with arg: <span class=\"keyword\">Any</span>?, waitUntilDone wait: Bool, modes array: [String]?)</span></span></span><br></pre></td></tr></table></figure>\n<p>来让指定的线程执行某个方法。</p>\n<p>或者使用 NSMachPort （Mach 音 <code>mak</code>）或是 Pipe 来传递消息。如果有更高级的需求，可以使用 socket 来通信。</p>\n<h3 id=\"MainThreadChecker\"><a href=\"#MainThreadChecker\" class=\"headerlink\" title=\"MainThreadChecker\"></a>MainThreadChecker</h3><p>检查主线程是否卡顿有多种方法，比如监测 RunLoop 的状态，或是定时向主线程发送 ping 消息，检查主线程是否能及时返回 pong 消息等。我采用了监测主线程 RunLoop 状态变化的方法，思路如下：</p>\n<p>我们开启一个子线程，实时读取主线程的 RunLoop 状态。如果当前任务很轻，没有卡顿，那 RunLoop 的状态应该是频繁跳动的。如果没有触发事件，也可能长时间处于休眠状态。我们检测 RunLoop 是否长时间处于 <code>beforeSources</code> 或是 <code>afterWaiting</code> 状态，如果很长时间都处于这两个状态而得不到更新，就意味着主线程正在处理很繁重的任务，即卡顿了。</p>\n<p>下面是一个初步的 demo，有些地方还需要进一步优化：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">BYRunLoopState</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> beforeSources</span><br><span class=\"line\">    <span class=\"keyword\">case</span> afterWaiting</span><br><span class=\"line\">    <span class=\"keyword\">case</span> others</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BYMainThreadChecker</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> runLoopState = <span class=\"type\">BYRunLoopState</span>.others</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isChecking = <span class=\"literal\">false</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> runLoopObserver: <span class=\"type\">CFRunLoopObserver?</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">start</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        addObserver()</span><br><span class=\"line\">        isChecking = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> lastTime = <span class=\"type\">NSDate</span>().timeIntervalSince1970 * <span class=\"number\">1000</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"keyword\">self</span>.isChecking &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">let</span> currentTime = <span class=\"type\">NSDate</span>().timeIntervalSince1970 * <span class=\"number\">1000</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.runLoopState == .afterWaiting || <span class=\"keyword\">self</span>.runLoopState == .beforeSources &#123;</span><br><span class=\"line\">                    lastTime = currentTime</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">let</span> dt = currentTime - lastTime</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> dt &gt; <span class=\"number\">50</span> &#123;</span><br><span class=\"line\">                        <span class=\"type\">NSLog</span>(<span class=\"string\">\"卡了一下\"</span>) </span><br><span class=\"line\">                        <span class=\"comment\">//可以在此时拿到调用栈信息，方便调试。当前发生卡顿会打印消息多次，后期可以做一个优化，单次卡顿只收集一次信息。</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        isChecking = <span class=\"literal\">false</span></span><br><span class=\"line\">        removeObserver()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addObserver</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> runLoop = <span class=\"type\">CFRunLoopGetCurrent</span>()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> observer = <span class=\"type\">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, <span class=\"type\">CFRunLoopActivity</span>.allActivities.rawValue, <span class=\"literal\">true</span>, <span class=\"number\">0</span>) &#123; (observer, activity) <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> activity == <span class=\"type\">CFRunLoopActivity</span>.beforeSources &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.runLoopState = .beforeSources</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> activity == <span class=\"type\">CFRunLoopActivity</span>.afterWaiting &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.runLoopState = .afterWaiting</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.runLoopState = .others</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">CFRunLoopAddObserver</span>(runLoop, observer, .commonModes)</span><br><span class=\"line\">        </span><br><span class=\"line\">        runLoopObserver = observer</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">removeObserver</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> runLoop = <span class=\"type\">CFRunLoopGetCurrent</span>()</span><br><span class=\"line\">        <span class=\"type\">CFRunLoopRemoveObserver</span>(runLoop, runLoopObserver, .commonModes)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS-多线程学习笔记\"><a href=\"#iOS-多线程学习笔记\" class=\"headerlink\" title=\"iOS 多线程学习笔记\"></a>iOS 多线程学习笔记</h1><h3 id=\"线程-vs-进程\"><a href=\"#线程-vs-进程\" class=\"headerlink\" title=\"线程 vs 进程\"></a>线程 vs 进程</h3><p>线程又被称为轻量进程，是进程中执行运算的最小单位。进程是资源费配的基本单位。一个程序至少拥有一个进程，一个进程至少拥有一个线程。线程拥有自己的堆栈和局部变量，但没有单独的地址空间，而进程的内存是独立的。一个线程崩溃，整个进程都会崩溃。但在操作系统的保护模式下，一个进程崩溃不影响其他进程，因此多进程的程序比多线程的程序及健壮。但是进程上下文切换比线程上下文切换更消耗资源。</p>\n<p>为什么会有多线程/多进程呢？因为 CPU 的速度和内存或是其他挂在总线上的设备的速度严重不匹配，CPU 要快得多。人们想要提高资源利用率，于是可以让 CPU 轮流处理多个任务（分时间片）。由于切换速度很快，在用户看来就是并行执行了。只有在 CPU 具有多个核心时，才可能实现真正的多线程。事实上，由于线程数量要远远多于 CPU 核心数（在写这篇文章时，我的电脑运行着 356 个进程，1289 个线程，而我的处理器只有两个核心），实际上还是要轮流处理😉</p>\n<p>在 iOS 中，一个正在运行的应用程序就是一个进程。每个程序中可以开启多个线程，以防止阻塞 UI 线程造成卡顿。</p>\n<h3 id=\"线程的状态-amp-生命周期\"><a href=\"#线程的状态-amp-生命周期\" class=\"headerlink\" title=\"线程的状态 &amp; 生命周期\"></a>线程的状态 &amp; 生命周期</h3><p>当一个线程被 new 出来之后，对它发送 start 信号就会进入就绪（Runnable）状态。线程开启（start）后会被放入可调度线程池中。</p>\n<p>当 CPU 调度当前线程时，它会进入运行（Running）状态；当 CPU 转而去调度其他线程，它就又返回就绪状态等待调度。</p>\n<p>当调用了 sleep 方法是在等待同步锁时，就进入阻塞（Blocked）状态。阻塞状态时，线程对象会被移出线程池，不可调度。而一旦 sleep 时间到，或者得到同步锁，就又返回就绪状态。</p>\n<p>当线程执行完毕，或是出现错误而强制退出时，就进入死亡（Dead）状态。线程对象会被销毁。</p>\n<h3 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h3><p>当多个线程对数据进行写操作时，有可能会出现数据不一致的情况。一般来说，我们通过添加同步锁来对数据进行保护，保证每个时刻只有一个线程在操作数据。如果在多线程下，运行结果仍和单线程下一致（或者说符合预期），那么我们就说这是线程安全的。</p>\n<p>如果加锁不当，或者是出现了循环依赖、资源竞争等情况，就会出现线程永久阻塞的死锁状态。如果没有外力作用，这些线程永远无法执行下去，在实际使用中一定要避免死锁产生。我们也可以监控死锁，不如设置时限，超时后采取措施解脱死锁状态。</p>\n<p>iOS 中，有最基本的互斥锁，保证一个线程在访问对象时，其他线程不能访问。还有递归锁，可以解决对一个线程加两次锁时的死锁问题。此外还有根据条件来加锁的条件锁。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对一个线程加两次互斥锁导致的死锁问题</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> lock = <span class=\"type\">NSLock</span>()</span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    lock.lock()</span><br><span class=\"line\">    lock.lock()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">\"deadlock\"</span>)</span><br><span class=\"line\">    lock.unlock()</span><br><span class=\"line\">    lock.unlock()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里简单解释下为什么 lock 两次就会死锁。假设这里的互斥锁是用信号量实现的，每次 lock 都会把信号量减一。如果一开始信号量是 1，那么 lock 一次信号量就降低到 0，其他线程就无法执行了。如果再 lock 一次，本线程就又把信号量减 1，同时发现信号量不再大于 0，于是自己也不能执行了。</p>\n<p><strong>多线程引用计数</strong></p>\n<p>由于对象可能在不同的线程被访问，所以引用计数必须是线程安全的。为了保证引用计数的读写操作是原子性的，retain / release / retainCount 都要被加锁。</p>\n<p><strong>atomic</strong></p>\n<p><code>atomic</code> 是 Objective-C 中的一个修饰属性的关键字，意思是原子性的。所谓原子，就是指不可继续划分的最小操作单位。被 atomic 修饰的属性的 getter 和 setter 会被加锁，从而保证了线程安全。</p>\n<p>atomic 一定是线程安全的吗？可以这么说，但也不能这么说😜首先，atomic 是修饰属性的关键字。如果你的属性是一个指针，比如一个 <code>NSMutableArray *array</code> ，它可以保证这个指针的线程安全，但是无法保证指针指向的内存块（数组本身）的线程安全。因为你给指针指向的地址赋值，是和指针自身的 getter 和 setter 没关系的。</p>\n<p>还有，就是 <code>a = a + 1</code> 这种情况。即使 a 是 int 类型的变量，并且也通过 atomic 关键字给它的 getter 和 setter 加锁。当你在进行 set 时，get 操作也会被阻塞（反之亦然），但是，仍会出现线程不安全的情况。比如，先安全地 get 到了 a，例如 a 的值为 1。之后进行加法运算，即运算 a + 1 = 2。如果在此时其他线程对 a 进行写操作，时不会被阻塞的。而运算完成之后，本线程又回对 a 进行一次写操作，就会出现数据不一致的情况。不过，单纯的对小于 64 位的基本类型数据做读写操作时，即使不加锁也是原子性的。因为 64 位机器的地址总线也是 64 位，读写可以在一次操作中完成。如果大于 64 位，就要分步来完成操作，有可能出现 A 线程写到一半，轮转给 B 线程操作的情况。</p>\n<p>既然 atomic 可以一定程度上保证线程安全，那要不要把所有的属性都声明为 atomic 的呢？当然不要，要知道加锁和解锁操作是需要消耗更多资源的，在手机这样性能较弱的嵌入式设备中，除非必要，不然不要声明为 atomic 的。而在 Mac 上面就问题不大了。</p>\n<p><strong>如何封装一个线程安全的字典</strong></p>\n<p>这是大疆的一道面试题。首先我们要知道，字典不是线程安全的：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dic = [<span class=\"type\">String</span>: <span class=\"type\">Int</span>]()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">        dic[<span class=\"string\">\"\\(dic.count)\"</span>] = dic.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(dic.description)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"number\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">1</span>...<span class=\"number\">10</span> &#123;</span><br><span class=\"line\">        dic[<span class=\"string\">\"\\(dic.count)\"</span>] = dic.<span class=\"built_in\">count</span></span><br><span class=\"line\">        <span class=\"type\">NSLog</span>(dic.description)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台打印的前几行：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.053788</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363511</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.053790</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363512</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>] </span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.054146</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363512</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>] <span class=\"comment\">//缺少1</span></span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.054184</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363512</span>] [<span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.054245</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363512</span>] [<span class=\"string\">\"4\"</span>: <span class=\"number\">4</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.054254</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363511</span>] [<span class=\"string\">\"4\"</span>: <span class=\"number\">4</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>] </span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">03</span>:<span class=\"number\">24.054281</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24651</span>:<span class=\"number\">2363512</span>] [<span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"6\"</span>: <span class=\"number\">6</span>, <span class=\"string\">\"4\"</span>: <span class=\"number\">4</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>] <span class=\"comment\">//缺少5</span></span><br></pre></td></tr></table></figure>\n<p>可以看到数据是紊乱的。我们可以通过给 getter 和 setter 加锁或者利用串行队列的方式来封装一个线程安全的字典，下面是一个简单的示例：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SafeDictionary</span>&lt;<span class=\"title\">Key</span>, <span class=\"title\">Element</span>&gt; <span class=\"title\">where</span> <span class=\"title\">Key</span>: <span class=\"title\">Hashable</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> dictionary = <span class=\"type\">Dictionary</span>&lt;<span class=\"type\">Key</span>, <span class=\"type\">Element</span>&gt;()</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lock = <span class=\"type\">NSLock</span>()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">subscript</span>(keyword: <span class=\"type\">Key</span>) -&gt; <span class=\"type\">Element?</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            lock.lock()</span><br><span class=\"line\">            <span class=\"keyword\">let</span> value = dictionary[keyword]</span><br><span class=\"line\">            lock.unlock()</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> newValue = newValue <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\">            lock.lock()</span><br><span class=\"line\">            dictionary[keyword] = newValue</span><br><span class=\"line\">            lock.unlock()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">extension</span> <span class=\"title\">SafeDictionary</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"built_in\">count</span>: <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        lock.lock()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = <span class=\"keyword\">self</span>.dictionary.<span class=\"built_in\">count</span></span><br><span class=\"line\">        lock.unlock()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> description: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        lock.lock()</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = <span class=\"keyword\">self</span>.dictionary.description</span><br><span class=\"line\">        lock.unlock()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台打印：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041003</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390589</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041003</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390590</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041580</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390590</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"1\"</span>: <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041620</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390590</span>] [<span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"1\"</span>: <span class=\"number\">1</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041748</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390589</span>] [<span class=\"string\">\"4\"</span>: <span class=\"number\">4</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"1\"</span>: <span class=\"number\">1</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"number\">2018</span>-<span class=\"number\">04</span>-<span class=\"number\">13</span> <span class=\"number\">15</span>:<span class=\"number\">37</span>:<span class=\"number\">51.041791</span>+<span class=\"number\">0800</span> test[<span class=\"number\">24761</span>:<span class=\"number\">2390589</span>] [<span class=\"string\">\"4\"</span>: <span class=\"number\">4</span>, <span class=\"string\">\"2\"</span>: <span class=\"number\">2</span>, <span class=\"string\">\"1\"</span>: <span class=\"number\">1</span>, <span class=\"string\">\"5\"</span>: <span class=\"number\">5</span>, <span class=\"string\">\"0\"</span>: <span class=\"number\">0</span>, <span class=\"string\">\"3\"</span>: <span class=\"number\">3</span>] <span class=\"comment\">//不再缺少某一项</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"线程间通信\"><a href=\"#线程间通信\" class=\"headerlink\" title=\"线程间通信\"></a>线程间通信</h3><p>再使用多线程时，我们有时希望线程之间能互相传递数据，或是在一个线程中执行完毕任务后，跳到另外一个线程继续执行任务，比如在子线程完成耗时操作后，回到主线程更新 UI。</p>\n<p>除了使用 GCD 切换到 main 队列以外，我们也可以通过函数：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">perform</span><span class=\"params\">(<span class=\"number\">_</span> aSelector: Selector, on thr: Thread, with arg: <span class=\"keyword\">Any</span>?, waitUntilDone wait: Bool, modes array: [String]?)</span></span></span><br></pre></td></tr></table></figure>\n<p>来让指定的线程执行某个方法。</p>\n<p>或者使用 NSMachPort （Mach 音 <code>mak</code>）或是 Pipe 来传递消息。如果有更高级的需求，可以使用 socket 来通信。</p>\n<h3 id=\"MainThreadChecker\"><a href=\"#MainThreadChecker\" class=\"headerlink\" title=\"MainThreadChecker\"></a>MainThreadChecker</h3><p>检查主线程是否卡顿有多种方法，比如监测 RunLoop 的状态，或是定时向主线程发送 ping 消息，检查主线程是否能及时返回 pong 消息等。我采用了监测主线程 RunLoop 状态变化的方法，思路如下：</p>\n<p>我们开启一个子线程，实时读取主线程的 RunLoop 状态。如果当前任务很轻，没有卡顿，那 RunLoop 的状态应该是频繁跳动的。如果没有触发事件，也可能长时间处于休眠状态。我们检测 RunLoop 是否长时间处于 <code>beforeSources</code> 或是 <code>afterWaiting</code> 状态，如果很长时间都处于这两个状态而得不到更新，就意味着主线程正在处理很繁重的任务，即卡顿了。</p>\n<p>下面是一个初步的 demo，有些地方还需要进一步优化：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">BYRunLoopState</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> beforeSources</span><br><span class=\"line\">    <span class=\"keyword\">case</span> afterWaiting</span><br><span class=\"line\">    <span class=\"keyword\">case</span> others</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BYMainThreadChecker</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> runLoopState = <span class=\"type\">BYRunLoopState</span>.others</span><br><span class=\"line\">    <span class=\"keyword\">var</span> isChecking = <span class=\"literal\">false</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">var</span> runLoopObserver: <span class=\"type\">CFRunLoopObserver?</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">start</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        addObserver()</span><br><span class=\"line\">        isChecking = <span class=\"literal\">true</span></span><br><span class=\"line\">        <span class=\"type\">DispatchQueue</span>.global().async &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> lastTime = <span class=\"type\">NSDate</span>().timeIntervalSince1970 * <span class=\"number\">1000</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> <span class=\"keyword\">self</span>.isChecking &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">let</span> currentTime = <span class=\"type\">NSDate</span>().timeIntervalSince1970 * <span class=\"number\">1000</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.runLoopState == .afterWaiting || <span class=\"keyword\">self</span>.runLoopState == .beforeSources &#123;</span><br><span class=\"line\">                    lastTime = currentTime</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">let</span> dt = currentTime - lastTime</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> dt &gt; <span class=\"number\">50</span> &#123;</span><br><span class=\"line\">                        <span class=\"type\">NSLog</span>(<span class=\"string\">\"卡了一下\"</span>) </span><br><span class=\"line\">                        <span class=\"comment\">//可以在此时拿到调用栈信息，方便调试。当前发生卡顿会打印消息多次，后期可以做一个优化，单次卡顿只收集一次信息。</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">stop</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        isChecking = <span class=\"literal\">false</span></span><br><span class=\"line\">        removeObserver()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">addObserver</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> runLoop = <span class=\"type\">CFRunLoopGetCurrent</span>()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">let</span> observer = <span class=\"type\">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, <span class=\"type\">CFRunLoopActivity</span>.allActivities.rawValue, <span class=\"literal\">true</span>, <span class=\"number\">0</span>) &#123; (observer, activity) <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> activity == <span class=\"type\">CFRunLoopActivity</span>.beforeSources &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.runLoopState = .beforeSources</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> activity == <span class=\"type\">CFRunLoopActivity</span>.afterWaiting &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.runLoopState = .afterWaiting</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">self</span>.runLoopState = .others</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">CFRunLoopAddObserver</span>(runLoop, observer, .commonModes)</span><br><span class=\"line\">        </span><br><span class=\"line\">        runLoopObserver = observer</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">removeObserver</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> runLoop = <span class=\"type\">CFRunLoopGetCurrent</span>()</span><br><span class=\"line\">        <span class=\"type\">CFRunLoopRemoveObserver</span>(runLoop, runLoopObserver, .commonModes)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"iOS图片裁剪、旋转、格式转换","date":"2018-07-20T09:14:52.000Z","_content":"\n# iOS图片裁剪、旋转、格式转换\n\n在使用 CoreML 对图片进行识别时，有时模型需要接收特定格式的图片，这就需要我们先对图片做好处理，再传递给模型。比如，我在一个识别人脸面部表情的程序中，就需要先裁剪出人脸区域，做成适当大小的灰度图，再交给 MLModel 进行识别。\n\n此篇文章汇总了一些对图片进行处理的函数。\n\n## CMSampleBufferRef 转 UIImage\n\n```objc\n- (UIImage *)getImageFromSampleBuffer:(CMSampleBufferRef) buffer {\n    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(buffer);\n    CVPixelBufferLockBaseAddress(imageBuffer, 0);\n    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    \n    CGContextRef context = CGBitmapContextCreate(baseAddress, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\n    CGImageRef quartzImage = CGBitmapContextCreateImage(context);\n    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);\n    CGContextRelease(context);\n    CGColorSpaceRelease(colorSpace);\n    UIImage *image = [UIImage imageWithCGImage:quartzImage];\n    CGImageRelease(quartzImage);\n    return image;\n}\n```\n\n## CGImageRef 转 CVPixelBufferRef\n\n这个函数中对图像做了一些翻转变化，而且还将图片转为了 8 位的灰度图，请注意色彩空间等地方。\n\n```objc\n- (CVPixelBufferRef) pixelBufferFromCGImage: (CGImageRef) image {\n    NSDictionary *options = @{\n                              (NSString*)kCVPixelBufferCGImageCompatibilityKey : @YES,\n                              (NSString*)kCVPixelBufferCGBitmapContextCompatibilityKey : @YES,\n                              };\n    \n    CVPixelBufferRef pxbuffer = NULL;\n\n    CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, CGImageGetWidth(image),\n                                          CGImageGetHeight(image), kCVPixelFormatType_OneComponent8, (__bridge CFDictionaryRef) options,\n                                          &pxbuffer);\n    if (status!=kCVReturnSuccess) {\n        NSLog(@\"Operation failed\");\n    }\n    NSParameterAssert(status == kCVReturnSuccess && pxbuffer != NULL);\n    \n    CVPixelBufferLockBaseAddress(pxbuffer, 0);\n    void *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);\n    \n    CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceGray(); //灰度\n    CGContextRef context = CGBitmapContextCreate(pxdata, CGImageGetWidth(image),\n                                                 CGImageGetHeight(image), 8, CVPixelBufferGetBytesPerRow(pxbuffer), rgbColorSpace,\n                                                 kCGImageAlphaNone);\n\n    NSParameterAssert(context);\n\n    CGContextConcatCTM(context, CGAffineTransformMakeRotation(0));\n    //CGAffineTransform flipVertical = CGAffineTransformMake( 1, 0, 0, -1, 0, CGImageGetHeight(image) );\n    //CGContextConcatCTM(context, flipVertical);\n    CGAffineTransform flipHorizontal = CGAffineTransformMake( -1.0, 0.0, 0.0, 1.0, CGImageGetWidth(image), 0.0 );\n    CGContextConcatCTM(context, flipHorizontal);\n    CGContextDrawImage(context, CGRectMake(0, 0, CGImageGetWidth(image),\n                                           CGImageGetHeight(image)), image);\n    CGColorSpaceRelease(rgbColorSpace);\n    CGContextRelease(context);\n    CVPixelBufferUnlockBaseAddress(pxbuffer, 0);\n    return pxbuffer;\n}\n```\n\n## CVPixelBufferRef 转 UIImage\n\n```objc\n- (UIImage *)imageFromPixelBuffer:(CVPixelBufferRef)pixelBufferRef {\n    CVImageBufferRef imageBuffer =  pixelBufferRef;\n    \n    CVPixelBufferLockBaseAddress(imageBuffer, 0);\n    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n    size_t bufferSize = CVPixelBufferGetDataSize(imageBuffer);\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 0);\n    \n    CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();\n    CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, baseAddress, bufferSize, NULL);\n    \n    CGImageRef cgImage = CGImageCreate(width, height, 8, 32, bytesPerRow, rgbColorSpace, kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrderDefault, provider, NULL, true, kCGRenderingIntentDefault);\n    UIImage *image = [UIImage imageWithCGImage:cgImage];\n    CGImageRelease(cgImage);\n    CGDataProviderRelease(provider);\n    CGColorSpaceRelease(rgbColorSpace);\n    \n    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);\n    return image;\n}\n```\n\n## 生成灰度图\n\n```objc\n- (UIImage*)grayImage:(UIImage*)sourceImage {\n    int width = sourceImage.size.width;\n    int height = sourceImage.size.height;\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();\n    CGContextRef context = CGBitmapContextCreate (nil, width, height,8,0, colorSpace,kCGImageAlphaNone);\n    CGColorSpaceRelease(colorSpace);\n    if (context ==NULL) {\n        return nil;\n    }\n    CGContextDrawImage(context,CGRectMake(0,0, width, height), sourceImage.CGImage);\n    UIImage *grayImage = [UIImage imageWithCGImage:CGBitmapContextCreateImage(context)];\n    CGContextRelease(context);\n    return grayImage;\n}\n```\n\n## 图片裁剪\n\n```objc\n- (UIImage*)getSubImage:(CGRect)rect cgImage:(CGImageRef)cgImage {\n    CGImageRef subImageRef = CGImageCreateWithImageInRect(cgImage, rect);\n    CGRect smallBounds = CGRectMake(0, 0, CGImageGetWidth(subImageRef), CGImageGetHeight(subImageRef));\n    \n    UIGraphicsBeginImageContext(smallBounds.size);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextDrawImage(context, smallBounds, subImageRef);\n    UIImage* smallImage = [UIImage imageWithCGImage:subImageRef];\n    UIGraphicsEndImageContext();\n    CGImageRelease(subImageRef);\n    return smallImage;\n}\n```\n\n## 图片旋转\n\n```objc\n- (UIImage*)rotateImageWithAngle:(UIImage*)vImg Angle:(CGFloat)vAngle IsExpand:(BOOL)vIsExpand {\n    CGSize imgSize = CGSizeMake(vImg.size.width * vImg.scale, vImg.size.height * vImg.scale);\n    \n    CGSize outputSize = imgSize;\n    if (vIsExpand) {\n        CGRect rect = CGRectMake(0, 0, imgSize.width, imgSize.height);\n        //旋转\n        rect = CGRectApplyAffineTransform(rect, CGAffineTransformMakeRotation(vAngle*M_PI/180.0));\n\n        outputSize = CGSizeMake(CGRectGetWidth(rect), CGRectGetHeight(rect));\n    }\n    \n    UIGraphicsBeginImageContext(outputSize);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    \n    CGContextTranslateCTM(context, outputSize.width / 2, outputSize.height / 2);\n    CGContextRotateCTM(context, vAngle*M_PI/180.0);\n    CGContextTranslateCTM(context, -imgSize.width / 2, -imgSize.height / 2);\n    \n    [vImg drawInRect:CGRectMake(0, 0, imgSize.width, imgSize.height)];\n    \n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    \n    return image;\n}\n```\n\n## CGImageRef 转 CVPixelBufferRef\n\n```objc\n- (CVPixelBufferRef) pixelBufferColorfulFromCGImage: (CGImageRef) image\n{\n    NSDictionary *options = @{\n                              (NSString*)kCVPixelBufferCGImageCompatibilityKey : @YES,\n                              (NSString*)kCVPixelBufferCGBitmapContextCompatibilityKey : @YES,\n                              (NSString*)kCVPixelBufferIOSurfacePropertiesKey: [NSDictionary dictionary]\n                              };\n    CVPixelBufferRef pxbuffer = NULL;\n    \n    CGFloat frameWidth = CGImageGetWidth(image);\n    CGFloat frameHeight = CGImageGetHeight(image);\n    \n    CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault,\n                                          frameWidth,\n                                          frameHeight,\n                                          kCVPixelFormatType_32BGRA,\n                                          (__bridge CFDictionaryRef) options,\n                                          &pxbuffer);\n    \n    NSParameterAssert(status == kCVReturnSuccess && pxbuffer != NULL);\n    \n    CVPixelBufferLockBaseAddress(pxbuffer, 0);\n    void *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);\n    NSParameterAssert(pxdata != NULL);\n    \n    CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();\n    \n    CGContextRef context = CGBitmapContextCreate(pxdata,\n                                                 frameWidth,\n                                                 frameHeight,\n                                                 8,\n                                                 CVPixelBufferGetBytesPerRow(pxbuffer),\n                                                 rgbColorSpace,\n                                                 (CGBitmapInfo)kCGImageAlphaNoneSkipFirst);\n    NSParameterAssert(context);\n    CGContextConcatCTM(context, CGAffineTransformIdentity);\n    CGContextDrawImage(context, CGRectMake(0,\n                                           0,\n                                           frameWidth,\n                                           frameHeight),\n                       image);\n    CGColorSpaceRelease(rgbColorSpace);\n    CGContextRelease(context);\n    \n    CVPixelBufferUnlockBaseAddress(pxbuffer, 0);\n    \n    return pxbuffer;\n}\n```\n\n以上各个函数基本都要操作指针，所以一定要注意手动释放内存，否则会造成非常严重的内存泄漏。","source":"_posts/iOS图片裁剪旋转格式转换.md","raw":"---\ntitle: iOS图片裁剪、旋转、格式转换\ndate: 2018-07-20 17:14:52\ntags: iOS\n---\n\n# iOS图片裁剪、旋转、格式转换\n\n在使用 CoreML 对图片进行识别时，有时模型需要接收特定格式的图片，这就需要我们先对图片做好处理，再传递给模型。比如，我在一个识别人脸面部表情的程序中，就需要先裁剪出人脸区域，做成适当大小的灰度图，再交给 MLModel 进行识别。\n\n此篇文章汇总了一些对图片进行处理的函数。\n\n## CMSampleBufferRef 转 UIImage\n\n```objc\n- (UIImage *)getImageFromSampleBuffer:(CMSampleBufferRef) buffer {\n    CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(buffer);\n    CVPixelBufferLockBaseAddress(imageBuffer, 0);\n    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n    \n    CGContextRef context = CGBitmapContextCreate(baseAddress, width, height, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);\n    CGImageRef quartzImage = CGBitmapContextCreateImage(context);\n    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);\n    CGContextRelease(context);\n    CGColorSpaceRelease(colorSpace);\n    UIImage *image = [UIImage imageWithCGImage:quartzImage];\n    CGImageRelease(quartzImage);\n    return image;\n}\n```\n\n## CGImageRef 转 CVPixelBufferRef\n\n这个函数中对图像做了一些翻转变化，而且还将图片转为了 8 位的灰度图，请注意色彩空间等地方。\n\n```objc\n- (CVPixelBufferRef) pixelBufferFromCGImage: (CGImageRef) image {\n    NSDictionary *options = @{\n                              (NSString*)kCVPixelBufferCGImageCompatibilityKey : @YES,\n                              (NSString*)kCVPixelBufferCGBitmapContextCompatibilityKey : @YES,\n                              };\n    \n    CVPixelBufferRef pxbuffer = NULL;\n\n    CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, CGImageGetWidth(image),\n                                          CGImageGetHeight(image), kCVPixelFormatType_OneComponent8, (__bridge CFDictionaryRef) options,\n                                          &pxbuffer);\n    if (status!=kCVReturnSuccess) {\n        NSLog(@\"Operation failed\");\n    }\n    NSParameterAssert(status == kCVReturnSuccess && pxbuffer != NULL);\n    \n    CVPixelBufferLockBaseAddress(pxbuffer, 0);\n    void *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);\n    \n    CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceGray(); //灰度\n    CGContextRef context = CGBitmapContextCreate(pxdata, CGImageGetWidth(image),\n                                                 CGImageGetHeight(image), 8, CVPixelBufferGetBytesPerRow(pxbuffer), rgbColorSpace,\n                                                 kCGImageAlphaNone);\n\n    NSParameterAssert(context);\n\n    CGContextConcatCTM(context, CGAffineTransformMakeRotation(0));\n    //CGAffineTransform flipVertical = CGAffineTransformMake( 1, 0, 0, -1, 0, CGImageGetHeight(image) );\n    //CGContextConcatCTM(context, flipVertical);\n    CGAffineTransform flipHorizontal = CGAffineTransformMake( -1.0, 0.0, 0.0, 1.0, CGImageGetWidth(image), 0.0 );\n    CGContextConcatCTM(context, flipHorizontal);\n    CGContextDrawImage(context, CGRectMake(0, 0, CGImageGetWidth(image),\n                                           CGImageGetHeight(image)), image);\n    CGColorSpaceRelease(rgbColorSpace);\n    CGContextRelease(context);\n    CVPixelBufferUnlockBaseAddress(pxbuffer, 0);\n    return pxbuffer;\n}\n```\n\n## CVPixelBufferRef 转 UIImage\n\n```objc\n- (UIImage *)imageFromPixelBuffer:(CVPixelBufferRef)pixelBufferRef {\n    CVImageBufferRef imageBuffer =  pixelBufferRef;\n    \n    CVPixelBufferLockBaseAddress(imageBuffer, 0);\n    void *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);\n    size_t width = CVPixelBufferGetWidth(imageBuffer);\n    size_t height = CVPixelBufferGetHeight(imageBuffer);\n    size_t bufferSize = CVPixelBufferGetDataSize(imageBuffer);\n    size_t bytesPerRow = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 0);\n    \n    CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();\n    CGDataProviderRef provider = CGDataProviderCreateWithData(NULL, baseAddress, bufferSize, NULL);\n    \n    CGImageRef cgImage = CGImageCreate(width, height, 8, 32, bytesPerRow, rgbColorSpace, kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrderDefault, provider, NULL, true, kCGRenderingIntentDefault);\n    UIImage *image = [UIImage imageWithCGImage:cgImage];\n    CGImageRelease(cgImage);\n    CGDataProviderRelease(provider);\n    CGColorSpaceRelease(rgbColorSpace);\n    \n    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);\n    return image;\n}\n```\n\n## 生成灰度图\n\n```objc\n- (UIImage*)grayImage:(UIImage*)sourceImage {\n    int width = sourceImage.size.width;\n    int height = sourceImage.size.height;\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();\n    CGContextRef context = CGBitmapContextCreate (nil, width, height,8,0, colorSpace,kCGImageAlphaNone);\n    CGColorSpaceRelease(colorSpace);\n    if (context ==NULL) {\n        return nil;\n    }\n    CGContextDrawImage(context,CGRectMake(0,0, width, height), sourceImage.CGImage);\n    UIImage *grayImage = [UIImage imageWithCGImage:CGBitmapContextCreateImage(context)];\n    CGContextRelease(context);\n    return grayImage;\n}\n```\n\n## 图片裁剪\n\n```objc\n- (UIImage*)getSubImage:(CGRect)rect cgImage:(CGImageRef)cgImage {\n    CGImageRef subImageRef = CGImageCreateWithImageInRect(cgImage, rect);\n    CGRect smallBounds = CGRectMake(0, 0, CGImageGetWidth(subImageRef), CGImageGetHeight(subImageRef));\n    \n    UIGraphicsBeginImageContext(smallBounds.size);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    CGContextDrawImage(context, smallBounds, subImageRef);\n    UIImage* smallImage = [UIImage imageWithCGImage:subImageRef];\n    UIGraphicsEndImageContext();\n    CGImageRelease(subImageRef);\n    return smallImage;\n}\n```\n\n## 图片旋转\n\n```objc\n- (UIImage*)rotateImageWithAngle:(UIImage*)vImg Angle:(CGFloat)vAngle IsExpand:(BOOL)vIsExpand {\n    CGSize imgSize = CGSizeMake(vImg.size.width * vImg.scale, vImg.size.height * vImg.scale);\n    \n    CGSize outputSize = imgSize;\n    if (vIsExpand) {\n        CGRect rect = CGRectMake(0, 0, imgSize.width, imgSize.height);\n        //旋转\n        rect = CGRectApplyAffineTransform(rect, CGAffineTransformMakeRotation(vAngle*M_PI/180.0));\n\n        outputSize = CGSizeMake(CGRectGetWidth(rect), CGRectGetHeight(rect));\n    }\n    \n    UIGraphicsBeginImageContext(outputSize);\n    CGContextRef context = UIGraphicsGetCurrentContext();\n    \n    CGContextTranslateCTM(context, outputSize.width / 2, outputSize.height / 2);\n    CGContextRotateCTM(context, vAngle*M_PI/180.0);\n    CGContextTranslateCTM(context, -imgSize.width / 2, -imgSize.height / 2);\n    \n    [vImg drawInRect:CGRectMake(0, 0, imgSize.width, imgSize.height)];\n    \n    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();\n    UIGraphicsEndImageContext();\n    \n    return image;\n}\n```\n\n## CGImageRef 转 CVPixelBufferRef\n\n```objc\n- (CVPixelBufferRef) pixelBufferColorfulFromCGImage: (CGImageRef) image\n{\n    NSDictionary *options = @{\n                              (NSString*)kCVPixelBufferCGImageCompatibilityKey : @YES,\n                              (NSString*)kCVPixelBufferCGBitmapContextCompatibilityKey : @YES,\n                              (NSString*)kCVPixelBufferIOSurfacePropertiesKey: [NSDictionary dictionary]\n                              };\n    CVPixelBufferRef pxbuffer = NULL;\n    \n    CGFloat frameWidth = CGImageGetWidth(image);\n    CGFloat frameHeight = CGImageGetHeight(image);\n    \n    CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault,\n                                          frameWidth,\n                                          frameHeight,\n                                          kCVPixelFormatType_32BGRA,\n                                          (__bridge CFDictionaryRef) options,\n                                          &pxbuffer);\n    \n    NSParameterAssert(status == kCVReturnSuccess && pxbuffer != NULL);\n    \n    CVPixelBufferLockBaseAddress(pxbuffer, 0);\n    void *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);\n    NSParameterAssert(pxdata != NULL);\n    \n    CGColorSpaceRef rgbColorSpace = CGColorSpaceCreateDeviceRGB();\n    \n    CGContextRef context = CGBitmapContextCreate(pxdata,\n                                                 frameWidth,\n                                                 frameHeight,\n                                                 8,\n                                                 CVPixelBufferGetBytesPerRow(pxbuffer),\n                                                 rgbColorSpace,\n                                                 (CGBitmapInfo)kCGImageAlphaNoneSkipFirst);\n    NSParameterAssert(context);\n    CGContextConcatCTM(context, CGAffineTransformIdentity);\n    CGContextDrawImage(context, CGRectMake(0,\n                                           0,\n                                           frameWidth,\n                                           frameHeight),\n                       image);\n    CGColorSpaceRelease(rgbColorSpace);\n    CGContextRelease(context);\n    \n    CVPixelBufferUnlockBaseAddress(pxbuffer, 0);\n    \n    return pxbuffer;\n}\n```\n\n以上各个函数基本都要操作指针，所以一定要注意手动释放内存，否则会造成非常严重的内存泄漏。","slug":"iOS图片裁剪旋转格式转换","published":1,"updated":"2020-01-04T08:16:16.918Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv45003lljc3n3u66vb6","content":"<h1 id=\"iOS图片裁剪、旋转、格式转换\"><a href=\"#iOS图片裁剪、旋转、格式转换\" class=\"headerlink\" title=\"iOS图片裁剪、旋转、格式转换\"></a>iOS图片裁剪、旋转、格式转换</h1><p>在使用 CoreML 对图片进行识别时，有时模型需要接收特定格式的图片，这就需要我们先对图片做好处理，再传递给模型。比如，我在一个识别人脸面部表情的程序中，就需要先裁剪出人脸区域，做成适当大小的灰度图，再交给 MLModel 进行识别。</p>\n<p>此篇文章汇总了一些对图片进行处理的函数。</p>\n<h2 id=\"CMSampleBufferRef-转-UIImage\"><a href=\"#CMSampleBufferRef-转-UIImage\" class=\"headerlink\" title=\"CMSampleBufferRef 转 UIImage\"></a>CMSampleBufferRef 转 UIImage</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span> *)getImageFromSampleBuffer:(<span class=\"built_in\">CMSampleBufferRef</span>) buffer &#123;</span><br><span class=\"line\">    CVImageBufferRef imageBuffer = <span class=\"built_in\">CMSampleBufferGetImageBuffer</span>(buffer);</span><br><span class=\"line\">    CVPixelBufferLockBaseAddress(imageBuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);</span><br><span class=\"line\">    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);</span><br><span class=\"line\">    size_t width = CVPixelBufferGetWidth(imageBuffer);</span><br><span class=\"line\">    size_t height = CVPixelBufferGetHeight(imageBuffer);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(baseAddress, width, height, <span class=\"number\">8</span>, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> quartzImage = <span class=\"built_in\">CGBitmapContextCreateImage</span>(context);</span><br><span class=\"line\">    CVPixelBufferUnlockBaseAddress(imageBuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWithCGImage:quartzImage];</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRelease</span>(quartzImage);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CGImageRef-转-CVPixelBufferRef\"><a href=\"#CGImageRef-转-CVPixelBufferRef\" class=\"headerlink\" title=\"CGImageRef 转 CVPixelBufferRef\"></a>CGImageRef 转 CVPixelBufferRef</h2><p>这个函数中对图像做了一些翻转变化，而且还将图片转为了 8 位的灰度图，请注意色彩空间等地方。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (CVPixelBufferRef) pixelBufferFromCGImage: (<span class=\"built_in\">CGImageRef</span>) image &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *options = @&#123;</span><br><span class=\"line\">                              (<span class=\"built_in\">NSString</span>*)kCVPixelBufferCGImageCompatibilityKey : @YES,</span><br><span class=\"line\">                              (<span class=\"built_in\">NSString</span>*)kCVPixelBufferCGBitmapContextCompatibilityKey : @YES,</span><br><span class=\"line\">                              &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferRef pxbuffer = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, <span class=\"built_in\">CGImageGetWidth</span>(image),</span><br><span class=\"line\">                                          <span class=\"built_in\">CGImageGetHeight</span>(image), kCVPixelFormatType_OneComponent8, (__bridge <span class=\"built_in\">CFDictionaryRef</span>) options,</span><br><span class=\"line\">                                          &amp;pxbuffer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status!=kCVReturnSuccess) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Operation failed\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(status == kCVReturnSuccess &amp;&amp; pxbuffer != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferLockBaseAddress(pxbuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> rgbColorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceGray</span>(); <span class=\"comment\">//灰度</span></span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(pxdata, <span class=\"built_in\">CGImageGetWidth</span>(image),</span><br><span class=\"line\">                                                 <span class=\"built_in\">CGImageGetHeight</span>(image), <span class=\"number\">8</span>, CVPixelBufferGetBytesPerRow(pxbuffer), rgbColorSpace,</span><br><span class=\"line\">                                                 kCGImageAlphaNone);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGContextConcatCTM</span>(context, <span class=\"built_in\">CGAffineTransformMakeRotation</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">//CGAffineTransform flipVertical = CGAffineTransformMake( 1, 0, 0, -1, 0, CGImageGetHeight(image) );</span></span><br><span class=\"line\">    <span class=\"comment\">//CGContextConcatCTM(context, flipVertical);</span></span><br><span class=\"line\">    <span class=\"built_in\">CGAffineTransform</span> flipHorizontal = <span class=\"built_in\">CGAffineTransformMake</span>( <span class=\"number\">-1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"built_in\">CGImageGetWidth</span>(image), <span class=\"number\">0.0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">CGContextConcatCTM</span>(context, flipHorizontal);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(context, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">CGImageGetWidth</span>(image),</span><br><span class=\"line\">                                           <span class=\"built_in\">CGImageGetHeight</span>(image)), image);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(rgbColorSpace);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">    CVPixelBufferUnlockBaseAddress(pxbuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pxbuffer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CVPixelBufferRef-转-UIImage\"><a href=\"#CVPixelBufferRef-转-UIImage\" class=\"headerlink\" title=\"CVPixelBufferRef 转 UIImage\"></a>CVPixelBufferRef 转 UIImage</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span> *)imageFromPixelBuffer:(CVPixelBufferRef)pixelBufferRef &#123;</span><br><span class=\"line\">    CVImageBufferRef imageBuffer =  pixelBufferRef;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferLockBaseAddress(imageBuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);</span><br><span class=\"line\">    size_t width = CVPixelBufferGetWidth(imageBuffer);</span><br><span class=\"line\">    size_t height = CVPixelBufferGetHeight(imageBuffer);</span><br><span class=\"line\">    size_t bufferSize = CVPixelBufferGetDataSize(imageBuffer);</span><br><span class=\"line\">    size_t bytesPerRow = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> rgbColorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGDataProviderRef</span> provider = <span class=\"built_in\">CGDataProviderCreateWithData</span>(<span class=\"literal\">NULL</span>, baseAddress, bufferSize, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> cgImage = <span class=\"built_in\">CGImageCreate</span>(width, height, <span class=\"number\">8</span>, <span class=\"number\">32</span>, bytesPerRow, rgbColorSpace, kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrderDefault, provider, <span class=\"literal\">NULL</span>, <span class=\"literal\">true</span>, kCGRenderingIntentDefault);</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWithCGImage:cgImage];</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRelease</span>(cgImage);</span><br><span class=\"line\">    <span class=\"built_in\">CGDataProviderRelease</span>(provider);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(rgbColorSpace);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferUnlockBaseAddress(imageBuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成灰度图\"><a href=\"#生成灰度图\" class=\"headerlink\" title=\"生成灰度图\"></a>生成灰度图</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span>*)grayImage:(<span class=\"built_in\">UIImage</span>*)sourceImage &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> width = sourceImage.size.width;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> height = sourceImage.size.height;</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceGray</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span> (<span class=\"literal\">nil</span>, width, height,<span class=\"number\">8</span>,<span class=\"number\">0</span>, colorSpace,kCGImageAlphaNone);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context ==<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(context,<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>, width, height), sourceImage.CGImage);</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *grayImage = [<span class=\"built_in\">UIImage</span> imageWithCGImage:<span class=\"built_in\">CGBitmapContextCreateImage</span>(context)];</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> grayImage;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"图片裁剪\"><a href=\"#图片裁剪\" class=\"headerlink\" title=\"图片裁剪\"></a>图片裁剪</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span>*)getSubImage:(<span class=\"built_in\">CGRect</span>)rect cgImage:(<span class=\"built_in\">CGImageRef</span>)cgImage &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> subImageRef = <span class=\"built_in\">CGImageCreateWithImageInRect</span>(cgImage, rect);</span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> smallBounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">CGImageGetWidth</span>(subImageRef), <span class=\"built_in\">CGImageGetHeight</span>(subImageRef));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsBeginImageContext</span>(smallBounds.size);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(context, smallBounds, subImageRef);</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span>* smallImage = [<span class=\"built_in\">UIImage</span> imageWithCGImage:subImageRef];</span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRelease</span>(subImageRef);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> smallImage;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"图片旋转\"><a href=\"#图片旋转\" class=\"headerlink\" title=\"图片旋转\"></a>图片旋转</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span>*)rotateImageWithAngle:(<span class=\"built_in\">UIImage</span>*)vImg Angle:(<span class=\"built_in\">CGFloat</span>)vAngle IsExpand:(<span class=\"built_in\">BOOL</span>)vIsExpand &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGSize</span> imgSize = <span class=\"built_in\">CGSizeMake</span>(vImg.size.width * vImg.scale, vImg.size.height * vImg.scale);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGSize</span> outputSize = imgSize;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vIsExpand) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, imgSize.width, imgSize.height);</span><br><span class=\"line\">        <span class=\"comment\">//旋转</span></span><br><span class=\"line\">        rect = <span class=\"built_in\">CGRectApplyAffineTransform</span>(rect, <span class=\"built_in\">CGAffineTransformMakeRotation</span>(vAngle*M_PI/<span class=\"number\">180.0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        outputSize = <span class=\"built_in\">CGSizeMake</span>(<span class=\"built_in\">CGRectGetWidth</span>(rect), <span class=\"built_in\">CGRectGetHeight</span>(rect));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsBeginImageContext</span>(outputSize);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextTranslateCTM</span>(context, outputSize.width / <span class=\"number\">2</span>, outputSize.height / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRotateCTM</span>(context, vAngle*M_PI/<span class=\"number\">180.0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextTranslateCTM</span>(context, -imgSize.width / <span class=\"number\">2</span>, -imgSize.height / <span class=\"number\">2</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [vImg drawInRect:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, imgSize.width, imgSize.height)];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *image = <span class=\"built_in\">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CGImageRef-转-CVPixelBufferRef-1\"><a href=\"#CGImageRef-转-CVPixelBufferRef-1\" class=\"headerlink\" title=\"CGImageRef 转 CVPixelBufferRef\"></a>CGImageRef 转 CVPixelBufferRef</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (CVPixelBufferRef) pixelBufferColorfulFromCGImage: (<span class=\"built_in\">CGImageRef</span>) image</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *options = @&#123;</span><br><span class=\"line\">                              (<span class=\"built_in\">NSString</span>*)kCVPixelBufferCGImageCompatibilityKey : @YES,</span><br><span class=\"line\">                              (<span class=\"built_in\">NSString</span>*)kCVPixelBufferCGBitmapContextCompatibilityKey : @YES,</span><br><span class=\"line\">                              (<span class=\"built_in\">NSString</span>*)kCVPixelBufferIOSurfacePropertiesKey: [<span class=\"built_in\">NSDictionary</span> dictionary]</span><br><span class=\"line\">                              &#125;;</span><br><span class=\"line\">    CVPixelBufferRef pxbuffer = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> frameWidth = <span class=\"built_in\">CGImageGetWidth</span>(image);</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> frameHeight = <span class=\"built_in\">CGImageGetHeight</span>(image);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault,</span><br><span class=\"line\">                                          frameWidth,</span><br><span class=\"line\">                                          frameHeight,</span><br><span class=\"line\">                                          kCVPixelFormatType_32BGRA,</span><br><span class=\"line\">                                          (__bridge <span class=\"built_in\">CFDictionaryRef</span>) options,</span><br><span class=\"line\">                                          &amp;pxbuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(status == kCVReturnSuccess &amp;&amp; pxbuffer != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferLockBaseAddress(pxbuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(pxdata != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> rgbColorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(pxdata,</span><br><span class=\"line\">                                                 frameWidth,</span><br><span class=\"line\">                                                 frameHeight,</span><br><span class=\"line\">                                                 <span class=\"number\">8</span>,</span><br><span class=\"line\">                                                 CVPixelBufferGetBytesPerRow(pxbuffer),</span><br><span class=\"line\">                                                 rgbColorSpace,</span><br><span class=\"line\">                                                 (<span class=\"built_in\">CGBitmapInfo</span>)kCGImageAlphaNoneSkipFirst);</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(context);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextConcatCTM</span>(context, <span class=\"built_in\">CGAffineTransformIdentity</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(context, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>,</span><br><span class=\"line\">                                           <span class=\"number\">0</span>,</span><br><span class=\"line\">                                           frameWidth,</span><br><span class=\"line\">                                           frameHeight),</span><br><span class=\"line\">                       image);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(rgbColorSpace);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferUnlockBaseAddress(pxbuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> pxbuffer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上各个函数基本都要操作指针，所以一定要注意手动释放内存，否则会造成非常严重的内存泄漏。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iOS图片裁剪、旋转、格式转换\"><a href=\"#iOS图片裁剪、旋转、格式转换\" class=\"headerlink\" title=\"iOS图片裁剪、旋转、格式转换\"></a>iOS图片裁剪、旋转、格式转换</h1><p>在使用 CoreML 对图片进行识别时，有时模型需要接收特定格式的图片，这就需要我们先对图片做好处理，再传递给模型。比如，我在一个识别人脸面部表情的程序中，就需要先裁剪出人脸区域，做成适当大小的灰度图，再交给 MLModel 进行识别。</p>\n<p>此篇文章汇总了一些对图片进行处理的函数。</p>\n<h2 id=\"CMSampleBufferRef-转-UIImage\"><a href=\"#CMSampleBufferRef-转-UIImage\" class=\"headerlink\" title=\"CMSampleBufferRef 转 UIImage\"></a>CMSampleBufferRef 转 UIImage</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span> *)getImageFromSampleBuffer:(<span class=\"built_in\">CMSampleBufferRef</span>) buffer &#123;</span><br><span class=\"line\">    CVImageBufferRef imageBuffer = <span class=\"built_in\">CMSampleBufferGetImageBuffer</span>(buffer);</span><br><span class=\"line\">    CVPixelBufferLockBaseAddress(imageBuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);</span><br><span class=\"line\">    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);</span><br><span class=\"line\">    size_t width = CVPixelBufferGetWidth(imageBuffer);</span><br><span class=\"line\">    size_t height = CVPixelBufferGetHeight(imageBuffer);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(baseAddress, width, height, <span class=\"number\">8</span>, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> quartzImage = <span class=\"built_in\">CGBitmapContextCreateImage</span>(context);</span><br><span class=\"line\">    CVPixelBufferUnlockBaseAddress(imageBuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWithCGImage:quartzImage];</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRelease</span>(quartzImage);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CGImageRef-转-CVPixelBufferRef\"><a href=\"#CGImageRef-转-CVPixelBufferRef\" class=\"headerlink\" title=\"CGImageRef 转 CVPixelBufferRef\"></a>CGImageRef 转 CVPixelBufferRef</h2><p>这个函数中对图像做了一些翻转变化，而且还将图片转为了 8 位的灰度图，请注意色彩空间等地方。</p>\n<figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (CVPixelBufferRef) pixelBufferFromCGImage: (<span class=\"built_in\">CGImageRef</span>) image &#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *options = @&#123;</span><br><span class=\"line\">                              (<span class=\"built_in\">NSString</span>*)kCVPixelBufferCGImageCompatibilityKey : @YES,</span><br><span class=\"line\">                              (<span class=\"built_in\">NSString</span>*)kCVPixelBufferCGBitmapContextCompatibilityKey : @YES,</span><br><span class=\"line\">                              &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferRef pxbuffer = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, <span class=\"built_in\">CGImageGetWidth</span>(image),</span><br><span class=\"line\">                                          <span class=\"built_in\">CGImageGetHeight</span>(image), kCVPixelFormatType_OneComponent8, (__bridge <span class=\"built_in\">CFDictionaryRef</span>) options,</span><br><span class=\"line\">                                          &amp;pxbuffer);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (status!=kCVReturnSuccess) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">NSLog</span>(<span class=\"string\">@\"Operation failed\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(status == kCVReturnSuccess &amp;&amp; pxbuffer != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferLockBaseAddress(pxbuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> rgbColorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceGray</span>(); <span class=\"comment\">//灰度</span></span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(pxdata, <span class=\"built_in\">CGImageGetWidth</span>(image),</span><br><span class=\"line\">                                                 <span class=\"built_in\">CGImageGetHeight</span>(image), <span class=\"number\">8</span>, CVPixelBufferGetBytesPerRow(pxbuffer), rgbColorSpace,</span><br><span class=\"line\">                                                 kCGImageAlphaNone);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(context);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">CGContextConcatCTM</span>(context, <span class=\"built_in\">CGAffineTransformMakeRotation</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"comment\">//CGAffineTransform flipVertical = CGAffineTransformMake( 1, 0, 0, -1, 0, CGImageGetHeight(image) );</span></span><br><span class=\"line\">    <span class=\"comment\">//CGContextConcatCTM(context, flipVertical);</span></span><br><span class=\"line\">    <span class=\"built_in\">CGAffineTransform</span> flipHorizontal = <span class=\"built_in\">CGAffineTransformMake</span>( <span class=\"number\">-1.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"built_in\">CGImageGetWidth</span>(image), <span class=\"number\">0.0</span> );</span><br><span class=\"line\">    <span class=\"built_in\">CGContextConcatCTM</span>(context, flipHorizontal);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(context, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">CGImageGetWidth</span>(image),</span><br><span class=\"line\">                                           <span class=\"built_in\">CGImageGetHeight</span>(image)), image);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(rgbColorSpace);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">    CVPixelBufferUnlockBaseAddress(pxbuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pxbuffer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CVPixelBufferRef-转-UIImage\"><a href=\"#CVPixelBufferRef-转-UIImage\" class=\"headerlink\" title=\"CVPixelBufferRef 转 UIImage\"></a>CVPixelBufferRef 转 UIImage</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span> *)imageFromPixelBuffer:(CVPixelBufferRef)pixelBufferRef &#123;</span><br><span class=\"line\">    CVImageBufferRef imageBuffer =  pixelBufferRef;</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferLockBaseAddress(imageBuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);</span><br><span class=\"line\">    size_t width = CVPixelBufferGetWidth(imageBuffer);</span><br><span class=\"line\">    size_t height = CVPixelBufferGetHeight(imageBuffer);</span><br><span class=\"line\">    size_t bufferSize = CVPixelBufferGetDataSize(imageBuffer);</span><br><span class=\"line\">    size_t bytesPerRow = CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> rgbColorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGDataProviderRef</span> provider = <span class=\"built_in\">CGDataProviderCreateWithData</span>(<span class=\"literal\">NULL</span>, baseAddress, bufferSize, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> cgImage = <span class=\"built_in\">CGImageCreate</span>(width, height, <span class=\"number\">8</span>, <span class=\"number\">32</span>, bytesPerRow, rgbColorSpace, kCGImageAlphaNoneSkipFirst | kCGBitmapByteOrderDefault, provider, <span class=\"literal\">NULL</span>, <span class=\"literal\">true</span>, kCGRenderingIntentDefault);</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *image = [<span class=\"built_in\">UIImage</span> imageWithCGImage:cgImage];</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRelease</span>(cgImage);</span><br><span class=\"line\">    <span class=\"built_in\">CGDataProviderRelease</span>(provider);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(rgbColorSpace);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferUnlockBaseAddress(imageBuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"生成灰度图\"><a href=\"#生成灰度图\" class=\"headerlink\" title=\"生成灰度图\"></a>生成灰度图</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span>*)grayImage:(<span class=\"built_in\">UIImage</span>*)sourceImage &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> width = sourceImage.size.width;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> height = sourceImage.size.height;</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> colorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceGray</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span> (<span class=\"literal\">nil</span>, width, height,<span class=\"number\">8</span>,<span class=\"number\">0</span>, colorSpace,kCGImageAlphaNone);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(colorSpace);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (context ==<span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(context,<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>,<span class=\"number\">0</span>, width, height), sourceImage.CGImage);</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *grayImage = [<span class=\"built_in\">UIImage</span> imageWithCGImage:<span class=\"built_in\">CGBitmapContextCreateImage</span>(context)];</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> grayImage;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"图片裁剪\"><a href=\"#图片裁剪\" class=\"headerlink\" title=\"图片裁剪\"></a>图片裁剪</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span>*)getSubImage:(<span class=\"built_in\">CGRect</span>)rect cgImage:(<span class=\"built_in\">CGImageRef</span>)cgImage &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRef</span> subImageRef = <span class=\"built_in\">CGImageCreateWithImageInRect</span>(cgImage, rect);</span><br><span class=\"line\">    <span class=\"built_in\">CGRect</span> smallBounds = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"built_in\">CGImageGetWidth</span>(subImageRef), <span class=\"built_in\">CGImageGetHeight</span>(subImageRef));</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsBeginImageContext</span>(smallBounds.size);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(context, smallBounds, subImageRef);</span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span>* smallImage = [<span class=\"built_in\">UIImage</span> imageWithCGImage:subImageRef];</span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CGImageRelease</span>(subImageRef);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> smallImage;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"图片旋转\"><a href=\"#图片旋转\" class=\"headerlink\" title=\"图片旋转\"></a>图片旋转</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (<span class=\"built_in\">UIImage</span>*)rotateImageWithAngle:(<span class=\"built_in\">UIImage</span>*)vImg Angle:(<span class=\"built_in\">CGFloat</span>)vAngle IsExpand:(<span class=\"built_in\">BOOL</span>)vIsExpand &#123;</span><br><span class=\"line\">    <span class=\"built_in\">CGSize</span> imgSize = <span class=\"built_in\">CGSizeMake</span>(vImg.size.width * vImg.scale, vImg.size.height * vImg.scale);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGSize</span> outputSize = imgSize;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vIsExpand) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CGRect</span> rect = <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, imgSize.width, imgSize.height);</span><br><span class=\"line\">        <span class=\"comment\">//旋转</span></span><br><span class=\"line\">        rect = <span class=\"built_in\">CGRectApplyAffineTransform</span>(rect, <span class=\"built_in\">CGAffineTransformMakeRotation</span>(vAngle*M_PI/<span class=\"number\">180.0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        outputSize = <span class=\"built_in\">CGSizeMake</span>(<span class=\"built_in\">CGRectGetWidth</span>(rect), <span class=\"built_in\">CGRectGetHeight</span>(rect));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsBeginImageContext</span>(outputSize);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">UIGraphicsGetCurrentContext</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextTranslateCTM</span>(context, outputSize.width / <span class=\"number\">2</span>, outputSize.height / <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRotateCTM</span>(context, vAngle*M_PI/<span class=\"number\">180.0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextTranslateCTM</span>(context, -imgSize.width / <span class=\"number\">2</span>, -imgSize.height / <span class=\"number\">2</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    [vImg drawInRect:<span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>, <span class=\"number\">0</span>, imgSize.width, imgSize.height)];</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">UIImage</span> *image = <span class=\"built_in\">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class=\"line\">    <span class=\"built_in\">UIGraphicsEndImageContext</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> image;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"CGImageRef-转-CVPixelBufferRef-1\"><a href=\"#CGImageRef-转-CVPixelBufferRef-1\" class=\"headerlink\" title=\"CGImageRef 转 CVPixelBufferRef\"></a>CGImageRef 转 CVPixelBufferRef</h2><figure class=\"highlight objc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- (CVPixelBufferRef) pixelBufferColorfulFromCGImage: (<span class=\"built_in\">CGImageRef</span>) image</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">NSDictionary</span> *options = @&#123;</span><br><span class=\"line\">                              (<span class=\"built_in\">NSString</span>*)kCVPixelBufferCGImageCompatibilityKey : @YES,</span><br><span class=\"line\">                              (<span class=\"built_in\">NSString</span>*)kCVPixelBufferCGBitmapContextCompatibilityKey : @YES,</span><br><span class=\"line\">                              (<span class=\"built_in\">NSString</span>*)kCVPixelBufferIOSurfacePropertiesKey: [<span class=\"built_in\">NSDictionary</span> dictionary]</span><br><span class=\"line\">                              &#125;;</span><br><span class=\"line\">    CVPixelBufferRef pxbuffer = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> frameWidth = <span class=\"built_in\">CGImageGetWidth</span>(image);</span><br><span class=\"line\">    <span class=\"built_in\">CGFloat</span> frameHeight = <span class=\"built_in\">CGImageGetHeight</span>(image);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault,</span><br><span class=\"line\">                                          frameWidth,</span><br><span class=\"line\">                                          frameHeight,</span><br><span class=\"line\">                                          kCVPixelFormatType_32BGRA,</span><br><span class=\"line\">                                          (__bridge <span class=\"built_in\">CFDictionaryRef</span>) options,</span><br><span class=\"line\">                                          &amp;pxbuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(status == kCVReturnSuccess &amp;&amp; pxbuffer != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferLockBaseAddress(pxbuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *pxdata = CVPixelBufferGetBaseAddress(pxbuffer);</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(pxdata != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRef</span> rgbColorSpace = <span class=\"built_in\">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">CGContextRef</span> context = <span class=\"built_in\">CGBitmapContextCreate</span>(pxdata,</span><br><span class=\"line\">                                                 frameWidth,</span><br><span class=\"line\">                                                 frameHeight,</span><br><span class=\"line\">                                                 <span class=\"number\">8</span>,</span><br><span class=\"line\">                                                 CVPixelBufferGetBytesPerRow(pxbuffer),</span><br><span class=\"line\">                                                 rgbColorSpace,</span><br><span class=\"line\">                                                 (<span class=\"built_in\">CGBitmapInfo</span>)kCGImageAlphaNoneSkipFirst);</span><br><span class=\"line\">    <span class=\"built_in\">NSParameterAssert</span>(context);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextConcatCTM</span>(context, <span class=\"built_in\">CGAffineTransformIdentity</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextDrawImage</span>(context, <span class=\"built_in\">CGRectMake</span>(<span class=\"number\">0</span>,</span><br><span class=\"line\">                                           <span class=\"number\">0</span>,</span><br><span class=\"line\">                                           frameWidth,</span><br><span class=\"line\">                                           frameHeight),</span><br><span class=\"line\">                       image);</span><br><span class=\"line\">    <span class=\"built_in\">CGColorSpaceRelease</span>(rgbColorSpace);</span><br><span class=\"line\">    <span class=\"built_in\">CGContextRelease</span>(context);</span><br><span class=\"line\">    </span><br><span class=\"line\">    CVPixelBufferUnlockBaseAddress(pxbuffer, <span class=\"number\">0</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> pxbuffer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上各个函数基本都要操作指针，所以一定要注意手动释放内存，否则会造成非常严重的内存泄漏。</p>\n"},{"title":"使用PlutoSDR构建简易通信系统","date":"2018-01-29T14:21:10.000Z","_content":"\n# 使用 Pluto SDR 构建简易通信系统\n\n### 作者\n\n**王路远**\n\n电子信息与通信学院 通信工程 1502 班\n\n联系方式：e@wangluyuan.cc\n\n同组人：李星\n\n### 基本情况\n\n我们利用 Pluto SDR 设备，在已有的示例程序 bpsk_demo 的基础上修改，实现了可靠的无线通信系统。两台 Pluto 中，一台作为发射机，另一台作为接收机，可在实际的无线信道中，传输任意长度的文字或文件。为了保证可靠传输，分别实现了简化的**停止等待协议**和**滑动窗口协议**。\n\n操作系统：Windows 、 Ubuntu\n\n（在 Windows 和 Ubuntu 设备上配置 Pluto 比较容易，按照说明文档操作就可以了。但是我们也尝试了许久在 macOS 上操作 Pluto，但没有成功。表现为：Matlab 下启动程序，报错 `image not found`。如果你成功在 macOS 上运行了相关程序，请联系我！）\n\n![overview](/img/Pluto/overview.JPG)\n\n### 准备工作\n\n在默认的库文件 `/library/matlab/iio_sys_obj_matlab.m` 中，函数 `function ret = stepImpl(obj, varargin)` 中实现了发射和接收数据，即\n\n```matlab\n% Implement the data transmit flow\nwriteData(obj.libiio_data_in_dev, varargin{1});\n            \n% Implement the data capture flow\n[~, data] = readData(obj.libiio_data_out_dev);\n```\n\n我们认为 Pluto 是拥有一个发送存储器和接收存储器，分别读、写这两个存储器完成发送和接收的功能。单个设备自发自收时，在一个函数里既发送又接收是正确的。但是我们现在要实现多台设备的通信，就需要指定发射机和接收机，也就是分别控制发送和接收。于是需要把 `stepImpl` 函数拆成两个函数：发送数据函数和接收数据函数：\n\n```matlab\n%用来发送数据\nfunction writeTxData(obj, varargin)\n\t%......\n    writeData(obj.libiio_data_in_dev, varargin{1});\nend\n%用来接收数据\nfunction ret = readRxData(obj)\n\tvarargout = cell(1, obj.out_ch_no + length(obj.iio_dev_cfg.mon_ch));\n\t[~, data] = readData(obj.libiio_data_out_dev);\n\t%......\n    ret=varargout;\nend\n```\n\n\n\n在 bpsk_demo 的文件 `/code/matlab/BPSK/transmitter/bpsk_tx_func.m` 中，原作者设置了要发送的 128*4 = 512 bit 的数据（原注释有错，应是 bit 而不是 byte）。其中前 480 比特是有用信息（60 个字符），后 32 位用作循环冗余校验（CRC）。由于在其他地方设置了收发的数据长度而不好更改，这里我们就用了这 512 比特作为一个数据帧。为了支持任意长度的数据，需要把给定的不足 60 个字符的消息结尾补没有意义的空白字符填充到 60。\n\n```matlab\nfunction txdata = bpsk_tx_func(msgStr)\n\t%......\n\tfor k = length(msgStr)+1 :60\n    \tmsgStr = [msgStr, char(0)];\n\tend\n\t%......\nend\n```\n\n当发送长消息时，以 60 个字符一切割，在接受到之后只需要抹去最后的空白字符就可以恢复原始消息。\n\n### 停止等待协议\n\n我们实现的停止等待协议是这样的：\n\n- 帧序号有 0 和 1 两种，在两种之间跳变\n- 每帧的前 3 个字符用作帧序号和其他控制信息。即有效信息从 60 个字符减少到 57 个字符\n- **发送方**每次发送一个帧，并开始计时\n- **接收方**如果收到一个帧，且该帧的序号是自己期望的，则把收到的帧序号返回，并保存相应数据\n- **发送方**如果没有到规定的超时时间（这里是 10 秒）：\n  - 持续监听返回值\n  - 如果收到自己刚刚发送到的帧序号\n    - 发送下一帧\n  - 否则\n    - 继续监听，直到超时\n- **发送方**如果超时，重新传输刚才的帧\n\n### 滑动窗口协议\n\n我们实现的滑动窗口协议是这样的：\n\n- 发送方和接收方窗口大小均设置为 5\n- 为了避免序号回滚时引起歧义，序号的个数设置为窗口大小的 2 倍，即取 1- 10\n- **发送方**维护发送窗口，在等待发送的数据数组上滚动\n- **接收方**维护接收窗口，判断收到的数据帧号是否落在自己的窗口内，并酌情保存数据\n- **接收方**发现有一段序号连续的数据后（顺序正常），滑动自己的窗口，并返回这些连续的数据中的最大序号\n- **发送方**一次发完从上次发送的位置到窗口末尾中的所有数据，并开始计时\n- **发送方**如果没有到规定的超时时间（这里是 10 秒）\n  - 持续监听返回值\n  - 如果收到的帧序号落在自己的发送窗口中，且与之前收到的帧序号不一样\n    - 滑动窗口并开始发送下一串数据\n  - 否则\n    - 继续监听，直到超时\n- **发送方**如果超时，重新传输窗口中的所有数据\n\n![sketch](/img/Pluto/sketch.JPG)\n\n（这是我们在讨论两种协议时打的草稿，当时忘记带草稿纸，只好用抽纸应急:P）\n\n### 传输文件\n\n一旦可靠的传输文字的系统构建完成，传输文件遍不再是问题。我们使用 Base64 编码，将二进制文件编码成字符串，就可以使用之前的通信系统来传输任意的文件了。\n\n需要注意的是，Base64 编码的字符集中不包含空白字符，因此不会与截取末尾空白字符的操作方法产生冲突。\n\n### 效果\n\n发送方将下图成功发送给接收方，该图片大小约为 3 kB。\n\n![logo](/img/Pluto/logo.png)\n\n发送过程中，控制台打印如下消息：\n\n![console1](/img/Pluto/console1.PNG)\n\n从上图可以看到，发送方先收到 4， 后收到 9，于是发送窗口滑动，一次性发送五条消息。\n\n![console2](/img/Pluto/console2.PNG)\n\n从上图可以看到，由于全部消息已经发完，即使收到的序号发生改变，窗口也不再继续滑动。最后双方挥手再见，退出程序。平均发送速度为 49.8558 bps。\n\n### 不足\n\n因为时间比较仓促（我要赴美国参加冬令营活动，李星即将去做手术），我们的程序还有一些不足。其中最主要的一点是发送数据的速度比较缓慢。我们分析的原因主要是，Pluto 每次接收数据都需要一定的时间，而发送的速度很快。有可能发送只用了一瞬间，而恰好这段时间接收方还在读取上次的数据，就错过了消息，导致丢包率非常严重，每次都不得不等待超时重传。我们对发送方发送的速度做了延迟，即同样的内容延长发送时间，效果有所改善，但仍不尽人意，两者不能进行很好的同步。目前我们还没找到比较好的解决方案。\n\n当然，改善发送速率也可以降低超时时间（现在的 10 秒是为了方便观察实验现象）；采用多进制的调制方式，如 4PSK、16QAM 等；增大包体积（因为误码率不算太高，而丢包率很高）还有增大滑动窗口大小等。\n\n### 遇到的困难\n\n- 在 macOS 上程序一直报错，还没有解决。最后我们使用了 Windows 和 Ubuntu 操作系统。\n- 公开的资料太少，上手不容易。不过在和同学讨论后得到解决，在写协议逻辑的时候还是很愉快的。\n- 发送方频繁接收到自己刚刚发送的数据，而很少收到接收方回复的消息。也就是应该接受的消息完全被淹没在自己发送的消息里了。为了确定是干扰导致的，我们先用同轴线将两台 Pluto 的 Rx 和 Tx 分别连在了一起。有线的状态下，电磁波基本都被屏蔽在导线内，这个问题果然不存在了。确定问题的原因后，我们修改了发送和接收所用的载波频率，发送和接收就不再互相干扰了。)\n\n![wire](/img/Pluto/wire.JPG)\n\n### 总结和收获\n\n做这样一件事情确实比较有挑战性。主要原因是网上公开的资料太少，无论是官方 Wiki 还是厂家提供的资料，帮助都比较小。再加上之前也没有使用过同类的 SDR 产品，开始确实比较懵。不过后来在自习阅读了厂家提供的示例代码，又和同学讨论过后，逐渐就能开始编写逻辑了。\n\n我和李星同学大概花了一天半的时间来实际的编写逻辑代码，时间确实比较紧张，不过收获也很多。从头到位设计可靠传输的协议实在太有意思了。事实上我们在写代码的时候完全没有翻看计算机网络的数据，也基本没有查找什么资料。因为时间过的比较久了，不少协议的细节我们都记不清楚了，于是就自己思考传输的过程中会出现什么差错，讨论解决这些问题的办法。有的时候会突然恍然大悟，想明白为什么前辈要这样设计！通过这次实验，熟悉了 SDR 设备、对通信原理中的理论知识有了一个落地，更是大大增强了对计算机网络的理解。\n\n期待以后还能有机会用 Pluto SDR 做一些更复杂、更有意思的东西。\n\n### 其他\n\n本项目的完整代码托管在了 GitHub 上：https://github.com/BeBeBerr/Pluto-Network\n\n此文章发布在了我的 Blog 上，[欢迎查看](http://blog.wangluyuan.cc/2018/01/29/使用PlutoSDR构建简易通信系统/)。\n\n","source":"_posts/使用PlutoSDR构建简易通信系统.md","raw":"---\ntitle: 使用PlutoSDR构建简易通信系统\ndate: 2018-01-29 22:21:10\ntags: PlutoSDR\n---\n\n# 使用 Pluto SDR 构建简易通信系统\n\n### 作者\n\n**王路远**\n\n电子信息与通信学院 通信工程 1502 班\n\n联系方式：e@wangluyuan.cc\n\n同组人：李星\n\n### 基本情况\n\n我们利用 Pluto SDR 设备，在已有的示例程序 bpsk_demo 的基础上修改，实现了可靠的无线通信系统。两台 Pluto 中，一台作为发射机，另一台作为接收机，可在实际的无线信道中，传输任意长度的文字或文件。为了保证可靠传输，分别实现了简化的**停止等待协议**和**滑动窗口协议**。\n\n操作系统：Windows 、 Ubuntu\n\n（在 Windows 和 Ubuntu 设备上配置 Pluto 比较容易，按照说明文档操作就可以了。但是我们也尝试了许久在 macOS 上操作 Pluto，但没有成功。表现为：Matlab 下启动程序，报错 `image not found`。如果你成功在 macOS 上运行了相关程序，请联系我！）\n\n![overview](/img/Pluto/overview.JPG)\n\n### 准备工作\n\n在默认的库文件 `/library/matlab/iio_sys_obj_matlab.m` 中，函数 `function ret = stepImpl(obj, varargin)` 中实现了发射和接收数据，即\n\n```matlab\n% Implement the data transmit flow\nwriteData(obj.libiio_data_in_dev, varargin{1});\n            \n% Implement the data capture flow\n[~, data] = readData(obj.libiio_data_out_dev);\n```\n\n我们认为 Pluto 是拥有一个发送存储器和接收存储器，分别读、写这两个存储器完成发送和接收的功能。单个设备自发自收时，在一个函数里既发送又接收是正确的。但是我们现在要实现多台设备的通信，就需要指定发射机和接收机，也就是分别控制发送和接收。于是需要把 `stepImpl` 函数拆成两个函数：发送数据函数和接收数据函数：\n\n```matlab\n%用来发送数据\nfunction writeTxData(obj, varargin)\n\t%......\n    writeData(obj.libiio_data_in_dev, varargin{1});\nend\n%用来接收数据\nfunction ret = readRxData(obj)\n\tvarargout = cell(1, obj.out_ch_no + length(obj.iio_dev_cfg.mon_ch));\n\t[~, data] = readData(obj.libiio_data_out_dev);\n\t%......\n    ret=varargout;\nend\n```\n\n\n\n在 bpsk_demo 的文件 `/code/matlab/BPSK/transmitter/bpsk_tx_func.m` 中，原作者设置了要发送的 128*4 = 512 bit 的数据（原注释有错，应是 bit 而不是 byte）。其中前 480 比特是有用信息（60 个字符），后 32 位用作循环冗余校验（CRC）。由于在其他地方设置了收发的数据长度而不好更改，这里我们就用了这 512 比特作为一个数据帧。为了支持任意长度的数据，需要把给定的不足 60 个字符的消息结尾补没有意义的空白字符填充到 60。\n\n```matlab\nfunction txdata = bpsk_tx_func(msgStr)\n\t%......\n\tfor k = length(msgStr)+1 :60\n    \tmsgStr = [msgStr, char(0)];\n\tend\n\t%......\nend\n```\n\n当发送长消息时，以 60 个字符一切割，在接受到之后只需要抹去最后的空白字符就可以恢复原始消息。\n\n### 停止等待协议\n\n我们实现的停止等待协议是这样的：\n\n- 帧序号有 0 和 1 两种，在两种之间跳变\n- 每帧的前 3 个字符用作帧序号和其他控制信息。即有效信息从 60 个字符减少到 57 个字符\n- **发送方**每次发送一个帧，并开始计时\n- **接收方**如果收到一个帧，且该帧的序号是自己期望的，则把收到的帧序号返回，并保存相应数据\n- **发送方**如果没有到规定的超时时间（这里是 10 秒）：\n  - 持续监听返回值\n  - 如果收到自己刚刚发送到的帧序号\n    - 发送下一帧\n  - 否则\n    - 继续监听，直到超时\n- **发送方**如果超时，重新传输刚才的帧\n\n### 滑动窗口协议\n\n我们实现的滑动窗口协议是这样的：\n\n- 发送方和接收方窗口大小均设置为 5\n- 为了避免序号回滚时引起歧义，序号的个数设置为窗口大小的 2 倍，即取 1- 10\n- **发送方**维护发送窗口，在等待发送的数据数组上滚动\n- **接收方**维护接收窗口，判断收到的数据帧号是否落在自己的窗口内，并酌情保存数据\n- **接收方**发现有一段序号连续的数据后（顺序正常），滑动自己的窗口，并返回这些连续的数据中的最大序号\n- **发送方**一次发完从上次发送的位置到窗口末尾中的所有数据，并开始计时\n- **发送方**如果没有到规定的超时时间（这里是 10 秒）\n  - 持续监听返回值\n  - 如果收到的帧序号落在自己的发送窗口中，且与之前收到的帧序号不一样\n    - 滑动窗口并开始发送下一串数据\n  - 否则\n    - 继续监听，直到超时\n- **发送方**如果超时，重新传输窗口中的所有数据\n\n![sketch](/img/Pluto/sketch.JPG)\n\n（这是我们在讨论两种协议时打的草稿，当时忘记带草稿纸，只好用抽纸应急:P）\n\n### 传输文件\n\n一旦可靠的传输文字的系统构建完成，传输文件遍不再是问题。我们使用 Base64 编码，将二进制文件编码成字符串，就可以使用之前的通信系统来传输任意的文件了。\n\n需要注意的是，Base64 编码的字符集中不包含空白字符，因此不会与截取末尾空白字符的操作方法产生冲突。\n\n### 效果\n\n发送方将下图成功发送给接收方，该图片大小约为 3 kB。\n\n![logo](/img/Pluto/logo.png)\n\n发送过程中，控制台打印如下消息：\n\n![console1](/img/Pluto/console1.PNG)\n\n从上图可以看到，发送方先收到 4， 后收到 9，于是发送窗口滑动，一次性发送五条消息。\n\n![console2](/img/Pluto/console2.PNG)\n\n从上图可以看到，由于全部消息已经发完，即使收到的序号发生改变，窗口也不再继续滑动。最后双方挥手再见，退出程序。平均发送速度为 49.8558 bps。\n\n### 不足\n\n因为时间比较仓促（我要赴美国参加冬令营活动，李星即将去做手术），我们的程序还有一些不足。其中最主要的一点是发送数据的速度比较缓慢。我们分析的原因主要是，Pluto 每次接收数据都需要一定的时间，而发送的速度很快。有可能发送只用了一瞬间，而恰好这段时间接收方还在读取上次的数据，就错过了消息，导致丢包率非常严重，每次都不得不等待超时重传。我们对发送方发送的速度做了延迟，即同样的内容延长发送时间，效果有所改善，但仍不尽人意，两者不能进行很好的同步。目前我们还没找到比较好的解决方案。\n\n当然，改善发送速率也可以降低超时时间（现在的 10 秒是为了方便观察实验现象）；采用多进制的调制方式，如 4PSK、16QAM 等；增大包体积（因为误码率不算太高，而丢包率很高）还有增大滑动窗口大小等。\n\n### 遇到的困难\n\n- 在 macOS 上程序一直报错，还没有解决。最后我们使用了 Windows 和 Ubuntu 操作系统。\n- 公开的资料太少，上手不容易。不过在和同学讨论后得到解决，在写协议逻辑的时候还是很愉快的。\n- 发送方频繁接收到自己刚刚发送的数据，而很少收到接收方回复的消息。也就是应该接受的消息完全被淹没在自己发送的消息里了。为了确定是干扰导致的，我们先用同轴线将两台 Pluto 的 Rx 和 Tx 分别连在了一起。有线的状态下，电磁波基本都被屏蔽在导线内，这个问题果然不存在了。确定问题的原因后，我们修改了发送和接收所用的载波频率，发送和接收就不再互相干扰了。)\n\n![wire](/img/Pluto/wire.JPG)\n\n### 总结和收获\n\n做这样一件事情确实比较有挑战性。主要原因是网上公开的资料太少，无论是官方 Wiki 还是厂家提供的资料，帮助都比较小。再加上之前也没有使用过同类的 SDR 产品，开始确实比较懵。不过后来在自习阅读了厂家提供的示例代码，又和同学讨论过后，逐渐就能开始编写逻辑了。\n\n我和李星同学大概花了一天半的时间来实际的编写逻辑代码，时间确实比较紧张，不过收获也很多。从头到位设计可靠传输的协议实在太有意思了。事实上我们在写代码的时候完全没有翻看计算机网络的数据，也基本没有查找什么资料。因为时间过的比较久了，不少协议的细节我们都记不清楚了，于是就自己思考传输的过程中会出现什么差错，讨论解决这些问题的办法。有的时候会突然恍然大悟，想明白为什么前辈要这样设计！通过这次实验，熟悉了 SDR 设备、对通信原理中的理论知识有了一个落地，更是大大增强了对计算机网络的理解。\n\n期待以后还能有机会用 Pluto SDR 做一些更复杂、更有意思的东西。\n\n### 其他\n\n本项目的完整代码托管在了 GitHub 上：https://github.com/BeBeBerr/Pluto-Network\n\n此文章发布在了我的 Blog 上，[欢迎查看](http://blog.wangluyuan.cc/2018/01/29/使用PlutoSDR构建简易通信系统/)。\n\n","slug":"使用PlutoSDR构建简易通信系统","published":1,"updated":"2020-01-04T08:16:16.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv46003nljc30334z6vz","content":"<h1 id=\"使用-Pluto-SDR-构建简易通信系统\"><a href=\"#使用-Pluto-SDR-构建简易通信系统\" class=\"headerlink\" title=\"使用 Pluto SDR 构建简易通信系统\"></a>使用 Pluto SDR 构建简易通信系统</h1><h3 id=\"作者\"><a href=\"#作者\" class=\"headerlink\" title=\"作者\"></a>作者</h3><p><strong>王路远</strong></p>\n<p>电子信息与通信学院 通信工程 1502 班</p>\n<p>联系方式：<a href=\"mailto:e@wangluyuan.cc\">e@wangluyuan.cc</a></p>\n<p>同组人：李星</p>\n<h3 id=\"基本情况\"><a href=\"#基本情况\" class=\"headerlink\" title=\"基本情况\"></a>基本情况</h3><p>我们利用 Pluto SDR 设备，在已有的示例程序 bpsk_demo 的基础上修改，实现了可靠的无线通信系统。两台 Pluto 中，一台作为发射机，另一台作为接收机，可在实际的无线信道中，传输任意长度的文字或文件。为了保证可靠传输，分别实现了简化的<strong>停止等待协议</strong>和<strong>滑动窗口协议</strong>。</p>\n<p>操作系统：Windows 、 Ubuntu</p>\n<p>（在 Windows 和 Ubuntu 设备上配置 Pluto 比较容易，按照说明文档操作就可以了。但是我们也尝试了许久在 macOS 上操作 Pluto，但没有成功。表现为：Matlab 下启动程序，报错 <code>image not found</code>。如果你成功在 macOS 上运行了相关程序，请联系我！）</p>\n<p><img src=\"/img/Pluto/overview.JPG\" alt=\"overview\"></p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>在默认的库文件 <code>/library/matlab/iio_sys_obj_matlab.m</code> 中，函数 <code>function ret = stepImpl(obj, varargin)</code> 中实现了发射和接收数据，即</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% Implement the data transmit flow</span></span><br><span class=\"line\">writeData(obj.libiio_data_in_dev, varargin&#123;<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"comment\">% Implement the data capture flow</span></span><br><span class=\"line\">[~, data] = readData(obj.libiio_data_out_dev);</span><br></pre></td></tr></table></figure>\n<p>我们认为 Pluto 是拥有一个发送存储器和接收存储器，分别读、写这两个存储器完成发送和接收的功能。单个设备自发自收时，在一个函数里既发送又接收是正确的。但是我们现在要实现多台设备的通信，就需要指定发射机和接收机，也就是分别控制发送和接收。于是需要把 <code>stepImpl</code> 函数拆成两个函数：发送数据函数和接收数据函数：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%用来发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">writeTxData</span><span class=\"params\">(obj, varargin)</span></span></span><br><span class=\"line\">\t<span class=\"comment\">%......</span></span><br><span class=\"line\">    writeData(obj.libiio_data_in_dev, varargin&#123;<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">%用来接收数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ret</span> = <span class=\"title\">readRxData</span><span class=\"params\">(obj)</span></span></span><br><span class=\"line\">\tvarargout = cell(<span class=\"number\">1</span>, obj.out_ch_no + <span class=\"built_in\">length</span>(obj.iio_dev_cfg.mon_ch));</span><br><span class=\"line\">\t[~, data] = readData(obj.libiio_data_out_dev);</span><br><span class=\"line\">\t<span class=\"comment\">%......</span></span><br><span class=\"line\">    ret=varargout;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>在 bpsk_demo 的文件 <code>/code/matlab/BPSK/transmitter/bpsk_tx_func.m</code> 中，原作者设置了要发送的 128*4 = 512 bit 的数据（原注释有错，应是 bit 而不是 byte）。其中前 480 比特是有用信息（60 个字符），后 32 位用作循环冗余校验（CRC）。由于在其他地方设置了收发的数据长度而不好更改，这里我们就用了这 512 比特作为一个数据帧。为了支持任意长度的数据，需要把给定的不足 60 个字符的消息结尾补没有意义的空白字符填充到 60。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">txdata</span> = <span class=\"title\">bpsk_tx_func</span><span class=\"params\">(msgStr)</span></span></span><br><span class=\"line\">\t<span class=\"comment\">%......</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k = <span class=\"built_in\">length</span>(msgStr)+<span class=\"number\">1</span> :<span class=\"number\">60</span></span><br><span class=\"line\">    \tmsgStr = [msgStr, char(<span class=\"number\">0</span>)];</span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\">\t<span class=\"comment\">%......</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>当发送长消息时，以 60 个字符一切割，在接受到之后只需要抹去最后的空白字符就可以恢复原始消息。</p>\n<h3 id=\"停止等待协议\"><a href=\"#停止等待协议\" class=\"headerlink\" title=\"停止等待协议\"></a>停止等待协议</h3><p>我们实现的停止等待协议是这样的：</p>\n<ul>\n<li>帧序号有 0 和 1 两种，在两种之间跳变</li>\n<li>每帧的前 3 个字符用作帧序号和其他控制信息。即有效信息从 60 个字符减少到 57 个字符</li>\n<li><strong>发送方</strong>每次发送一个帧，并开始计时</li>\n<li><strong>接收方</strong>如果收到一个帧，且该帧的序号是自己期望的，则把收到的帧序号返回，并保存相应数据</li>\n<li><strong>发送方</strong>如果没有到规定的超时时间（这里是 10 秒）：<ul>\n<li>持续监听返回值</li>\n<li>如果收到自己刚刚发送到的帧序号<ul>\n<li>发送下一帧</li>\n</ul>\n</li>\n<li>否则<ul>\n<li>继续监听，直到超时</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>发送方</strong>如果超时，重新传输刚才的帧</li>\n</ul>\n<h3 id=\"滑动窗口协议\"><a href=\"#滑动窗口协议\" class=\"headerlink\" title=\"滑动窗口协议\"></a>滑动窗口协议</h3><p>我们实现的滑动窗口协议是这样的：</p>\n<ul>\n<li>发送方和接收方窗口大小均设置为 5</li>\n<li>为了避免序号回滚时引起歧义，序号的个数设置为窗口大小的 2 倍，即取 1- 10</li>\n<li><strong>发送方</strong>维护发送窗口，在等待发送的数据数组上滚动</li>\n<li><strong>接收方</strong>维护接收窗口，判断收到的数据帧号是否落在自己的窗口内，并酌情保存数据</li>\n<li><strong>接收方</strong>发现有一段序号连续的数据后（顺序正常），滑动自己的窗口，并返回这些连续的数据中的最大序号</li>\n<li><strong>发送方</strong>一次发完从上次发送的位置到窗口末尾中的所有数据，并开始计时</li>\n<li><strong>发送方</strong>如果没有到规定的超时时间（这里是 10 秒）<ul>\n<li>持续监听返回值</li>\n<li>如果收到的帧序号落在自己的发送窗口中，且与之前收到的帧序号不一样<ul>\n<li>滑动窗口并开始发送下一串数据</li>\n</ul>\n</li>\n<li>否则<ul>\n<li>继续监听，直到超时</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>发送方</strong>如果超时，重新传输窗口中的所有数据</li>\n</ul>\n<p><img src=\"/img/Pluto/sketch.JPG\" alt=\"sketch\"></p>\n<p>（这是我们在讨论两种协议时打的草稿，当时忘记带草稿纸，只好用抽纸应急:P）</p>\n<h3 id=\"传输文件\"><a href=\"#传输文件\" class=\"headerlink\" title=\"传输文件\"></a>传输文件</h3><p>一旦可靠的传输文字的系统构建完成，传输文件遍不再是问题。我们使用 Base64 编码，将二进制文件编码成字符串，就可以使用之前的通信系统来传输任意的文件了。</p>\n<p>需要注意的是，Base64 编码的字符集中不包含空白字符，因此不会与截取末尾空白字符的操作方法产生冲突。</p>\n<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p>发送方将下图成功发送给接收方，该图片大小约为 3 kB。</p>\n<p><img src=\"/img/Pluto/logo.png\" alt=\"logo\"></p>\n<p>发送过程中，控制台打印如下消息：</p>\n<p><img src=\"/img/Pluto/console1.PNG\" alt=\"console1\"></p>\n<p>从上图可以看到，发送方先收到 4， 后收到 9，于是发送窗口滑动，一次性发送五条消息。</p>\n<p><img src=\"/img/Pluto/console2.PNG\" alt=\"console2\"></p>\n<p>从上图可以看到，由于全部消息已经发完，即使收到的序号发生改变，窗口也不再继续滑动。最后双方挥手再见，退出程序。平均发送速度为 49.8558 bps。</p>\n<h3 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h3><p>因为时间比较仓促（我要赴美国参加冬令营活动，李星即将去做手术），我们的程序还有一些不足。其中最主要的一点是发送数据的速度比较缓慢。我们分析的原因主要是，Pluto 每次接收数据都需要一定的时间，而发送的速度很快。有可能发送只用了一瞬间，而恰好这段时间接收方还在读取上次的数据，就错过了消息，导致丢包率非常严重，每次都不得不等待超时重传。我们对发送方发送的速度做了延迟，即同样的内容延长发送时间，效果有所改善，但仍不尽人意，两者不能进行很好的同步。目前我们还没找到比较好的解决方案。</p>\n<p>当然，改善发送速率也可以降低超时时间（现在的 10 秒是为了方便观察实验现象）；采用多进制的调制方式，如 4PSK、16QAM 等；增大包体积（因为误码率不算太高，而丢包率很高）还有增大滑动窗口大小等。</p>\n<h3 id=\"遇到的困难\"><a href=\"#遇到的困难\" class=\"headerlink\" title=\"遇到的困难\"></a>遇到的困难</h3><ul>\n<li>在 macOS 上程序一直报错，还没有解决。最后我们使用了 Windows 和 Ubuntu 操作系统。</li>\n<li>公开的资料太少，上手不容易。不过在和同学讨论后得到解决，在写协议逻辑的时候还是很愉快的。</li>\n<li>发送方频繁接收到自己刚刚发送的数据，而很少收到接收方回复的消息。也就是应该接受的消息完全被淹没在自己发送的消息里了。为了确定是干扰导致的，我们先用同轴线将两台 Pluto 的 Rx 和 Tx 分别连在了一起。有线的状态下，电磁波基本都被屏蔽在导线内，这个问题果然不存在了。确定问题的原因后，我们修改了发送和接收所用的载波频率，发送和接收就不再互相干扰了。)</li>\n</ul>\n<p><img src=\"/img/Pluto/wire.JPG\" alt=\"wire\"></p>\n<h3 id=\"总结和收获\"><a href=\"#总结和收获\" class=\"headerlink\" title=\"总结和收获\"></a>总结和收获</h3><p>做这样一件事情确实比较有挑战性。主要原因是网上公开的资料太少，无论是官方 Wiki 还是厂家提供的资料，帮助都比较小。再加上之前也没有使用过同类的 SDR 产品，开始确实比较懵。不过后来在自习阅读了厂家提供的示例代码，又和同学讨论过后，逐渐就能开始编写逻辑了。</p>\n<p>我和李星同学大概花了一天半的时间来实际的编写逻辑代码，时间确实比较紧张，不过收获也很多。从头到位设计可靠传输的协议实在太有意思了。事实上我们在写代码的时候完全没有翻看计算机网络的数据，也基本没有查找什么资料。因为时间过的比较久了，不少协议的细节我们都记不清楚了，于是就自己思考传输的过程中会出现什么差错，讨论解决这些问题的办法。有的时候会突然恍然大悟，想明白为什么前辈要这样设计！通过这次实验，熟悉了 SDR 设备、对通信原理中的理论知识有了一个落地，更是大大增强了对计算机网络的理解。</p>\n<p>期待以后还能有机会用 Pluto SDR 做一些更复杂、更有意思的东西。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>本项目的完整代码托管在了 GitHub 上：<a href=\"https://github.com/BeBeBerr/Pluto-Network\">https://github.com/BeBeBerr/Pluto-Network</a></p>\n<p>此文章发布在了我的 Blog 上，<a href=\"http://blog.wangluyuan.cc/2018/01/29/使用PlutoSDR构建简易通信系统/\">欢迎查看</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用-Pluto-SDR-构建简易通信系统\"><a href=\"#使用-Pluto-SDR-构建简易通信系统\" class=\"headerlink\" title=\"使用 Pluto SDR 构建简易通信系统\"></a>使用 Pluto SDR 构建简易通信系统</h1><h3 id=\"作者\"><a href=\"#作者\" class=\"headerlink\" title=\"作者\"></a>作者</h3><p><strong>王路远</strong></p>\n<p>电子信息与通信学院 通信工程 1502 班</p>\n<p>联系方式：<a href=\"mailto:e@wangluyuan.cc\">e@wangluyuan.cc</a></p>\n<p>同组人：李星</p>\n<h3 id=\"基本情况\"><a href=\"#基本情况\" class=\"headerlink\" title=\"基本情况\"></a>基本情况</h3><p>我们利用 Pluto SDR 设备，在已有的示例程序 bpsk_demo 的基础上修改，实现了可靠的无线通信系统。两台 Pluto 中，一台作为发射机，另一台作为接收机，可在实际的无线信道中，传输任意长度的文字或文件。为了保证可靠传输，分别实现了简化的<strong>停止等待协议</strong>和<strong>滑动窗口协议</strong>。</p>\n<p>操作系统：Windows 、 Ubuntu</p>\n<p>（在 Windows 和 Ubuntu 设备上配置 Pluto 比较容易，按照说明文档操作就可以了。但是我们也尝试了许久在 macOS 上操作 Pluto，但没有成功。表现为：Matlab 下启动程序，报错 <code>image not found</code>。如果你成功在 macOS 上运行了相关程序，请联系我！）</p>\n<p><img src=\"/img/Pluto/overview.JPG\" alt=\"overview\"></p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>在默认的库文件 <code>/library/matlab/iio_sys_obj_matlab.m</code> 中，函数 <code>function ret = stepImpl(obj, varargin)</code> 中实现了发射和接收数据，即</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">% Implement the data transmit flow</span></span><br><span class=\"line\">writeData(obj.libiio_data_in_dev, varargin&#123;<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">            </span><br><span class=\"line\"><span class=\"comment\">% Implement the data capture flow</span></span><br><span class=\"line\">[~, data] = readData(obj.libiio_data_out_dev);</span><br></pre></td></tr></table></figure>\n<p>我们认为 Pluto 是拥有一个发送存储器和接收存储器，分别读、写这两个存储器完成发送和接收的功能。单个设备自发自收时，在一个函数里既发送又接收是正确的。但是我们现在要实现多台设备的通信，就需要指定发射机和接收机，也就是分别控制发送和接收。于是需要把 <code>stepImpl</code> 函数拆成两个函数：发送数据函数和接收数据函数：</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%用来发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">writeTxData</span><span class=\"params\">(obj, varargin)</span></span></span><br><span class=\"line\">\t<span class=\"comment\">%......</span></span><br><span class=\"line\">    writeData(obj.libiio_data_in_dev, varargin&#123;<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"comment\">%用来接收数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ret</span> = <span class=\"title\">readRxData</span><span class=\"params\">(obj)</span></span></span><br><span class=\"line\">\tvarargout = cell(<span class=\"number\">1</span>, obj.out_ch_no + <span class=\"built_in\">length</span>(obj.iio_dev_cfg.mon_ch));</span><br><span class=\"line\">\t[~, data] = readData(obj.libiio_data_out_dev);</span><br><span class=\"line\">\t<span class=\"comment\">%......</span></span><br><span class=\"line\">    ret=varargout;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>在 bpsk_demo 的文件 <code>/code/matlab/BPSK/transmitter/bpsk_tx_func.m</code> 中，原作者设置了要发送的 128*4 = 512 bit 的数据（原注释有错，应是 bit 而不是 byte）。其中前 480 比特是有用信息（60 个字符），后 32 位用作循环冗余校验（CRC）。由于在其他地方设置了收发的数据长度而不好更改，这里我们就用了这 512 比特作为一个数据帧。为了支持任意长度的数据，需要把给定的不足 60 个字符的消息结尾补没有意义的空白字符填充到 60。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">txdata</span> = <span class=\"title\">bpsk_tx_func</span><span class=\"params\">(msgStr)</span></span></span><br><span class=\"line\">\t<span class=\"comment\">%......</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> k = <span class=\"built_in\">length</span>(msgStr)+<span class=\"number\">1</span> :<span class=\"number\">60</span></span><br><span class=\"line\">    \tmsgStr = [msgStr, char(<span class=\"number\">0</span>)];</span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\">\t<span class=\"comment\">%......</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<p>当发送长消息时，以 60 个字符一切割，在接受到之后只需要抹去最后的空白字符就可以恢复原始消息。</p>\n<h3 id=\"停止等待协议\"><a href=\"#停止等待协议\" class=\"headerlink\" title=\"停止等待协议\"></a>停止等待协议</h3><p>我们实现的停止等待协议是这样的：</p>\n<ul>\n<li>帧序号有 0 和 1 两种，在两种之间跳变</li>\n<li>每帧的前 3 个字符用作帧序号和其他控制信息。即有效信息从 60 个字符减少到 57 个字符</li>\n<li><strong>发送方</strong>每次发送一个帧，并开始计时</li>\n<li><strong>接收方</strong>如果收到一个帧，且该帧的序号是自己期望的，则把收到的帧序号返回，并保存相应数据</li>\n<li><strong>发送方</strong>如果没有到规定的超时时间（这里是 10 秒）：<ul>\n<li>持续监听返回值</li>\n<li>如果收到自己刚刚发送到的帧序号<ul>\n<li>发送下一帧</li>\n</ul>\n</li>\n<li>否则<ul>\n<li>继续监听，直到超时</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>发送方</strong>如果超时，重新传输刚才的帧</li>\n</ul>\n<h3 id=\"滑动窗口协议\"><a href=\"#滑动窗口协议\" class=\"headerlink\" title=\"滑动窗口协议\"></a>滑动窗口协议</h3><p>我们实现的滑动窗口协议是这样的：</p>\n<ul>\n<li>发送方和接收方窗口大小均设置为 5</li>\n<li>为了避免序号回滚时引起歧义，序号的个数设置为窗口大小的 2 倍，即取 1- 10</li>\n<li><strong>发送方</strong>维护发送窗口，在等待发送的数据数组上滚动</li>\n<li><strong>接收方</strong>维护接收窗口，判断收到的数据帧号是否落在自己的窗口内，并酌情保存数据</li>\n<li><strong>接收方</strong>发现有一段序号连续的数据后（顺序正常），滑动自己的窗口，并返回这些连续的数据中的最大序号</li>\n<li><strong>发送方</strong>一次发完从上次发送的位置到窗口末尾中的所有数据，并开始计时</li>\n<li><strong>发送方</strong>如果没有到规定的超时时间（这里是 10 秒）<ul>\n<li>持续监听返回值</li>\n<li>如果收到的帧序号落在自己的发送窗口中，且与之前收到的帧序号不一样<ul>\n<li>滑动窗口并开始发送下一串数据</li>\n</ul>\n</li>\n<li>否则<ul>\n<li>继续监听，直到超时</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>发送方</strong>如果超时，重新传输窗口中的所有数据</li>\n</ul>\n<p><img src=\"/img/Pluto/sketch.JPG\" alt=\"sketch\"></p>\n<p>（这是我们在讨论两种协议时打的草稿，当时忘记带草稿纸，只好用抽纸应急:P）</p>\n<h3 id=\"传输文件\"><a href=\"#传输文件\" class=\"headerlink\" title=\"传输文件\"></a>传输文件</h3><p>一旦可靠的传输文字的系统构建完成，传输文件遍不再是问题。我们使用 Base64 编码，将二进制文件编码成字符串，就可以使用之前的通信系统来传输任意的文件了。</p>\n<p>需要注意的是，Base64 编码的字符集中不包含空白字符，因此不会与截取末尾空白字符的操作方法产生冲突。</p>\n<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p>发送方将下图成功发送给接收方，该图片大小约为 3 kB。</p>\n<p><img src=\"/img/Pluto/logo.png\" alt=\"logo\"></p>\n<p>发送过程中，控制台打印如下消息：</p>\n<p><img src=\"/img/Pluto/console1.PNG\" alt=\"console1\"></p>\n<p>从上图可以看到，发送方先收到 4， 后收到 9，于是发送窗口滑动，一次性发送五条消息。</p>\n<p><img src=\"/img/Pluto/console2.PNG\" alt=\"console2\"></p>\n<p>从上图可以看到，由于全部消息已经发完，即使收到的序号发生改变，窗口也不再继续滑动。最后双方挥手再见，退出程序。平均发送速度为 49.8558 bps。</p>\n<h3 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h3><p>因为时间比较仓促（我要赴美国参加冬令营活动，李星即将去做手术），我们的程序还有一些不足。其中最主要的一点是发送数据的速度比较缓慢。我们分析的原因主要是，Pluto 每次接收数据都需要一定的时间，而发送的速度很快。有可能发送只用了一瞬间，而恰好这段时间接收方还在读取上次的数据，就错过了消息，导致丢包率非常严重，每次都不得不等待超时重传。我们对发送方发送的速度做了延迟，即同样的内容延长发送时间，效果有所改善，但仍不尽人意，两者不能进行很好的同步。目前我们还没找到比较好的解决方案。</p>\n<p>当然，改善发送速率也可以降低超时时间（现在的 10 秒是为了方便观察实验现象）；采用多进制的调制方式，如 4PSK、16QAM 等；增大包体积（因为误码率不算太高，而丢包率很高）还有增大滑动窗口大小等。</p>\n<h3 id=\"遇到的困难\"><a href=\"#遇到的困难\" class=\"headerlink\" title=\"遇到的困难\"></a>遇到的困难</h3><ul>\n<li>在 macOS 上程序一直报错，还没有解决。最后我们使用了 Windows 和 Ubuntu 操作系统。</li>\n<li>公开的资料太少，上手不容易。不过在和同学讨论后得到解决，在写协议逻辑的时候还是很愉快的。</li>\n<li>发送方频繁接收到自己刚刚发送的数据，而很少收到接收方回复的消息。也就是应该接受的消息完全被淹没在自己发送的消息里了。为了确定是干扰导致的，我们先用同轴线将两台 Pluto 的 Rx 和 Tx 分别连在了一起。有线的状态下，电磁波基本都被屏蔽在导线内，这个问题果然不存在了。确定问题的原因后，我们修改了发送和接收所用的载波频率，发送和接收就不再互相干扰了。)</li>\n</ul>\n<p><img src=\"/img/Pluto/wire.JPG\" alt=\"wire\"></p>\n<h3 id=\"总结和收获\"><a href=\"#总结和收获\" class=\"headerlink\" title=\"总结和收获\"></a>总结和收获</h3><p>做这样一件事情确实比较有挑战性。主要原因是网上公开的资料太少，无论是官方 Wiki 还是厂家提供的资料，帮助都比较小。再加上之前也没有使用过同类的 SDR 产品，开始确实比较懵。不过后来在自习阅读了厂家提供的示例代码，又和同学讨论过后，逐渐就能开始编写逻辑了。</p>\n<p>我和李星同学大概花了一天半的时间来实际的编写逻辑代码，时间确实比较紧张，不过收获也很多。从头到位设计可靠传输的协议实在太有意思了。事实上我们在写代码的时候完全没有翻看计算机网络的数据，也基本没有查找什么资料。因为时间过的比较久了，不少协议的细节我们都记不清楚了，于是就自己思考传输的过程中会出现什么差错，讨论解决这些问题的办法。有的时候会突然恍然大悟，想明白为什么前辈要这样设计！通过这次实验，熟悉了 SDR 设备、对通信原理中的理论知识有了一个落地，更是大大增强了对计算机网络的理解。</p>\n<p>期待以后还能有机会用 Pluto SDR 做一些更复杂、更有意思的东西。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>本项目的完整代码托管在了 GitHub 上：<a href=\"https://github.com/BeBeBerr/Pluto-Network\">https://github.com/BeBeBerr/Pluto-Network</a></p>\n<p>此文章发布在了我的 Blog 上，<a href=\"http://blog.wangluyuan.cc/2018/01/29/使用PlutoSDR构建简易通信系统/\">欢迎查看</a>。</p>\n"},{"title":"Flutter for iOS devs 翻译","date":"2018-07-10T16:12:00.000Z","_content":"\n# Flutter for iOS Developers 翻译\n\n官方文档原文链接：https://flutter.io/flutter-for-ios/\n\n此翻译文档已被 [Flutter 中文网](https://flutterchina.club/flutter-for-ios/) 收录。\n\n------\n\n本文档适用那些希望将现有 iOS 经验应用于 Flutter 的开发者。如果你拥有 iOS 开发基础，那么你可以使用这篇文档开始学习 Flutter 的开发。\n\n开发 Flutter 时，你的 iOS 经验和技能将会大有裨益，因为 Flutter 依赖于移动操作系统的众多功能和配置。Flutter 是用于为移动设备构建用户界面的全新方式，但它也有一个插件系统用于和 iOS（及 Android）进行非 UI 任务的通信。如果你是 iOS 开发专家，则你不必将 Flutter 彻底重新学习一遍。\n\n你可以将此文档作为 cookbook，通过跳转并查找与你的需求最相关的问题。\n\n## Views\n\n### UIView 相当于 Flutter 中的什么？\n\n在 iOS 中，构建 UI 的过程中将大量使用 view 对象。这些对象都是 `UIView` 的实例。它们可以用作容器来承载其他的 UIView，最终构成你的界面布局。\n\n在 Flutter 中，你可以粗略地认为 `Widget` 相当于 `UIView` 。Widget 和 iOS 中的控件并不完全等价，但当你试图去理解 Flutter 是如何工作的时候，你可以认为它们是“声明和构建 UI 的方法”。\n\n然而，Widget 和 UIView 还是有些区别的。首先，widgets 拥有不同的生存时间：它们一直存在且保持不变，直到当它们需要被改变。当 widgets 和它们的状态被改变时，Flutter 会构建一颗新的 widgets 树。作为对比，iOS 中的 views 在改变时并不会被重新创建。但是与其说 views 是可变的实例，不如说它们被绘制了一次，并且直到使用 `setNeedsDisplay()` 之后才会被重新绘制。\n\n此外，不像 UIView，由于不可变性，Flutter 的 widgets 非常轻量。这是因为它们本身并不是什么控件，也不会被直接绘制出什么，而只是 UI 的描述。\n\nFlutter 包含了 [Material 组件](https://material.io/develop/flutter/)库。这些 widgets 遵循了 [Material 设计规范](https://material.io/design/)。MD 是一个灵活的设计系统，并且为包括 iOS 在内的[所有系统进行了优化](https://material.io/design/platform-guidance/cross-platform-adaptation.html#cross-platform-guidelines)。\n\n但是用 Flutter 实现任何的设计语言都非常的灵活和富有表现力。在 iOS 平台，你可以使用 [Cupertino widgets](https://flutter.io/widgets/cupertino/) 来构建遵循了 [Apple’s iOS design language](https://developer.apple.com/design/resources/) 的界面。\n\n### 我怎么来更新 Widgets？\n\n在 iOS 上更新 views，只需要直接改变它们就可以了。在 Flutter 中，widgets 是不可变的，而且不能被直接更新。你需要去操纵 widget 的 state。\n\n这也正是有状态的和无状态的 widget 这一概念的来源。一个 `StatelessWidget` 正如它听起来一样，是一个没有附加状态的 widget。\n\n`StatelessWidget` 在你构建初始化后不再进行改变的界面时非常有用。\n\n举个例子，你可能会用一个 `UIImageView` 来展示你的 logo `image` 。如果这个 logo 在运行时不会改变，那么你就可以在 Flutter 中使用 `StatelessWidget` 。\n\n如果你希望在发起 HTTP 请求时，依托接收到的数据动态的改变 UI，请使用 `StatefulWidget`。当 HTTP 请求结束后，通知 Flutter 框架 widget 的 `State` 更新了，好让系统来更新 UI。\n\n有状态和无状态的 widget 之间一个非常重要的区别是，`StatefulWidget` 拥有一个 `State` 对象来存储它的状态数据，并在 widget 树重建时携带着它，因此状态不会丢失。\n\n如果你有疑惑，请记住以下规则：如果一个 widget 在它的 `build` 方法之外改变（例如，在运行时由于用户的操作而改变），它就是有状态的。如果一个 widget 在一次 build 之后永远不变，那它就是无状态的。但是，即便一个 widget 是有状态的，包含它的父亲 widget 也可以是无状态的，只要父 widget 本身不响应这些变化。\n\n下面的例子展示了如何使用一个 `StatelessWidget` 。一个常见的 `StatelessWidget` 是 `Text` widget。如果你查看 Text 的实现，你会发现它是 StatelessWidget 的子类。\n\n```dart\nText(\n  'I like Flutter!',\n  style: TextStyle(fontWeight: FontWeight.bold),\n);\n```\n\n阅读上面的代码，你可能会注意到 `Text` widget 并不显示地携带任何状态。它通过传入给它的构造器的数据来渲染，除此之外再无其他。\n\n但是，如果你希望 `I like Flutter `在点击 `FloatingActionButton` 时动态的改变呢？\n\n为了实现这个，用 `StatefulWidget` 包裹 `Text` widget，并在用户点击按钮时更新它。\n\n举个例子：\n\n```dart\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  // Default placeholder text\n  String textToShow = \"I Like Flutter\";\n  void _updateText() {\n    setState(() {\n      // update the text\n      textToShow = \"Flutter is Awesome!\";\n    });\n  }\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: Center(child: Text(textToShow)),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _updateText,\n        tooltip: 'Update Text',\n        child: Icon(Icons.update),\n      ),\n    );\n  }\n}\n```\n\n### 我怎么对 widget 布局？我的 Storyboard 在哪？\n\n在 iOS 中，你可能会用 Storyboard 文件来组织 views，并对它们设置约束，或者，你可能在 view controller 中使用代码来设置约束。在 Flutter 中，你通过编写一个 widget 树来声明你的布局。\n\n下面这个例子展示了如何展示一个带有 padding 的简单 widget：\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(\"Sample App\"),\n    ),\n    body: Center(\n      child: CupertinoButton(\n        onPressed: () {\n          setState(() { _pressedCount += 1; });\n        },\n        child: Text('Hello'),\n        padding: EdgeInsets.only(left: 10.0, right: 10.0),\n      ),\n    ),\n  );\n}\n```\n\n你可以给任何的 widget 添加 padding，这很像 iOS 中约束的功能。\n\n你可以在 [widget catalog](https://flutter.io/widgets/layout/) 中查看 Flutter 提供的布局。\n\n### 我怎么在我的约束中添加或移除组件？\n\n在 iOS 中，你在父 view 中调用 `addSubview()` 或在子 view 中调用 `removeFromSuperview()` 来动态地添加或移除子 views。在 Flutter 中，由于 widget 不可变，所以没有和 `addSubview()` 直接等价的东西。作为替代，你可以向 parent 传入一个返回 widget 的函数，并用一个布尔值来控制子 widget 的创建。\n\n下面这个例子展示了在点击 `FloatingActionButton` 时如何动态地切换两个 widgets：\n\n```dart\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  // Default value for toggle\n  bool toggle = true;\n  void _toggle() {\n    setState(() {\n      toggle = !toggle;\n    });\n  }\n\n  _getToggleChild() {\n    if (toggle) {\n      return Text('Toggle One');\n    } else {\n      return CupertinoButton(\n        onPressed: () {},\n        child: Text('Toggle Two'),\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: Center(\n        child: _getToggleChild(),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _toggle,\n        tooltip: 'Update Text',\n        child: Icon(Icons.update),\n      ),\n    );\n  }\n}\n```\n\n### 我怎么对 widget 做动画？\n\n在 iOS 中，你通过调用 `animate(withDuration:animations:)` 方法来给一个 view 创建动画。在 Flutter 中，使用动画库来包裹 widgets，而不是创建一个动画 widget。\n\n在 Flutter 中，使用 `AnimationController` 。这是一个可以暂停、寻找、停止、反转动画的 `Animation<double>` 类型。它需要一个 `Ticker` 当 vsync 发生时来发送信号，并且在每帧运行时创建一个介于 0 和 1 之间的线性插话（interpolation）。你可以创建一个或多个的 `Animation` 并附加给一个 controller。\n\n例如，你可能会用 `CurvedAnimation` 来实现一个 interpolated 曲线。在这个场景中，controller 是动画过程的“主人”，而 `CurvedAnimation` 计算曲线，并替代 controller 默认的线性模式。\n\n当构建 widget 树时，你会把 `Animation` 指定给一个 widget 的动画属性，比如 `FadeTransition` 的 opacity，并告诉控制器开始动画。\n\n下面这个例子展示了在点击 `FloatingActionButton` 之后，如何使用 `FadeTransition` 来让 widget 淡出到 logo 图标：\n\n```dart\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Fade Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: MyFadeTest(title: 'Fade Demo'),\n    );\n  }\n}\n\nclass MyFadeTest extends StatefulWidget {\n  MyFadeTest({Key key, this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  _MyFadeTest createState() => _MyFadeTest();\n}\n\nclass _MyFadeTest extends State<MyFadeTest> with TickerProviderStateMixin {\n  AnimationController controller;\n  CurvedAnimation curve;\n\n  @override\n  void initState() {\n    controller = AnimationController(duration: const Duration(milliseconds: 2000), vsync: this);\n    curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Container(\n          child: FadeTransition(\n            opacity: curve,\n            child: FlutterLogo(\n              size: 100.0,\n            )\n          )\n        )\n      ),\n      floatingActionButton: FloatingActionButton(\n        tooltip: 'Fade',\n        child: Icon(Icons.brush),\n        onPressed: () {\n          controller.forward();\n        },\n      ),\n    );\n  }\n\n  @override\n  dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n}\n```\n\n更多信息，请参阅 [Animation & Motion widgets](https://flutter.io/widgets/animation/)， [Animations tutorial](https://flutter.io/tutorials/animation) 以及 [Animations overview](https://flutter.io/animations/)。\n\n### 我该怎么绘图？\n\n在 iOS 上，你通过 `CoreGraphics` 来在屏幕上绘制线条和形状。Flutter 有一套基于 `Canvas` 类的不同的 API，还有 `CustomPaint` 和 `CustomPainter` 这两个类来帮助你绘图。后者实现你在 canvas 上的绘图算法。\n\n想要学习如何实现一个笔迹画笔，请参考 Collin 在 [StackOverflow](https://stackoverflow.com/questions/46241071/create-signature-area-for-mobile-app-in-dart-flutter) 上的回答。\n\n```dart\nclass SignaturePainter extends CustomPainter {\n  SignaturePainter(this.points);\n\n  final List<Offset> points;\n\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.black\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 5.0;\n    for (int i = 0; i < points.length - 1; i++) {\n      if (points[i] != null && points[i + 1] != null)\n        canvas.drawLine(points[i], points[i + 1], paint);\n    }\n  }\n\n  bool shouldRepaint(SignaturePainter other) => other.points != points;\n}\n\nclass Signature extends StatefulWidget {\n  SignatureState createState() => SignatureState();\n}\n\nclass SignatureState extends State<Signature> {\n\n  List<Offset> _points = <Offset>[];\n\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onPanUpdate: (DragUpdateDetails details) {\n        setState(() {\n          RenderBox referenceBox = context.findRenderObject();\n          Offset localPosition =\n          referenceBox.globalToLocal(details.globalPosition);\n          _points = List.from(_points)..add(localPosition);\n        });\n      },\n      onPanEnd: (DragEndDetails details) => _points.add(null),\n      child: CustomPaint(painter: SignaturePainter(_points), size: Size.infinite),\n    );\n  }\n}\n```\n\n### Widget 的透明度在哪里？\n\n在 iOS 中，什么东西都会有一个 .opacity 或是 .alpha 的属性。在 Flutter 中，你需要给 widget 包裹一个 Opacity widget 来做到这一点。\n\n### 我怎么创建自定义的 widgets？\n\n在 iOS 中，你编写 `UIView` 的子类，或使用已经存在的 view 来重载并实现方法，以达到特定的功能。在 Flutter 中，你会组合（[composing](https://flutter.io/technical-overview/#everythings-a-widget)）多个小的 widgets 来构建一个自定义的 widget（而不是扩展它）。\n\n举个例子，如果你要构建一个 `CustomButton` ，并在构造器中传入它的 label？那就组合 `RaisedButton` 和 label，而不是扩展 `RaisedButton`。\n\n```dart\nclass CustomButton extends StatelessWidget {\n  final String label;\n\n  CustomButton(this.label);\n\n  @override\n  Widget build(BuildContext context) {\n    return RaisedButton(onPressed: () {}, child: Text(label));\n  }\n}\n```\n\n然后就像你使用其他任何 Flutter 的 widget 一样，使用你的 CustomButton：\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return Center(\n    child: CustomButton(\"Hello\"),\n  );\n}\n```\n\n## 导航\n\n### 我怎么在不同页面之间跳转？\n\n在 iOS 中，你可以使用管理了 view controller 栈的 `UINavigationController` 来在不同的 view controller 之间跳转。\n\nFlutter 也有类似的实现，使用了 `Navigator` 和 `Routes`。一个路由是 App 中“屏幕”或“页面”的抽象，而一个 Navigator 是管理多个路由的 [widget](https://flutter.io/flutter-for-ios/technical-overview/#everythings-a-widget) 。你可以粗略地把一个路由对应到一个 `UIViewController`。Navigator 的工作原理和 iOS 中 `UINavigationController` 非常相似，当你想跳转到新页面或者从新页面返回时，它可以 `push()` 和 `pop()` 路由。\n\n在页面之间跳转，你有一对选择：\n\n- 具体指定一个由路由名构成的 `Map`。（MaterialApp）\n- 直接跳转到一个路由。（WidgetApp）\n\n下面是构建一个 Map 的例子：\n\n```dart\nvoid main() {\n  runApp(MaterialApp(\n    home: MyAppHome(), // becomes the route named '/'\n    routes: <String, WidgetBuilder> {\n      '/a': (BuildContext context) => MyPage(title: 'page A'),\n      '/b': (BuildContext context) => MyPage(title: 'page B'),\n      '/c': (BuildContext context) => MyPage(title: 'page C'),\n    },\n  ));\n}\n```\n\n通过把路由的名字 `push` 给一个 `Navigator` 来跳转：\n\n```dart\nNavigator.of(context).pushNamed('/b');\n```\n\n`Navigator` 类不仅用来处理 Flutter 中的路由，还被用来获取你刚 push 到栈中的路由返回的结果。通过 `await` `push()` 返回的 `Future` 来达到这点。\n\n举个例子，要跳转到“位置”路由来让用户选择一个地点，你可能要这么做：\n\n```dart\nMap coordinates = await Navigator.of(context).pushNamed('/location');\n```\n\n之后，在 location 路由中，一旦用户选择了地点，携带结果一起 `pop()` 出栈：\n\n```dart\nNavigator.of(context).pop({\"lat\":43.821757,\"long\":-79.226392});\n```\n\n### 我怎么跳转到其他 App？\n\n在 iOS 中，要跳转到其他 App，你需要一个特定的 URL Scheme。对系统级别的 App 来说，这个 scheme 取决于 App。为了在 Flutter 中实现这个功能，你可以创建一个原生平台的整合层，或者使用现有的 [plugin](https://flutter.io/flutter-for-ios/#plugins)，例如 [url_launcher](https://pub.dartlang.org/packages/url_launcher)。\n\n## 线程和异步\n\n### 我怎么编写异步的代码？\n\nDart 是单线程执行模型，但是它支持 `Isolate`（一种让 Dart 代码运行在其他线程的方式）、事件循环和异步编程。除非你自己创建一个 `Isolate` ，否则你的 Dart 代码永远运行在 UI 线程，并由 event loop 驱动。Flutter 的 event loop 和 iOS 中的 main loop 相似——`Looper` 是附加在主线程上的。\n\nDart 的单线程模型并不意味着你写的代码一定是阻塞操作，从而卡住 UI。相反，使用 Dart 语言提供的异步工具，例如 `async` / `await` ，来实现异步操作。\n\n举个例子，你可以使用 `async` / `await` 来让 Dart 帮你做一些繁重的工作，编写网络请求代码而不会挂起 UI：\n\n```dart\nloadData() async {\n  String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n  http.Response response = await http.get(dataURL);\n  setState(() {\n    widgets = json.decode(response.body);\n  });\n}\n```\n\n一旦 `await` 到网络请求完成，通过调用 `setState()` 来更新 UI，这会触发 widget 子树的重建，并更新相关数据。\n\n下面的例子展示了异步加载数据，并用 `ListView` 展示出来：\n\n```dart\nimport 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n\n    loadData();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView.builder(\n          itemCount: widgets.length,\n          itemBuilder: (BuildContext context, int position) {\n            return getRow(position);\n          }));\n  }\n\n  Widget getRow(int i) {\n    return Padding(\n      padding: EdgeInsets.all(10.0),\n      child: Text(\"Row ${widgets[i][\"title\"]}\")\n    );\n  }\n\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}\n```\n\n 更多关于在后台工作的信息，以及 Flutter 和 iOS 的区别，请参考下一章节。\n\n### 你是怎么把工作放到后台线程的？\n\n由于 Flutter 是单线程并且跑着一个 event loop 的（就像 Node.js 那样），你不必为线程管理或是开启后台线程而操心。如果你正在做 I/O 操作，如访问磁盘或网络请求，安全地使用 `async` / `await` 就完事了。如果，在另外的情况下，你需要做让 CPU 保持繁忙的计算密集型任务，你需要使用 `Isolate` 来避免阻塞 event loop。\n\n对于 I/O 操作，把方法声明为 `async` 方法，并且 `await` 方法里需要长期运行的任务：\n\n```dart\nloadData() async {\n  String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n  http.Response response = await http.get(dataURL);\n  setState(() {\n    widgets = json.decode(response.body);\n  });\n}\n```\n\n这就是对诸如网络请求或数据库访问等 I/O 操作的典型做法。\n\n然而，有时候你需要处理大量的数据，这会导致你的 UI 挂起。在 Flutter 中，使用 `Isolate` 来发挥多核心 CPU 的优势来处理那些长期运行或是计算密集型的任务。\n\nIsolates 是分离的运行线程，并且不和主线程的内存堆共享内存。这意味着你不能访问主线程中的变量，或者使用 `setState()` 来更新 UI。正如它们的名字一样，Isolates 不能共享内存。\n\n下面的例子展示了一个简单的 isolate，是如何把数据返回给主线程来更新 UI 的：\n\n```dart\nloadData() async {\n  ReceivePort receivePort = ReceivePort();\n  await Isolate.spawn(dataLoader, receivePort.sendPort);\n\n  // The 'echo' isolate sends its SendPort as the first message\n  SendPort sendPort = await receivePort.first;\n\n  List msg = await sendReceive(sendPort, \"https://jsonplaceholder.typicode.com/posts\");\n\n  setState(() {\n    widgets = msg;\n  });\n}\n\n// The entry point for the isolate\nstatic dataLoader(SendPort sendPort) async {\n  // Open the ReceivePort for incoming messages.\n  ReceivePort port = ReceivePort();\n\n  // Notify any other isolates what port this isolate listens to.\n  sendPort.send(port.sendPort);\n\n  await for (var msg in port) {\n    String data = msg[0];\n    SendPort replyTo = msg[1];\n\n    String dataURL = data;\n    http.Response response = await http.get(dataURL);\n    // Lots of JSON to parse\n    replyTo.send(json.decode(response.body));\n  }\n}\n\nFuture sendReceive(SendPort port, msg) {\n  ReceivePort response = ReceivePort();\n  port.send([msg, response.sendPort]);\n  return response.first;\n}\n```\n\n这里，`dataLoader()` 是一个运行于自己独立执行线程上的 `Isolate`。在 isolate 里，你可以执行 CPU 密集型任务（例如解析一个庞大的 json），或是计算密集型的数学操作，如加密或信号处理等。\n\n你可以运行下面的完整例子：\n\n```dart\nimport 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:async';\nimport 'dart:isolate';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    loadData();\n  }\n\n  showLoadingDialog() {\n    if (widgets.length == 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  getBody() {\n    if (showLoadingDialog()) {\n      return getProgressDialog();\n    } else {\n      return getListView();\n    }\n  }\n\n  getProgressDialog() {\n    return Center(child: CircularProgressIndicator());\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text(\"Sample App\"),\n        ),\n        body: getBody());\n  }\n\n  ListView getListView() => ListView.builder(\n      itemCount: widgets.length,\n      itemBuilder: (BuildContext context, int position) {\n        return getRow(position);\n      });\n\n  Widget getRow(int i) {\n    return Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row ${widgets[i][\"title\"]}\"));\n  }\n\n  loadData() async {\n    ReceivePort receivePort = ReceivePort();\n    await Isolate.spawn(dataLoader, receivePort.sendPort);\n\n    // The 'echo' isolate sends its SendPort as the first message\n    SendPort sendPort = await receivePort.first;\n\n    List msg = await sendReceive(sendPort, \"https://jsonplaceholder.typicode.com/posts\");\n\n    setState(() {\n      widgets = msg;\n    });\n  }\n\n// the entry point for the isolate\n  static dataLoader(SendPort sendPort) async {\n    // Open the ReceivePort for incoming messages.\n    ReceivePort port = ReceivePort();\n\n    // Notify any other isolates what port this isolate listens to.\n    sendPort.send(port.sendPort);\n\n    await for (var msg in port) {\n      String data = msg[0];\n      SendPort replyTo = msg[1];\n\n      String dataURL = data;\n      http.Response response = await http.get(dataURL);\n      // Lots of JSON to parse\n      replyTo.send(json.decode(response.body));\n    }\n  }\n\n  Future sendReceive(SendPort port, msg) {\n    ReceivePort response = ReceivePort();\n    port.send([msg, response.sendPort]);\n    return response.first;\n  }\n}\n```\n\n### 我怎么发起网络请求？\n\n在 Flutter 中，使用流行的 [http package](https://pub.dartlang.org/packages/http) 做网络请求非常简单。它把你可能需要自己做的网络请求操作抽象了出来，让发起请求变得简单。\n\n要使用 `http` 包，在 `pubspec.yaml` 中把它添加为依赖：\n\n```\ndependencies:\n  ...\n  http: ^0.11.3+16\n```\n\n发起网络请求，在 `http.get()` 这个 `async` 方法中使用 `await` ：\n\n```dart\nimport 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n[...]\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}\n```\n\n### 我怎么展示一个长时间运行的任务的进度？\n\n在 iOS 中，在后台运行耗时任务时你会使用 `UIProgressView`。 \n\n在 Flutter 中，使用一个 `ProgressIndicator` widget。通过一个布尔 flag 来控制是否展示进度。在任务开始时，告诉 Flutter 更新状态，并在结束后隐去。\n\n在下面的例子中，build 函数被拆分成三个函数。如果 `showLoadingDialog()` 是 `true` （当 `widgets.length == 0` 时），则渲染 `ProgressIndicator`。否则，当数据从网络请求中返回时，渲染 `ListView` 。\n\n```dart\nimport 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    loadData();\n  }\n\n  showLoadingDialog() {\n    return widgets.length == 0;\n  }\n\n  getBody() {\n    if (showLoadingDialog()) {\n      return getProgressDialog();\n    } else {\n      return getListView();\n    }\n  }\n\n  getProgressDialog() {\n    return Center(child: CircularProgressIndicator());\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text(\"Sample App\"),\n        ),\n        body: getBody());\n  }\n\n  ListView getListView() => ListView.builder(\n      itemCount: widgets.length,\n      itemBuilder: (BuildContext context, int position) {\n        return getRow(position);\n      });\n\n  Widget getRow(int i) {\n    return Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row ${widgets[i][\"title\"]}\"));\n  }\n\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}\n```\n\n## 工程结构、本地化、依赖和资源\n\n### 我怎么在 Flutter 中引入 image assets？多分辨率怎么办？\n\niOS 把 images 和 assets 作为不同的东西，而 Flutter 中只有 assets。被放到 iOS 中 `Images.xcasset` 文件夹下的资源在 Flutter 中被放到了 assets 文件夹中。assets 可以是任意类型的文件，而不仅仅是图片。例如，你可以把 json 文件放置到 `my-assets` 文件夹中。\n\n```\nmy-assets/data.json\n```\n\n在 `pubspec.yaml` 文件中声明 assets：\n\n```\nassets:\n - my-assets/data.json\n```\n\n然后在代码中使用 [`AssetBundle`](https://docs.flutter.io/flutter/services/AssetBundle-class.html) 来访问它：\n\n```dart\nimport 'dart:async' show Future;\nimport 'package:flutter/services.dart' show rootBundle;\n\nFuture<String> loadAsset() async {\n  return await rootBundle.loadString('my-assets/data.json');\n}\n```\n\n对于图片，Flutter 像 iOS 一样，遵循了一个简单的基于像素密度的格式。Image assets 可能是 `1.0x` `2.0x` `3.0x` 或是其他的任何倍数。这些所谓的 [`devicePixelRatio`](https://docs.flutter.io/flutter/dart-ui/Window/devicePixelRatio.html) 传达了物理像素到单个逻辑像素的比率。\n\nAssets 可以被放置到任何属性文件夹中——Flutter 并没有预先定义的文件结构。在 `pubspec.yaml` 文件中声明 assets （和位置），然后 Flutter 会把他们识别出来。\n\n举个例子，要把一个叫 `my_icon.png` 的图片放到 Flutter 工程中，你可能想要把存储它的文件夹叫做 `images`。把基础图片（1.0x）放置到 `images` 文件夹中，并把其他变体放置在子文件夹中，并接上合适的比例系数：\n\n```\nimages/my_icon.png       // Base: 1.0x image\nimages/2.0x/my_icon.png  // 2.0x image\nimages/3.0x/my_icon.png  // 3.0x image\n```\n\n接着，在 `pubspec.yaml` 文件夹中声明这些图片：\n\n```\nassets:\n - images/my_icon.jpeg\n```\n\n你可以用 `AssetImage` 来访问这些图片：\n\n```dart\nreturn AssetImage(\"images/a_dot_burr.jpeg\");\n```\n\n或者在 `Image` widget 中直接使用：\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return Image.asset(\"images/my_image.png\");\n}\n```\n\n更多细节，参见 [Adding Assets and Images in Flutter](https://flutter.io/assets-and-images)。\n\n### 我在哪里放置字符串？我怎么做本地化？\n\n不像 iOS 拥有一个 `Localizable.strings` 文件，Flutter 目前并没有一个用于处理字符串的系统。目前，最佳实践是把你的文本拷贝到静态区，并在这里访问。例如：\n\n```dart\nclass Strings {\n  static String welcomeMessage = \"Welcome To Flutter\";\n}\n```\n\n并且这样访问你的字符串：\n\n```dart\nText(Strings.welcomeMessage)\n```\n\n默认情况下，Flutter 只支持美式英语字符串。如果你要支持其他语言，请引入 `flutter_localizations` 包。你可能也要引入  [`intl`](https://pub.dartlang.org/packages/intl) 包来支持其他的 i10n 机制，比如日期/时间格式化。\n\n```\ndependencies:\n  # ...\n  flutter_localizations:\n    sdk: flutter\n  intl: \"^0.15.6\"\n```\n\n要使用 `flutter_localizations` 包，在 app widget 中指 `localizationsDelegates` 和 `supportedLocales`。\n\n```dart\nimport 'package:flutter_localizations/flutter_localizations.dart';\n\nMaterialApp(\n localizationsDelegates: [\n   // Add app-specific localization delegate[s] here\n   GlobalMaterialLocalizations.delegate,\n   GlobalWidgetsLocalizations.delegate,\n ],\n supportedLocales: [\n    const Locale('en', 'US'), // English\n    const Locale('he', 'IL'), // Hebrew\n    // ... other locales the app supports\n  ],\n  // ...\n)\n```\n\n这些代理包括了实际的本地化值，并且 `supportedLocales` 定义了 App 支持哪些地区。上面的例子使用了一个 `MaterialApp` ，所以它既有 `GlobalWidgetsLocalizations` 用于基础 widgets，也有 `MaterialWidgetsLocalizations` 用于 Material wigets 的本地化。如果你使用 `WidgetsApp` ，则无需包括后者。注意，这两个代理虽然包括了“默认”值，但如果你想让你的 App 本地化，你仍需要提供一或多个代理作为你的 App 本地化副本。\n\n当初始化时，`WidgetsApp` 或 `MaterialApp` 会使用你指定的代理为你创建一个  [`Localizations`](https://docs.flutter.io/flutter/widgets/Localizations-class.html) widget。`Localizations` widget 可以随时从当前上下文中访问设备的地点，或者使用 [`Window.locale`](https://docs.flutter.io/flutter/dart-ui/Window/locale.html)。\n\n要访问本地化文件，使用 `Localizations.of()` 方法来访问提供代理的特定本地化类。如需翻译，使用  [`intl_translation`](https://pub.dartlang.org/packages/intl_translation) 包来取出翻译副本到 [arb](https://code.google.com/p/arb/wiki/ApplicationResourceBundleSpecification) 文件中。把它们引入 App 中，并用 `intl` 来使用它们。\n\n更多 Flutter 中国际化和本地化的细节，请访问 [internationalization guide](https://flutter.io/tutorials/internationalization) ，那里有不使用 `intl` 包的示例代码。\n\n注意，在 Flutter 1.0 beta 2 之前，在 Flutter 中定义的 assets 不能在原生一侧被访问。原生定义的资源在 Flutter 中也不可用，因为它们在独立的文件夹中。\n\n### Cocoapods 相当于什么？我该如何添加依赖？\n\n在 iOS 中，你把依赖添加到 `Podfile` 中。Flutter 使用 Dart 构建系统和 Pub 包管理器来处理依赖。这些工具将本机 Android 和 iOS 包装应用程序的构建委派给相应的构建系统。\n\n如果你的 Flutter 工程中的 iOS 文件夹中拥有 Podfile，请仅在你为每个平台集成时使用它。总体来说，使用 `pubspec.yaml` 来在 Flutter 中声明外部依赖。一个可以找到优秀 Flutter 包的地方是 [Pub](https://pub.dartlang.org/flutter/packages/)。\n\n## ViewControllers\n\n### ViewController 相当于 Flutter 中的什么？\n\n在 iOS 中，一个 ViewController 代表了用户界面的一部分，最常用于一个屏幕，或是其中一部分。它们被组合在一起用于构建复杂的用户界面，并帮助你拆分 App 的 UI。在 Flutter 中，这一任务回落到了 widgets 中。就像在界面导航部分提到的一样，一个屏幕也是被 widgets 来表示的，因为“万物皆 widget！”。使用 `Navigator` 在 `Route` 之间跳转，或者渲染相同数据的不同状态。\n\n### 我该怎么监听 iOS 中的生命周期事件？\n\n在 iOS 中，你可以重写 `ViewController` 中的方法来补货它的视图的生命周期，或者在 `AppDelegate` 中注册生命周期的回调函数。在 Flutter 中没有这两个概念，但你可以通过 hook `WidgetsBinding` 观察者来监听生命周期事件，并监听 `didChangeAppLifecycleState()` 的变化事件。\n\n可观察的生命周期事件有：\n\n- `inactive` - 应用处于不活跃的状态，并且不会接受用户的输入。这个事件仅工作在 iOS 平台，在 Android 上没有等价的事件。\n- `paused` - 应用暂时对用户不可见，虽然不接受用户输入，但是是在后台运行的。\n- `resumed` - 应用可见，也响应用户的输入。\n- `suspending` - 应用暂时被挂起，在 iOS 上没有这一事件。\n\n更多关于这些状态的细节和含义，请参见  [`AppLifecycleStatus` documentation](https://docs.flutter.io/flutter/dart-ui/AppLifecycleState-class.html) 。\n\n## 布局\n\n### UITableView 和 UICollectionView 相当于 Flutter 中的什么？\n\n在 iOS 中，你可能用 UITableView 或 UICollectionView 来展示一个列表。在 Flutter 中，你可以用 `ListView` 来达到相似的实现。在 iOS 中，你通过代理方法来确定行数，每一个 index path 的单元格，以及单元格的尺寸。\n\n由于 Flutter 中 widget 的不可变特性，你需要向 `ListView` 传递一个 widget 列表，Flutter 会确保滚动是快速且流畅的。\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: _getListData()),\n    );\n  }\n\n  _getListData() {\n    List<Widget> widgets = [];\n    for (int i = 0; i < 100; i++) {\n      widgets.add(Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row $i\")));\n    }\n    return widgets;\n  }\n}\n```\n\n### 我怎么知道列表的哪个元素被点击了？\n\niOS 中，你通过 `tableView:didSelectRowAtIndexPath:` 代理方法来实现。在 Flutter 中，使用传递进来的 widget 的 touch handle：\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: _getListData()),\n    );\n  }\n\n  _getListData() {\n    List<Widget> widgets = [];\n    for (int i = 0; i < 100; i++) {\n      widgets.add(GestureDetector(\n        child: Padding(\n          padding: EdgeInsets.all(10.0),\n          child: Text(\"Row $i\"),\n        ),\n        onTap: () {\n          print('row tapped');\n        },\n      ));\n    }\n    return widgets;\n  }\n}\n```\n\n### 我怎么动态地更新 ListView？\n\n在 iOS 中，你改变列表的数据，并通过 `reloadData()` 方法来通知 table 或是 collection view。\n\n在 Flutter 中，如果你想通过 `setState()` 方法来更新 widget 列表，你会很快发现你的数据展示并没有变化。这是因为当 `setState()` 被调用时，Flutter 渲染引擎会去检查 widget 树来查看是否有什么地方被改变了。当它得到你的 `ListView` 时，它会使用一个 `==` 判断，并且发现两个 `ListView` 是相同的。没有什么东西是变了的，因此更新不是必须的。\n\n一个更新 `ListView` 的简单方法是，在 `setState()` 中创建一个新的 list，并把旧 list 的数据拷贝给新的 list。虽然这样很简单，但当数据集很大时，并不推荐这样做：\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    for (int i = 0; i < 100; i++) {\n      widgets.add(getRow(i));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: widgets),\n    );\n  }\n\n  Widget getRow(int i) {\n    return GestureDetector(\n      child: Padding(\n        padding: EdgeInsets.all(10.0),\n        child: Text(\"Row $i\"),\n      ),\n      onTap: () {\n        setState(() {\n          widgets = List.from(widgets);\n          widgets.add(getRow(widgets.length + 1));\n          print('row $i');\n        });\n      },\n    );\n  }\n}\n```\n\n一个推荐的、高效的且有效的做法是，使用 `ListView.Builder` 来构建列表。这个方法在你想要构建动态列表，或是列表拥有大量数据时会非常好用。\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    for (int i = 0; i < 100; i++) {\n      widgets.add(getRow(i));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView.builder(\n        itemCount: widgets.length,\n        itemBuilder: (BuildContext context, int position) {\n          return getRow(position);\n        },\n      ),\n    );\n  }\n\n  Widget getRow(int i) {\n    return GestureDetector(\n      child: Padding(\n        padding: EdgeInsets.all(10.0),\n        child: Text(\"Row $i\"),\n      ),\n      onTap: () {\n        setState(() {\n          widgets.add(getRow(widgets.length + 1));\n          print('row $i');\n        });\n      },\n    );\n  }\n}\n```\n\n与创建一个 “ListView” 不同，创建一个 `ListView.builder` 接受两个主要参数：列表的初始长度，和一个 `ItemBuilder` 方法。\n\n`ItemBuilder` 方法和 `cellForItemAt` 代理方法非常类似，它接受一个位置，并且返回在这个位置上你希望渲染的 cell。\n\n最后，也是最重要的，注意 `onTap()` 函数里并没有重新创建一个 list，而是 `.add` 了一个 widget。\n\n### ScrollView 相当于 Flutter 里的什么？\n\n在 iOS 中，你给 view 包裹上 `ScrollView` 来允许用户在需要时滚动你的内容。\n\n在 Flutter 中，最简单的方法是使用 `ListView` widget。它表现得既和 iOS 中的 `ScrollView` 一致，也能和 `TableView` 一致，因为你可以给它的 widget 做垂直排布：\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return ListView(\n    children: <Widget>[\n      Text('Row One'),\n      Text('Row Two'),\n      Text('Row Three'),\n      Text('Row Four'),\n    ],\n  );\n}\n```\n\n更多关于在 Flutter 总如何排布 widget 的文档，请参阅 [layout tutorial](https://flutter.io/widgets/layout/)。\n\n## 手势检测及触摸事件处理\n\n### 我怎么给 Flutter 的 widget 添加一个点击监听者？\n\n在 iOS 中，你给一个 view 添加 `GestureRecognizer` 来处理点击事件。在 Flutter 中，有两种方法来添加点击监听者：\n\n1. 如果 widget 本身支持事件监测，直接传递给它一个函数，并在这个函数里实现响应方法。例如，`RaisedButton` widget 拥有一个 `RaisedButton` 参数：\n\n   ```dart\n   @override\n   Widget build(BuildContext context) {\n     return RaisedButton(\n       onPressed: () {\n         print(\"click\");\n       },\n       child: Text(\"Button\"),\n     );\n   }\n   ```\n\n2. 如果 widget 本身不支持事件监测，则在外面包裹一个 GestureDetector，并给它的 onTap 属性传递一个函数：\n\n   ```dart\n   class SampleApp extends StatelessWidget {\n     @override\n     Widget build(BuildContext context) {\n       return Scaffold(\n         body: Center(\n           child: GestureDetector(\n             child: FlutterLogo(\n               size: 200.0,\n             ),\n             onTap: () {\n               print(\"tap\");\n             },\n           ),\n         ),\n       );\n     }\n   }\n   ```\n\n### 我怎么处理 widget 上的其他手势？\n\n使用 `GestureDetector` 你可以监听更广阔范围内的手势，比如：\n\n- Tapping\n  - `onTapDown` — 在特定位置轻触手势接触了屏幕。\n  - `onTapUp` — 在特定位置产生了一个轻触手势，并停止接触屏幕。\n  - `onTap` — 产生了一个轻触手势。\n  - `onTapCancel` — 触发了 `onTapDown` 但没能触发 tap。\n- Double tapping\n  - `onDoubleTap` — 用户在同一个位置快速点击了两下屏幕。\n- Long pressing\n  - `onLongPress` — 用户在同一个位置长时间接触屏幕。\n- Vertical dragging\n  - `onVerticalDragStart` — 接触了屏幕，并且可能会垂直移动。\n  - `onVerticalDragUpdate` — 接触了屏幕，并继续在垂直方向移动。\n  - `onVerticalDragEnd` — 之前接触了屏幕并垂直移动，并在停止接触屏幕前以某个垂直的速度移动。\n- Horizontal dragging\n  - `onHorizontalDragStart` \n  - `onHorizontalDragUpdate`\n  - `onHorizontalDragEnd`\n\n下面这个例子展示了一个 `GestureDetector` 是如何在双击时旋转 Flutter 的 logo 的：\n\n```dart\nAnimationController controller;\nCurvedAnimation curve;\n\n@override\nvoid initState() {\n  controller = AnimationController(duration: const Duration(milliseconds: 2000), vsync: this);\n  curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: GestureDetector(\n          child: RotationTransition(\n            turns: curve,\n            child: FlutterLogo(\n              size: 200.0,\n            )),\n          onDoubleTap: () {\n            if (controller.isCompleted) {\n              controller.reverse();\n            } else {\n              controller.forward();\n            }\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 主题和文字\n\n### 我怎么给 App 设置主题？\n\nFlutter 实现了一套漂亮的 MD 组件，并且开箱可用。它接管了一大堆你需要的样式和主题。\n\n为了充分发挥你的 App 中 MD 组件的优势，声明一个顶级 widget，MaterialApp，用作你的 App 入口。MaterialApp 是一个便利组件，包含了许多 App 通常需要的 MD 风格组件。它通过一个 WidgetsApp 添加了 MD 功能来实现。\n\n但是 Flutter 足够地灵活和富有表现力来实现任何其他的设计语言。在 iOS 上，你可以用 [Cupertino library](https://docs.flutter.io/flutter/cupertino/cupertino-library.html) 来制作遵守  [Human Interface Guidelines](https://developer.apple.com/ios/human-interface-guidelines/overview/themes/) 的界面。查看这些 widget 的集合，请参阅 [Cupertino widgets gallery](https://flutter.io/widgets/cupertino/)。\n\n你也可以在你的 App 中使用 WidgetApp，它提供了许多相似的功能，但不如 `MaterialApp` 那样强大。\n\n对任何子组件定义颜色和样式，可以给 `MaterialApp` widget 传递一个 `ThemeData` 对象。举个例子，在下面的代码中，primary swatch 被设置为蓝色，并且文字的选中颜色是红色：\n\n```dart\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        textSelectionColor: Colors.red\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n```\n\n### 我怎么给 Text widget 设置自定义字体？\n\n在 iOS 中，你在项目中引入任意的 `ttf` 文件，并在 `info.plist` 中设置引用。在 Flutter 中，在文件夹中放置字体文件，并在 `pubspec.yaml` 中引用它，就像添加图片那样。\n\n```\nfonts:\n   - family: MyCustomFont\n     fonts:\n       - asset: fonts/MyCustomFont.ttf\n       - style: italic\n```\n\n然后在你的 `Text` widget 中指定字体：\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(\"Sample App\"),\n    ),\n    body: Center(\n      child: Text(\n        'This is a custom font text',\n        style: TextStyle(fontFamily: 'MyCustomFont'),\n      ),\n    ),\n  );\n}\n```\n\n### 我怎么给我的 Text widget 设置样式？\n\n除了字体以外，你也可以给 Text widget 的样式元素设置自定义值。`Text` widget 接受一个  `TextStyle` 对象，你可以指定许多参数，比如：\n\n- `color`\n- `decoration`\n- `decorationColor`\n- `decorationStyle`\n- `fontFamily`\n- `fontSize`\n- `fontStyle`\n- `fontWeight`\n- `hashCode`\n- `height`\n- `inherit`\n- `letterSpacing`\n- `textBaseline`\n- `wordSpacing`\n\n## 表单输入\n\n### Flutter 中表单怎么工作？我怎么拿到用户的输入？\n\n我们已经提到 Flutter 使用不可变的 widget，并且状态是分离的，你可能会好奇在这种情境下怎么处理用户的输入。在 iOS 中，你经常在需要提交数据时查询组件当前的状态或动作，但这在 Flutter 中是怎么工作的呢？\n\n在表单处理的实践中，就像在 Flutter 中任何其他的地方一样，要通过特定的 widgets。如果你有一个 `TextField` 或是 `TextFormField`，你可以通过 [`TextEditingController`](https://docs.flutter.io/flutter/widgets/TextEditingController-class.html) 来获得用户输入：\n\n```dart\nclass _MyFormState extends State<MyForm> {\n  // Create a text controller and use it to retrieve the current value.\n  // of the TextField!\n  final myController = TextEditingController();\n\n  @override\n  void dispose() {\n    // Clean up the controller when disposing of the Widget.\n    myController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Retrieve Text Input'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: TextField(\n          controller: myController,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        // When the user presses the button, show an alert dialog with the\n        // text the user has typed into our text field.\n        onPressed: () {\n          return showDialog(\n            context: context,\n            builder: (context) {\n              return AlertDialog(\n                // Retrieve the text the user has typed in using our\n                // TextEditingController\n                content: Text(myController.text),\n              );\n            },\n          );\n        },\n        tooltip: 'Show me the value!',\n        child: Icon(Icons.text_fields),\n      ),\n    );\n  }\n}\n```\n\n你可以在这里获得更多信息，或是完整的代码列表： [Retrieve the value of a text field](https://flutter.io/cookbook/forms/retrieve-input/)，来自 [Flutter Cookbook](https://flutter.io/cookbook/) 。\n\n### Text field 中的 placeholder 相当于什么？\n\n在 Flutter 中，你可以轻易地通过向 Text widget 的装饰构造器参数重传递 `InputDecoration` 来展示“小提示”，或是占位符文字：\n\n```dart\nbody: Center(\n  child: TextField(\n    decoration: InputDecoration(hintText: \"This is a hint\"),\n  ),\n)\n```\n\n### 我怎么展示验证错误信息？\n\n就像展示“小提示”一样，向 Text widget 的装饰器构造器参数中传递一个 `InputDecoration`。\n\n然而，你并不想在一开始就显示错误信息。相反，当用户输入了验证信息，更新状态，并传入一个新的 `InputDecoration` 对象：\n\n```dart\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  String _errorText;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: Center(\n        child: TextField(\n          onSubmitted: (String text) {\n            setState(() {\n              if (!isEmail(text)) {\n                _errorText = 'Error: This is not an email';\n              } else {\n                _errorText = null;\n              }\n            });\n          },\n          decoration: InputDecoration(hintText: \"This is a hint\", errorText: _getErrorText()),\n        ),\n      ),\n    );\n  }\n\n  _getErrorText() {\n    return _errorText;\n  }\n\n  bool isEmail(String em) {\n    String emailRegexp =\n        r'^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$';\n\n    RegExp regExp = RegExp(p);\n\n    return regExp.hasMatch(em);\n  }\n}\n```\n\n## 和硬件、第三方服务以及平台交互\n\n### 我怎么和平台，以及平台的原生代码交互？\n\nFlutter 的代码并不直接在平台之下运行，相反，Dart 代码构建的 Flutter 应用在设备上以原生的方式运行，却“侧步躲开了”平台提供的 SDK。这意味着，例如，你在 Dart 中发起一个网络请求，它就直接在 Dart 的上下文中运行。你并不会用上平常在 iOS 或 Android 上使用的原生 API。你的 Flutter 程序仍然被原生平台的 `ViewController` 管理作一个 view，但是你并不会直接访问 `ViewController` 自身，或是原生框架。\n\n但这并不意味着 Flutter 不能和原生 API，或任何你编写的原生代码交互。Flutter 提供了 [platform channels](https://flutter.io/platform-channels/) ，来和管理你的 Flutter view 的 ViewController 通信和交互数据。平台管道本质上是一个异步通信机制，桥接了 Dart 代码和宿主 ViewController，以及它运行于的 iOS 框架。你可以用平台管道来执行一个原生的函数，或者是从设备的传感器中获取数据。\n\n除了直接使用平台管道之外，你还可以使用一系列预先制作好的 [plugins](https://flutter.io/using-packages/)。例如，你可以直接使用插件来访问相机胶卷或是设备的摄像头，而不必编写你自己的集成层代码。你可以在 [Pub](https://pub.dartlang.org/) 上找到插件，这是一个 Dart 和 Flutter 的开源包仓库。其中一些包可能会支持集成 iOS 或 Android，或两者均可。\n\n如果你在 Pub 上找不到符合你需求的插件，你可以[自己编写](https://flutter.io/developing-packages/) ，并且[发布在 Pub 上](https://flutter.io/developing-packages/#publish)。\n\n### 我怎么访问 GPS 传感器？\n\n使用 [`location`](https://pub.dartlang.org/packages/location) 社区插件。\n\n### 我怎么访问摄像头？\n\n[`image_picker`](https://pub.dartlang.org/packages/image_picker) 在访问摄像头时非常常用。\n\n### 我怎么登录 Facebook？\n\n登录 Facebook 可以使用 [`flutter_facebook_login`](https://pub.dartlang.org/packages/flutter_facebook_login) 社区插件。\n\n### 我怎么使用 Firebase 特性？\n\n大多数 Firebase 特性被  [first party plugins](https://pub.dartlang.org/flutter/packages?q=firebase) 包含了。这些第一方插件由 Flutter 团队维护：\n\n- [`firebase_admob`](https://pub.dartlang.org/packages/firebase_admob) for Firebase AdMob\n- [`firebase_analytics`](https://pub.dartlang.org/packages/firebase_analytics) for Firebase Analytics\n- [`firebase_auth`](https://pub.dartlang.org/packages/firebase_auth) for Firebase Auth\n- [`firebase_core`](https://pub.dartlang.org/packages/firebase_core) for Firebase’s Core package\n- [`firebase_database`](https://pub.dartlang.org/packages/firebase_database) for Firebase RTDB\n- [`firebase_storage`](https://pub.dartlang.org/packages/firebase_storage) for Firebase Cloud Storage\n- [`firebase_messaging`](https://pub.dartlang.org/packages/firebase_messaging) for Firebase Messaging (FCM)\n- [`cloud_firestore`](https://pub.dartlang.org/packages/cloud_firestore) for Firebase Cloud Firestore\n\n你也可以在 Pub 上找到 Firebase 的第三方插件。\n\n### 我怎创建自己的原生集成层？\n\n如果有一些 Flutter 和社区插件遗漏的平台相关的特性，可以根据  [developing packages and plugins](https://flutter.io/developing-packages/) 页面构建自己的插件。\n\nFlutter 的插件结构，简要来说，就像 Android 中的 Event bus。你发送一个消息，并让接受者处理并反馈结果给你。在这种情况下，接受者就是在 Android 或 iOS 上的原生代码。\n\n## 数据库和本地存储\n\n### 我怎么在 Flutter 中访问 UserDefaults？\n\n在 iOS 中，你可以使用属性列表来存储键值对的集合，即我们熟悉的 UserDefaults。\n\n在 Flutter 中，可以使用  [Shared Preferences plugin](https://pub.dartlang.org/packages/shared_preferences) 来达到相似的功能。它包裹了 `UserDefaluts` 以及 Android 上等价的 `SharedPreferences` 的功能。\n\n### CoreData 相当于 Flutter 中的什么？\n\n在 iOS 中，你通过 CoreData 来存储结构化的数据。这是一个 SQL 数据库的上层封装，让查询和关联模型变得更加简单。\n\n在 Flutter 中，使用 [SQFlite](https://pub.dartlang.org/packages/sqflite) 插件来实现这个功能。\n\n## 通知\n\n### 我怎么推送通知？\n\n在 iOS 中，你需要向 developer portal 中注册来允许推送通知。\n\n在 Flutter 中，使用 `firebase_messaging` 插件来实现这一功能。\n\n更多使用 Firebase Cloud Messaging API 的信息，请参阅 [`firebase_messaging`](https://pub.dartlang.org/packages/firebase_messaging) 插件文档。\n\n------\n\n此文档由 Luyuan Wang 原创翻译。2018 - 07 - 11","source":"_posts/Flutter-for-iOS-dev-翻译.md","raw":"---\ntitle: Flutter for iOS devs 翻译\ndate: 2018-07-11 00:12:00\ntags: Flutter\n---\n\n# Flutter for iOS Developers 翻译\n\n官方文档原文链接：https://flutter.io/flutter-for-ios/\n\n此翻译文档已被 [Flutter 中文网](https://flutterchina.club/flutter-for-ios/) 收录。\n\n------\n\n本文档适用那些希望将现有 iOS 经验应用于 Flutter 的开发者。如果你拥有 iOS 开发基础，那么你可以使用这篇文档开始学习 Flutter 的开发。\n\n开发 Flutter 时，你的 iOS 经验和技能将会大有裨益，因为 Flutter 依赖于移动操作系统的众多功能和配置。Flutter 是用于为移动设备构建用户界面的全新方式，但它也有一个插件系统用于和 iOS（及 Android）进行非 UI 任务的通信。如果你是 iOS 开发专家，则你不必将 Flutter 彻底重新学习一遍。\n\n你可以将此文档作为 cookbook，通过跳转并查找与你的需求最相关的问题。\n\n## Views\n\n### UIView 相当于 Flutter 中的什么？\n\n在 iOS 中，构建 UI 的过程中将大量使用 view 对象。这些对象都是 `UIView` 的实例。它们可以用作容器来承载其他的 UIView，最终构成你的界面布局。\n\n在 Flutter 中，你可以粗略地认为 `Widget` 相当于 `UIView` 。Widget 和 iOS 中的控件并不完全等价，但当你试图去理解 Flutter 是如何工作的时候，你可以认为它们是“声明和构建 UI 的方法”。\n\n然而，Widget 和 UIView 还是有些区别的。首先，widgets 拥有不同的生存时间：它们一直存在且保持不变，直到当它们需要被改变。当 widgets 和它们的状态被改变时，Flutter 会构建一颗新的 widgets 树。作为对比，iOS 中的 views 在改变时并不会被重新创建。但是与其说 views 是可变的实例，不如说它们被绘制了一次，并且直到使用 `setNeedsDisplay()` 之后才会被重新绘制。\n\n此外，不像 UIView，由于不可变性，Flutter 的 widgets 非常轻量。这是因为它们本身并不是什么控件，也不会被直接绘制出什么，而只是 UI 的描述。\n\nFlutter 包含了 [Material 组件](https://material.io/develop/flutter/)库。这些 widgets 遵循了 [Material 设计规范](https://material.io/design/)。MD 是一个灵活的设计系统，并且为包括 iOS 在内的[所有系统进行了优化](https://material.io/design/platform-guidance/cross-platform-adaptation.html#cross-platform-guidelines)。\n\n但是用 Flutter 实现任何的设计语言都非常的灵活和富有表现力。在 iOS 平台，你可以使用 [Cupertino widgets](https://flutter.io/widgets/cupertino/) 来构建遵循了 [Apple’s iOS design language](https://developer.apple.com/design/resources/) 的界面。\n\n### 我怎么来更新 Widgets？\n\n在 iOS 上更新 views，只需要直接改变它们就可以了。在 Flutter 中，widgets 是不可变的，而且不能被直接更新。你需要去操纵 widget 的 state。\n\n这也正是有状态的和无状态的 widget 这一概念的来源。一个 `StatelessWidget` 正如它听起来一样，是一个没有附加状态的 widget。\n\n`StatelessWidget` 在你构建初始化后不再进行改变的界面时非常有用。\n\n举个例子，你可能会用一个 `UIImageView` 来展示你的 logo `image` 。如果这个 logo 在运行时不会改变，那么你就可以在 Flutter 中使用 `StatelessWidget` 。\n\n如果你希望在发起 HTTP 请求时，依托接收到的数据动态的改变 UI，请使用 `StatefulWidget`。当 HTTP 请求结束后，通知 Flutter 框架 widget 的 `State` 更新了，好让系统来更新 UI。\n\n有状态和无状态的 widget 之间一个非常重要的区别是，`StatefulWidget` 拥有一个 `State` 对象来存储它的状态数据，并在 widget 树重建时携带着它，因此状态不会丢失。\n\n如果你有疑惑，请记住以下规则：如果一个 widget 在它的 `build` 方法之外改变（例如，在运行时由于用户的操作而改变），它就是有状态的。如果一个 widget 在一次 build 之后永远不变，那它就是无状态的。但是，即便一个 widget 是有状态的，包含它的父亲 widget 也可以是无状态的，只要父 widget 本身不响应这些变化。\n\n下面的例子展示了如何使用一个 `StatelessWidget` 。一个常见的 `StatelessWidget` 是 `Text` widget。如果你查看 Text 的实现，你会发现它是 StatelessWidget 的子类。\n\n```dart\nText(\n  'I like Flutter!',\n  style: TextStyle(fontWeight: FontWeight.bold),\n);\n```\n\n阅读上面的代码，你可能会注意到 `Text` widget 并不显示地携带任何状态。它通过传入给它的构造器的数据来渲染，除此之外再无其他。\n\n但是，如果你希望 `I like Flutter `在点击 `FloatingActionButton` 时动态的改变呢？\n\n为了实现这个，用 `StatefulWidget` 包裹 `Text` widget，并在用户点击按钮时更新它。\n\n举个例子：\n\n```dart\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  // Default placeholder text\n  String textToShow = \"I Like Flutter\";\n  void _updateText() {\n    setState(() {\n      // update the text\n      textToShow = \"Flutter is Awesome!\";\n    });\n  }\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: Center(child: Text(textToShow)),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _updateText,\n        tooltip: 'Update Text',\n        child: Icon(Icons.update),\n      ),\n    );\n  }\n}\n```\n\n### 我怎么对 widget 布局？我的 Storyboard 在哪？\n\n在 iOS 中，你可能会用 Storyboard 文件来组织 views，并对它们设置约束，或者，你可能在 view controller 中使用代码来设置约束。在 Flutter 中，你通过编写一个 widget 树来声明你的布局。\n\n下面这个例子展示了如何展示一个带有 padding 的简单 widget：\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(\"Sample App\"),\n    ),\n    body: Center(\n      child: CupertinoButton(\n        onPressed: () {\n          setState(() { _pressedCount += 1; });\n        },\n        child: Text('Hello'),\n        padding: EdgeInsets.only(left: 10.0, right: 10.0),\n      ),\n    ),\n  );\n}\n```\n\n你可以给任何的 widget 添加 padding，这很像 iOS 中约束的功能。\n\n你可以在 [widget catalog](https://flutter.io/widgets/layout/) 中查看 Flutter 提供的布局。\n\n### 我怎么在我的约束中添加或移除组件？\n\n在 iOS 中，你在父 view 中调用 `addSubview()` 或在子 view 中调用 `removeFromSuperview()` 来动态地添加或移除子 views。在 Flutter 中，由于 widget 不可变，所以没有和 `addSubview()` 直接等价的东西。作为替代，你可以向 parent 传入一个返回 widget 的函数，并用一个布尔值来控制子 widget 的创建。\n\n下面这个例子展示了在点击 `FloatingActionButton` 时如何动态地切换两个 widgets：\n\n```dart\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  // Default value for toggle\n  bool toggle = true;\n  void _toggle() {\n    setState(() {\n      toggle = !toggle;\n    });\n  }\n\n  _getToggleChild() {\n    if (toggle) {\n      return Text('Toggle One');\n    } else {\n      return CupertinoButton(\n        onPressed: () {},\n        child: Text('Toggle Two'),\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: Center(\n        child: _getToggleChild(),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _toggle,\n        tooltip: 'Update Text',\n        child: Icon(Icons.update),\n      ),\n    );\n  }\n}\n```\n\n### 我怎么对 widget 做动画？\n\n在 iOS 中，你通过调用 `animate(withDuration:animations:)` 方法来给一个 view 创建动画。在 Flutter 中，使用动画库来包裹 widgets，而不是创建一个动画 widget。\n\n在 Flutter 中，使用 `AnimationController` 。这是一个可以暂停、寻找、停止、反转动画的 `Animation<double>` 类型。它需要一个 `Ticker` 当 vsync 发生时来发送信号，并且在每帧运行时创建一个介于 0 和 1 之间的线性插话（interpolation）。你可以创建一个或多个的 `Animation` 并附加给一个 controller。\n\n例如，你可能会用 `CurvedAnimation` 来实现一个 interpolated 曲线。在这个场景中，controller 是动画过程的“主人”，而 `CurvedAnimation` 计算曲线，并替代 controller 默认的线性模式。\n\n当构建 widget 树时，你会把 `Animation` 指定给一个 widget 的动画属性，比如 `FadeTransition` 的 opacity，并告诉控制器开始动画。\n\n下面这个例子展示了在点击 `FloatingActionButton` 之后，如何使用 `FadeTransition` 来让 widget 淡出到 logo 图标：\n\n```dart\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Fade Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: MyFadeTest(title: 'Fade Demo'),\n    );\n  }\n}\n\nclass MyFadeTest extends StatefulWidget {\n  MyFadeTest({Key key, this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  _MyFadeTest createState() => _MyFadeTest();\n}\n\nclass _MyFadeTest extends State<MyFadeTest> with TickerProviderStateMixin {\n  AnimationController controller;\n  CurvedAnimation curve;\n\n  @override\n  void initState() {\n    controller = AnimationController(duration: const Duration(milliseconds: 2000), vsync: this);\n    curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Container(\n          child: FadeTransition(\n            opacity: curve,\n            child: FlutterLogo(\n              size: 100.0,\n            )\n          )\n        )\n      ),\n      floatingActionButton: FloatingActionButton(\n        tooltip: 'Fade',\n        child: Icon(Icons.brush),\n        onPressed: () {\n          controller.forward();\n        },\n      ),\n    );\n  }\n\n  @override\n  dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n}\n```\n\n更多信息，请参阅 [Animation & Motion widgets](https://flutter.io/widgets/animation/)， [Animations tutorial](https://flutter.io/tutorials/animation) 以及 [Animations overview](https://flutter.io/animations/)。\n\n### 我该怎么绘图？\n\n在 iOS 上，你通过 `CoreGraphics` 来在屏幕上绘制线条和形状。Flutter 有一套基于 `Canvas` 类的不同的 API，还有 `CustomPaint` 和 `CustomPainter` 这两个类来帮助你绘图。后者实现你在 canvas 上的绘图算法。\n\n想要学习如何实现一个笔迹画笔，请参考 Collin 在 [StackOverflow](https://stackoverflow.com/questions/46241071/create-signature-area-for-mobile-app-in-dart-flutter) 上的回答。\n\n```dart\nclass SignaturePainter extends CustomPainter {\n  SignaturePainter(this.points);\n\n  final List<Offset> points;\n\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.black\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 5.0;\n    for (int i = 0; i < points.length - 1; i++) {\n      if (points[i] != null && points[i + 1] != null)\n        canvas.drawLine(points[i], points[i + 1], paint);\n    }\n  }\n\n  bool shouldRepaint(SignaturePainter other) => other.points != points;\n}\n\nclass Signature extends StatefulWidget {\n  SignatureState createState() => SignatureState();\n}\n\nclass SignatureState extends State<Signature> {\n\n  List<Offset> _points = <Offset>[];\n\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onPanUpdate: (DragUpdateDetails details) {\n        setState(() {\n          RenderBox referenceBox = context.findRenderObject();\n          Offset localPosition =\n          referenceBox.globalToLocal(details.globalPosition);\n          _points = List.from(_points)..add(localPosition);\n        });\n      },\n      onPanEnd: (DragEndDetails details) => _points.add(null),\n      child: CustomPaint(painter: SignaturePainter(_points), size: Size.infinite),\n    );\n  }\n}\n```\n\n### Widget 的透明度在哪里？\n\n在 iOS 中，什么东西都会有一个 .opacity 或是 .alpha 的属性。在 Flutter 中，你需要给 widget 包裹一个 Opacity widget 来做到这一点。\n\n### 我怎么创建自定义的 widgets？\n\n在 iOS 中，你编写 `UIView` 的子类，或使用已经存在的 view 来重载并实现方法，以达到特定的功能。在 Flutter 中，你会组合（[composing](https://flutter.io/technical-overview/#everythings-a-widget)）多个小的 widgets 来构建一个自定义的 widget（而不是扩展它）。\n\n举个例子，如果你要构建一个 `CustomButton` ，并在构造器中传入它的 label？那就组合 `RaisedButton` 和 label，而不是扩展 `RaisedButton`。\n\n```dart\nclass CustomButton extends StatelessWidget {\n  final String label;\n\n  CustomButton(this.label);\n\n  @override\n  Widget build(BuildContext context) {\n    return RaisedButton(onPressed: () {}, child: Text(label));\n  }\n}\n```\n\n然后就像你使用其他任何 Flutter 的 widget 一样，使用你的 CustomButton：\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return Center(\n    child: CustomButton(\"Hello\"),\n  );\n}\n```\n\n## 导航\n\n### 我怎么在不同页面之间跳转？\n\n在 iOS 中，你可以使用管理了 view controller 栈的 `UINavigationController` 来在不同的 view controller 之间跳转。\n\nFlutter 也有类似的实现，使用了 `Navigator` 和 `Routes`。一个路由是 App 中“屏幕”或“页面”的抽象，而一个 Navigator 是管理多个路由的 [widget](https://flutter.io/flutter-for-ios/technical-overview/#everythings-a-widget) 。你可以粗略地把一个路由对应到一个 `UIViewController`。Navigator 的工作原理和 iOS 中 `UINavigationController` 非常相似，当你想跳转到新页面或者从新页面返回时，它可以 `push()` 和 `pop()` 路由。\n\n在页面之间跳转，你有一对选择：\n\n- 具体指定一个由路由名构成的 `Map`。（MaterialApp）\n- 直接跳转到一个路由。（WidgetApp）\n\n下面是构建一个 Map 的例子：\n\n```dart\nvoid main() {\n  runApp(MaterialApp(\n    home: MyAppHome(), // becomes the route named '/'\n    routes: <String, WidgetBuilder> {\n      '/a': (BuildContext context) => MyPage(title: 'page A'),\n      '/b': (BuildContext context) => MyPage(title: 'page B'),\n      '/c': (BuildContext context) => MyPage(title: 'page C'),\n    },\n  ));\n}\n```\n\n通过把路由的名字 `push` 给一个 `Navigator` 来跳转：\n\n```dart\nNavigator.of(context).pushNamed('/b');\n```\n\n`Navigator` 类不仅用来处理 Flutter 中的路由，还被用来获取你刚 push 到栈中的路由返回的结果。通过 `await` `push()` 返回的 `Future` 来达到这点。\n\n举个例子，要跳转到“位置”路由来让用户选择一个地点，你可能要这么做：\n\n```dart\nMap coordinates = await Navigator.of(context).pushNamed('/location');\n```\n\n之后，在 location 路由中，一旦用户选择了地点，携带结果一起 `pop()` 出栈：\n\n```dart\nNavigator.of(context).pop({\"lat\":43.821757,\"long\":-79.226392});\n```\n\n### 我怎么跳转到其他 App？\n\n在 iOS 中，要跳转到其他 App，你需要一个特定的 URL Scheme。对系统级别的 App 来说，这个 scheme 取决于 App。为了在 Flutter 中实现这个功能，你可以创建一个原生平台的整合层，或者使用现有的 [plugin](https://flutter.io/flutter-for-ios/#plugins)，例如 [url_launcher](https://pub.dartlang.org/packages/url_launcher)。\n\n## 线程和异步\n\n### 我怎么编写异步的代码？\n\nDart 是单线程执行模型，但是它支持 `Isolate`（一种让 Dart 代码运行在其他线程的方式）、事件循环和异步编程。除非你自己创建一个 `Isolate` ，否则你的 Dart 代码永远运行在 UI 线程，并由 event loop 驱动。Flutter 的 event loop 和 iOS 中的 main loop 相似——`Looper` 是附加在主线程上的。\n\nDart 的单线程模型并不意味着你写的代码一定是阻塞操作，从而卡住 UI。相反，使用 Dart 语言提供的异步工具，例如 `async` / `await` ，来实现异步操作。\n\n举个例子，你可以使用 `async` / `await` 来让 Dart 帮你做一些繁重的工作，编写网络请求代码而不会挂起 UI：\n\n```dart\nloadData() async {\n  String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n  http.Response response = await http.get(dataURL);\n  setState(() {\n    widgets = json.decode(response.body);\n  });\n}\n```\n\n一旦 `await` 到网络请求完成，通过调用 `setState()` 来更新 UI，这会触发 widget 子树的重建，并更新相关数据。\n\n下面的例子展示了异步加载数据，并用 `ListView` 展示出来：\n\n```dart\nimport 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n\n    loadData();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView.builder(\n          itemCount: widgets.length,\n          itemBuilder: (BuildContext context, int position) {\n            return getRow(position);\n          }));\n  }\n\n  Widget getRow(int i) {\n    return Padding(\n      padding: EdgeInsets.all(10.0),\n      child: Text(\"Row ${widgets[i][\"title\"]}\")\n    );\n  }\n\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}\n```\n\n 更多关于在后台工作的信息，以及 Flutter 和 iOS 的区别，请参考下一章节。\n\n### 你是怎么把工作放到后台线程的？\n\n由于 Flutter 是单线程并且跑着一个 event loop 的（就像 Node.js 那样），你不必为线程管理或是开启后台线程而操心。如果你正在做 I/O 操作，如访问磁盘或网络请求，安全地使用 `async` / `await` 就完事了。如果，在另外的情况下，你需要做让 CPU 保持繁忙的计算密集型任务，你需要使用 `Isolate` 来避免阻塞 event loop。\n\n对于 I/O 操作，把方法声明为 `async` 方法，并且 `await` 方法里需要长期运行的任务：\n\n```dart\nloadData() async {\n  String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n  http.Response response = await http.get(dataURL);\n  setState(() {\n    widgets = json.decode(response.body);\n  });\n}\n```\n\n这就是对诸如网络请求或数据库访问等 I/O 操作的典型做法。\n\n然而，有时候你需要处理大量的数据，这会导致你的 UI 挂起。在 Flutter 中，使用 `Isolate` 来发挥多核心 CPU 的优势来处理那些长期运行或是计算密集型的任务。\n\nIsolates 是分离的运行线程，并且不和主线程的内存堆共享内存。这意味着你不能访问主线程中的变量，或者使用 `setState()` 来更新 UI。正如它们的名字一样，Isolates 不能共享内存。\n\n下面的例子展示了一个简单的 isolate，是如何把数据返回给主线程来更新 UI 的：\n\n```dart\nloadData() async {\n  ReceivePort receivePort = ReceivePort();\n  await Isolate.spawn(dataLoader, receivePort.sendPort);\n\n  // The 'echo' isolate sends its SendPort as the first message\n  SendPort sendPort = await receivePort.first;\n\n  List msg = await sendReceive(sendPort, \"https://jsonplaceholder.typicode.com/posts\");\n\n  setState(() {\n    widgets = msg;\n  });\n}\n\n// The entry point for the isolate\nstatic dataLoader(SendPort sendPort) async {\n  // Open the ReceivePort for incoming messages.\n  ReceivePort port = ReceivePort();\n\n  // Notify any other isolates what port this isolate listens to.\n  sendPort.send(port.sendPort);\n\n  await for (var msg in port) {\n    String data = msg[0];\n    SendPort replyTo = msg[1];\n\n    String dataURL = data;\n    http.Response response = await http.get(dataURL);\n    // Lots of JSON to parse\n    replyTo.send(json.decode(response.body));\n  }\n}\n\nFuture sendReceive(SendPort port, msg) {\n  ReceivePort response = ReceivePort();\n  port.send([msg, response.sendPort]);\n  return response.first;\n}\n```\n\n这里，`dataLoader()` 是一个运行于自己独立执行线程上的 `Isolate`。在 isolate 里，你可以执行 CPU 密集型任务（例如解析一个庞大的 json），或是计算密集型的数学操作，如加密或信号处理等。\n\n你可以运行下面的完整例子：\n\n```dart\nimport 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:async';\nimport 'dart:isolate';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    loadData();\n  }\n\n  showLoadingDialog() {\n    if (widgets.length == 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  getBody() {\n    if (showLoadingDialog()) {\n      return getProgressDialog();\n    } else {\n      return getListView();\n    }\n  }\n\n  getProgressDialog() {\n    return Center(child: CircularProgressIndicator());\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text(\"Sample App\"),\n        ),\n        body: getBody());\n  }\n\n  ListView getListView() => ListView.builder(\n      itemCount: widgets.length,\n      itemBuilder: (BuildContext context, int position) {\n        return getRow(position);\n      });\n\n  Widget getRow(int i) {\n    return Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row ${widgets[i][\"title\"]}\"));\n  }\n\n  loadData() async {\n    ReceivePort receivePort = ReceivePort();\n    await Isolate.spawn(dataLoader, receivePort.sendPort);\n\n    // The 'echo' isolate sends its SendPort as the first message\n    SendPort sendPort = await receivePort.first;\n\n    List msg = await sendReceive(sendPort, \"https://jsonplaceholder.typicode.com/posts\");\n\n    setState(() {\n      widgets = msg;\n    });\n  }\n\n// the entry point for the isolate\n  static dataLoader(SendPort sendPort) async {\n    // Open the ReceivePort for incoming messages.\n    ReceivePort port = ReceivePort();\n\n    // Notify any other isolates what port this isolate listens to.\n    sendPort.send(port.sendPort);\n\n    await for (var msg in port) {\n      String data = msg[0];\n      SendPort replyTo = msg[1];\n\n      String dataURL = data;\n      http.Response response = await http.get(dataURL);\n      // Lots of JSON to parse\n      replyTo.send(json.decode(response.body));\n    }\n  }\n\n  Future sendReceive(SendPort port, msg) {\n    ReceivePort response = ReceivePort();\n    port.send([msg, response.sendPort]);\n    return response.first;\n  }\n}\n```\n\n### 我怎么发起网络请求？\n\n在 Flutter 中，使用流行的 [http package](https://pub.dartlang.org/packages/http) 做网络请求非常简单。它把你可能需要自己做的网络请求操作抽象了出来，让发起请求变得简单。\n\n要使用 `http` 包，在 `pubspec.yaml` 中把它添加为依赖：\n\n```\ndependencies:\n  ...\n  http: ^0.11.3+16\n```\n\n发起网络请求，在 `http.get()` 这个 `async` 方法中使用 `await` ：\n\n```dart\nimport 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n[...]\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}\n```\n\n### 我怎么展示一个长时间运行的任务的进度？\n\n在 iOS 中，在后台运行耗时任务时你会使用 `UIProgressView`。 \n\n在 Flutter 中，使用一个 `ProgressIndicator` widget。通过一个布尔 flag 来控制是否展示进度。在任务开始时，告诉 Flutter 更新状态，并在结束后隐去。\n\n在下面的例子中，build 函数被拆分成三个函数。如果 `showLoadingDialog()` 是 `true` （当 `widgets.length == 0` 时），则渲染 `ProgressIndicator`。否则，当数据从网络请求中返回时，渲染 `ListView` 。\n\n```dart\nimport 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    loadData();\n  }\n\n  showLoadingDialog() {\n    return widgets.length == 0;\n  }\n\n  getBody() {\n    if (showLoadingDialog()) {\n      return getProgressDialog();\n    } else {\n      return getListView();\n    }\n  }\n\n  getProgressDialog() {\n    return Center(child: CircularProgressIndicator());\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text(\"Sample App\"),\n        ),\n        body: getBody());\n  }\n\n  ListView getListView() => ListView.builder(\n      itemCount: widgets.length,\n      itemBuilder: (BuildContext context, int position) {\n        return getRow(position);\n      });\n\n  Widget getRow(int i) {\n    return Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row ${widgets[i][\"title\"]}\"));\n  }\n\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}\n```\n\n## 工程结构、本地化、依赖和资源\n\n### 我怎么在 Flutter 中引入 image assets？多分辨率怎么办？\n\niOS 把 images 和 assets 作为不同的东西，而 Flutter 中只有 assets。被放到 iOS 中 `Images.xcasset` 文件夹下的资源在 Flutter 中被放到了 assets 文件夹中。assets 可以是任意类型的文件，而不仅仅是图片。例如，你可以把 json 文件放置到 `my-assets` 文件夹中。\n\n```\nmy-assets/data.json\n```\n\n在 `pubspec.yaml` 文件中声明 assets：\n\n```\nassets:\n - my-assets/data.json\n```\n\n然后在代码中使用 [`AssetBundle`](https://docs.flutter.io/flutter/services/AssetBundle-class.html) 来访问它：\n\n```dart\nimport 'dart:async' show Future;\nimport 'package:flutter/services.dart' show rootBundle;\n\nFuture<String> loadAsset() async {\n  return await rootBundle.loadString('my-assets/data.json');\n}\n```\n\n对于图片，Flutter 像 iOS 一样，遵循了一个简单的基于像素密度的格式。Image assets 可能是 `1.0x` `2.0x` `3.0x` 或是其他的任何倍数。这些所谓的 [`devicePixelRatio`](https://docs.flutter.io/flutter/dart-ui/Window/devicePixelRatio.html) 传达了物理像素到单个逻辑像素的比率。\n\nAssets 可以被放置到任何属性文件夹中——Flutter 并没有预先定义的文件结构。在 `pubspec.yaml` 文件中声明 assets （和位置），然后 Flutter 会把他们识别出来。\n\n举个例子，要把一个叫 `my_icon.png` 的图片放到 Flutter 工程中，你可能想要把存储它的文件夹叫做 `images`。把基础图片（1.0x）放置到 `images` 文件夹中，并把其他变体放置在子文件夹中，并接上合适的比例系数：\n\n```\nimages/my_icon.png       // Base: 1.0x image\nimages/2.0x/my_icon.png  // 2.0x image\nimages/3.0x/my_icon.png  // 3.0x image\n```\n\n接着，在 `pubspec.yaml` 文件夹中声明这些图片：\n\n```\nassets:\n - images/my_icon.jpeg\n```\n\n你可以用 `AssetImage` 来访问这些图片：\n\n```dart\nreturn AssetImage(\"images/a_dot_burr.jpeg\");\n```\n\n或者在 `Image` widget 中直接使用：\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return Image.asset(\"images/my_image.png\");\n}\n```\n\n更多细节，参见 [Adding Assets and Images in Flutter](https://flutter.io/assets-and-images)。\n\n### 我在哪里放置字符串？我怎么做本地化？\n\n不像 iOS 拥有一个 `Localizable.strings` 文件，Flutter 目前并没有一个用于处理字符串的系统。目前，最佳实践是把你的文本拷贝到静态区，并在这里访问。例如：\n\n```dart\nclass Strings {\n  static String welcomeMessage = \"Welcome To Flutter\";\n}\n```\n\n并且这样访问你的字符串：\n\n```dart\nText(Strings.welcomeMessage)\n```\n\n默认情况下，Flutter 只支持美式英语字符串。如果你要支持其他语言，请引入 `flutter_localizations` 包。你可能也要引入  [`intl`](https://pub.dartlang.org/packages/intl) 包来支持其他的 i10n 机制，比如日期/时间格式化。\n\n```\ndependencies:\n  # ...\n  flutter_localizations:\n    sdk: flutter\n  intl: \"^0.15.6\"\n```\n\n要使用 `flutter_localizations` 包，在 app widget 中指 `localizationsDelegates` 和 `supportedLocales`。\n\n```dart\nimport 'package:flutter_localizations/flutter_localizations.dart';\n\nMaterialApp(\n localizationsDelegates: [\n   // Add app-specific localization delegate[s] here\n   GlobalMaterialLocalizations.delegate,\n   GlobalWidgetsLocalizations.delegate,\n ],\n supportedLocales: [\n    const Locale('en', 'US'), // English\n    const Locale('he', 'IL'), // Hebrew\n    // ... other locales the app supports\n  ],\n  // ...\n)\n```\n\n这些代理包括了实际的本地化值，并且 `supportedLocales` 定义了 App 支持哪些地区。上面的例子使用了一个 `MaterialApp` ，所以它既有 `GlobalWidgetsLocalizations` 用于基础 widgets，也有 `MaterialWidgetsLocalizations` 用于 Material wigets 的本地化。如果你使用 `WidgetsApp` ，则无需包括后者。注意，这两个代理虽然包括了“默认”值，但如果你想让你的 App 本地化，你仍需要提供一或多个代理作为你的 App 本地化副本。\n\n当初始化时，`WidgetsApp` 或 `MaterialApp` 会使用你指定的代理为你创建一个  [`Localizations`](https://docs.flutter.io/flutter/widgets/Localizations-class.html) widget。`Localizations` widget 可以随时从当前上下文中访问设备的地点，或者使用 [`Window.locale`](https://docs.flutter.io/flutter/dart-ui/Window/locale.html)。\n\n要访问本地化文件，使用 `Localizations.of()` 方法来访问提供代理的特定本地化类。如需翻译，使用  [`intl_translation`](https://pub.dartlang.org/packages/intl_translation) 包来取出翻译副本到 [arb](https://code.google.com/p/arb/wiki/ApplicationResourceBundleSpecification) 文件中。把它们引入 App 中，并用 `intl` 来使用它们。\n\n更多 Flutter 中国际化和本地化的细节，请访问 [internationalization guide](https://flutter.io/tutorials/internationalization) ，那里有不使用 `intl` 包的示例代码。\n\n注意，在 Flutter 1.0 beta 2 之前，在 Flutter 中定义的 assets 不能在原生一侧被访问。原生定义的资源在 Flutter 中也不可用，因为它们在独立的文件夹中。\n\n### Cocoapods 相当于什么？我该如何添加依赖？\n\n在 iOS 中，你把依赖添加到 `Podfile` 中。Flutter 使用 Dart 构建系统和 Pub 包管理器来处理依赖。这些工具将本机 Android 和 iOS 包装应用程序的构建委派给相应的构建系统。\n\n如果你的 Flutter 工程中的 iOS 文件夹中拥有 Podfile，请仅在你为每个平台集成时使用它。总体来说，使用 `pubspec.yaml` 来在 Flutter 中声明外部依赖。一个可以找到优秀 Flutter 包的地方是 [Pub](https://pub.dartlang.org/flutter/packages/)。\n\n## ViewControllers\n\n### ViewController 相当于 Flutter 中的什么？\n\n在 iOS 中，一个 ViewController 代表了用户界面的一部分，最常用于一个屏幕，或是其中一部分。它们被组合在一起用于构建复杂的用户界面，并帮助你拆分 App 的 UI。在 Flutter 中，这一任务回落到了 widgets 中。就像在界面导航部分提到的一样，一个屏幕也是被 widgets 来表示的，因为“万物皆 widget！”。使用 `Navigator` 在 `Route` 之间跳转，或者渲染相同数据的不同状态。\n\n### 我该怎么监听 iOS 中的生命周期事件？\n\n在 iOS 中，你可以重写 `ViewController` 中的方法来补货它的视图的生命周期，或者在 `AppDelegate` 中注册生命周期的回调函数。在 Flutter 中没有这两个概念，但你可以通过 hook `WidgetsBinding` 观察者来监听生命周期事件，并监听 `didChangeAppLifecycleState()` 的变化事件。\n\n可观察的生命周期事件有：\n\n- `inactive` - 应用处于不活跃的状态，并且不会接受用户的输入。这个事件仅工作在 iOS 平台，在 Android 上没有等价的事件。\n- `paused` - 应用暂时对用户不可见，虽然不接受用户输入，但是是在后台运行的。\n- `resumed` - 应用可见，也响应用户的输入。\n- `suspending` - 应用暂时被挂起，在 iOS 上没有这一事件。\n\n更多关于这些状态的细节和含义，请参见  [`AppLifecycleStatus` documentation](https://docs.flutter.io/flutter/dart-ui/AppLifecycleState-class.html) 。\n\n## 布局\n\n### UITableView 和 UICollectionView 相当于 Flutter 中的什么？\n\n在 iOS 中，你可能用 UITableView 或 UICollectionView 来展示一个列表。在 Flutter 中，你可以用 `ListView` 来达到相似的实现。在 iOS 中，你通过代理方法来确定行数，每一个 index path 的单元格，以及单元格的尺寸。\n\n由于 Flutter 中 widget 的不可变特性，你需要向 `ListView` 传递一个 widget 列表，Flutter 会确保滚动是快速且流畅的。\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: _getListData()),\n    );\n  }\n\n  _getListData() {\n    List<Widget> widgets = [];\n    for (int i = 0; i < 100; i++) {\n      widgets.add(Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row $i\")));\n    }\n    return widgets;\n  }\n}\n```\n\n### 我怎么知道列表的哪个元素被点击了？\n\niOS 中，你通过 `tableView:didSelectRowAtIndexPath:` 代理方法来实现。在 Flutter 中，使用传递进来的 widget 的 touch handle：\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: _getListData()),\n    );\n  }\n\n  _getListData() {\n    List<Widget> widgets = [];\n    for (int i = 0; i < 100; i++) {\n      widgets.add(GestureDetector(\n        child: Padding(\n          padding: EdgeInsets.all(10.0),\n          child: Text(\"Row $i\"),\n        ),\n        onTap: () {\n          print('row tapped');\n        },\n      ));\n    }\n    return widgets;\n  }\n}\n```\n\n### 我怎么动态地更新 ListView？\n\n在 iOS 中，你改变列表的数据，并通过 `reloadData()` 方法来通知 table 或是 collection view。\n\n在 Flutter 中，如果你想通过 `setState()` 方法来更新 widget 列表，你会很快发现你的数据展示并没有变化。这是因为当 `setState()` 被调用时，Flutter 渲染引擎会去检查 widget 树来查看是否有什么地方被改变了。当它得到你的 `ListView` 时，它会使用一个 `==` 判断，并且发现两个 `ListView` 是相同的。没有什么东西是变了的，因此更新不是必须的。\n\n一个更新 `ListView` 的简单方法是，在 `setState()` 中创建一个新的 list，并把旧 list 的数据拷贝给新的 list。虽然这样很简单，但当数据集很大时，并不推荐这样做：\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    for (int i = 0; i < 100; i++) {\n      widgets.add(getRow(i));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: widgets),\n    );\n  }\n\n  Widget getRow(int i) {\n    return GestureDetector(\n      child: Padding(\n        padding: EdgeInsets.all(10.0),\n        child: Text(\"Row $i\"),\n      ),\n      onTap: () {\n        setState(() {\n          widgets = List.from(widgets);\n          widgets.add(getRow(widgets.length + 1));\n          print('row $i');\n        });\n      },\n    );\n  }\n}\n```\n\n一个推荐的、高效的且有效的做法是，使用 `ListView.Builder` 来构建列表。这个方法在你想要构建动态列表，或是列表拥有大量数据时会非常好用。\n\n```dart\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    for (int i = 0; i < 100; i++) {\n      widgets.add(getRow(i));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView.builder(\n        itemCount: widgets.length,\n        itemBuilder: (BuildContext context, int position) {\n          return getRow(position);\n        },\n      ),\n    );\n  }\n\n  Widget getRow(int i) {\n    return GestureDetector(\n      child: Padding(\n        padding: EdgeInsets.all(10.0),\n        child: Text(\"Row $i\"),\n      ),\n      onTap: () {\n        setState(() {\n          widgets.add(getRow(widgets.length + 1));\n          print('row $i');\n        });\n      },\n    );\n  }\n}\n```\n\n与创建一个 “ListView” 不同，创建一个 `ListView.builder` 接受两个主要参数：列表的初始长度，和一个 `ItemBuilder` 方法。\n\n`ItemBuilder` 方法和 `cellForItemAt` 代理方法非常类似，它接受一个位置，并且返回在这个位置上你希望渲染的 cell。\n\n最后，也是最重要的，注意 `onTap()` 函数里并没有重新创建一个 list，而是 `.add` 了一个 widget。\n\n### ScrollView 相当于 Flutter 里的什么？\n\n在 iOS 中，你给 view 包裹上 `ScrollView` 来允许用户在需要时滚动你的内容。\n\n在 Flutter 中，最简单的方法是使用 `ListView` widget。它表现得既和 iOS 中的 `ScrollView` 一致，也能和 `TableView` 一致，因为你可以给它的 widget 做垂直排布：\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return ListView(\n    children: <Widget>[\n      Text('Row One'),\n      Text('Row Two'),\n      Text('Row Three'),\n      Text('Row Four'),\n    ],\n  );\n}\n```\n\n更多关于在 Flutter 总如何排布 widget 的文档，请参阅 [layout tutorial](https://flutter.io/widgets/layout/)。\n\n## 手势检测及触摸事件处理\n\n### 我怎么给 Flutter 的 widget 添加一个点击监听者？\n\n在 iOS 中，你给一个 view 添加 `GestureRecognizer` 来处理点击事件。在 Flutter 中，有两种方法来添加点击监听者：\n\n1. 如果 widget 本身支持事件监测，直接传递给它一个函数，并在这个函数里实现响应方法。例如，`RaisedButton` widget 拥有一个 `RaisedButton` 参数：\n\n   ```dart\n   @override\n   Widget build(BuildContext context) {\n     return RaisedButton(\n       onPressed: () {\n         print(\"click\");\n       },\n       child: Text(\"Button\"),\n     );\n   }\n   ```\n\n2. 如果 widget 本身不支持事件监测，则在外面包裹一个 GestureDetector，并给它的 onTap 属性传递一个函数：\n\n   ```dart\n   class SampleApp extends StatelessWidget {\n     @override\n     Widget build(BuildContext context) {\n       return Scaffold(\n         body: Center(\n           child: GestureDetector(\n             child: FlutterLogo(\n               size: 200.0,\n             ),\n             onTap: () {\n               print(\"tap\");\n             },\n           ),\n         ),\n       );\n     }\n   }\n   ```\n\n### 我怎么处理 widget 上的其他手势？\n\n使用 `GestureDetector` 你可以监听更广阔范围内的手势，比如：\n\n- Tapping\n  - `onTapDown` — 在特定位置轻触手势接触了屏幕。\n  - `onTapUp` — 在特定位置产生了一个轻触手势，并停止接触屏幕。\n  - `onTap` — 产生了一个轻触手势。\n  - `onTapCancel` — 触发了 `onTapDown` 但没能触发 tap。\n- Double tapping\n  - `onDoubleTap` — 用户在同一个位置快速点击了两下屏幕。\n- Long pressing\n  - `onLongPress` — 用户在同一个位置长时间接触屏幕。\n- Vertical dragging\n  - `onVerticalDragStart` — 接触了屏幕，并且可能会垂直移动。\n  - `onVerticalDragUpdate` — 接触了屏幕，并继续在垂直方向移动。\n  - `onVerticalDragEnd` — 之前接触了屏幕并垂直移动，并在停止接触屏幕前以某个垂直的速度移动。\n- Horizontal dragging\n  - `onHorizontalDragStart` \n  - `onHorizontalDragUpdate`\n  - `onHorizontalDragEnd`\n\n下面这个例子展示了一个 `GestureDetector` 是如何在双击时旋转 Flutter 的 logo 的：\n\n```dart\nAnimationController controller;\nCurvedAnimation curve;\n\n@override\nvoid initState() {\n  controller = AnimationController(duration: const Duration(milliseconds: 2000), vsync: this);\n  curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: GestureDetector(\n          child: RotationTransition(\n            turns: curve,\n            child: FlutterLogo(\n              size: 200.0,\n            )),\n          onDoubleTap: () {\n            if (controller.isCompleted) {\n              controller.reverse();\n            } else {\n              controller.forward();\n            }\n          },\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 主题和文字\n\n### 我怎么给 App 设置主题？\n\nFlutter 实现了一套漂亮的 MD 组件，并且开箱可用。它接管了一大堆你需要的样式和主题。\n\n为了充分发挥你的 App 中 MD 组件的优势，声明一个顶级 widget，MaterialApp，用作你的 App 入口。MaterialApp 是一个便利组件，包含了许多 App 通常需要的 MD 风格组件。它通过一个 WidgetsApp 添加了 MD 功能来实现。\n\n但是 Flutter 足够地灵活和富有表现力来实现任何其他的设计语言。在 iOS 上，你可以用 [Cupertino library](https://docs.flutter.io/flutter/cupertino/cupertino-library.html) 来制作遵守  [Human Interface Guidelines](https://developer.apple.com/ios/human-interface-guidelines/overview/themes/) 的界面。查看这些 widget 的集合，请参阅 [Cupertino widgets gallery](https://flutter.io/widgets/cupertino/)。\n\n你也可以在你的 App 中使用 WidgetApp，它提供了许多相似的功能，但不如 `MaterialApp` 那样强大。\n\n对任何子组件定义颜色和样式，可以给 `MaterialApp` widget 传递一个 `ThemeData` 对象。举个例子，在下面的代码中，primary swatch 被设置为蓝色，并且文字的选中颜色是红色：\n\n```dart\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        textSelectionColor: Colors.red\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n```\n\n### 我怎么给 Text widget 设置自定义字体？\n\n在 iOS 中，你在项目中引入任意的 `ttf` 文件，并在 `info.plist` 中设置引用。在 Flutter 中，在文件夹中放置字体文件，并在 `pubspec.yaml` 中引用它，就像添加图片那样。\n\n```\nfonts:\n   - family: MyCustomFont\n     fonts:\n       - asset: fonts/MyCustomFont.ttf\n       - style: italic\n```\n\n然后在你的 `Text` widget 中指定字体：\n\n```dart\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(\"Sample App\"),\n    ),\n    body: Center(\n      child: Text(\n        'This is a custom font text',\n        style: TextStyle(fontFamily: 'MyCustomFont'),\n      ),\n    ),\n  );\n}\n```\n\n### 我怎么给我的 Text widget 设置样式？\n\n除了字体以外，你也可以给 Text widget 的样式元素设置自定义值。`Text` widget 接受一个  `TextStyle` 对象，你可以指定许多参数，比如：\n\n- `color`\n- `decoration`\n- `decorationColor`\n- `decorationStyle`\n- `fontFamily`\n- `fontSize`\n- `fontStyle`\n- `fontWeight`\n- `hashCode`\n- `height`\n- `inherit`\n- `letterSpacing`\n- `textBaseline`\n- `wordSpacing`\n\n## 表单输入\n\n### Flutter 中表单怎么工作？我怎么拿到用户的输入？\n\n我们已经提到 Flutter 使用不可变的 widget，并且状态是分离的，你可能会好奇在这种情境下怎么处理用户的输入。在 iOS 中，你经常在需要提交数据时查询组件当前的状态或动作，但这在 Flutter 中是怎么工作的呢？\n\n在表单处理的实践中，就像在 Flutter 中任何其他的地方一样，要通过特定的 widgets。如果你有一个 `TextField` 或是 `TextFormField`，你可以通过 [`TextEditingController`](https://docs.flutter.io/flutter/widgets/TextEditingController-class.html) 来获得用户输入：\n\n```dart\nclass _MyFormState extends State<MyForm> {\n  // Create a text controller and use it to retrieve the current value.\n  // of the TextField!\n  final myController = TextEditingController();\n\n  @override\n  void dispose() {\n    // Clean up the controller when disposing of the Widget.\n    myController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Retrieve Text Input'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: TextField(\n          controller: myController,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        // When the user presses the button, show an alert dialog with the\n        // text the user has typed into our text field.\n        onPressed: () {\n          return showDialog(\n            context: context,\n            builder: (context) {\n              return AlertDialog(\n                // Retrieve the text the user has typed in using our\n                // TextEditingController\n                content: Text(myController.text),\n              );\n            },\n          );\n        },\n        tooltip: 'Show me the value!',\n        child: Icon(Icons.text_fields),\n      ),\n    );\n  }\n}\n```\n\n你可以在这里获得更多信息，或是完整的代码列表： [Retrieve the value of a text field](https://flutter.io/cookbook/forms/retrieve-input/)，来自 [Flutter Cookbook](https://flutter.io/cookbook/) 。\n\n### Text field 中的 placeholder 相当于什么？\n\n在 Flutter 中，你可以轻易地通过向 Text widget 的装饰构造器参数重传递 `InputDecoration` 来展示“小提示”，或是占位符文字：\n\n```dart\nbody: Center(\n  child: TextField(\n    decoration: InputDecoration(hintText: \"This is a hint\"),\n  ),\n)\n```\n\n### 我怎么展示验证错误信息？\n\n就像展示“小提示”一样，向 Text widget 的装饰器构造器参数中传递一个 `InputDecoration`。\n\n然而，你并不想在一开始就显示错误信息。相反，当用户输入了验证信息，更新状态，并传入一个新的 `InputDecoration` 对象：\n\n```dart\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() => _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State<SampleAppPage> {\n  String _errorText;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: Center(\n        child: TextField(\n          onSubmitted: (String text) {\n            setState(() {\n              if (!isEmail(text)) {\n                _errorText = 'Error: This is not an email';\n              } else {\n                _errorText = null;\n              }\n            });\n          },\n          decoration: InputDecoration(hintText: \"This is a hint\", errorText: _getErrorText()),\n        ),\n      ),\n    );\n  }\n\n  _getErrorText() {\n    return _errorText;\n  }\n\n  bool isEmail(String em) {\n    String emailRegexp =\n        r'^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$';\n\n    RegExp regExp = RegExp(p);\n\n    return regExp.hasMatch(em);\n  }\n}\n```\n\n## 和硬件、第三方服务以及平台交互\n\n### 我怎么和平台，以及平台的原生代码交互？\n\nFlutter 的代码并不直接在平台之下运行，相反，Dart 代码构建的 Flutter 应用在设备上以原生的方式运行，却“侧步躲开了”平台提供的 SDK。这意味着，例如，你在 Dart 中发起一个网络请求，它就直接在 Dart 的上下文中运行。你并不会用上平常在 iOS 或 Android 上使用的原生 API。你的 Flutter 程序仍然被原生平台的 `ViewController` 管理作一个 view，但是你并不会直接访问 `ViewController` 自身，或是原生框架。\n\n但这并不意味着 Flutter 不能和原生 API，或任何你编写的原生代码交互。Flutter 提供了 [platform channels](https://flutter.io/platform-channels/) ，来和管理你的 Flutter view 的 ViewController 通信和交互数据。平台管道本质上是一个异步通信机制，桥接了 Dart 代码和宿主 ViewController，以及它运行于的 iOS 框架。你可以用平台管道来执行一个原生的函数，或者是从设备的传感器中获取数据。\n\n除了直接使用平台管道之外，你还可以使用一系列预先制作好的 [plugins](https://flutter.io/using-packages/)。例如，你可以直接使用插件来访问相机胶卷或是设备的摄像头，而不必编写你自己的集成层代码。你可以在 [Pub](https://pub.dartlang.org/) 上找到插件，这是一个 Dart 和 Flutter 的开源包仓库。其中一些包可能会支持集成 iOS 或 Android，或两者均可。\n\n如果你在 Pub 上找不到符合你需求的插件，你可以[自己编写](https://flutter.io/developing-packages/) ，并且[发布在 Pub 上](https://flutter.io/developing-packages/#publish)。\n\n### 我怎么访问 GPS 传感器？\n\n使用 [`location`](https://pub.dartlang.org/packages/location) 社区插件。\n\n### 我怎么访问摄像头？\n\n[`image_picker`](https://pub.dartlang.org/packages/image_picker) 在访问摄像头时非常常用。\n\n### 我怎么登录 Facebook？\n\n登录 Facebook 可以使用 [`flutter_facebook_login`](https://pub.dartlang.org/packages/flutter_facebook_login) 社区插件。\n\n### 我怎么使用 Firebase 特性？\n\n大多数 Firebase 特性被  [first party plugins](https://pub.dartlang.org/flutter/packages?q=firebase) 包含了。这些第一方插件由 Flutter 团队维护：\n\n- [`firebase_admob`](https://pub.dartlang.org/packages/firebase_admob) for Firebase AdMob\n- [`firebase_analytics`](https://pub.dartlang.org/packages/firebase_analytics) for Firebase Analytics\n- [`firebase_auth`](https://pub.dartlang.org/packages/firebase_auth) for Firebase Auth\n- [`firebase_core`](https://pub.dartlang.org/packages/firebase_core) for Firebase’s Core package\n- [`firebase_database`](https://pub.dartlang.org/packages/firebase_database) for Firebase RTDB\n- [`firebase_storage`](https://pub.dartlang.org/packages/firebase_storage) for Firebase Cloud Storage\n- [`firebase_messaging`](https://pub.dartlang.org/packages/firebase_messaging) for Firebase Messaging (FCM)\n- [`cloud_firestore`](https://pub.dartlang.org/packages/cloud_firestore) for Firebase Cloud Firestore\n\n你也可以在 Pub 上找到 Firebase 的第三方插件。\n\n### 我怎创建自己的原生集成层？\n\n如果有一些 Flutter 和社区插件遗漏的平台相关的特性，可以根据  [developing packages and plugins](https://flutter.io/developing-packages/) 页面构建自己的插件。\n\nFlutter 的插件结构，简要来说，就像 Android 中的 Event bus。你发送一个消息，并让接受者处理并反馈结果给你。在这种情况下，接受者就是在 Android 或 iOS 上的原生代码。\n\n## 数据库和本地存储\n\n### 我怎么在 Flutter 中访问 UserDefaults？\n\n在 iOS 中，你可以使用属性列表来存储键值对的集合，即我们熟悉的 UserDefaults。\n\n在 Flutter 中，可以使用  [Shared Preferences plugin](https://pub.dartlang.org/packages/shared_preferences) 来达到相似的功能。它包裹了 `UserDefaluts` 以及 Android 上等价的 `SharedPreferences` 的功能。\n\n### CoreData 相当于 Flutter 中的什么？\n\n在 iOS 中，你通过 CoreData 来存储结构化的数据。这是一个 SQL 数据库的上层封装，让查询和关联模型变得更加简单。\n\n在 Flutter 中，使用 [SQFlite](https://pub.dartlang.org/packages/sqflite) 插件来实现这个功能。\n\n## 通知\n\n### 我怎么推送通知？\n\n在 iOS 中，你需要向 developer portal 中注册来允许推送通知。\n\n在 Flutter 中，使用 `firebase_messaging` 插件来实现这一功能。\n\n更多使用 Firebase Cloud Messaging API 的信息，请参阅 [`firebase_messaging`](https://pub.dartlang.org/packages/firebase_messaging) 插件文档。\n\n------\n\n此文档由 Luyuan Wang 原创翻译。2018 - 07 - 11","slug":"Flutter-for-iOS-dev-翻译","published":1,"updated":"2020-01-04T08:16:16.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4zcnv500040ljc3u22llptr","content":"<h1 id=\"Flutter-for-iOS-Developers-翻译\"><a href=\"#Flutter-for-iOS-Developers-翻译\" class=\"headerlink\" title=\"Flutter for iOS Developers 翻译\"></a>Flutter for iOS Developers 翻译</h1><p>官方文档原文链接：<a href=\"https://flutter.io/flutter-for-ios/\">https://flutter.io/flutter-for-ios/</a></p>\n<p>此翻译文档已被 <a href=\"https://flutterchina.club/flutter-for-ios/\">Flutter 中文网</a> 收录。</p>\n<hr>\n<p>本文档适用那些希望将现有 iOS 经验应用于 Flutter 的开发者。如果你拥有 iOS 开发基础，那么你可以使用这篇文档开始学习 Flutter 的开发。</p>\n<p>开发 Flutter 时，你的 iOS 经验和技能将会大有裨益，因为 Flutter 依赖于移动操作系统的众多功能和配置。Flutter 是用于为移动设备构建用户界面的全新方式，但它也有一个插件系统用于和 iOS（及 Android）进行非 UI 任务的通信。如果你是 iOS 开发专家，则你不必将 Flutter 彻底重新学习一遍。</p>\n<p>你可以将此文档作为 cookbook，通过跳转并查找与你的需求最相关的问题。</p>\n<h2 id=\"Views\"><a href=\"#Views\" class=\"headerlink\" title=\"Views\"></a>Views</h2><h3 id=\"UIView-相当于-Flutter-中的什么？\"><a href=\"#UIView-相当于-Flutter-中的什么？\" class=\"headerlink\" title=\"UIView 相当于 Flutter 中的什么？\"></a>UIView 相当于 Flutter 中的什么？</h3><p>在 iOS 中，构建 UI 的过程中将大量使用 view 对象。这些对象都是 <code>UIView</code> 的实例。它们可以用作容器来承载其他的 UIView，最终构成你的界面布局。</p>\n<p>在 Flutter 中，你可以粗略地认为 <code>Widget</code> 相当于 <code>UIView</code> 。Widget 和 iOS 中的控件并不完全等价，但当你试图去理解 Flutter 是如何工作的时候，你可以认为它们是“声明和构建 UI 的方法”。</p>\n<p>然而，Widget 和 UIView 还是有些区别的。首先，widgets 拥有不同的生存时间：它们一直存在且保持不变，直到当它们需要被改变。当 widgets 和它们的状态被改变时，Flutter 会构建一颗新的 widgets 树。作为对比，iOS 中的 views 在改变时并不会被重新创建。但是与其说 views 是可变的实例，不如说它们被绘制了一次，并且直到使用 <code>setNeedsDisplay()</code> 之后才会被重新绘制。</p>\n<p>此外，不像 UIView，由于不可变性，Flutter 的 widgets 非常轻量。这是因为它们本身并不是什么控件，也不会被直接绘制出什么，而只是 UI 的描述。</p>\n<p>Flutter 包含了 <a href=\"https://material.io/develop/flutter/\">Material 组件</a>库。这些 widgets 遵循了 <a href=\"https://material.io/design/\">Material 设计规范</a>。MD 是一个灵活的设计系统，并且为包括 iOS 在内的<a href=\"https://material.io/design/platform-guidance/cross-platform-adaptation.html#cross-platform-guidelines\">所有系统进行了优化</a>。</p>\n<p>但是用 Flutter 实现任何的设计语言都非常的灵活和富有表现力。在 iOS 平台，你可以使用 <a href=\"https://flutter.io/widgets/cupertino/\">Cupertino widgets</a> 来构建遵循了 <a href=\"https://developer.apple.com/design/resources/\">Apple’s iOS design language</a> 的界面。</p>\n<h3 id=\"我怎么来更新-Widgets？\"><a href=\"#我怎么来更新-Widgets？\" class=\"headerlink\" title=\"我怎么来更新 Widgets？\"></a>我怎么来更新 Widgets？</h3><p>在 iOS 上更新 views，只需要直接改变它们就可以了。在 Flutter 中，widgets 是不可变的，而且不能被直接更新。你需要去操纵 widget 的 state。</p>\n<p>这也正是有状态的和无状态的 widget 这一概念的来源。一个 <code>StatelessWidget</code> 正如它听起来一样，是一个没有附加状态的 widget。</p>\n<p><code>StatelessWidget</code> 在你构建初始化后不再进行改变的界面时非常有用。</p>\n<p>举个例子，你可能会用一个 <code>UIImageView</code> 来展示你的 logo <code>image</code> 。如果这个 logo 在运行时不会改变，那么你就可以在 Flutter 中使用 <code>StatelessWidget</code> 。</p>\n<p>如果你希望在发起 HTTP 请求时，依托接收到的数据动态的改变 UI，请使用 <code>StatefulWidget</code>。当 HTTP 请求结束后，通知 Flutter 框架 widget 的 <code>State</code> 更新了，好让系统来更新 UI。</p>\n<p>有状态和无状态的 widget 之间一个非常重要的区别是，<code>StatefulWidget</code> 拥有一个 <code>State</code> 对象来存储它的状态数据，并在 widget 树重建时携带着它，因此状态不会丢失。</p>\n<p>如果你有疑惑，请记住以下规则：如果一个 widget 在它的 <code>build</code> 方法之外改变（例如，在运行时由于用户的操作而改变），它就是有状态的。如果一个 widget 在一次 build 之后永远不变，那它就是无状态的。但是，即便一个 widget 是有状态的，包含它的父亲 widget 也可以是无状态的，只要父 widget 本身不响应这些变化。</p>\n<p>下面的例子展示了如何使用一个 <code>StatelessWidget</code> 。一个常见的 <code>StatelessWidget</code> 是 <code>Text</code> widget。如果你查看 Text 的实现，你会发现它是 StatelessWidget 的子类。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Text(</span><br><span class=\"line\">  <span class=\"string\">'I like Flutter!'</span>,</span><br><span class=\"line\">  style: TextStyle(fontWeight: FontWeight.bold),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>阅读上面的代码，你可能会注意到 <code>Text</code> widget 并不显示地携带任何状态。它通过传入给它的构造器的数据来渲染，除此之外再无其他。</p>\n<p>但是，如果你希望 <code>I like Flutter</code>在点击 <code>FloatingActionButton</code> 时动态的改变呢？</p>\n<p>为了实现这个，用 <code>StatefulWidget</code> 包裹 <code>Text</code> widget，并在用户点击按钮时更新它。</p>\n<p>举个例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Default placeholder text</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> textToShow = <span class=\"string\">\"I Like Flutter\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> _updateText() &#123;</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// update the text</span></span><br><span class=\"line\">      textToShow = <span class=\"string\">\"Flutter is Awesome!\"</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: Center(child: Text(textToShow)),</span><br><span class=\"line\">      floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">        onPressed: _updateText,</span><br><span class=\"line\">        tooltip: <span class=\"string\">'Update Text'</span>,</span><br><span class=\"line\">        child: Icon(Icons.update),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么对-widget-布局？我的-Storyboard-在哪？\"><a href=\"#我怎么对-widget-布局？我的-Storyboard-在哪？\" class=\"headerlink\" title=\"我怎么对 widget 布局？我的 Storyboard 在哪？\"></a>我怎么对 widget 布局？我的 Storyboard 在哪？</h3><p>在 iOS 中，你可能会用 Storyboard 文件来组织 views，并对它们设置约束，或者，你可能在 view controller 中使用代码来设置约束。在 Flutter 中，你通过编写一个 widget 树来声明你的布局。</p>\n<p>下面这个例子展示了如何展示一个带有 padding 的简单 widget：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">    appBar: AppBar(</span><br><span class=\"line\">      title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    body: Center(</span><br><span class=\"line\">      child: CupertinoButton(</span><br><span class=\"line\">        onPressed: () &#123;</span><br><span class=\"line\">          setState(() &#123; _pressedCount += <span class=\"number\">1</span>; &#125;);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        child: Text(<span class=\"string\">'Hello'</span>),</span><br><span class=\"line\">        padding: EdgeInsets.only(left: <span class=\"number\">10.0</span>, right: <span class=\"number\">10.0</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以给任何的 widget 添加 padding，这很像 iOS 中约束的功能。</p>\n<p>你可以在 <a href=\"https://flutter.io/widgets/layout/\">widget catalog</a> 中查看 Flutter 提供的布局。</p>\n<h3 id=\"我怎么在我的约束中添加或移除组件？\"><a href=\"#我怎么在我的约束中添加或移除组件？\" class=\"headerlink\" title=\"我怎么在我的约束中添加或移除组件？\"></a>我怎么在我的约束中添加或移除组件？</h3><p>在 iOS 中，你在父 view 中调用 <code>addSubview()</code> 或在子 view 中调用 <code>removeFromSuperview()</code> 来动态地添加或移除子 views。在 Flutter 中，由于 widget 不可变，所以没有和 <code>addSubview()</code> 直接等价的东西。作为替代，你可以向 parent 传入一个返回 widget 的函数，并用一个布尔值来控制子 widget 的创建。</p>\n<p>下面这个例子展示了在点击 <code>FloatingActionButton</code> 时如何动态地切换两个 widgets：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Default value for toggle</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> toggle = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> _toggle() &#123;</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      toggle = !toggle;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _getToggleChild() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (toggle) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Text(<span class=\"string\">'Toggle One'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> CupertinoButton(</span><br><span class=\"line\">        onPressed: () &#123;&#125;,</span><br><span class=\"line\">        child: Text(<span class=\"string\">'Toggle Two'</span>),</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">        child: _getToggleChild(),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">        onPressed: _toggle,</span><br><span class=\"line\">        tooltip: <span class=\"string\">'Update Text'</span>,</span><br><span class=\"line\">        child: Icon(Icons.update),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么对-widget-做动画？\"><a href=\"#我怎么对-widget-做动画？\" class=\"headerlink\" title=\"我怎么对 widget 做动画？\"></a>我怎么对 widget 做动画？</h3><p>在 iOS 中，你通过调用 <code>animate(withDuration:animations:)</code> 方法来给一个 view 创建动画。在 Flutter 中，使用动画库来包裹 widgets，而不是创建一个动画 widget。</p>\n<p>在 Flutter 中，使用 <code>AnimationController</code> 。这是一个可以暂停、寻找、停止、反转动画的 <code>Animation&lt;double&gt;</code> 类型。它需要一个 <code>Ticker</code> 当 vsync 发生时来发送信号，并且在每帧运行时创建一个介于 0 和 1 之间的线性插话（interpolation）。你可以创建一个或多个的 <code>Animation</code> 并附加给一个 controller。</p>\n<p>例如，你可能会用 <code>CurvedAnimation</code> 来实现一个 interpolated 曲线。在这个场景中，controller 是动画过程的“主人”，而 <code>CurvedAnimation</code> 计算曲线，并替代 controller 默认的线性模式。</p>\n<p>当构建 widget 树时，你会把 <code>Animation</code> 指定给一个 widget 的动画属性，比如 <code>FadeTransition</code> 的 opacity，并告诉控制器开始动画。</p>\n<p>下面这个例子展示了在点击 <code>FloatingActionButton</code> 之后，如何使用 <code>FadeTransition</code> 来让 widget 淡出到 logo 图标：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Fade Demo'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: MyFadeTest(title: <span class=\"string\">'Fade Demo'</span>),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFadeTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  MyFadeTest(&#123;Key key, <span class=\"keyword\">this</span>.title&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> title;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _MyFadeTest createState() =&gt; _MyFadeTest();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_MyFadeTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">MyFadeTest</span>&gt; <span class=\"title\">with</span> <span class=\"title\">TickerProviderStateMixin</span> </span>&#123;</span><br><span class=\"line\">  AnimationController controller;</span><br><span class=\"line\">  CurvedAnimation curve;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    controller = AnimationController(duration: <span class=\"keyword\">const</span> <span class=\"built_in\">Duration</span>(milliseconds: <span class=\"number\">2000</span>), vsync: <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(widget.title),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">        child: Container(</span><br><span class=\"line\">          child: FadeTransition(</span><br><span class=\"line\">            opacity: curve,</span><br><span class=\"line\">            child: FlutterLogo(</span><br><span class=\"line\">              size: <span class=\"number\">100.0</span>,</span><br><span class=\"line\">            )</span><br><span class=\"line\">          )</span><br><span class=\"line\">        )</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">        tooltip: <span class=\"string\">'Fade'</span>,</span><br><span class=\"line\">        child: Icon(Icons.brush),</span><br><span class=\"line\">        onPressed: () &#123;</span><br><span class=\"line\">          controller.forward();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  dispose() &#123;</span><br><span class=\"line\">    controller.dispose();</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.dispose();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多信息，请参阅 <a href=\"https://flutter.io/widgets/animation/\">Animation &amp; Motion widgets</a>， <a href=\"https://flutter.io/tutorials/animation\">Animations tutorial</a> 以及 <a href=\"https://flutter.io/animations/\">Animations overview</a>。</p>\n<h3 id=\"我该怎么绘图？\"><a href=\"#我该怎么绘图？\" class=\"headerlink\" title=\"我该怎么绘图？\"></a>我该怎么绘图？</h3><p>在 iOS 上，你通过 <code>CoreGraphics</code> 来在屏幕上绘制线条和形状。Flutter 有一套基于 <code>Canvas</code> 类的不同的 API，还有 <code>CustomPaint</code> 和 <code>CustomPainter</code> 这两个类来帮助你绘图。后者实现你在 canvas 上的绘图算法。</p>\n<p>想要学习如何实现一个笔迹画笔，请参考 Collin 在 <a href=\"https://stackoverflow.com/questions/46241071/create-signature-area-for-mobile-app-in-dart-flutter\">StackOverflow</a> 上的回答。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SignaturePainter</span> <span class=\"keyword\">extends</span> <span class=\"title\">CustomPainter</span> </span>&#123;</span><br><span class=\"line\">  SignaturePainter(<span class=\"keyword\">this</span>.points);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;Offset&gt; points;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> paint(Canvas canvas, Size size) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> paint = Paint()</span><br><span class=\"line\">      ..color = Colors.black</span><br><span class=\"line\">      ..strokeCap = StrokeCap.round</span><br><span class=\"line\">      ..strokeWidth = <span class=\"number\">5.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; points.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (points[i] != <span class=\"keyword\">null</span> &amp;&amp; points[i + <span class=\"number\">1</span>] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        canvas.drawLine(points[i], points[i + <span class=\"number\">1</span>], paint);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> shouldRepaint(SignaturePainter other) =&gt; other.points != points;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Signature</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SignatureState createState() =&gt; SignatureState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SignatureState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">Signature</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;Offset&gt; _points = &lt;Offset&gt;[];</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> GestureDetector(</span><br><span class=\"line\">      onPanUpdate: (DragUpdateDetails details) &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          RenderBox referenceBox = context.findRenderObject();</span><br><span class=\"line\">          Offset localPosition =</span><br><span class=\"line\">          referenceBox.globalToLocal(details.globalPosition);</span><br><span class=\"line\">          _points = <span class=\"built_in\">List</span>.from(_points)..add(localPosition);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      onPanEnd: (DragEndDetails details) =&gt; _points.add(<span class=\"keyword\">null</span>),</span><br><span class=\"line\">      child: CustomPaint(painter: SignaturePainter(_points), size: Size.infinite),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Widget-的透明度在哪里？\"><a href=\"#Widget-的透明度在哪里？\" class=\"headerlink\" title=\"Widget 的透明度在哪里？\"></a>Widget 的透明度在哪里？</h3><p>在 iOS 中，什么东西都会有一个 .opacity 或是 .alpha 的属性。在 Flutter 中，你需要给 widget 包裹一个 Opacity widget 来做到这一点。</p>\n<h3 id=\"我怎么创建自定义的-widgets？\"><a href=\"#我怎么创建自定义的-widgets？\" class=\"headerlink\" title=\"我怎么创建自定义的 widgets？\"></a>我怎么创建自定义的 widgets？</h3><p>在 iOS 中，你编写 <code>UIView</code> 的子类，或使用已经存在的 view 来重载并实现方法，以达到特定的功能。在 Flutter 中，你会组合（<a href=\"https://flutter.io/technical-overview/#everythings-a-widget\">composing</a>）多个小的 widgets 来构建一个自定义的 widget（而不是扩展它）。</p>\n<p>举个例子，如果你要构建一个 <code>CustomButton</code> ，并在构造器中传入它的 label？那就组合 <code>RaisedButton</code> 和 label，而不是扩展 <code>RaisedButton</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> label;</span><br><span class=\"line\"></span><br><span class=\"line\">  CustomButton(<span class=\"keyword\">this</span>.label);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RaisedButton(onPressed: () &#123;&#125;, child: Text(label));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后就像你使用其他任何 Flutter 的 widget 一样，使用你的 CustomButton：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Center(</span><br><span class=\"line\">    child: CustomButton(<span class=\"string\">\"Hello\"</span>),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"导航\"><a href=\"#导航\" class=\"headerlink\" title=\"导航\"></a>导航</h2><h3 id=\"我怎么在不同页面之间跳转？\"><a href=\"#我怎么在不同页面之间跳转？\" class=\"headerlink\" title=\"我怎么在不同页面之间跳转？\"></a>我怎么在不同页面之间跳转？</h3><p>在 iOS 中，你可以使用管理了 view controller 栈的 <code>UINavigationController</code> 来在不同的 view controller 之间跳转。</p>\n<p>Flutter 也有类似的实现，使用了 <code>Navigator</code> 和 <code>Routes</code>。一个路由是 App 中“屏幕”或“页面”的抽象，而一个 Navigator 是管理多个路由的 <a href=\"https://flutter.io/flutter-for-ios/technical-overview/#everythings-a-widget\">widget</a> 。你可以粗略地把一个路由对应到一个 <code>UIViewController</code>。Navigator 的工作原理和 iOS 中 <code>UINavigationController</code> 非常相似，当你想跳转到新页面或者从新页面返回时，它可以 <code>push()</code> 和 <code>pop()</code> 路由。</p>\n<p>在页面之间跳转，你有一对选择：</p>\n<ul>\n<li>具体指定一个由路由名构成的 <code>Map</code>。（MaterialApp）</li>\n<li>直接跳转到一个路由。（WidgetApp）</li>\n</ul>\n<p>下面是构建一个 Map 的例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(MaterialApp(</span><br><span class=\"line\">    home: MyAppHome(), <span class=\"comment\">// becomes the route named '/'</span></span><br><span class=\"line\">    routes: &lt;<span class=\"built_in\">String</span>, WidgetBuilder&gt; &#123;</span><br><span class=\"line\">      <span class=\"string\">'/a'</span>: (BuildContext context) =&gt; MyPage(title: <span class=\"string\">'page A'</span>),</span><br><span class=\"line\">      <span class=\"string\">'/b'</span>: (BuildContext context) =&gt; MyPage(title: <span class=\"string\">'page B'</span>),</span><br><span class=\"line\">      <span class=\"string\">'/c'</span>: (BuildContext context) =&gt; MyPage(title: <span class=\"string\">'page C'</span>),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过把路由的名字 <code>push</code> 给一个 <code>Navigator</code> 来跳转：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Navigator.of(context).pushNamed(<span class=\"string\">'/b'</span>);</span><br></pre></td></tr></table></figure>\n<p><code>Navigator</code> 类不仅用来处理 Flutter 中的路由，还被用来获取你刚 push 到栈中的路由返回的结果。通过 <code>await</code> <code>push()</code> 返回的 <code>Future</code> 来达到这点。</p>\n<p>举个例子，要跳转到“位置”路由来让用户选择一个地点，你可能要这么做：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span> coordinates = <span class=\"keyword\">await</span> Navigator.of(context).pushNamed(<span class=\"string\">'/location'</span>);</span><br></pre></td></tr></table></figure>\n<p>之后，在 location 路由中，一旦用户选择了地点，携带结果一起 <code>pop()</code> 出栈：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Navigator.of(context).pop(&#123;<span class=\"string\">\"lat\"</span>:<span class=\"number\">43.821757</span>,<span class=\"string\">\"long\"</span>:<span class=\"number\">-79.226392</span>&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么跳转到其他-App？\"><a href=\"#我怎么跳转到其他-App？\" class=\"headerlink\" title=\"我怎么跳转到其他 App？\"></a>我怎么跳转到其他 App？</h3><p>在 iOS 中，要跳转到其他 App，你需要一个特定的 URL Scheme。对系统级别的 App 来说，这个 scheme 取决于 App。为了在 Flutter 中实现这个功能，你可以创建一个原生平台的整合层，或者使用现有的 <a href=\"https://flutter.io/flutter-for-ios/#plugins\">plugin</a>，例如 <a href=\"https://pub.dartlang.org/packages/url_launcher\">url_launcher</a>。</p>\n<h2 id=\"线程和异步\"><a href=\"#线程和异步\" class=\"headerlink\" title=\"线程和异步\"></a>线程和异步</h2><h3 id=\"我怎么编写异步的代码？\"><a href=\"#我怎么编写异步的代码？\" class=\"headerlink\" title=\"我怎么编写异步的代码？\"></a>我怎么编写异步的代码？</h3><p>Dart 是单线程执行模型，但是它支持 <code>Isolate</code>（一种让 Dart 代码运行在其他线程的方式）、事件循环和异步编程。除非你自己创建一个 <code>Isolate</code> ，否则你的 Dart 代码永远运行在 UI 线程，并由 event loop 驱动。Flutter 的 event loop 和 iOS 中的 main loop 相似——<code>Looper</code> 是附加在主线程上的。</p>\n<p>Dart 的单线程模型并不意味着你写的代码一定是阻塞操作，从而卡住 UI。相反，使用 Dart 语言提供的异步工具，例如 <code>async</code> / <code>await</code> ，来实现异步操作。</p>\n<p>举个例子，你可以使用 <code>async</code> / <code>await</code> 来让 Dart 帮你做一些繁重的工作，编写网络请求代码而不会挂起 UI：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> dataURL = <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>;</span><br><span class=\"line\">  http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">  setState(() &#123;</span><br><span class=\"line\">    widgets = json.decode(response.body);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一旦 <code>await</code> 到网络请求完成，通过调用 <code>setState()</code> 来更新 UI，这会触发 widget 子树的重建，并更新相关数据。</p>\n<p>下面的例子展示了异步加载数据，并用 <code>ListView</code> 展示出来：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:convert'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:http/http.dart'</span> <span class=\"keyword\">as</span> http;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> widgets = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\"></span><br><span class=\"line\">    loadData();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: ListView.builder(</span><br><span class=\"line\">          itemCount: widgets.length,</span><br><span class=\"line\">          itemBuilder: (BuildContext context, <span class=\"built_in\">int</span> position) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getRow(position);</span><br><span class=\"line\">          &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget getRow(<span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Padding(</span><br><span class=\"line\">      padding: EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">      child: Text(<span class=\"string\">\"Row <span class=\"subst\">$&#123;widgets[i][<span class=\"string\">\"title\"</span>]&#125;</span>\"</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> dataURL = <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>;</span><br><span class=\"line\">    http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      widgets = json.decode(response.body);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 更多关于在后台工作的信息，以及 Flutter 和 iOS 的区别，请参考下一章节。</p>\n<h3 id=\"你是怎么把工作放到后台线程的？\"><a href=\"#你是怎么把工作放到后台线程的？\" class=\"headerlink\" title=\"你是怎么把工作放到后台线程的？\"></a>你是怎么把工作放到后台线程的？</h3><p>由于 Flutter 是单线程并且跑着一个 event loop 的（就像 Node.js 那样），你不必为线程管理或是开启后台线程而操心。如果你正在做 I/O 操作，如访问磁盘或网络请求，安全地使用 <code>async</code> / <code>await</code> 就完事了。如果，在另外的情况下，你需要做让 CPU 保持繁忙的计算密集型任务，你需要使用 <code>Isolate</code> 来避免阻塞 event loop。</p>\n<p>对于 I/O 操作，把方法声明为 <code>async</code> 方法，并且 <code>await</code> 方法里需要长期运行的任务：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> dataURL = <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>;</span><br><span class=\"line\">  http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">  setState(() &#123;</span><br><span class=\"line\">    widgets = json.decode(response.body);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是对诸如网络请求或数据库访问等 I/O 操作的典型做法。</p>\n<p>然而，有时候你需要处理大量的数据，这会导致你的 UI 挂起。在 Flutter 中，使用 <code>Isolate</code> 来发挥多核心 CPU 的优势来处理那些长期运行或是计算密集型的任务。</p>\n<p>Isolates 是分离的运行线程，并且不和主线程的内存堆共享内存。这意味着你不能访问主线程中的变量，或者使用 <code>setState()</code> 来更新 UI。正如它们的名字一样，Isolates 不能共享内存。</p>\n<p>下面的例子展示了一个简单的 isolate，是如何把数据返回给主线程来更新 UI 的：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  ReceivePort receivePort = ReceivePort();</span><br><span class=\"line\">  <span class=\"keyword\">await</span> Isolate.spawn(dataLoader, receivePort.sendPort);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The 'echo' isolate sends its SendPort as the first message</span></span><br><span class=\"line\">  SendPort sendPort = <span class=\"keyword\">await</span> receivePort.first;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">List</span> msg = <span class=\"keyword\">await</span> sendReceive(sendPort, <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  setState(() &#123;</span><br><span class=\"line\">    widgets = msg;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The entry point for the isolate</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> dataLoader(SendPort sendPort) <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Open the ReceivePort for incoming messages.</span></span><br><span class=\"line\">  ReceivePort port = ReceivePort();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Notify any other isolates what port this isolate listens to.</span></span><br><span class=\"line\">  sendPort.send(port.sendPort);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> port) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> data = msg[<span class=\"number\">0</span>];</span><br><span class=\"line\">    SendPort replyTo = msg[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">String</span> dataURL = data;</span><br><span class=\"line\">    http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">    <span class=\"comment\">// Lots of JSON to parse</span></span><br><span class=\"line\">    replyTo.send(json.decode(response.body));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Future sendReceive(SendPort port, msg) &#123;</span><br><span class=\"line\">  ReceivePort response = ReceivePort();</span><br><span class=\"line\">  port.send([msg, response.sendPort]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response.first;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里，<code>dataLoader()</code> 是一个运行于自己独立执行线程上的 <code>Isolate</code>。在 isolate 里，你可以执行 CPU 密集型任务（例如解析一个庞大的 json），或是计算密集型的数学操作，如加密或信号处理等。</p>\n<p>你可以运行下面的完整例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:convert'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:http/http.dart'</span> <span class=\"keyword\">as</span> http;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:async'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:isolate'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> widgets = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">    loadData();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  showLoadingDialog() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (widgets.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getBody() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (showLoadingDialog()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getProgressDialog();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getListView();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getProgressDialog() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Center(child: CircularProgressIndicator());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">        appBar: AppBar(</span><br><span class=\"line\">          title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: getBody());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ListView getListView() =&gt; ListView.builder(</span><br><span class=\"line\">      itemCount: widgets.length,</span><br><span class=\"line\">      itemBuilder: (BuildContext context, <span class=\"built_in\">int</span> position) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getRow(position);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget getRow(<span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Padding(padding: EdgeInsets.all(<span class=\"number\">10.0</span>), child: Text(<span class=\"string\">\"Row <span class=\"subst\">$&#123;widgets[i][<span class=\"string\">\"title\"</span>]&#125;</span>\"</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    ReceivePort receivePort = ReceivePort();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> Isolate.spawn(dataLoader, receivePort.sendPort);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// The 'echo' isolate sends its SendPort as the first message</span></span><br><span class=\"line\">    SendPort sendPort = <span class=\"keyword\">await</span> receivePort.first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">List</span> msg = <span class=\"keyword\">await</span> sendReceive(sendPort, <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      widgets = msg;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the entry point for the isolate</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> dataLoader(SendPort sendPort) <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Open the ReceivePort for incoming messages.</span></span><br><span class=\"line\">    ReceivePort port = ReceivePort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Notify any other isolates what port this isolate listens to.</span></span><br><span class=\"line\">    sendPort.send(port.sendPort);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> port) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">String</span> data = msg[<span class=\"number\">0</span>];</span><br><span class=\"line\">      SendPort replyTo = msg[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">String</span> dataURL = data;</span><br><span class=\"line\">      http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">      <span class=\"comment\">// Lots of JSON to parse</span></span><br><span class=\"line\">      replyTo.send(json.decode(response.body));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Future sendReceive(SendPort port, msg) &#123;</span><br><span class=\"line\">    ReceivePort response = ReceivePort();</span><br><span class=\"line\">    port.send([msg, response.sendPort]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.first;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么发起网络请求？\"><a href=\"#我怎么发起网络请求？\" class=\"headerlink\" title=\"我怎么发起网络请求？\"></a>我怎么发起网络请求？</h3><p>在 Flutter 中，使用流行的 <a href=\"https://pub.dartlang.org/packages/http\">http package</a> 做网络请求非常简单。它把你可能需要自己做的网络请求操作抽象了出来，让发起请求变得简单。</p>\n<p>要使用 <code>http</code> 包，在 <code>pubspec.yaml</code> 中把它添加为依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies:</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  http: ^0.11.3+16</span><br></pre></td></tr></table></figure>\n<p>发起网络请求，在 <code>http.get()</code> 这个 <code>async</code> 方法中使用 <code>await</code> ：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:convert'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:http/http.dart'</span> <span class=\"keyword\">as</span> http;</span><br><span class=\"line\">[...]</span><br><span class=\"line\">  loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> dataURL = <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>;</span><br><span class=\"line\">    http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      widgets = json.decode(response.body);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么展示一个长时间运行的任务的进度？\"><a href=\"#我怎么展示一个长时间运行的任务的进度？\" class=\"headerlink\" title=\"我怎么展示一个长时间运行的任务的进度？\"></a>我怎么展示一个长时间运行的任务的进度？</h3><p>在 iOS 中，在后台运行耗时任务时你会使用 <code>UIProgressView</code>。 </p>\n<p>在 Flutter 中，使用一个 <code>ProgressIndicator</code> widget。通过一个布尔 flag 来控制是否展示进度。在任务开始时，告诉 Flutter 更新状态，并在结束后隐去。</p>\n<p>在下面的例子中，build 函数被拆分成三个函数。如果 <code>showLoadingDialog()</code> 是 <code>true</code> （当 <code>widgets.length == 0</code> 时），则渲染 <code>ProgressIndicator</code>。否则，当数据从网络请求中返回时，渲染 <code>ListView</code> 。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:convert'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:http/http.dart'</span> <span class=\"keyword\">as</span> http;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> widgets = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">    loadData();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  showLoadingDialog() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> widgets.length == <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getBody() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (showLoadingDialog()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getProgressDialog();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getListView();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getProgressDialog() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Center(child: CircularProgressIndicator());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">        appBar: AppBar(</span><br><span class=\"line\">          title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: getBody());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ListView getListView() =&gt; ListView.builder(</span><br><span class=\"line\">      itemCount: widgets.length,</span><br><span class=\"line\">      itemBuilder: (BuildContext context, <span class=\"built_in\">int</span> position) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getRow(position);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget getRow(<span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Padding(padding: EdgeInsets.all(<span class=\"number\">10.0</span>), child: Text(<span class=\"string\">\"Row <span class=\"subst\">$&#123;widgets[i][<span class=\"string\">\"title\"</span>]&#125;</span>\"</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> dataURL = <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>;</span><br><span class=\"line\">    http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      widgets = json.decode(response.body);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"工程结构、本地化、依赖和资源\"><a href=\"#工程结构、本地化、依赖和资源\" class=\"headerlink\" title=\"工程结构、本地化、依赖和资源\"></a>工程结构、本地化、依赖和资源</h2><h3 id=\"我怎么在-Flutter-中引入-image-assets？多分辨率怎么办？\"><a href=\"#我怎么在-Flutter-中引入-image-assets？多分辨率怎么办？\" class=\"headerlink\" title=\"我怎么在 Flutter 中引入 image assets？多分辨率怎么办？\"></a>我怎么在 Flutter 中引入 image assets？多分辨率怎么办？</h3><p>iOS 把 images 和 assets 作为不同的东西，而 Flutter 中只有 assets。被放到 iOS 中 <code>Images.xcasset</code> 文件夹下的资源在 Flutter 中被放到了 assets 文件夹中。assets 可以是任意类型的文件，而不仅仅是图片。例如，你可以把 json 文件放置到 <code>my-assets</code> 文件夹中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-assets/data.json</span><br></pre></td></tr></table></figure>\n<p>在 <code>pubspec.yaml</code> 文件中声明 assets：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assets:</span><br><span class=\"line\"> - my-assets/data.json</span><br></pre></td></tr></table></figure>\n<p>然后在代码中使用 <a href=\"https://docs.flutter.io/flutter/services/AssetBundle-class.html\"><code>AssetBundle</code></a> 来访问它：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:async'</span> show Future;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/services.dart'</span> show rootBundle;</span><br><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">String</span>&gt; loadAsset() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> rootBundle.loadString(<span class=\"string\">'my-assets/data.json'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于图片，Flutter 像 iOS 一样，遵循了一个简单的基于像素密度的格式。Image assets 可能是 <code>1.0x</code> <code>2.0x</code> <code>3.0x</code> 或是其他的任何倍数。这些所谓的 <a href=\"https://docs.flutter.io/flutter/dart-ui/Window/devicePixelRatio.html\"><code>devicePixelRatio</code></a> 传达了物理像素到单个逻辑像素的比率。</p>\n<p>Assets 可以被放置到任何属性文件夹中——Flutter 并没有预先定义的文件结构。在 <code>pubspec.yaml</code> 文件中声明 assets （和位置），然后 Flutter 会把他们识别出来。</p>\n<p>举个例子，要把一个叫 <code>my_icon.png</code> 的图片放到 Flutter 工程中，你可能想要把存储它的文件夹叫做 <code>images</code>。把基础图片（1.0x）放置到 <code>images</code> 文件夹中，并把其他变体放置在子文件夹中，并接上合适的比例系数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">images/my_icon.png       // Base: 1.0x image</span><br><span class=\"line\">images/2.0x/my_icon.png  // 2.0x image</span><br><span class=\"line\">images/3.0x/my_icon.png  // 3.0x image</span><br></pre></td></tr></table></figure>\n<p>接着，在 <code>pubspec.yaml</code> 文件夹中声明这些图片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assets:</span><br><span class=\"line\"> - images/my_icon.jpeg</span><br></pre></td></tr></table></figure>\n<p>你可以用 <code>AssetImage</code> 来访问这些图片：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> AssetImage(<span class=\"string\">\"images/a_dot_burr.jpeg\"</span>);</span><br></pre></td></tr></table></figure>\n<p>或者在 <code>Image</code> widget 中直接使用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Image.asset(<span class=\"string\">\"images/my_image.png\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多细节，参见 <a href=\"https://flutter.io/assets-and-images\">Adding Assets and Images in Flutter</a>。</p>\n<h3 id=\"我在哪里放置字符串？我怎么做本地化？\"><a href=\"#我在哪里放置字符串？我怎么做本地化？\" class=\"headerlink\" title=\"我在哪里放置字符串？我怎么做本地化？\"></a>我在哪里放置字符串？我怎么做本地化？</h3><p>不像 iOS 拥有一个 <code>Localizable.strings</code> 文件，Flutter 目前并没有一个用于处理字符串的系统。目前，最佳实践是把你的文本拷贝到静态区，并在这里访问。例如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Strings</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">String</span> welcomeMessage = <span class=\"string\">\"Welcome To Flutter\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且这样访问你的字符串：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Text(Strings.welcomeMessage)</span><br></pre></td></tr></table></figure>\n<p>默认情况下，Flutter 只支持美式英语字符串。如果你要支持其他语言，请引入 <code>flutter_localizations</code> 包。你可能也要引入  <a href=\"https://pub.dartlang.org/packages/intl\"><code>intl</code></a> 包来支持其他的 i10n 机制，比如日期/时间格式化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies:</span><br><span class=\"line\">  # ...</span><br><span class=\"line\">  flutter_localizations:</span><br><span class=\"line\">    sdk: flutter</span><br><span class=\"line\">  intl: &quot;^0.15.6&quot;</span><br></pre></td></tr></table></figure>\n<p>要使用 <code>flutter_localizations</code> 包，在 app widget 中指 <code>localizationsDelegates</code> 和 <code>supportedLocales</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter_localizations/flutter_localizations.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MaterialApp(</span><br><span class=\"line\"> localizationsDelegates: [</span><br><span class=\"line\">   <span class=\"comment\">// Add app-specific localization delegate[s] here</span></span><br><span class=\"line\">   GlobalMaterialLocalizations.delegate,</span><br><span class=\"line\">   GlobalWidgetsLocalizations.delegate,</span><br><span class=\"line\"> ],</span><br><span class=\"line\"> supportedLocales: [</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Locale(<span class=\"string\">'en'</span>, <span class=\"string\">'US'</span>), <span class=\"comment\">// English</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> Locale(<span class=\"string\">'he'</span>, <span class=\"string\">'IL'</span>), <span class=\"comment\">// Hebrew</span></span><br><span class=\"line\">    <span class=\"comment\">// ... other locales the app supports</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这些代理包括了实际的本地化值，并且 <code>supportedLocales</code> 定义了 App 支持哪些地区。上面的例子使用了一个 <code>MaterialApp</code> ，所以它既有 <code>GlobalWidgetsLocalizations</code> 用于基础 widgets，也有 <code>MaterialWidgetsLocalizations</code> 用于 Material wigets 的本地化。如果你使用 <code>WidgetsApp</code> ，则无需包括后者。注意，这两个代理虽然包括了“默认”值，但如果你想让你的 App 本地化，你仍需要提供一或多个代理作为你的 App 本地化副本。</p>\n<p>当初始化时，<code>WidgetsApp</code> 或 <code>MaterialApp</code> 会使用你指定的代理为你创建一个  <a href=\"https://docs.flutter.io/flutter/widgets/Localizations-class.html\"><code>Localizations</code></a> widget。<code>Localizations</code> widget 可以随时从当前上下文中访问设备的地点，或者使用 <a href=\"https://docs.flutter.io/flutter/dart-ui/Window/locale.html\"><code>Window.locale</code></a>。</p>\n<p>要访问本地化文件，使用 <code>Localizations.of()</code> 方法来访问提供代理的特定本地化类。如需翻译，使用  <a href=\"https://pub.dartlang.org/packages/intl_translation\"><code>intl_translation</code></a> 包来取出翻译副本到 <a href=\"https://code.google.com/p/arb/wiki/ApplicationResourceBundleSpecification\">arb</a> 文件中。把它们引入 App 中，并用 <code>intl</code> 来使用它们。</p>\n<p>更多 Flutter 中国际化和本地化的细节，请访问 <a href=\"https://flutter.io/tutorials/internationalization\">internationalization guide</a> ，那里有不使用 <code>intl</code> 包的示例代码。</p>\n<p>注意，在 Flutter 1.0 beta 2 之前，在 Flutter 中定义的 assets 不能在原生一侧被访问。原生定义的资源在 Flutter 中也不可用，因为它们在独立的文件夹中。</p>\n<h3 id=\"Cocoapods-相当于什么？我该如何添加依赖？\"><a href=\"#Cocoapods-相当于什么？我该如何添加依赖？\" class=\"headerlink\" title=\"Cocoapods 相当于什么？我该如何添加依赖？\"></a>Cocoapods 相当于什么？我该如何添加依赖？</h3><p>在 iOS 中，你把依赖添加到 <code>Podfile</code> 中。Flutter 使用 Dart 构建系统和 Pub 包管理器来处理依赖。这些工具将本机 Android 和 iOS 包装应用程序的构建委派给相应的构建系统。</p>\n<p>如果你的 Flutter 工程中的 iOS 文件夹中拥有 Podfile，请仅在你为每个平台集成时使用它。总体来说，使用 <code>pubspec.yaml</code> 来在 Flutter 中声明外部依赖。一个可以找到优秀 Flutter 包的地方是 <a href=\"https://pub.dartlang.org/flutter/packages/\">Pub</a>。</p>\n<h2 id=\"ViewControllers\"><a href=\"#ViewControllers\" class=\"headerlink\" title=\"ViewControllers\"></a>ViewControllers</h2><h3 id=\"ViewController-相当于-Flutter-中的什么？\"><a href=\"#ViewController-相当于-Flutter-中的什么？\" class=\"headerlink\" title=\"ViewController 相当于 Flutter 中的什么？\"></a>ViewController 相当于 Flutter 中的什么？</h3><p>在 iOS 中，一个 ViewController 代表了用户界面的一部分，最常用于一个屏幕，或是其中一部分。它们被组合在一起用于构建复杂的用户界面，并帮助你拆分 App 的 UI。在 Flutter 中，这一任务回落到了 widgets 中。就像在界面导航部分提到的一样，一个屏幕也是被 widgets 来表示的，因为“万物皆 widget！”。使用 <code>Navigator</code> 在 <code>Route</code> 之间跳转，或者渲染相同数据的不同状态。</p>\n<h3 id=\"我该怎么监听-iOS-中的生命周期事件？\"><a href=\"#我该怎么监听-iOS-中的生命周期事件？\" class=\"headerlink\" title=\"我该怎么监听 iOS 中的生命周期事件？\"></a>我该怎么监听 iOS 中的生命周期事件？</h3><p>在 iOS 中，你可以重写 <code>ViewController</code> 中的方法来补货它的视图的生命周期，或者在 <code>AppDelegate</code> 中注册生命周期的回调函数。在 Flutter 中没有这两个概念，但你可以通过 hook <code>WidgetsBinding</code> 观察者来监听生命周期事件，并监听 <code>didChangeAppLifecycleState()</code> 的变化事件。</p>\n<p>可观察的生命周期事件有：</p>\n<ul>\n<li><code>inactive</code> - 应用处于不活跃的状态，并且不会接受用户的输入。这个事件仅工作在 iOS 平台，在 Android 上没有等价的事件。</li>\n<li><code>paused</code> - 应用暂时对用户不可见，虽然不接受用户输入，但是是在后台运行的。</li>\n<li><code>resumed</code> - 应用可见，也响应用户的输入。</li>\n<li><code>suspending</code> - 应用暂时被挂起，在 iOS 上没有这一事件。</li>\n</ul>\n<p>更多关于这些状态的细节和含义，请参见  <a href=\"https://docs.flutter.io/flutter/dart-ui/AppLifecycleState-class.html\"><code>AppLifecycleStatus</code> documentation</a> 。</p>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><h3 id=\"UITableView-和-UICollectionView-相当于-Flutter-中的什么？\"><a href=\"#UITableView-和-UICollectionView-相当于-Flutter-中的什么？\" class=\"headerlink\" title=\"UITableView 和 UICollectionView 相当于 Flutter 中的什么？\"></a>UITableView 和 UICollectionView 相当于 Flutter 中的什么？</h3><p>在 iOS 中，你可能用 UITableView 或 UICollectionView 来展示一个列表。在 Flutter 中，你可以用 <code>ListView</code> 来达到相似的实现。在 iOS 中，你通过代理方法来确定行数，每一个 index path 的单元格，以及单元格的尺寸。</p>\n<p>由于 Flutter 中 widget 的不可变特性，你需要向 <code>ListView</code> 传递一个 widget 列表，Flutter 会确保滚动是快速且流畅的。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: ListView(children: _getListData()),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _getListData() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">List</span>&lt;Widget&gt; widgets = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">      widgets.add(Padding(padding: EdgeInsets.all(<span class=\"number\">10.0</span>), child: Text(<span class=\"string\">\"Row <span class=\"subst\">$i</span>\"</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> widgets;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么知道列表的哪个元素被点击了？\"><a href=\"#我怎么知道列表的哪个元素被点击了？\" class=\"headerlink\" title=\"我怎么知道列表的哪个元素被点击了？\"></a>我怎么知道列表的哪个元素被点击了？</h3><p>iOS 中，你通过 <code>tableView:didSelectRowAtIndexPath:</code> 代理方法来实现。在 Flutter 中，使用传递进来的 widget 的 touch handle：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: ListView(children: _getListData()),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _getListData() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">List</span>&lt;Widget&gt; widgets = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">      widgets.add(GestureDetector(</span><br><span class=\"line\">        child: Padding(</span><br><span class=\"line\">          padding: EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">          child: Text(<span class=\"string\">\"Row <span class=\"subst\">$i</span>\"</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        onTap: () &#123;</span><br><span class=\"line\">          <span class=\"built_in\">print</span>(<span class=\"string\">'row tapped'</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> widgets;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么动态地更新-ListView？\"><a href=\"#我怎么动态地更新-ListView？\" class=\"headerlink\" title=\"我怎么动态地更新 ListView？\"></a>我怎么动态地更新 ListView？</h3><p>在 iOS 中，你改变列表的数据，并通过 <code>reloadData()</code> 方法来通知 table 或是 collection view。</p>\n<p>在 Flutter 中，如果你想通过 <code>setState()</code> 方法来更新 widget 列表，你会很快发现你的数据展示并没有变化。这是因为当 <code>setState()</code> 被调用时，Flutter 渲染引擎会去检查 widget 树来查看是否有什么地方被改变了。当它得到你的 <code>ListView</code> 时，它会使用一个 <code>==</code> 判断，并且发现两个 <code>ListView</code> 是相同的。没有什么东西是变了的，因此更新不是必须的。</p>\n<p>一个更新 <code>ListView</code> 的简单方法是，在 <code>setState()</code> 中创建一个新的 list，并把旧 list 的数据拷贝给新的 list。虽然这样很简单，但当数据集很大时，并不推荐这样做：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> widgets = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">      widgets.add(getRow(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: ListView(children: widgets),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget getRow(<span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> GestureDetector(</span><br><span class=\"line\">      child: Padding(</span><br><span class=\"line\">        padding: EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"Row <span class=\"subst\">$i</span>\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      onTap: () &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          widgets = <span class=\"built_in\">List</span>.from(widgets);</span><br><span class=\"line\">          widgets.add(getRow(widgets.length + <span class=\"number\">1</span>));</span><br><span class=\"line\">          <span class=\"built_in\">print</span>(<span class=\"string\">'row <span class=\"subst\">$i</span>'</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个推荐的、高效的且有效的做法是，使用 <code>ListView.Builder</code> 来构建列表。这个方法在你想要构建动态列表，或是列表拥有大量数据时会非常好用。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> widgets = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">      widgets.add(getRow(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: ListView.builder(</span><br><span class=\"line\">        itemCount: widgets.length,</span><br><span class=\"line\">        itemBuilder: (BuildContext context, <span class=\"built_in\">int</span> position) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> getRow(position);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget getRow(<span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> GestureDetector(</span><br><span class=\"line\">      child: Padding(</span><br><span class=\"line\">        padding: EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"Row <span class=\"subst\">$i</span>\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      onTap: () &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          widgets.add(getRow(widgets.length + <span class=\"number\">1</span>));</span><br><span class=\"line\">          <span class=\"built_in\">print</span>(<span class=\"string\">'row <span class=\"subst\">$i</span>'</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与创建一个 “ListView” 不同，创建一个 <code>ListView.builder</code> 接受两个主要参数：列表的初始长度，和一个 <code>ItemBuilder</code> 方法。</p>\n<p><code>ItemBuilder</code> 方法和 <code>cellForItemAt</code> 代理方法非常类似，它接受一个位置，并且返回在这个位置上你希望渲染的 cell。</p>\n<p>最后，也是最重要的，注意 <code>onTap()</code> 函数里并没有重新创建一个 list，而是 <code>.add</code> 了一个 widget。</p>\n<h3 id=\"ScrollView-相当于-Flutter-里的什么？\"><a href=\"#ScrollView-相当于-Flutter-里的什么？\" class=\"headerlink\" title=\"ScrollView 相当于 Flutter 里的什么？\"></a>ScrollView 相当于 Flutter 里的什么？</h3><p>在 iOS 中，你给 view 包裹上 <code>ScrollView</code> 来允许用户在需要时滚动你的内容。</p>\n<p>在 Flutter 中，最简单的方法是使用 <code>ListView</code> widget。它表现得既和 iOS 中的 <code>ScrollView</code> 一致，也能和 <code>TableView</code> 一致，因为你可以给它的 widget 做垂直排布：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ListView(</span><br><span class=\"line\">    children: &lt;Widget&gt;[</span><br><span class=\"line\">      Text(<span class=\"string\">'Row One'</span>),</span><br><span class=\"line\">      Text(<span class=\"string\">'Row Two'</span>),</span><br><span class=\"line\">      Text(<span class=\"string\">'Row Three'</span>),</span><br><span class=\"line\">      Text(<span class=\"string\">'Row Four'</span>),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多关于在 Flutter 总如何排布 widget 的文档，请参阅 <a href=\"https://flutter.io/widgets/layout/\">layout tutorial</a>。</p>\n<h2 id=\"手势检测及触摸事件处理\"><a href=\"#手势检测及触摸事件处理\" class=\"headerlink\" title=\"手势检测及触摸事件处理\"></a>手势检测及触摸事件处理</h2><h3 id=\"我怎么给-Flutter-的-widget-添加一个点击监听者？\"><a href=\"#我怎么给-Flutter-的-widget-添加一个点击监听者？\" class=\"headerlink\" title=\"我怎么给 Flutter 的 widget 添加一个点击监听者？\"></a>我怎么给 Flutter 的 widget 添加一个点击监听者？</h3><p>在 iOS 中，你给一个 view 添加 <code>GestureRecognizer</code> 来处理点击事件。在 Flutter 中，有两种方法来添加点击监听者：</p>\n<ol>\n<li><p>如果 widget 本身支持事件监测，直接传递给它一个函数，并在这个函数里实现响应方法。例如，<code>RaisedButton</code> widget 拥有一个 <code>RaisedButton</code> 参数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> RaisedButton(</span><br><span class=\"line\">    onPressed: () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">\"click\"</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"Button\"</span>),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果 widget 本身不支持事件监测，则在外面包裹一个 GestureDetector，并给它的 onTap 属性传递一个函数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">        child: GestureDetector(</span><br><span class=\"line\">          child: FlutterLogo(</span><br><span class=\"line\">            size: <span class=\"number\">200.0</span>,</span><br><span class=\"line\">          ),</span><br><span class=\"line\">          onTap: () &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"tap\"</span>);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"我怎么处理-widget-上的其他手势？\"><a href=\"#我怎么处理-widget-上的其他手势？\" class=\"headerlink\" title=\"我怎么处理 widget 上的其他手势？\"></a>我怎么处理 widget 上的其他手势？</h3><p>使用 <code>GestureDetector</code> 你可以监听更广阔范围内的手势，比如：</p>\n<ul>\n<li>Tapping<ul>\n<li><code>onTapDown</code> — 在特定位置轻触手势接触了屏幕。</li>\n<li><code>onTapUp</code> — 在特定位置产生了一个轻触手势，并停止接触屏幕。</li>\n<li><code>onTap</code> — 产生了一个轻触手势。</li>\n<li><code>onTapCancel</code> — 触发了 <code>onTapDown</code> 但没能触发 tap。</li>\n</ul>\n</li>\n<li>Double tapping<ul>\n<li><code>onDoubleTap</code> — 用户在同一个位置快速点击了两下屏幕。</li>\n</ul>\n</li>\n<li>Long pressing<ul>\n<li><code>onLongPress</code> — 用户在同一个位置长时间接触屏幕。</li>\n</ul>\n</li>\n<li>Vertical dragging<ul>\n<li><code>onVerticalDragStart</code> — 接触了屏幕，并且可能会垂直移动。</li>\n<li><code>onVerticalDragUpdate</code> — 接触了屏幕，并继续在垂直方向移动。</li>\n<li><code>onVerticalDragEnd</code> — 之前接触了屏幕并垂直移动，并在停止接触屏幕前以某个垂直的速度移动。</li>\n</ul>\n</li>\n<li>Horizontal dragging<ul>\n<li><code>onHorizontalDragStart</code> </li>\n<li><code>onHorizontalDragUpdate</code></li>\n<li><code>onHorizontalDragEnd</code></li>\n</ul>\n</li>\n</ul>\n<p>下面这个例子展示了一个 <code>GestureDetector</code> 是如何在双击时旋转 Flutter 的 logo 的：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnimationController controller;</span><br><span class=\"line\">CurvedAnimation curve;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">  controller = AnimationController(duration: <span class=\"keyword\">const</span> <span class=\"built_in\">Duration</span>(milliseconds: <span class=\"number\">2000</span>), vsync: <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">        child: GestureDetector(</span><br><span class=\"line\">          child: RotationTransition(</span><br><span class=\"line\">            turns: curve,</span><br><span class=\"line\">            child: FlutterLogo(</span><br><span class=\"line\">              size: <span class=\"number\">200.0</span>,</span><br><span class=\"line\">            )),</span><br><span class=\"line\">          onDoubleTap: () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (controller.isCompleted) &#123;</span><br><span class=\"line\">              controller.reverse();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              controller.forward();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"主题和文字\"><a href=\"#主题和文字\" class=\"headerlink\" title=\"主题和文字\"></a>主题和文字</h2><h3 id=\"我怎么给-App-设置主题？\"><a href=\"#我怎么给-App-设置主题？\" class=\"headerlink\" title=\"我怎么给 App 设置主题？\"></a>我怎么给 App 设置主题？</h3><p>Flutter 实现了一套漂亮的 MD 组件，并且开箱可用。它接管了一大堆你需要的样式和主题。</p>\n<p>为了充分发挥你的 App 中 MD 组件的优势，声明一个顶级 widget，MaterialApp，用作你的 App 入口。MaterialApp 是一个便利组件，包含了许多 App 通常需要的 MD 风格组件。它通过一个 WidgetsApp 添加了 MD 功能来实现。</p>\n<p>但是 Flutter 足够地灵活和富有表现力来实现任何其他的设计语言。在 iOS 上，你可以用 <a href=\"https://docs.flutter.io/flutter/cupertino/cupertino-library.html\">Cupertino library</a> 来制作遵守  <a href=\"https://developer.apple.com/ios/human-interface-guidelines/overview/themes/\">Human Interface Guidelines</a> 的界面。查看这些 widget 的集合，请参阅 <a href=\"https://flutter.io/widgets/cupertino/\">Cupertino widgets gallery</a>。</p>\n<p>你也可以在你的 App 中使用 WidgetApp，它提供了许多相似的功能，但不如 <code>MaterialApp</code> 那样强大。</p>\n<p>对任何子组件定义颜色和样式，可以给 <code>MaterialApp</code> widget 传递一个 <code>ThemeData</code> 对象。举个例子，在下面的代码中，primary swatch 被设置为蓝色，并且文字的选中颜色是红色：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">        textSelectionColor: Colors.red</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么给-Text-widget-设置自定义字体？\"><a href=\"#我怎么给-Text-widget-设置自定义字体？\" class=\"headerlink\" title=\"我怎么给 Text widget 设置自定义字体？\"></a>我怎么给 Text widget 设置自定义字体？</h3><p>在 iOS 中，你在项目中引入任意的 <code>ttf</code> 文件，并在 <code>info.plist</code> 中设置引用。在 Flutter 中，在文件夹中放置字体文件，并在 <code>pubspec.yaml</code> 中引用它，就像添加图片那样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fonts:</span><br><span class=\"line\">   - family: MyCustomFont</span><br><span class=\"line\">     fonts:</span><br><span class=\"line\">       - asset: fonts/MyCustomFont.ttf</span><br><span class=\"line\">       - style: italic</span><br></pre></td></tr></table></figure>\n<p>然后在你的 <code>Text</code> widget 中指定字体：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">    appBar: AppBar(</span><br><span class=\"line\">      title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    body: Center(</span><br><span class=\"line\">      child: Text(</span><br><span class=\"line\">        <span class=\"string\">'This is a custom font text'</span>,</span><br><span class=\"line\">        style: TextStyle(fontFamily: <span class=\"string\">'MyCustomFont'</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么给我的-Text-widget-设置样式？\"><a href=\"#我怎么给我的-Text-widget-设置样式？\" class=\"headerlink\" title=\"我怎么给我的 Text widget 设置样式？\"></a>我怎么给我的 Text widget 设置样式？</h3><p>除了字体以外，你也可以给 Text widget 的样式元素设置自定义值。<code>Text</code> widget 接受一个  <code>TextStyle</code> 对象，你可以指定许多参数，比如：</p>\n<ul>\n<li><code>color</code></li>\n<li><code>decoration</code></li>\n<li><code>decorationColor</code></li>\n<li><code>decorationStyle</code></li>\n<li><code>fontFamily</code></li>\n<li><code>fontSize</code></li>\n<li><code>fontStyle</code></li>\n<li><code>fontWeight</code></li>\n<li><code>hashCode</code></li>\n<li><code>height</code></li>\n<li><code>inherit</code></li>\n<li><code>letterSpacing</code></li>\n<li><code>textBaseline</code></li>\n<li><code>wordSpacing</code></li>\n</ul>\n<h2 id=\"表单输入\"><a href=\"#表单输入\" class=\"headerlink\" title=\"表单输入\"></a>表单输入</h2><h3 id=\"Flutter-中表单怎么工作？我怎么拿到用户的输入？\"><a href=\"#Flutter-中表单怎么工作？我怎么拿到用户的输入？\" class=\"headerlink\" title=\"Flutter 中表单怎么工作？我怎么拿到用户的输入？\"></a>Flutter 中表单怎么工作？我怎么拿到用户的输入？</h3><p>我们已经提到 Flutter 使用不可变的 widget，并且状态是分离的，你可能会好奇在这种情境下怎么处理用户的输入。在 iOS 中，你经常在需要提交数据时查询组件当前的状态或动作，但这在 Flutter 中是怎么工作的呢？</p>\n<p>在表单处理的实践中，就像在 Flutter 中任何其他的地方一样，要通过特定的 widgets。如果你有一个 <code>TextField</code> 或是 <code>TextFormField</code>，你可以通过 <a href=\"https://docs.flutter.io/flutter/widgets/TextEditingController-class.html\"><code>TextEditingController</code></a> 来获得用户输入：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_MyFormState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">MyForm</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create a text controller and use it to retrieve the current value.</span></span><br><span class=\"line\">  <span class=\"comment\">// of the TextField!</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> myController = TextEditingController();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> dispose() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Clean up the controller when disposing of the Widget.</span></span><br><span class=\"line\">    myController.dispose();</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.dispose();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">'Retrieve Text Input'</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: Padding(</span><br><span class=\"line\">        padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">16.0</span>),</span><br><span class=\"line\">        child: TextField(</span><br><span class=\"line\">          controller: myController,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">        <span class=\"comment\">// When the user presses the button, show an alert dialog with the</span></span><br><span class=\"line\">        <span class=\"comment\">// text the user has typed into our text field.</span></span><br><span class=\"line\">        onPressed: () &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> showDialog(</span><br><span class=\"line\">            context: context,</span><br><span class=\"line\">            builder: (context) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> AlertDialog(</span><br><span class=\"line\">                <span class=\"comment\">// Retrieve the text the user has typed in using our</span></span><br><span class=\"line\">                <span class=\"comment\">// TextEditingController</span></span><br><span class=\"line\">                content: Text(myController.text),</span><br><span class=\"line\">              );</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        tooltip: <span class=\"string\">'Show me the value!'</span>,</span><br><span class=\"line\">        child: Icon(Icons.text_fields),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以在这里获得更多信息，或是完整的代码列表： <a href=\"https://flutter.io/cookbook/forms/retrieve-input/\">Retrieve the value of a text field</a>，来自 <a href=\"https://flutter.io/cookbook/\">Flutter Cookbook</a> 。</p>\n<h3 id=\"Text-field-中的-placeholder-相当于什么？\"><a href=\"#Text-field-中的-placeholder-相当于什么？\" class=\"headerlink\" title=\"Text field 中的 placeholder 相当于什么？\"></a>Text field 中的 placeholder 相当于什么？</h3><p>在 Flutter 中，你可以轻易地通过向 Text widget 的装饰构造器参数重传递 <code>InputDecoration</code> 来展示“小提示”，或是占位符文字：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body: Center(</span><br><span class=\"line\">  child: TextField(</span><br><span class=\"line\">    decoration: InputDecoration(hintText: <span class=\"string\">\"This is a hint\"</span>),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么展示验证错误信息？\"><a href=\"#我怎么展示验证错误信息？\" class=\"headerlink\" title=\"我怎么展示验证错误信息？\"></a>我怎么展示验证错误信息？</h3><p>就像展示“小提示”一样，向 Text widget 的装饰器构造器参数中传递一个 <code>InputDecoration</code>。</p>\n<p>然而，你并不想在一开始就显示错误信息。相反，当用户输入了验证信息，更新状态，并传入一个新的 <code>InputDecoration</code> 对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> _errorText;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">        child: TextField(</span><br><span class=\"line\">          onSubmitted: (<span class=\"built_in\">String</span> text) &#123;</span><br><span class=\"line\">            setState(() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!isEmail(text)) &#123;</span><br><span class=\"line\">                _errorText = <span class=\"string\">'Error: This is not an email'</span>;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                _errorText = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          decoration: InputDecoration(hintText: <span class=\"string\">\"This is a hint\"</span>, errorText: _getErrorText()),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _getErrorText() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _errorText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> isEmail(<span class=\"built_in\">String</span> em) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> emailRegexp =</span><br><span class=\"line\">        <span class=\"string\">r'^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]&#123;2,&#125;))$'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">RegExp</span> regExp = <span class=\"built_in\">RegExp</span>(p);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> regExp.hasMatch(em);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"和硬件、第三方服务以及平台交互\"><a href=\"#和硬件、第三方服务以及平台交互\" class=\"headerlink\" title=\"和硬件、第三方服务以及平台交互\"></a>和硬件、第三方服务以及平台交互</h2><h3 id=\"我怎么和平台，以及平台的原生代码交互？\"><a href=\"#我怎么和平台，以及平台的原生代码交互？\" class=\"headerlink\" title=\"我怎么和平台，以及平台的原生代码交互？\"></a>我怎么和平台，以及平台的原生代码交互？</h3><p>Flutter 的代码并不直接在平台之下运行，相反，Dart 代码构建的 Flutter 应用在设备上以原生的方式运行，却“侧步躲开了”平台提供的 SDK。这意味着，例如，你在 Dart 中发起一个网络请求，它就直接在 Dart 的上下文中运行。你并不会用上平常在 iOS 或 Android 上使用的原生 API。你的 Flutter 程序仍然被原生平台的 <code>ViewController</code> 管理作一个 view，但是你并不会直接访问 <code>ViewController</code> 自身，或是原生框架。</p>\n<p>但这并不意味着 Flutter 不能和原生 API，或任何你编写的原生代码交互。Flutter 提供了 <a href=\"https://flutter.io/platform-channels/\">platform channels</a> ，来和管理你的 Flutter view 的 ViewController 通信和交互数据。平台管道本质上是一个异步通信机制，桥接了 Dart 代码和宿主 ViewController，以及它运行于的 iOS 框架。你可以用平台管道来执行一个原生的函数，或者是从设备的传感器中获取数据。</p>\n<p>除了直接使用平台管道之外，你还可以使用一系列预先制作好的 <a href=\"https://flutter.io/using-packages/\">plugins</a>。例如，你可以直接使用插件来访问相机胶卷或是设备的摄像头，而不必编写你自己的集成层代码。你可以在 <a href=\"https://pub.dartlang.org/\">Pub</a> 上找到插件，这是一个 Dart 和 Flutter 的开源包仓库。其中一些包可能会支持集成 iOS 或 Android，或两者均可。</p>\n<p>如果你在 Pub 上找不到符合你需求的插件，你可以<a href=\"https://flutter.io/developing-packages/\">自己编写</a> ，并且<a href=\"https://flutter.io/developing-packages/#publish\">发布在 Pub 上</a>。</p>\n<h3 id=\"我怎么访问-GPS-传感器？\"><a href=\"#我怎么访问-GPS-传感器？\" class=\"headerlink\" title=\"我怎么访问 GPS 传感器？\"></a>我怎么访问 GPS 传感器？</h3><p>使用 <a href=\"https://pub.dartlang.org/packages/location\"><code>location</code></a> 社区插件。</p>\n<h3 id=\"我怎么访问摄像头？\"><a href=\"#我怎么访问摄像头？\" class=\"headerlink\" title=\"我怎么访问摄像头？\"></a>我怎么访问摄像头？</h3><p><a href=\"https://pub.dartlang.org/packages/image_picker\"><code>image_picker</code></a> 在访问摄像头时非常常用。</p>\n<h3 id=\"我怎么登录-Facebook？\"><a href=\"#我怎么登录-Facebook？\" class=\"headerlink\" title=\"我怎么登录 Facebook？\"></a>我怎么登录 Facebook？</h3><p>登录 Facebook 可以使用 <a href=\"https://pub.dartlang.org/packages/flutter_facebook_login\"><code>flutter_facebook_login</code></a> 社区插件。</p>\n<h3 id=\"我怎么使用-Firebase-特性？\"><a href=\"#我怎么使用-Firebase-特性？\" class=\"headerlink\" title=\"我怎么使用 Firebase 特性？\"></a>我怎么使用 Firebase 特性？</h3><p>大多数 Firebase 特性被  <a href=\"https://pub.dartlang.org/flutter/packages?q=firebase\">first party plugins</a> 包含了。这些第一方插件由 Flutter 团队维护：</p>\n<ul>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_admob\"><code>firebase_admob</code></a> for Firebase AdMob</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_analytics\"><code>firebase_analytics</code></a> for Firebase Analytics</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_auth\"><code>firebase_auth</code></a> for Firebase Auth</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_core\"><code>firebase_core</code></a> for Firebase’s Core package</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_database\"><code>firebase_database</code></a> for Firebase RTDB</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_storage\"><code>firebase_storage</code></a> for Firebase Cloud Storage</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_messaging\"><code>firebase_messaging</code></a> for Firebase Messaging (FCM)</li>\n<li><a href=\"https://pub.dartlang.org/packages/cloud_firestore\"><code>cloud_firestore</code></a> for Firebase Cloud Firestore</li>\n</ul>\n<p>你也可以在 Pub 上找到 Firebase 的第三方插件。</p>\n<h3 id=\"我怎创建自己的原生集成层？\"><a href=\"#我怎创建自己的原生集成层？\" class=\"headerlink\" title=\"我怎创建自己的原生集成层？\"></a>我怎创建自己的原生集成层？</h3><p>如果有一些 Flutter 和社区插件遗漏的平台相关的特性，可以根据  <a href=\"https://flutter.io/developing-packages/\">developing packages and plugins</a> 页面构建自己的插件。</p>\n<p>Flutter 的插件结构，简要来说，就像 Android 中的 Event bus。你发送一个消息，并让接受者处理并反馈结果给你。在这种情况下，接受者就是在 Android 或 iOS 上的原生代码。</p>\n<h2 id=\"数据库和本地存储\"><a href=\"#数据库和本地存储\" class=\"headerlink\" title=\"数据库和本地存储\"></a>数据库和本地存储</h2><h3 id=\"我怎么在-Flutter-中访问-UserDefaults？\"><a href=\"#我怎么在-Flutter-中访问-UserDefaults？\" class=\"headerlink\" title=\"我怎么在 Flutter 中访问 UserDefaults？\"></a>我怎么在 Flutter 中访问 UserDefaults？</h3><p>在 iOS 中，你可以使用属性列表来存储键值对的集合，即我们熟悉的 UserDefaults。</p>\n<p>在 Flutter 中，可以使用  <a href=\"https://pub.dartlang.org/packages/shared_preferences\">Shared Preferences plugin</a> 来达到相似的功能。它包裹了 <code>UserDefaluts</code> 以及 Android 上等价的 <code>SharedPreferences</code> 的功能。</p>\n<h3 id=\"CoreData-相当于-Flutter-中的什么？\"><a href=\"#CoreData-相当于-Flutter-中的什么？\" class=\"headerlink\" title=\"CoreData 相当于 Flutter 中的什么？\"></a>CoreData 相当于 Flutter 中的什么？</h3><p>在 iOS 中，你通过 CoreData 来存储结构化的数据。这是一个 SQL 数据库的上层封装，让查询和关联模型变得更加简单。</p>\n<p>在 Flutter 中，使用 <a href=\"https://pub.dartlang.org/packages/sqflite\">SQFlite</a> 插件来实现这个功能。</p>\n<h2 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h2><h3 id=\"我怎么推送通知？\"><a href=\"#我怎么推送通知？\" class=\"headerlink\" title=\"我怎么推送通知？\"></a>我怎么推送通知？</h3><p>在 iOS 中，你需要向 developer portal 中注册来允许推送通知。</p>\n<p>在 Flutter 中，使用 <code>firebase_messaging</code> 插件来实现这一功能。</p>\n<p>更多使用 Firebase Cloud Messaging API 的信息，请参阅 <a href=\"https://pub.dartlang.org/packages/firebase_messaging\"><code>firebase_messaging</code></a> 插件文档。</p>\n<hr>\n<p>此文档由 Luyuan Wang 原创翻译。2018 - 07 - 11</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Flutter-for-iOS-Developers-翻译\"><a href=\"#Flutter-for-iOS-Developers-翻译\" class=\"headerlink\" title=\"Flutter for iOS Developers 翻译\"></a>Flutter for iOS Developers 翻译</h1><p>官方文档原文链接：<a href=\"https://flutter.io/flutter-for-ios/\">https://flutter.io/flutter-for-ios/</a></p>\n<p>此翻译文档已被 <a href=\"https://flutterchina.club/flutter-for-ios/\">Flutter 中文网</a> 收录。</p>\n<hr>\n<p>本文档适用那些希望将现有 iOS 经验应用于 Flutter 的开发者。如果你拥有 iOS 开发基础，那么你可以使用这篇文档开始学习 Flutter 的开发。</p>\n<p>开发 Flutter 时，你的 iOS 经验和技能将会大有裨益，因为 Flutter 依赖于移动操作系统的众多功能和配置。Flutter 是用于为移动设备构建用户界面的全新方式，但它也有一个插件系统用于和 iOS（及 Android）进行非 UI 任务的通信。如果你是 iOS 开发专家，则你不必将 Flutter 彻底重新学习一遍。</p>\n<p>你可以将此文档作为 cookbook，通过跳转并查找与你的需求最相关的问题。</p>\n<h2 id=\"Views\"><a href=\"#Views\" class=\"headerlink\" title=\"Views\"></a>Views</h2><h3 id=\"UIView-相当于-Flutter-中的什么？\"><a href=\"#UIView-相当于-Flutter-中的什么？\" class=\"headerlink\" title=\"UIView 相当于 Flutter 中的什么？\"></a>UIView 相当于 Flutter 中的什么？</h3><p>在 iOS 中，构建 UI 的过程中将大量使用 view 对象。这些对象都是 <code>UIView</code> 的实例。它们可以用作容器来承载其他的 UIView，最终构成你的界面布局。</p>\n<p>在 Flutter 中，你可以粗略地认为 <code>Widget</code> 相当于 <code>UIView</code> 。Widget 和 iOS 中的控件并不完全等价，但当你试图去理解 Flutter 是如何工作的时候，你可以认为它们是“声明和构建 UI 的方法”。</p>\n<p>然而，Widget 和 UIView 还是有些区别的。首先，widgets 拥有不同的生存时间：它们一直存在且保持不变，直到当它们需要被改变。当 widgets 和它们的状态被改变时，Flutter 会构建一颗新的 widgets 树。作为对比，iOS 中的 views 在改变时并不会被重新创建。但是与其说 views 是可变的实例，不如说它们被绘制了一次，并且直到使用 <code>setNeedsDisplay()</code> 之后才会被重新绘制。</p>\n<p>此外，不像 UIView，由于不可变性，Flutter 的 widgets 非常轻量。这是因为它们本身并不是什么控件，也不会被直接绘制出什么，而只是 UI 的描述。</p>\n<p>Flutter 包含了 <a href=\"https://material.io/develop/flutter/\">Material 组件</a>库。这些 widgets 遵循了 <a href=\"https://material.io/design/\">Material 设计规范</a>。MD 是一个灵活的设计系统，并且为包括 iOS 在内的<a href=\"https://material.io/design/platform-guidance/cross-platform-adaptation.html#cross-platform-guidelines\">所有系统进行了优化</a>。</p>\n<p>但是用 Flutter 实现任何的设计语言都非常的灵活和富有表现力。在 iOS 平台，你可以使用 <a href=\"https://flutter.io/widgets/cupertino/\">Cupertino widgets</a> 来构建遵循了 <a href=\"https://developer.apple.com/design/resources/\">Apple’s iOS design language</a> 的界面。</p>\n<h3 id=\"我怎么来更新-Widgets？\"><a href=\"#我怎么来更新-Widgets？\" class=\"headerlink\" title=\"我怎么来更新 Widgets？\"></a>我怎么来更新 Widgets？</h3><p>在 iOS 上更新 views，只需要直接改变它们就可以了。在 Flutter 中，widgets 是不可变的，而且不能被直接更新。你需要去操纵 widget 的 state。</p>\n<p>这也正是有状态的和无状态的 widget 这一概念的来源。一个 <code>StatelessWidget</code> 正如它听起来一样，是一个没有附加状态的 widget。</p>\n<p><code>StatelessWidget</code> 在你构建初始化后不再进行改变的界面时非常有用。</p>\n<p>举个例子，你可能会用一个 <code>UIImageView</code> 来展示你的 logo <code>image</code> 。如果这个 logo 在运行时不会改变，那么你就可以在 Flutter 中使用 <code>StatelessWidget</code> 。</p>\n<p>如果你希望在发起 HTTP 请求时，依托接收到的数据动态的改变 UI，请使用 <code>StatefulWidget</code>。当 HTTP 请求结束后，通知 Flutter 框架 widget 的 <code>State</code> 更新了，好让系统来更新 UI。</p>\n<p>有状态和无状态的 widget 之间一个非常重要的区别是，<code>StatefulWidget</code> 拥有一个 <code>State</code> 对象来存储它的状态数据，并在 widget 树重建时携带着它，因此状态不会丢失。</p>\n<p>如果你有疑惑，请记住以下规则：如果一个 widget 在它的 <code>build</code> 方法之外改变（例如，在运行时由于用户的操作而改变），它就是有状态的。如果一个 widget 在一次 build 之后永远不变，那它就是无状态的。但是，即便一个 widget 是有状态的，包含它的父亲 widget 也可以是无状态的，只要父 widget 本身不响应这些变化。</p>\n<p>下面的例子展示了如何使用一个 <code>StatelessWidget</code> 。一个常见的 <code>StatelessWidget</code> 是 <code>Text</code> widget。如果你查看 Text 的实现，你会发现它是 StatelessWidget 的子类。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Text(</span><br><span class=\"line\">  <span class=\"string\">'I like Flutter!'</span>,</span><br><span class=\"line\">  style: TextStyle(fontWeight: FontWeight.bold),</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>阅读上面的代码，你可能会注意到 <code>Text</code> widget 并不显示地携带任何状态。它通过传入给它的构造器的数据来渲染，除此之外再无其他。</p>\n<p>但是，如果你希望 <code>I like Flutter</code>在点击 <code>FloatingActionButton</code> 时动态的改变呢？</p>\n<p>为了实现这个，用 <code>StatefulWidget</code> 包裹 <code>Text</code> widget，并在用户点击按钮时更新它。</p>\n<p>举个例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Default placeholder text</span></span><br><span class=\"line\">  <span class=\"built_in\">String</span> textToShow = <span class=\"string\">\"I Like Flutter\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> _updateText() &#123;</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      <span class=\"comment\">// update the text</span></span><br><span class=\"line\">      textToShow = <span class=\"string\">\"Flutter is Awesome!\"</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: Center(child: Text(textToShow)),</span><br><span class=\"line\">      floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">        onPressed: _updateText,</span><br><span class=\"line\">        tooltip: <span class=\"string\">'Update Text'</span>,</span><br><span class=\"line\">        child: Icon(Icons.update),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么对-widget-布局？我的-Storyboard-在哪？\"><a href=\"#我怎么对-widget-布局？我的-Storyboard-在哪？\" class=\"headerlink\" title=\"我怎么对 widget 布局？我的 Storyboard 在哪？\"></a>我怎么对 widget 布局？我的 Storyboard 在哪？</h3><p>在 iOS 中，你可能会用 Storyboard 文件来组织 views，并对它们设置约束，或者，你可能在 view controller 中使用代码来设置约束。在 Flutter 中，你通过编写一个 widget 树来声明你的布局。</p>\n<p>下面这个例子展示了如何展示一个带有 padding 的简单 widget：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">    appBar: AppBar(</span><br><span class=\"line\">      title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    body: Center(</span><br><span class=\"line\">      child: CupertinoButton(</span><br><span class=\"line\">        onPressed: () &#123;</span><br><span class=\"line\">          setState(() &#123; _pressedCount += <span class=\"number\">1</span>; &#125;);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        child: Text(<span class=\"string\">'Hello'</span>),</span><br><span class=\"line\">        padding: EdgeInsets.only(left: <span class=\"number\">10.0</span>, right: <span class=\"number\">10.0</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以给任何的 widget 添加 padding，这很像 iOS 中约束的功能。</p>\n<p>你可以在 <a href=\"https://flutter.io/widgets/layout/\">widget catalog</a> 中查看 Flutter 提供的布局。</p>\n<h3 id=\"我怎么在我的约束中添加或移除组件？\"><a href=\"#我怎么在我的约束中添加或移除组件？\" class=\"headerlink\" title=\"我怎么在我的约束中添加或移除组件？\"></a>我怎么在我的约束中添加或移除组件？</h3><p>在 iOS 中，你在父 view 中调用 <code>addSubview()</code> 或在子 view 中调用 <code>removeFromSuperview()</code> 来动态地添加或移除子 views。在 Flutter 中，由于 widget 不可变，所以没有和 <code>addSubview()</code> 直接等价的东西。作为替代，你可以向 parent 传入一个返回 widget 的函数，并用一个布尔值来控制子 widget 的创建。</p>\n<p>下面这个例子展示了在点击 <code>FloatingActionButton</code> 时如何动态地切换两个 widgets：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Default value for toggle</span></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> toggle = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> _toggle() &#123;</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      toggle = !toggle;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _getToggleChild() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (toggle) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Text(<span class=\"string\">'Toggle One'</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> CupertinoButton(</span><br><span class=\"line\">        onPressed: () &#123;&#125;,</span><br><span class=\"line\">        child: Text(<span class=\"string\">'Toggle Two'</span>),</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">        child: _getToggleChild(),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">        onPressed: _toggle,</span><br><span class=\"line\">        tooltip: <span class=\"string\">'Update Text'</span>,</span><br><span class=\"line\">        child: Icon(Icons.update),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么对-widget-做动画？\"><a href=\"#我怎么对-widget-做动画？\" class=\"headerlink\" title=\"我怎么对 widget 做动画？\"></a>我怎么对 widget 做动画？</h3><p>在 iOS 中，你通过调用 <code>animate(withDuration:animations:)</code> 方法来给一个 view 创建动画。在 Flutter 中，使用动画库来包裹 widgets，而不是创建一个动画 widget。</p>\n<p>在 Flutter 中，使用 <code>AnimationController</code> 。这是一个可以暂停、寻找、停止、反转动画的 <code>Animation&lt;double&gt;</code> 类型。它需要一个 <code>Ticker</code> 当 vsync 发生时来发送信号，并且在每帧运行时创建一个介于 0 和 1 之间的线性插话（interpolation）。你可以创建一个或多个的 <code>Animation</code> 并附加给一个 controller。</p>\n<p>例如，你可能会用 <code>CurvedAnimation</code> 来实现一个 interpolated 曲线。在这个场景中，controller 是动画过程的“主人”，而 <code>CurvedAnimation</code> 计算曲线，并替代 controller 默认的线性模式。</p>\n<p>当构建 widget 树时，你会把 <code>Animation</code> 指定给一个 widget 的动画属性，比如 <code>FadeTransition</code> 的 opacity，并告诉控制器开始动画。</p>\n<p>下面这个例子展示了在点击 <code>FloatingActionButton</code> 之后，如何使用 <code>FadeTransition</code> 来让 widget 淡出到 logo 图标：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Fade Demo'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: MyFadeTest(title: <span class=\"string\">'Fade Demo'</span>),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFadeTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  MyFadeTest(&#123;Key key, <span class=\"keyword\">this</span>.title&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> title;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _MyFadeTest createState() =&gt; _MyFadeTest();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_MyFadeTest</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">MyFadeTest</span>&gt; <span class=\"title\">with</span> <span class=\"title\">TickerProviderStateMixin</span> </span>&#123;</span><br><span class=\"line\">  AnimationController controller;</span><br><span class=\"line\">  CurvedAnimation curve;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    controller = AnimationController(duration: <span class=\"keyword\">const</span> <span class=\"built_in\">Duration</span>(milliseconds: <span class=\"number\">2000</span>), vsync: <span class=\"keyword\">this</span>);</span><br><span class=\"line\">    curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(widget.title),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">        child: Container(</span><br><span class=\"line\">          child: FadeTransition(</span><br><span class=\"line\">            opacity: curve,</span><br><span class=\"line\">            child: FlutterLogo(</span><br><span class=\"line\">              size: <span class=\"number\">100.0</span>,</span><br><span class=\"line\">            )</span><br><span class=\"line\">          )</span><br><span class=\"line\">        )</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">        tooltip: <span class=\"string\">'Fade'</span>,</span><br><span class=\"line\">        child: Icon(Icons.brush),</span><br><span class=\"line\">        onPressed: () &#123;</span><br><span class=\"line\">          controller.forward();</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  dispose() &#123;</span><br><span class=\"line\">    controller.dispose();</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.dispose();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多信息，请参阅 <a href=\"https://flutter.io/widgets/animation/\">Animation &amp; Motion widgets</a>， <a href=\"https://flutter.io/tutorials/animation\">Animations tutorial</a> 以及 <a href=\"https://flutter.io/animations/\">Animations overview</a>。</p>\n<h3 id=\"我该怎么绘图？\"><a href=\"#我该怎么绘图？\" class=\"headerlink\" title=\"我该怎么绘图？\"></a>我该怎么绘图？</h3><p>在 iOS 上，你通过 <code>CoreGraphics</code> 来在屏幕上绘制线条和形状。Flutter 有一套基于 <code>Canvas</code> 类的不同的 API，还有 <code>CustomPaint</code> 和 <code>CustomPainter</code> 这两个类来帮助你绘图。后者实现你在 canvas 上的绘图算法。</p>\n<p>想要学习如何实现一个笔迹画笔，请参考 Collin 在 <a href=\"https://stackoverflow.com/questions/46241071/create-signature-area-for-mobile-app-in-dart-flutter\">StackOverflow</a> 上的回答。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SignaturePainter</span> <span class=\"keyword\">extends</span> <span class=\"title\">CustomPainter</span> </span>&#123;</span><br><span class=\"line\">  SignaturePainter(<span class=\"keyword\">this</span>.points);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">List</span>&lt;Offset&gt; points;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">void</span> paint(Canvas canvas, Size size) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> paint = Paint()</span><br><span class=\"line\">      ..color = Colors.black</span><br><span class=\"line\">      ..strokeCap = StrokeCap.round</span><br><span class=\"line\">      ..strokeWidth = <span class=\"number\">5.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; points.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (points[i] != <span class=\"keyword\">null</span> &amp;&amp; points[i + <span class=\"number\">1</span>] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        canvas.drawLine(points[i], points[i + <span class=\"number\">1</span>], paint);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> shouldRepaint(SignaturePainter other) =&gt; other.points != points;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Signature</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SignatureState createState() =&gt; SignatureState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SignatureState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">Signature</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">List</span>&lt;Offset&gt; _points = &lt;Offset&gt;[];</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> GestureDetector(</span><br><span class=\"line\">      onPanUpdate: (DragUpdateDetails details) &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          RenderBox referenceBox = context.findRenderObject();</span><br><span class=\"line\">          Offset localPosition =</span><br><span class=\"line\">          referenceBox.globalToLocal(details.globalPosition);</span><br><span class=\"line\">          _points = <span class=\"built_in\">List</span>.from(_points)..add(localPosition);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      onPanEnd: (DragEndDetails details) =&gt; _points.add(<span class=\"keyword\">null</span>),</span><br><span class=\"line\">      child: CustomPaint(painter: SignaturePainter(_points), size: Size.infinite),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Widget-的透明度在哪里？\"><a href=\"#Widget-的透明度在哪里？\" class=\"headerlink\" title=\"Widget 的透明度在哪里？\"></a>Widget 的透明度在哪里？</h3><p>在 iOS 中，什么东西都会有一个 .opacity 或是 .alpha 的属性。在 Flutter 中，你需要给 widget 包裹一个 Opacity widget 来做到这一点。</p>\n<h3 id=\"我怎么创建自定义的-widgets？\"><a href=\"#我怎么创建自定义的-widgets？\" class=\"headerlink\" title=\"我怎么创建自定义的 widgets？\"></a>我怎么创建自定义的 widgets？</h3><p>在 iOS 中，你编写 <code>UIView</code> 的子类，或使用已经存在的 view 来重载并实现方法，以达到特定的功能。在 Flutter 中，你会组合（<a href=\"https://flutter.io/technical-overview/#everythings-a-widget\">composing</a>）多个小的 widgets 来构建一个自定义的 widget（而不是扩展它）。</p>\n<p>举个例子，如果你要构建一个 <code>CustomButton</code> ，并在构造器中传入它的 label？那就组合 <code>RaisedButton</code> 和 label，而不是扩展 <code>RaisedButton</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomButton</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">final</span> <span class=\"built_in\">String</span> label;</span><br><span class=\"line\"></span><br><span class=\"line\">  CustomButton(<span class=\"keyword\">this</span>.label);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> RaisedButton(onPressed: () &#123;&#125;, child: Text(label));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后就像你使用其他任何 Flutter 的 widget 一样，使用你的 CustomButton：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Center(</span><br><span class=\"line\">    child: CustomButton(<span class=\"string\">\"Hello\"</span>),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"导航\"><a href=\"#导航\" class=\"headerlink\" title=\"导航\"></a>导航</h2><h3 id=\"我怎么在不同页面之间跳转？\"><a href=\"#我怎么在不同页面之间跳转？\" class=\"headerlink\" title=\"我怎么在不同页面之间跳转？\"></a>我怎么在不同页面之间跳转？</h3><p>在 iOS 中，你可以使用管理了 view controller 栈的 <code>UINavigationController</code> 来在不同的 view controller 之间跳转。</p>\n<p>Flutter 也有类似的实现，使用了 <code>Navigator</code> 和 <code>Routes</code>。一个路由是 App 中“屏幕”或“页面”的抽象，而一个 Navigator 是管理多个路由的 <a href=\"https://flutter.io/flutter-for-ios/technical-overview/#everythings-a-widget\">widget</a> 。你可以粗略地把一个路由对应到一个 <code>UIViewController</code>。Navigator 的工作原理和 iOS 中 <code>UINavigationController</code> 非常相似，当你想跳转到新页面或者从新页面返回时，它可以 <code>push()</code> 和 <code>pop()</code> 路由。</p>\n<p>在页面之间跳转，你有一对选择：</p>\n<ul>\n<li>具体指定一个由路由名构成的 <code>Map</code>。（MaterialApp）</li>\n<li>直接跳转到一个路由。（WidgetApp）</li>\n</ul>\n<p>下面是构建一个 Map 的例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(MaterialApp(</span><br><span class=\"line\">    home: MyAppHome(), <span class=\"comment\">// becomes the route named '/'</span></span><br><span class=\"line\">    routes: &lt;<span class=\"built_in\">String</span>, WidgetBuilder&gt; &#123;</span><br><span class=\"line\">      <span class=\"string\">'/a'</span>: (BuildContext context) =&gt; MyPage(title: <span class=\"string\">'page A'</span>),</span><br><span class=\"line\">      <span class=\"string\">'/b'</span>: (BuildContext context) =&gt; MyPage(title: <span class=\"string\">'page B'</span>),</span><br><span class=\"line\">      <span class=\"string\">'/c'</span>: (BuildContext context) =&gt; MyPage(title: <span class=\"string\">'page C'</span>),</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过把路由的名字 <code>push</code> 给一个 <code>Navigator</code> 来跳转：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Navigator.of(context).pushNamed(<span class=\"string\">'/b'</span>);</span><br></pre></td></tr></table></figure>\n<p><code>Navigator</code> 类不仅用来处理 Flutter 中的路由，还被用来获取你刚 push 到栈中的路由返回的结果。通过 <code>await</code> <code>push()</code> 返回的 <code>Future</code> 来达到这点。</p>\n<p>举个例子，要跳转到“位置”路由来让用户选择一个地点，你可能要这么做：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span> coordinates = <span class=\"keyword\">await</span> Navigator.of(context).pushNamed(<span class=\"string\">'/location'</span>);</span><br></pre></td></tr></table></figure>\n<p>之后，在 location 路由中，一旦用户选择了地点，携带结果一起 <code>pop()</code> 出栈：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Navigator.of(context).pop(&#123;<span class=\"string\">\"lat\"</span>:<span class=\"number\">43.821757</span>,<span class=\"string\">\"long\"</span>:<span class=\"number\">-79.226392</span>&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么跳转到其他-App？\"><a href=\"#我怎么跳转到其他-App？\" class=\"headerlink\" title=\"我怎么跳转到其他 App？\"></a>我怎么跳转到其他 App？</h3><p>在 iOS 中，要跳转到其他 App，你需要一个特定的 URL Scheme。对系统级别的 App 来说，这个 scheme 取决于 App。为了在 Flutter 中实现这个功能，你可以创建一个原生平台的整合层，或者使用现有的 <a href=\"https://flutter.io/flutter-for-ios/#plugins\">plugin</a>，例如 <a href=\"https://pub.dartlang.org/packages/url_launcher\">url_launcher</a>。</p>\n<h2 id=\"线程和异步\"><a href=\"#线程和异步\" class=\"headerlink\" title=\"线程和异步\"></a>线程和异步</h2><h3 id=\"我怎么编写异步的代码？\"><a href=\"#我怎么编写异步的代码？\" class=\"headerlink\" title=\"我怎么编写异步的代码？\"></a>我怎么编写异步的代码？</h3><p>Dart 是单线程执行模型，但是它支持 <code>Isolate</code>（一种让 Dart 代码运行在其他线程的方式）、事件循环和异步编程。除非你自己创建一个 <code>Isolate</code> ，否则你的 Dart 代码永远运行在 UI 线程，并由 event loop 驱动。Flutter 的 event loop 和 iOS 中的 main loop 相似——<code>Looper</code> 是附加在主线程上的。</p>\n<p>Dart 的单线程模型并不意味着你写的代码一定是阻塞操作，从而卡住 UI。相反，使用 Dart 语言提供的异步工具，例如 <code>async</code> / <code>await</code> ，来实现异步操作。</p>\n<p>举个例子，你可以使用 <code>async</code> / <code>await</code> 来让 Dart 帮你做一些繁重的工作，编写网络请求代码而不会挂起 UI：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> dataURL = <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>;</span><br><span class=\"line\">  http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">  setState(() &#123;</span><br><span class=\"line\">    widgets = json.decode(response.body);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一旦 <code>await</code> 到网络请求完成，通过调用 <code>setState()</code> 来更新 UI，这会触发 widget 子树的重建，并更新相关数据。</p>\n<p>下面的例子展示了异步加载数据，并用 <code>ListView</code> 展示出来：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:convert'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:http/http.dart'</span> <span class=\"keyword\">as</span> http;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> widgets = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\"></span><br><span class=\"line\">    loadData();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: ListView.builder(</span><br><span class=\"line\">          itemCount: widgets.length,</span><br><span class=\"line\">          itemBuilder: (BuildContext context, <span class=\"built_in\">int</span> position) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> getRow(position);</span><br><span class=\"line\">          &#125;));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget getRow(<span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Padding(</span><br><span class=\"line\">      padding: EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">      child: Text(<span class=\"string\">\"Row <span class=\"subst\">$&#123;widgets[i][<span class=\"string\">\"title\"</span>]&#125;</span>\"</span>)</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> dataURL = <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>;</span><br><span class=\"line\">    http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      widgets = json.decode(response.body);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 更多关于在后台工作的信息，以及 Flutter 和 iOS 的区别，请参考下一章节。</p>\n<h3 id=\"你是怎么把工作放到后台线程的？\"><a href=\"#你是怎么把工作放到后台线程的？\" class=\"headerlink\" title=\"你是怎么把工作放到后台线程的？\"></a>你是怎么把工作放到后台线程的？</h3><p>由于 Flutter 是单线程并且跑着一个 event loop 的（就像 Node.js 那样），你不必为线程管理或是开启后台线程而操心。如果你正在做 I/O 操作，如访问磁盘或网络请求，安全地使用 <code>async</code> / <code>await</code> 就完事了。如果，在另外的情况下，你需要做让 CPU 保持繁忙的计算密集型任务，你需要使用 <code>Isolate</code> 来避免阻塞 event loop。</p>\n<p>对于 I/O 操作，把方法声明为 <code>async</code> 方法，并且 <code>await</code> 方法里需要长期运行的任务：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> dataURL = <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>;</span><br><span class=\"line\">  http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">  setState(() &#123;</span><br><span class=\"line\">    widgets = json.decode(response.body);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是对诸如网络请求或数据库访问等 I/O 操作的典型做法。</p>\n<p>然而，有时候你需要处理大量的数据，这会导致你的 UI 挂起。在 Flutter 中，使用 <code>Isolate</code> 来发挥多核心 CPU 的优势来处理那些长期运行或是计算密集型的任务。</p>\n<p>Isolates 是分离的运行线程，并且不和主线程的内存堆共享内存。这意味着你不能访问主线程中的变量，或者使用 <code>setState()</code> 来更新 UI。正如它们的名字一样，Isolates 不能共享内存。</p>\n<p>下面的例子展示了一个简单的 isolate，是如何把数据返回给主线程来更新 UI 的：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  ReceivePort receivePort = ReceivePort();</span><br><span class=\"line\">  <span class=\"keyword\">await</span> Isolate.spawn(dataLoader, receivePort.sendPort);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// The 'echo' isolate sends its SendPort as the first message</span></span><br><span class=\"line\">  SendPort sendPort = <span class=\"keyword\">await</span> receivePort.first;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">List</span> msg = <span class=\"keyword\">await</span> sendReceive(sendPort, <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  setState(() &#123;</span><br><span class=\"line\">    widgets = msg;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// The entry point for the isolate</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> dataLoader(SendPort sendPort) <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// Open the ReceivePort for incoming messages.</span></span><br><span class=\"line\">  ReceivePort port = ReceivePort();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Notify any other isolates what port this isolate listens to.</span></span><br><span class=\"line\">  sendPort.send(port.sendPort);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> port) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> data = msg[<span class=\"number\">0</span>];</span><br><span class=\"line\">    SendPort replyTo = msg[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">String</span> dataURL = data;</span><br><span class=\"line\">    http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">    <span class=\"comment\">// Lots of JSON to parse</span></span><br><span class=\"line\">    replyTo.send(json.decode(response.body));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Future sendReceive(SendPort port, msg) &#123;</span><br><span class=\"line\">  ReceivePort response = ReceivePort();</span><br><span class=\"line\">  port.send([msg, response.sendPort]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response.first;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里，<code>dataLoader()</code> 是一个运行于自己独立执行线程上的 <code>Isolate</code>。在 isolate 里，你可以执行 CPU 密集型任务（例如解析一个庞大的 json），或是计算密集型的数学操作，如加密或信号处理等。</p>\n<p>你可以运行下面的完整例子：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:convert'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:http/http.dart'</span> <span class=\"keyword\">as</span> http;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:async'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:isolate'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> widgets = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">    loadData();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  showLoadingDialog() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (widgets.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getBody() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (showLoadingDialog()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getProgressDialog();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getListView();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getProgressDialog() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Center(child: CircularProgressIndicator());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">        appBar: AppBar(</span><br><span class=\"line\">          title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: getBody());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ListView getListView() =&gt; ListView.builder(</span><br><span class=\"line\">      itemCount: widgets.length,</span><br><span class=\"line\">      itemBuilder: (BuildContext context, <span class=\"built_in\">int</span> position) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getRow(position);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget getRow(<span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Padding(padding: EdgeInsets.all(<span class=\"number\">10.0</span>), child: Text(<span class=\"string\">\"Row <span class=\"subst\">$&#123;widgets[i][<span class=\"string\">\"title\"</span>]&#125;</span>\"</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    ReceivePort receivePort = ReceivePort();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> Isolate.spawn(dataLoader, receivePort.sendPort);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// The 'echo' isolate sends its SendPort as the first message</span></span><br><span class=\"line\">    SendPort sendPort = <span class=\"keyword\">await</span> receivePort.first;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">List</span> msg = <span class=\"keyword\">await</span> sendReceive(sendPort, <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      widgets = msg;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// the entry point for the isolate</span></span><br><span class=\"line\">  <span class=\"keyword\">static</span> dataLoader(SendPort sendPort) <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Open the ReceivePort for incoming messages.</span></span><br><span class=\"line\">    ReceivePort port = ReceivePort();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Notify any other isolates what port this isolate listens to.</span></span><br><span class=\"line\">    sendPort.send(port.sendPort);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> msg <span class=\"keyword\">in</span> port) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">String</span> data = msg[<span class=\"number\">0</span>];</span><br><span class=\"line\">      SendPort replyTo = msg[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"built_in\">String</span> dataURL = data;</span><br><span class=\"line\">      http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">      <span class=\"comment\">// Lots of JSON to parse</span></span><br><span class=\"line\">      replyTo.send(json.decode(response.body));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Future sendReceive(SendPort port, msg) &#123;</span><br><span class=\"line\">    ReceivePort response = ReceivePort();</span><br><span class=\"line\">    port.send([msg, response.sendPort]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.first;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么发起网络请求？\"><a href=\"#我怎么发起网络请求？\" class=\"headerlink\" title=\"我怎么发起网络请求？\"></a>我怎么发起网络请求？</h3><p>在 Flutter 中，使用流行的 <a href=\"https://pub.dartlang.org/packages/http\">http package</a> 做网络请求非常简单。它把你可能需要自己做的网络请求操作抽象了出来，让发起请求变得简单。</p>\n<p>要使用 <code>http</code> 包，在 <code>pubspec.yaml</code> 中把它添加为依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies:</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  http: ^0.11.3+16</span><br></pre></td></tr></table></figure>\n<p>发起网络请求，在 <code>http.get()</code> 这个 <code>async</code> 方法中使用 <code>await</code> ：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:convert'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:http/http.dart'</span> <span class=\"keyword\">as</span> http;</span><br><span class=\"line\">[...]</span><br><span class=\"line\">  loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> dataURL = <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>;</span><br><span class=\"line\">    http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      widgets = json.decode(response.body);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么展示一个长时间运行的任务的进度？\"><a href=\"#我怎么展示一个长时间运行的任务的进度？\" class=\"headerlink\" title=\"我怎么展示一个长时间运行的任务的进度？\"></a>我怎么展示一个长时间运行的任务的进度？</h3><p>在 iOS 中，在后台运行耗时任务时你会使用 <code>UIProgressView</code>。 </p>\n<p>在 Flutter 中，使用一个 <code>ProgressIndicator</code> widget。通过一个布尔 flag 来控制是否展示进度。在任务开始时，告诉 Flutter 更新状态，并在结束后隐去。</p>\n<p>在下面的例子中，build 函数被拆分成三个函数。如果 <code>showLoadingDialog()</code> 是 <code>true</code> （当 <code>widgets.length == 0</code> 时），则渲染 <code>ProgressIndicator</code>。否则，当数据从网络请求中返回时，渲染 <code>ListView</code> 。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:convert'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:http/http.dart'</span> <span class=\"keyword\">as</span> http;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> widgets = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">    loadData();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  showLoadingDialog() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> widgets.length == <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getBody() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (showLoadingDialog()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getProgressDialog();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> getListView();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getProgressDialog() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Center(child: CircularProgressIndicator());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">        appBar: AppBar(</span><br><span class=\"line\">          title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        body: getBody());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ListView getListView() =&gt; ListView.builder(</span><br><span class=\"line\">      itemCount: widgets.length,</span><br><span class=\"line\">      itemBuilder: (BuildContext context, <span class=\"built_in\">int</span> position) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getRow(position);</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget getRow(<span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Padding(padding: EdgeInsets.all(<span class=\"number\">10.0</span>), child: Text(<span class=\"string\">\"Row <span class=\"subst\">$&#123;widgets[i][<span class=\"string\">\"title\"</span>]&#125;</span>\"</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  loadData() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> dataURL = <span class=\"string\">\"https://jsonplaceholder.typicode.com/posts\"</span>;</span><br><span class=\"line\">    http.Response response = <span class=\"keyword\">await</span> http.<span class=\"keyword\">get</span>(dataURL);</span><br><span class=\"line\">    setState(() &#123;</span><br><span class=\"line\">      widgets = json.decode(response.body);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"工程结构、本地化、依赖和资源\"><a href=\"#工程结构、本地化、依赖和资源\" class=\"headerlink\" title=\"工程结构、本地化、依赖和资源\"></a>工程结构、本地化、依赖和资源</h2><h3 id=\"我怎么在-Flutter-中引入-image-assets？多分辨率怎么办？\"><a href=\"#我怎么在-Flutter-中引入-image-assets？多分辨率怎么办？\" class=\"headerlink\" title=\"我怎么在 Flutter 中引入 image assets？多分辨率怎么办？\"></a>我怎么在 Flutter 中引入 image assets？多分辨率怎么办？</h3><p>iOS 把 images 和 assets 作为不同的东西，而 Flutter 中只有 assets。被放到 iOS 中 <code>Images.xcasset</code> 文件夹下的资源在 Flutter 中被放到了 assets 文件夹中。assets 可以是任意类型的文件，而不仅仅是图片。例如，你可以把 json 文件放置到 <code>my-assets</code> 文件夹中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my-assets/data.json</span><br></pre></td></tr></table></figure>\n<p>在 <code>pubspec.yaml</code> 文件中声明 assets：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assets:</span><br><span class=\"line\"> - my-assets/data.json</span><br></pre></td></tr></table></figure>\n<p>然后在代码中使用 <a href=\"https://docs.flutter.io/flutter/services/AssetBundle-class.html\"><code>AssetBundle</code></a> 来访问它：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'dart:async'</span> show Future;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/services.dart'</span> show rootBundle;</span><br><span class=\"line\"></span><br><span class=\"line\">Future&lt;<span class=\"built_in\">String</span>&gt; loadAsset() <span class=\"keyword\">async</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> rootBundle.loadString(<span class=\"string\">'my-assets/data.json'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于图片，Flutter 像 iOS 一样，遵循了一个简单的基于像素密度的格式。Image assets 可能是 <code>1.0x</code> <code>2.0x</code> <code>3.0x</code> 或是其他的任何倍数。这些所谓的 <a href=\"https://docs.flutter.io/flutter/dart-ui/Window/devicePixelRatio.html\"><code>devicePixelRatio</code></a> 传达了物理像素到单个逻辑像素的比率。</p>\n<p>Assets 可以被放置到任何属性文件夹中——Flutter 并没有预先定义的文件结构。在 <code>pubspec.yaml</code> 文件中声明 assets （和位置），然后 Flutter 会把他们识别出来。</p>\n<p>举个例子，要把一个叫 <code>my_icon.png</code> 的图片放到 Flutter 工程中，你可能想要把存储它的文件夹叫做 <code>images</code>。把基础图片（1.0x）放置到 <code>images</code> 文件夹中，并把其他变体放置在子文件夹中，并接上合适的比例系数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">images/my_icon.png       // Base: 1.0x image</span><br><span class=\"line\">images/2.0x/my_icon.png  // 2.0x image</span><br><span class=\"line\">images/3.0x/my_icon.png  // 3.0x image</span><br></pre></td></tr></table></figure>\n<p>接着，在 <code>pubspec.yaml</code> 文件夹中声明这些图片：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assets:</span><br><span class=\"line\"> - images/my_icon.jpeg</span><br></pre></td></tr></table></figure>\n<p>你可以用 <code>AssetImage</code> 来访问这些图片：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> AssetImage(<span class=\"string\">\"images/a_dot_burr.jpeg\"</span>);</span><br></pre></td></tr></table></figure>\n<p>或者在 <code>Image</code> widget 中直接使用：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Image.asset(<span class=\"string\">\"images/my_image.png\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多细节，参见 <a href=\"https://flutter.io/assets-and-images\">Adding Assets and Images in Flutter</a>。</p>\n<h3 id=\"我在哪里放置字符串？我怎么做本地化？\"><a href=\"#我在哪里放置字符串？我怎么做本地化？\" class=\"headerlink\" title=\"我在哪里放置字符串？我怎么做本地化？\"></a>我在哪里放置字符串？我怎么做本地化？</h3><p>不像 iOS 拥有一个 <code>Localizable.strings</code> 文件，Flutter 目前并没有一个用于处理字符串的系统。目前，最佳实践是把你的文本拷贝到静态区，并在这里访问。例如：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Strings</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> <span class=\"built_in\">String</span> welcomeMessage = <span class=\"string\">\"Welcome To Flutter\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并且这样访问你的字符串：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Text(Strings.welcomeMessage)</span><br></pre></td></tr></table></figure>\n<p>默认情况下，Flutter 只支持美式英语字符串。如果你要支持其他语言，请引入 <code>flutter_localizations</code> 包。你可能也要引入  <a href=\"https://pub.dartlang.org/packages/intl\"><code>intl</code></a> 包来支持其他的 i10n 机制，比如日期/时间格式化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dependencies:</span><br><span class=\"line\">  # ...</span><br><span class=\"line\">  flutter_localizations:</span><br><span class=\"line\">    sdk: flutter</span><br><span class=\"line\">  intl: &quot;^0.15.6&quot;</span><br></pre></td></tr></table></figure>\n<p>要使用 <code>flutter_localizations</code> 包，在 app widget 中指 <code>localizationsDelegates</code> 和 <code>supportedLocales</code>。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter_localizations/flutter_localizations.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MaterialApp(</span><br><span class=\"line\"> localizationsDelegates: [</span><br><span class=\"line\">   <span class=\"comment\">// Add app-specific localization delegate[s] here</span></span><br><span class=\"line\">   GlobalMaterialLocalizations.delegate,</span><br><span class=\"line\">   GlobalWidgetsLocalizations.delegate,</span><br><span class=\"line\"> ],</span><br><span class=\"line\"> supportedLocales: [</span><br><span class=\"line\">    <span class=\"keyword\">const</span> Locale(<span class=\"string\">'en'</span>, <span class=\"string\">'US'</span>), <span class=\"comment\">// English</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> Locale(<span class=\"string\">'he'</span>, <span class=\"string\">'IL'</span>), <span class=\"comment\">// Hebrew</span></span><br><span class=\"line\">    <span class=\"comment\">// ... other locales the app supports</span></span><br><span class=\"line\">  ],</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>这些代理包括了实际的本地化值，并且 <code>supportedLocales</code> 定义了 App 支持哪些地区。上面的例子使用了一个 <code>MaterialApp</code> ，所以它既有 <code>GlobalWidgetsLocalizations</code> 用于基础 widgets，也有 <code>MaterialWidgetsLocalizations</code> 用于 Material wigets 的本地化。如果你使用 <code>WidgetsApp</code> ，则无需包括后者。注意，这两个代理虽然包括了“默认”值，但如果你想让你的 App 本地化，你仍需要提供一或多个代理作为你的 App 本地化副本。</p>\n<p>当初始化时，<code>WidgetsApp</code> 或 <code>MaterialApp</code> 会使用你指定的代理为你创建一个  <a href=\"https://docs.flutter.io/flutter/widgets/Localizations-class.html\"><code>Localizations</code></a> widget。<code>Localizations</code> widget 可以随时从当前上下文中访问设备的地点，或者使用 <a href=\"https://docs.flutter.io/flutter/dart-ui/Window/locale.html\"><code>Window.locale</code></a>。</p>\n<p>要访问本地化文件，使用 <code>Localizations.of()</code> 方法来访问提供代理的特定本地化类。如需翻译，使用  <a href=\"https://pub.dartlang.org/packages/intl_translation\"><code>intl_translation</code></a> 包来取出翻译副本到 <a href=\"https://code.google.com/p/arb/wiki/ApplicationResourceBundleSpecification\">arb</a> 文件中。把它们引入 App 中，并用 <code>intl</code> 来使用它们。</p>\n<p>更多 Flutter 中国际化和本地化的细节，请访问 <a href=\"https://flutter.io/tutorials/internationalization\">internationalization guide</a> ，那里有不使用 <code>intl</code> 包的示例代码。</p>\n<p>注意，在 Flutter 1.0 beta 2 之前，在 Flutter 中定义的 assets 不能在原生一侧被访问。原生定义的资源在 Flutter 中也不可用，因为它们在独立的文件夹中。</p>\n<h3 id=\"Cocoapods-相当于什么？我该如何添加依赖？\"><a href=\"#Cocoapods-相当于什么？我该如何添加依赖？\" class=\"headerlink\" title=\"Cocoapods 相当于什么？我该如何添加依赖？\"></a>Cocoapods 相当于什么？我该如何添加依赖？</h3><p>在 iOS 中，你把依赖添加到 <code>Podfile</code> 中。Flutter 使用 Dart 构建系统和 Pub 包管理器来处理依赖。这些工具将本机 Android 和 iOS 包装应用程序的构建委派给相应的构建系统。</p>\n<p>如果你的 Flutter 工程中的 iOS 文件夹中拥有 Podfile，请仅在你为每个平台集成时使用它。总体来说，使用 <code>pubspec.yaml</code> 来在 Flutter 中声明外部依赖。一个可以找到优秀 Flutter 包的地方是 <a href=\"https://pub.dartlang.org/flutter/packages/\">Pub</a>。</p>\n<h2 id=\"ViewControllers\"><a href=\"#ViewControllers\" class=\"headerlink\" title=\"ViewControllers\"></a>ViewControllers</h2><h3 id=\"ViewController-相当于-Flutter-中的什么？\"><a href=\"#ViewController-相当于-Flutter-中的什么？\" class=\"headerlink\" title=\"ViewController 相当于 Flutter 中的什么？\"></a>ViewController 相当于 Flutter 中的什么？</h3><p>在 iOS 中，一个 ViewController 代表了用户界面的一部分，最常用于一个屏幕，或是其中一部分。它们被组合在一起用于构建复杂的用户界面，并帮助你拆分 App 的 UI。在 Flutter 中，这一任务回落到了 widgets 中。就像在界面导航部分提到的一样，一个屏幕也是被 widgets 来表示的，因为“万物皆 widget！”。使用 <code>Navigator</code> 在 <code>Route</code> 之间跳转，或者渲染相同数据的不同状态。</p>\n<h3 id=\"我该怎么监听-iOS-中的生命周期事件？\"><a href=\"#我该怎么监听-iOS-中的生命周期事件？\" class=\"headerlink\" title=\"我该怎么监听 iOS 中的生命周期事件？\"></a>我该怎么监听 iOS 中的生命周期事件？</h3><p>在 iOS 中，你可以重写 <code>ViewController</code> 中的方法来补货它的视图的生命周期，或者在 <code>AppDelegate</code> 中注册生命周期的回调函数。在 Flutter 中没有这两个概念，但你可以通过 hook <code>WidgetsBinding</code> 观察者来监听生命周期事件，并监听 <code>didChangeAppLifecycleState()</code> 的变化事件。</p>\n<p>可观察的生命周期事件有：</p>\n<ul>\n<li><code>inactive</code> - 应用处于不活跃的状态，并且不会接受用户的输入。这个事件仅工作在 iOS 平台，在 Android 上没有等价的事件。</li>\n<li><code>paused</code> - 应用暂时对用户不可见，虽然不接受用户输入，但是是在后台运行的。</li>\n<li><code>resumed</code> - 应用可见，也响应用户的输入。</li>\n<li><code>suspending</code> - 应用暂时被挂起，在 iOS 上没有这一事件。</li>\n</ul>\n<p>更多关于这些状态的细节和含义，请参见  <a href=\"https://docs.flutter.io/flutter/dart-ui/AppLifecycleState-class.html\"><code>AppLifecycleStatus</code> documentation</a> 。</p>\n<h2 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h2><h3 id=\"UITableView-和-UICollectionView-相当于-Flutter-中的什么？\"><a href=\"#UITableView-和-UICollectionView-相当于-Flutter-中的什么？\" class=\"headerlink\" title=\"UITableView 和 UICollectionView 相当于 Flutter 中的什么？\"></a>UITableView 和 UICollectionView 相当于 Flutter 中的什么？</h3><p>在 iOS 中，你可能用 UITableView 或 UICollectionView 来展示一个列表。在 Flutter 中，你可以用 <code>ListView</code> 来达到相似的实现。在 iOS 中，你通过代理方法来确定行数，每一个 index path 的单元格，以及单元格的尺寸。</p>\n<p>由于 Flutter 中 widget 的不可变特性，你需要向 <code>ListView</code> 传递一个 widget 列表，Flutter 会确保滚动是快速且流畅的。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: ListView(children: _getListData()),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _getListData() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">List</span>&lt;Widget&gt; widgets = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">      widgets.add(Padding(padding: EdgeInsets.all(<span class=\"number\">10.0</span>), child: Text(<span class=\"string\">\"Row <span class=\"subst\">$i</span>\"</span>)));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> widgets;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么知道列表的哪个元素被点击了？\"><a href=\"#我怎么知道列表的哪个元素被点击了？\" class=\"headerlink\" title=\"我怎么知道列表的哪个元素被点击了？\"></a>我怎么知道列表的哪个元素被点击了？</h3><p>iOS 中，你通过 <code>tableView:didSelectRowAtIndexPath:</code> 代理方法来实现。在 Flutter 中，使用传递进来的 widget 的 touch handle：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: ListView(children: _getListData()),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _getListData() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">List</span>&lt;Widget&gt; widgets = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">      widgets.add(GestureDetector(</span><br><span class=\"line\">        child: Padding(</span><br><span class=\"line\">          padding: EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">          child: Text(<span class=\"string\">\"Row <span class=\"subst\">$i</span>\"</span>),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        onTap: () &#123;</span><br><span class=\"line\">          <span class=\"built_in\">print</span>(<span class=\"string\">'row tapped'</span>);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> widgets;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么动态地更新-ListView？\"><a href=\"#我怎么动态地更新-ListView？\" class=\"headerlink\" title=\"我怎么动态地更新 ListView？\"></a>我怎么动态地更新 ListView？</h3><p>在 iOS 中，你改变列表的数据，并通过 <code>reloadData()</code> 方法来通知 table 或是 collection view。</p>\n<p>在 Flutter 中，如果你想通过 <code>setState()</code> 方法来更新 widget 列表，你会很快发现你的数据展示并没有变化。这是因为当 <code>setState()</code> 被调用时，Flutter 渲染引擎会去检查 widget 树来查看是否有什么地方被改变了。当它得到你的 <code>ListView</code> 时，它会使用一个 <code>==</code> 判断，并且发现两个 <code>ListView</code> 是相同的。没有什么东西是变了的，因此更新不是必须的。</p>\n<p>一个更新 <code>ListView</code> 的简单方法是，在 <code>setState()</code> 中创建一个新的 list，并把旧 list 的数据拷贝给新的 list。虽然这样很简单，但当数据集很大时，并不推荐这样做：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> widgets = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">      widgets.add(getRow(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: ListView(children: widgets),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget getRow(<span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> GestureDetector(</span><br><span class=\"line\">      child: Padding(</span><br><span class=\"line\">        padding: EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"Row <span class=\"subst\">$i</span>\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      onTap: () &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          widgets = <span class=\"built_in\">List</span>.from(widgets);</span><br><span class=\"line\">          widgets.add(getRow(widgets.length + <span class=\"number\">1</span>));</span><br><span class=\"line\">          <span class=\"built_in\">print</span>(<span class=\"string\">'row <span class=\"subst\">$i</span>'</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个推荐的、高效的且有效的做法是，使用 <code>ListView.Builder</code> 来构建列表。这个方法在你想要构建动态列表，或是列表拥有大量数据时会非常好用。</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'package:flutter/material.dart'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> main() &#123;</span><br><span class=\"line\">  runApp(SampleApp());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">List</span> widgets = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.initState();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">      widgets.add(getRow(i));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: ListView.builder(</span><br><span class=\"line\">        itemCount: widgets.length,</span><br><span class=\"line\">        itemBuilder: (BuildContext context, <span class=\"built_in\">int</span> position) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> getRow(position);</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Widget getRow(<span class=\"built_in\">int</span> i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> GestureDetector(</span><br><span class=\"line\">      child: Padding(</span><br><span class=\"line\">        padding: EdgeInsets.all(<span class=\"number\">10.0</span>),</span><br><span class=\"line\">        child: Text(<span class=\"string\">\"Row <span class=\"subst\">$i</span>\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      onTap: () &#123;</span><br><span class=\"line\">        setState(() &#123;</span><br><span class=\"line\">          widgets.add(getRow(widgets.length + <span class=\"number\">1</span>));</span><br><span class=\"line\">          <span class=\"built_in\">print</span>(<span class=\"string\">'row <span class=\"subst\">$i</span>'</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>与创建一个 “ListView” 不同，创建一个 <code>ListView.builder</code> 接受两个主要参数：列表的初始长度，和一个 <code>ItemBuilder</code> 方法。</p>\n<p><code>ItemBuilder</code> 方法和 <code>cellForItemAt</code> 代理方法非常类似，它接受一个位置，并且返回在这个位置上你希望渲染的 cell。</p>\n<p>最后，也是最重要的，注意 <code>onTap()</code> 函数里并没有重新创建一个 list，而是 <code>.add</code> 了一个 widget。</p>\n<h3 id=\"ScrollView-相当于-Flutter-里的什么？\"><a href=\"#ScrollView-相当于-Flutter-里的什么？\" class=\"headerlink\" title=\"ScrollView 相当于 Flutter 里的什么？\"></a>ScrollView 相当于 Flutter 里的什么？</h3><p>在 iOS 中，你给 view 包裹上 <code>ScrollView</code> 来允许用户在需要时滚动你的内容。</p>\n<p>在 Flutter 中，最简单的方法是使用 <code>ListView</code> widget。它表现得既和 iOS 中的 <code>ScrollView</code> 一致，也能和 <code>TableView</code> 一致，因为你可以给它的 widget 做垂直排布：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ListView(</span><br><span class=\"line\">    children: &lt;Widget&gt;[</span><br><span class=\"line\">      Text(<span class=\"string\">'Row One'</span>),</span><br><span class=\"line\">      Text(<span class=\"string\">'Row Two'</span>),</span><br><span class=\"line\">      Text(<span class=\"string\">'Row Three'</span>),</span><br><span class=\"line\">      Text(<span class=\"string\">'Row Four'</span>),</span><br><span class=\"line\">    ],</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>更多关于在 Flutter 总如何排布 widget 的文档，请参阅 <a href=\"https://flutter.io/widgets/layout/\">layout tutorial</a>。</p>\n<h2 id=\"手势检测及触摸事件处理\"><a href=\"#手势检测及触摸事件处理\" class=\"headerlink\" title=\"手势检测及触摸事件处理\"></a>手势检测及触摸事件处理</h2><h3 id=\"我怎么给-Flutter-的-widget-添加一个点击监听者？\"><a href=\"#我怎么给-Flutter-的-widget-添加一个点击监听者？\" class=\"headerlink\" title=\"我怎么给 Flutter 的 widget 添加一个点击监听者？\"></a>我怎么给 Flutter 的 widget 添加一个点击监听者？</h3><p>在 iOS 中，你给一个 view 添加 <code>GestureRecognizer</code> 来处理点击事件。在 Flutter 中，有两种方法来添加点击监听者：</p>\n<ol>\n<li><p>如果 widget 本身支持事件监测，直接传递给它一个函数，并在这个函数里实现响应方法。例如，<code>RaisedButton</code> widget 拥有一个 <code>RaisedButton</code> 参数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> RaisedButton(</span><br><span class=\"line\">    onPressed: () &#123;</span><br><span class=\"line\">      <span class=\"built_in\">print</span>(<span class=\"string\">\"click\"</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    child: Text(<span class=\"string\">\"Button\"</span>),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果 widget 本身不支持事件监测，则在外面包裹一个 GestureDetector，并给它的 onTap 属性传递一个函数：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">        child: GestureDetector(</span><br><span class=\"line\">          child: FlutterLogo(</span><br><span class=\"line\">            size: <span class=\"number\">200.0</span>,</span><br><span class=\"line\">          ),</span><br><span class=\"line\">          onTap: () &#123;</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">\"tap\"</span>);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"我怎么处理-widget-上的其他手势？\"><a href=\"#我怎么处理-widget-上的其他手势？\" class=\"headerlink\" title=\"我怎么处理 widget 上的其他手势？\"></a>我怎么处理 widget 上的其他手势？</h3><p>使用 <code>GestureDetector</code> 你可以监听更广阔范围内的手势，比如：</p>\n<ul>\n<li>Tapping<ul>\n<li><code>onTapDown</code> — 在特定位置轻触手势接触了屏幕。</li>\n<li><code>onTapUp</code> — 在特定位置产生了一个轻触手势，并停止接触屏幕。</li>\n<li><code>onTap</code> — 产生了一个轻触手势。</li>\n<li><code>onTapCancel</code> — 触发了 <code>onTapDown</code> 但没能触发 tap。</li>\n</ul>\n</li>\n<li>Double tapping<ul>\n<li><code>onDoubleTap</code> — 用户在同一个位置快速点击了两下屏幕。</li>\n</ul>\n</li>\n<li>Long pressing<ul>\n<li><code>onLongPress</code> — 用户在同一个位置长时间接触屏幕。</li>\n</ul>\n</li>\n<li>Vertical dragging<ul>\n<li><code>onVerticalDragStart</code> — 接触了屏幕，并且可能会垂直移动。</li>\n<li><code>onVerticalDragUpdate</code> — 接触了屏幕，并继续在垂直方向移动。</li>\n<li><code>onVerticalDragEnd</code> — 之前接触了屏幕并垂直移动，并在停止接触屏幕前以某个垂直的速度移动。</li>\n</ul>\n</li>\n<li>Horizontal dragging<ul>\n<li><code>onHorizontalDragStart</code> </li>\n<li><code>onHorizontalDragUpdate</code></li>\n<li><code>onHorizontalDragEnd</code></li>\n</ul>\n</li>\n</ul>\n<p>下面这个例子展示了一个 <code>GestureDetector</code> 是如何在双击时旋转 Flutter 的 logo 的：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AnimationController controller;</span><br><span class=\"line\">CurvedAnimation curve;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> initState() &#123;</span><br><span class=\"line\">  controller = AnimationController(duration: <span class=\"keyword\">const</span> <span class=\"built_in\">Duration</span>(milliseconds: <span class=\"number\">2000</span>), vsync: <span class=\"keyword\">this</span>);</span><br><span class=\"line\">  curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">        child: GestureDetector(</span><br><span class=\"line\">          child: RotationTransition(</span><br><span class=\"line\">            turns: curve,</span><br><span class=\"line\">            child: FlutterLogo(</span><br><span class=\"line\">              size: <span class=\"number\">200.0</span>,</span><br><span class=\"line\">            )),</span><br><span class=\"line\">          onDoubleTap: () &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (controller.isCompleted) &#123;</span><br><span class=\"line\">              controller.reverse();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              controller.forward();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"主题和文字\"><a href=\"#主题和文字\" class=\"headerlink\" title=\"主题和文字\"></a>主题和文字</h2><h3 id=\"我怎么给-App-设置主题？\"><a href=\"#我怎么给-App-设置主题？\" class=\"headerlink\" title=\"我怎么给 App 设置主题？\"></a>我怎么给 App 设置主题？</h3><p>Flutter 实现了一套漂亮的 MD 组件，并且开箱可用。它接管了一大堆你需要的样式和主题。</p>\n<p>为了充分发挥你的 App 中 MD 组件的优势，声明一个顶级 widget，MaterialApp，用作你的 App 入口。MaterialApp 是一个便利组件，包含了许多 App 通常需要的 MD 风格组件。它通过一个 WidgetsApp 添加了 MD 功能来实现。</p>\n<p>但是 Flutter 足够地灵活和富有表现力来实现任何其他的设计语言。在 iOS 上，你可以用 <a href=\"https://docs.flutter.io/flutter/cupertino/cupertino-library.html\">Cupertino library</a> 来制作遵守  <a href=\"https://developer.apple.com/ios/human-interface-guidelines/overview/themes/\">Human Interface Guidelines</a> 的界面。查看这些 widget 的集合，请参阅 <a href=\"https://flutter.io/widgets/cupertino/\">Cupertino widgets gallery</a>。</p>\n<p>你也可以在你的 App 中使用 WidgetApp，它提供了许多相似的功能，但不如 <code>MaterialApp</code> 那样强大。</p>\n<p>对任何子组件定义颜色和样式，可以给 <code>MaterialApp</code> widget 传递一个 <code>ThemeData</code> 对象。举个例子，在下面的代码中，primary swatch 被设置为蓝色，并且文字的选中颜色是红色：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">        textSelectionColor: Colors.red</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么给-Text-widget-设置自定义字体？\"><a href=\"#我怎么给-Text-widget-设置自定义字体？\" class=\"headerlink\" title=\"我怎么给 Text widget 设置自定义字体？\"></a>我怎么给 Text widget 设置自定义字体？</h3><p>在 iOS 中，你在项目中引入任意的 <code>ttf</code> 文件，并在 <code>info.plist</code> 中设置引用。在 Flutter 中，在文件夹中放置字体文件，并在 <code>pubspec.yaml</code> 中引用它，就像添加图片那样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fonts:</span><br><span class=\"line\">   - family: MyCustomFont</span><br><span class=\"line\">     fonts:</span><br><span class=\"line\">       - asset: fonts/MyCustomFont.ttf</span><br><span class=\"line\">       - style: italic</span><br></pre></td></tr></table></figure>\n<p>然后在你的 <code>Text</code> widget 中指定字体：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@override</span></span><br><span class=\"line\">Widget build(BuildContext context) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">    appBar: AppBar(</span><br><span class=\"line\">      title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">    body: Center(</span><br><span class=\"line\">      child: Text(</span><br><span class=\"line\">        <span class=\"string\">'This is a custom font text'</span>,</span><br><span class=\"line\">        style: TextStyle(fontFamily: <span class=\"string\">'MyCustomFont'</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    ),</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么给我的-Text-widget-设置样式？\"><a href=\"#我怎么给我的-Text-widget-设置样式？\" class=\"headerlink\" title=\"我怎么给我的 Text widget 设置样式？\"></a>我怎么给我的 Text widget 设置样式？</h3><p>除了字体以外，你也可以给 Text widget 的样式元素设置自定义值。<code>Text</code> widget 接受一个  <code>TextStyle</code> 对象，你可以指定许多参数，比如：</p>\n<ul>\n<li><code>color</code></li>\n<li><code>decoration</code></li>\n<li><code>decorationColor</code></li>\n<li><code>decorationStyle</code></li>\n<li><code>fontFamily</code></li>\n<li><code>fontSize</code></li>\n<li><code>fontStyle</code></li>\n<li><code>fontWeight</code></li>\n<li><code>hashCode</code></li>\n<li><code>height</code></li>\n<li><code>inherit</code></li>\n<li><code>letterSpacing</code></li>\n<li><code>textBaseline</code></li>\n<li><code>wordSpacing</code></li>\n</ul>\n<h2 id=\"表单输入\"><a href=\"#表单输入\" class=\"headerlink\" title=\"表单输入\"></a>表单输入</h2><h3 id=\"Flutter-中表单怎么工作？我怎么拿到用户的输入？\"><a href=\"#Flutter-中表单怎么工作？我怎么拿到用户的输入？\" class=\"headerlink\" title=\"Flutter 中表单怎么工作？我怎么拿到用户的输入？\"></a>Flutter 中表单怎么工作？我怎么拿到用户的输入？</h3><p>我们已经提到 Flutter 使用不可变的 widget，并且状态是分离的，你可能会好奇在这种情境下怎么处理用户的输入。在 iOS 中，你经常在需要提交数据时查询组件当前的状态或动作，但这在 Flutter 中是怎么工作的呢？</p>\n<p>在表单处理的实践中，就像在 Flutter 中任何其他的地方一样，要通过特定的 widgets。如果你有一个 <code>TextField</code> 或是 <code>TextFormField</code>，你可以通过 <a href=\"https://docs.flutter.io/flutter/widgets/TextEditingController-class.html\"><code>TextEditingController</code></a> 来获得用户输入：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_MyFormState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">MyForm</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create a text controller and use it to retrieve the current value.</span></span><br><span class=\"line\">  <span class=\"comment\">// of the TextField!</span></span><br><span class=\"line\">  <span class=\"keyword\">final</span> myController = TextEditingController();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"keyword\">void</span> dispose() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Clean up the controller when disposing of the Widget.</span></span><br><span class=\"line\">    myController.dispose();</span><br><span class=\"line\">    <span class=\"keyword\">super</span>.dispose();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">'Retrieve Text Input'</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: Padding(</span><br><span class=\"line\">        padding: <span class=\"keyword\">const</span> EdgeInsets.all(<span class=\"number\">16.0</span>),</span><br><span class=\"line\">        child: TextField(</span><br><span class=\"line\">          controller: myController,</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      floatingActionButton: FloatingActionButton(</span><br><span class=\"line\">        <span class=\"comment\">// When the user presses the button, show an alert dialog with the</span></span><br><span class=\"line\">        <span class=\"comment\">// text the user has typed into our text field.</span></span><br><span class=\"line\">        onPressed: () &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> showDialog(</span><br><span class=\"line\">            context: context,</span><br><span class=\"line\">            builder: (context) &#123;</span><br><span class=\"line\">              <span class=\"keyword\">return</span> AlertDialog(</span><br><span class=\"line\">                <span class=\"comment\">// Retrieve the text the user has typed in using our</span></span><br><span class=\"line\">                <span class=\"comment\">// TextEditingController</span></span><br><span class=\"line\">                content: Text(myController.text),</span><br><span class=\"line\">              );</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          );</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        tooltip: <span class=\"string\">'Show me the value!'</span>,</span><br><span class=\"line\">        child: Icon(Icons.text_fields),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以在这里获得更多信息，或是完整的代码列表： <a href=\"https://flutter.io/cookbook/forms/retrieve-input/\">Retrieve the value of a text field</a>，来自 <a href=\"https://flutter.io/cookbook/\">Flutter Cookbook</a> 。</p>\n<h3 id=\"Text-field-中的-placeholder-相当于什么？\"><a href=\"#Text-field-中的-placeholder-相当于什么？\" class=\"headerlink\" title=\"Text field 中的 placeholder 相当于什么？\"></a>Text field 中的 placeholder 相当于什么？</h3><p>在 Flutter 中，你可以轻易地通过向 Text widget 的装饰构造器参数重传递 <code>InputDecoration</code> 来展示“小提示”，或是占位符文字：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">body: Center(</span><br><span class=\"line\">  child: TextField(</span><br><span class=\"line\">    decoration: InputDecoration(hintText: <span class=\"string\">\"This is a hint\"</span>),</span><br><span class=\"line\">  ),</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<h3 id=\"我怎么展示验证错误信息？\"><a href=\"#我怎么展示验证错误信息？\" class=\"headerlink\" title=\"我怎么展示验证错误信息？\"></a>我怎么展示验证错误信息？</h3><p>就像展示“小提示”一样，向 Text widget 的装饰器构造器参数中传递一个 <code>InputDecoration</code>。</p>\n<p>然而，你并不想在一开始就显示错误信息。相反，当用户输入了验证信息，更新状态，并传入一个新的 <code>InputDecoration</code> 对象：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleApp</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatelessWidget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// This widget is the root of your application.</span></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaterialApp(</span><br><span class=\"line\">      title: <span class=\"string\">'Sample App'</span>,</span><br><span class=\"line\">      theme: ThemeData(</span><br><span class=\"line\">        primarySwatch: Colors.blue,</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      home: SampleAppPage(),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SampleAppPage</span> <span class=\"keyword\">extends</span> <span class=\"title\">StatefulWidget</span> </span>&#123;</span><br><span class=\"line\">  SampleAppPage(&#123;Key key&#125;) : <span class=\"keyword\">super</span>(key: key);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  _SampleAppPageState createState() =&gt; _SampleAppPageState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">_SampleAppPageState</span> <span class=\"keyword\">extends</span> <span class=\"title\">State</span>&lt;<span class=\"title\">SampleAppPage</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">String</span> _errorText;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  Widget build(BuildContext context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Scaffold(</span><br><span class=\"line\">      appBar: AppBar(</span><br><span class=\"line\">        title: Text(<span class=\"string\">\"Sample App\"</span>),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">      body: Center(</span><br><span class=\"line\">        child: TextField(</span><br><span class=\"line\">          onSubmitted: (<span class=\"built_in\">String</span> text) &#123;</span><br><span class=\"line\">            setState(() &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!isEmail(text)) &#123;</span><br><span class=\"line\">                _errorText = <span class=\"string\">'Error: This is not an email'</span>;</span><br><span class=\"line\">              &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                _errorText = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">          &#125;,</span><br><span class=\"line\">          decoration: InputDecoration(hintText: <span class=\"string\">\"This is a hint\"</span>, errorText: _getErrorText()),</span><br><span class=\"line\">        ),</span><br><span class=\"line\">      ),</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  _getErrorText() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _errorText;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">bool</span> isEmail(<span class=\"built_in\">String</span> em) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> emailRegexp =</span><br><span class=\"line\">        <span class=\"string\">r'^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\.[0-9]&#123;1,3&#125;\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]&#123;2,&#125;))$'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">RegExp</span> regExp = <span class=\"built_in\">RegExp</span>(p);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> regExp.hasMatch(em);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"和硬件、第三方服务以及平台交互\"><a href=\"#和硬件、第三方服务以及平台交互\" class=\"headerlink\" title=\"和硬件、第三方服务以及平台交互\"></a>和硬件、第三方服务以及平台交互</h2><h3 id=\"我怎么和平台，以及平台的原生代码交互？\"><a href=\"#我怎么和平台，以及平台的原生代码交互？\" class=\"headerlink\" title=\"我怎么和平台，以及平台的原生代码交互？\"></a>我怎么和平台，以及平台的原生代码交互？</h3><p>Flutter 的代码并不直接在平台之下运行，相反，Dart 代码构建的 Flutter 应用在设备上以原生的方式运行，却“侧步躲开了”平台提供的 SDK。这意味着，例如，你在 Dart 中发起一个网络请求，它就直接在 Dart 的上下文中运行。你并不会用上平常在 iOS 或 Android 上使用的原生 API。你的 Flutter 程序仍然被原生平台的 <code>ViewController</code> 管理作一个 view，但是你并不会直接访问 <code>ViewController</code> 自身，或是原生框架。</p>\n<p>但这并不意味着 Flutter 不能和原生 API，或任何你编写的原生代码交互。Flutter 提供了 <a href=\"https://flutter.io/platform-channels/\">platform channels</a> ，来和管理你的 Flutter view 的 ViewController 通信和交互数据。平台管道本质上是一个异步通信机制，桥接了 Dart 代码和宿主 ViewController，以及它运行于的 iOS 框架。你可以用平台管道来执行一个原生的函数，或者是从设备的传感器中获取数据。</p>\n<p>除了直接使用平台管道之外，你还可以使用一系列预先制作好的 <a href=\"https://flutter.io/using-packages/\">plugins</a>。例如，你可以直接使用插件来访问相机胶卷或是设备的摄像头，而不必编写你自己的集成层代码。你可以在 <a href=\"https://pub.dartlang.org/\">Pub</a> 上找到插件，这是一个 Dart 和 Flutter 的开源包仓库。其中一些包可能会支持集成 iOS 或 Android，或两者均可。</p>\n<p>如果你在 Pub 上找不到符合你需求的插件，你可以<a href=\"https://flutter.io/developing-packages/\">自己编写</a> ，并且<a href=\"https://flutter.io/developing-packages/#publish\">发布在 Pub 上</a>。</p>\n<h3 id=\"我怎么访问-GPS-传感器？\"><a href=\"#我怎么访问-GPS-传感器？\" class=\"headerlink\" title=\"我怎么访问 GPS 传感器？\"></a>我怎么访问 GPS 传感器？</h3><p>使用 <a href=\"https://pub.dartlang.org/packages/location\"><code>location</code></a> 社区插件。</p>\n<h3 id=\"我怎么访问摄像头？\"><a href=\"#我怎么访问摄像头？\" class=\"headerlink\" title=\"我怎么访问摄像头？\"></a>我怎么访问摄像头？</h3><p><a href=\"https://pub.dartlang.org/packages/image_picker\"><code>image_picker</code></a> 在访问摄像头时非常常用。</p>\n<h3 id=\"我怎么登录-Facebook？\"><a href=\"#我怎么登录-Facebook？\" class=\"headerlink\" title=\"我怎么登录 Facebook？\"></a>我怎么登录 Facebook？</h3><p>登录 Facebook 可以使用 <a href=\"https://pub.dartlang.org/packages/flutter_facebook_login\"><code>flutter_facebook_login</code></a> 社区插件。</p>\n<h3 id=\"我怎么使用-Firebase-特性？\"><a href=\"#我怎么使用-Firebase-特性？\" class=\"headerlink\" title=\"我怎么使用 Firebase 特性？\"></a>我怎么使用 Firebase 特性？</h3><p>大多数 Firebase 特性被  <a href=\"https://pub.dartlang.org/flutter/packages?q=firebase\">first party plugins</a> 包含了。这些第一方插件由 Flutter 团队维护：</p>\n<ul>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_admob\"><code>firebase_admob</code></a> for Firebase AdMob</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_analytics\"><code>firebase_analytics</code></a> for Firebase Analytics</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_auth\"><code>firebase_auth</code></a> for Firebase Auth</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_core\"><code>firebase_core</code></a> for Firebase’s Core package</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_database\"><code>firebase_database</code></a> for Firebase RTDB</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_storage\"><code>firebase_storage</code></a> for Firebase Cloud Storage</li>\n<li><a href=\"https://pub.dartlang.org/packages/firebase_messaging\"><code>firebase_messaging</code></a> for Firebase Messaging (FCM)</li>\n<li><a href=\"https://pub.dartlang.org/packages/cloud_firestore\"><code>cloud_firestore</code></a> for Firebase Cloud Firestore</li>\n</ul>\n<p>你也可以在 Pub 上找到 Firebase 的第三方插件。</p>\n<h3 id=\"我怎创建自己的原生集成层？\"><a href=\"#我怎创建自己的原生集成层？\" class=\"headerlink\" title=\"我怎创建自己的原生集成层？\"></a>我怎创建自己的原生集成层？</h3><p>如果有一些 Flutter 和社区插件遗漏的平台相关的特性，可以根据  <a href=\"https://flutter.io/developing-packages/\">developing packages and plugins</a> 页面构建自己的插件。</p>\n<p>Flutter 的插件结构，简要来说，就像 Android 中的 Event bus。你发送一个消息，并让接受者处理并反馈结果给你。在这种情况下，接受者就是在 Android 或 iOS 上的原生代码。</p>\n<h2 id=\"数据库和本地存储\"><a href=\"#数据库和本地存储\" class=\"headerlink\" title=\"数据库和本地存储\"></a>数据库和本地存储</h2><h3 id=\"我怎么在-Flutter-中访问-UserDefaults？\"><a href=\"#我怎么在-Flutter-中访问-UserDefaults？\" class=\"headerlink\" title=\"我怎么在 Flutter 中访问 UserDefaults？\"></a>我怎么在 Flutter 中访问 UserDefaults？</h3><p>在 iOS 中，你可以使用属性列表来存储键值对的集合，即我们熟悉的 UserDefaults。</p>\n<p>在 Flutter 中，可以使用  <a href=\"https://pub.dartlang.org/packages/shared_preferences\">Shared Preferences plugin</a> 来达到相似的功能。它包裹了 <code>UserDefaluts</code> 以及 Android 上等价的 <code>SharedPreferences</code> 的功能。</p>\n<h3 id=\"CoreData-相当于-Flutter-中的什么？\"><a href=\"#CoreData-相当于-Flutter-中的什么？\" class=\"headerlink\" title=\"CoreData 相当于 Flutter 中的什么？\"></a>CoreData 相当于 Flutter 中的什么？</h3><p>在 iOS 中，你通过 CoreData 来存储结构化的数据。这是一个 SQL 数据库的上层封装，让查询和关联模型变得更加简单。</p>\n<p>在 Flutter 中，使用 <a href=\"https://pub.dartlang.org/packages/sqflite\">SQFlite</a> 插件来实现这个功能。</p>\n<h2 id=\"通知\"><a href=\"#通知\" class=\"headerlink\" title=\"通知\"></a>通知</h2><h3 id=\"我怎么推送通知？\"><a href=\"#我怎么推送通知？\" class=\"headerlink\" title=\"我怎么推送通知？\"></a>我怎么推送通知？</h3><p>在 iOS 中，你需要向 developer portal 中注册来允许推送通知。</p>\n<p>在 Flutter 中，使用 <code>firebase_messaging</code> 插件来实现这一功能。</p>\n<p>更多使用 Firebase Cloud Messaging API 的信息，请参阅 <a href=\"https://pub.dartlang.org/packages/firebase_messaging\"><code>firebase_messaging</code></a> 插件文档。</p>\n<hr>\n<p>此文档由 Luyuan Wang 原创翻译。2018 - 07 - 11</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck4zcnv2m0001ljc3h67k313p","tag_id":"ck4zcnv2r0004ljc3dridlkqr","_id":"ck4zcnv2w0009ljc374aevl44"},{"post_id":"ck4zcnv2q0003ljc3q6dvxiyp","tag_id":"ck4zcnv2w0008ljc3d131ijup","_id":"ck4zcnv2z000eljc3pnte3qfz"},{"post_id":"ck4zcnv2u0005ljc3uki3lg5l","tag_id":"ck4zcnv2y000cljc3e3xqq1nw","_id":"ck4zcnv30000iljc39rkfsrho"},{"post_id":"ck4zcnv2v0006ljc3naict7gj","tag_id":"ck4zcnv30000gljc3mj5qumg2","_id":"ck4zcnv32000mljc3rawuxs8p"},{"post_id":"ck4zcnv2v0007ljc3skwvpnii","tag_id":"ck4zcnv31000kljc3tqxm9pv2","_id":"ck4zcnv33000qljc3kh4koqd9"},{"post_id":"ck4zcnv2w000aljc31ll0atwc","tag_id":"ck4zcnv33000pljc30ww7stc6","_id":"ck4zcnv36000vljc33otak6ds"},{"post_id":"ck4zcnv2x000bljc3cu11mocy","tag_id":"ck4zcnv31000kljc3tqxm9pv2","_id":"ck4zcnv38000zljc36gufw4zc"},{"post_id":"ck4zcnv2y000dljc3l2ikmr6q","tag_id":"ck4zcnv31000kljc3tqxm9pv2","_id":"ck4zcnv390013ljc3drjcain3"},{"post_id":"ck4zcnv2z000fljc33u1wr3ky","tag_id":"ck4zcnv31000kljc3tqxm9pv2","_id":"ck4zcnv3b0017ljc3azaew21g"},{"post_id":"ck4zcnv30000jljc3xatzc9bi","tag_id":"ck4zcnv3a0015ljc3zi95qrqa","_id":"ck4zcnv3c001bljc3d6z5j0op"},{"post_id":"ck4zcnv31000lljc36msnw7gu","tag_id":"ck4zcnv3c0019ljc3tozplnsn","_id":"ck4zcnv3e001fljc384wawcz3"},{"post_id":"ck4zcnv32000nljc3jiy3exfp","tag_id":"ck4zcnv3d001dljc32hs3t9p2","_id":"ck4zcnv3g001jljc343a0x61b"},{"post_id":"ck4zcnv32000oljc3wr6068j5","tag_id":"ck4zcnv3d001dljc32hs3t9p2","_id":"ck4zcnv3h001nljc39catl8x6"},{"post_id":"ck4zcnv33000rljc3p7sanu3t","tag_id":"ck4zcnv3h001mljc30q0svio5","_id":"ck4zcnv3j001sljc3wa7zwy3q"},{"post_id":"ck4zcnv3i001pljc3j2zc998t","tag_id":"ck4zcnv2w0008ljc3d131ijup","_id":"ck4zcnv3k001uljc3wsc6rnck"},{"post_id":"ck4zcnv34000sljc3m3whcwgb","tag_id":"ck4zcnv3j001qljc3dkhlwpsa","_id":"ck4zcnv3l001xljc3yar616ci"},{"post_id":"ck4zcnv36000wljc3ok92srtw","tag_id":"ck4zcnv3k001vljc3buv4iy6w","_id":"ck4zcnv3m0020ljc39cm4y45q"},{"post_id":"ck4zcnv37000yljc3ls69hg45","tag_id":"ck4zcnv3l001zljc37h573sxi","_id":"ck4zcnv3m0022ljc3jgc3165k"},{"post_id":"ck4zcnv390012ljc39qe9hfv7","tag_id":"ck4zcnv3m0021ljc3locdxy99","_id":"ck4zcnv3m0024ljc3wf8g8qxq"},{"post_id":"ck4zcnv390014ljc3pf008bm0","tag_id":"ck4zcnv3m0023ljc3p2yn87xm","_id":"ck4zcnv3m0026ljc3ng2u5vgb"},{"post_id":"ck4zcnv3a0016ljc31ckeorgj","tag_id":"ck4zcnv3m0025ljc3uqd5pijr","_id":"ck4zcnv3m0028ljc3yzyuop2j"},{"post_id":"ck4zcnv3b0018ljc3fqt4lne9","tag_id":"ck4zcnv3m0027ljc3o61i5eh4","_id":"ck4zcnv3n002aljc3zoqa400c"},{"post_id":"ck4zcnv3c001aljc39nl3taf3","tag_id":"ck4zcnv3n0029ljc3oao88udo","_id":"ck4zcnv3n002cljc3iuufanml"},{"post_id":"ck4zcnv3c001cljc3l1yuruxz","tag_id":"ck4zcnv3n002bljc3qxtygydb","_id":"ck4zcnv3n002eljc3cjem1wuc"},{"post_id":"ck4zcnv3d001eljc3mf9qkmob","tag_id":"ck4zcnv3n002dljc3a104ekbk","_id":"ck4zcnv3o002gljc3cgmr9re5"},{"post_id":"ck4zcnv3e001gljc3mq92yz3i","tag_id":"ck4zcnv3n002bljc3qxtygydb","_id":"ck4zcnv3o002iljc34x5iwal1"},{"post_id":"ck4zcnv3f001hljc36udx8y9n","tag_id":"ck4zcnv3n002bljc3qxtygydb","_id":"ck4zcnv3o002kljc394ykj89z"},{"post_id":"ck4zcnv3g001kljc3ylm40aid","tag_id":"ck4zcnv3n002bljc3qxtygydb","_id":"ck4zcnv3p002mljc3ox398tot"},{"post_id":"ck4zcnv3g001lljc3qn4o2zof","tag_id":"ck4zcnv3o002lljc3ea27cy31","_id":"ck4zcnv3p002oljc3a5mzxfhk"},{"post_id":"ck4zcnv3h001oljc3vz5y37gg","tag_id":"ck4zcnv3n002bljc3qxtygydb","_id":"ck4zcnv3p002qljc3muaroywa"},{"post_id":"ck4zcnv3j001rljc3rba002ky","tag_id":"ck4zcnv3p002pljc3dsoe99e9","_id":"ck4zcnv3p002sljc3lycjeoe8"},{"post_id":"ck4zcnv3j001tljc3owkqgcdl","tag_id":"ck4zcnv3p002rljc3q6hxc076","_id":"ck4zcnv3q002uljc3p6f43muh"},{"post_id":"ck4zcnv3k001wljc3yim1ftsm","tag_id":"ck4zcnv3p002tljc3v84fvqg7","_id":"ck4zcnv3q002wljc35o67203v"},{"post_id":"ck4zcnv3l001yljc3nkxqdmcj","tag_id":"ck4zcnv3q002vljc3m50jzhd5","_id":"ck4zcnv3q002xljc3j0m16v93"},{"post_id":"ck4zcnv3v002zljc3hjjd2b7y","tag_id":"ck4zcnv3p002tljc3v84fvqg7","_id":"ck4zcnv3x0032ljc33q6c16ez"},{"post_id":"ck4zcnv3w0031ljc3srfuechj","tag_id":"ck4zcnv30000gljc3mj5qumg2","_id":"ck4zcnv3y0034ljc30o1hou6n"},{"post_id":"ck4zcnv3v002yljc3td16btks","tag_id":"ck4zcnv3w0030ljc3d6h3tpdk","_id":"ck4zcnv3y0037ljc3gvqkwawk"},{"post_id":"ck4zcnv3x0033ljc3ofjxaw5w","tag_id":"ck4zcnv3y0036ljc3o32pkiw6","_id":"ck4zcnv41003cljc39gav5dei"},{"post_id":"ck4zcnv41003dljc38jz5ni4m","tag_id":"ck4zcnv3m0023ljc3p2yn87xm","_id":"ck4zcnv43003gljc37upxpf9n"},{"post_id":"ck4zcnv3y0035ljc3m4n8rk6h","tag_id":"ck4zcnv41003bljc3gdd93h9v","_id":"ck4zcnv44003iljc3716v6k2a"},{"post_id":"ck4zcnv3z0038ljc39wx6p6hx","tag_id":"ck4zcnv43003fljc34qr47z0o","_id":"ck4zcnv46003mljc3rk9zbmix"},{"post_id":"ck4zcnv44003jljc32m4s4kvk","tag_id":"ck4zcnv43003fljc34qr47z0o","_id":"ck4zcnv46003oljc3rcuue8a8"},{"post_id":"ck4zcnv3z0039ljc3fth9w34q","tag_id":"ck4zcnv45003kljc3omn98pjt","_id":"ck4zcnv48003qljc30ogz85y8"},{"post_id":"ck4zcnv40003aljc3lf4jzap3","tag_id":"ck4zcnv47003pljc3auv8ou1v","_id":"ck4zcnv48003sljc3okodgr9w"},{"post_id":"ck4zcnv42003eljc307ygwkrq","tag_id":"ck4zcnv48003rljc3wli97yor","_id":"ck4zcnv48003uljc3d4mjboa3"},{"post_id":"ck4zcnv43003hljc3yumtu57y","tag_id":"ck4zcnv48003tljc3srtf6oyo","_id":"ck4zcnv48003wljc3p1e1ehgl"},{"post_id":"ck4zcnv45003lljc3n3u66vb6","tag_id":"ck4zcnv48003vljc3lb1156aq","_id":"ck4zcnv49003yljc3wd48lkbb"},{"post_id":"ck4zcnv46003nljc30334z6vz","tag_id":"ck4zcnv48003xljc3z7rxxxv5","_id":"ck4zcnv49003zljc3rfffsro3"},{"post_id":"ck4zcnv500040ljc3u22llptr","tag_id":"ck4zcnv510041ljc3veeintan","_id":"ck4zcnv510042ljc3frimdgjv"}],"Tag":[{"name":"C/C++","_id":"ck4zcnv2r0004ljc3dridlkqr"},{"name":"AFNetworking","_id":"ck4zcnv2w0008ljc3d131ijup"},{"name":"Java","_id":"ck4zcnv2y000cljc3e3xqq1nw"},{"name":"Computer Organization","_id":"ck4zcnv30000gljc3mj5qumg2"},{"name":"Obj-C","_id":"ck4zcnv31000kljc3tqxm9pv2"},{"name":"perf","_id":"ck4zcnv33000pljc30ww7stc6"},{"name":"RaspberryPi","_id":"ck4zcnv3a0015ljc3zi95qrqa"},{"name":"SQLite","_id":"ck4zcnv3c0019ljc3tozplnsn"},{"name":"Swift","_id":"ck4zcnv3d001dljc32hs3t9p2"},{"name":"network","_id":"ck4zcnv3h001mljc30q0svio5"},{"name":"Robotics","_id":"ck4zcnv3j001qljc3dkhlwpsa"},{"name":"UITableView","_id":"ck4zcnv3k001vljc3buv4iy6w"},{"name":"CoreAnimation","_id":"ck4zcnv3l001zljc37h573sxi"},{"name":"手势冲突","_id":"ck4zcnv3m0021ljc3locdxy99"},{"name":"CoreBluetooth","_id":"ck4zcnv3m0023ljc3p2yn87xm"},{"name":"Push","_id":"ck4zcnv3m0025ljc3uqd5pijr"},{"name":"dyld","_id":"ck4zcnv3m0027ljc3o61i5eh4"},{"name":"macOS","_id":"ck4zcnv3n0029ljc3oao88udo"},{"name":"Algorithm","_id":"ck4zcnv3n002bljc3qxtygydb"},{"name":"gem5","_id":"ck4zcnv3n002dljc3a104ekbk"},{"name":"Instruments","_id":"ck4zcnv3o002lljc3ea27cy31"},{"name":"Xcode","_id":"ck4zcnv3p002pljc3dsoe99e9"},{"name":"DesignPattern","_id":"ck4zcnv3p002rljc3q6hxc076"},{"name":"JSCore","_id":"ck4zcnv3p002tljc3v84fvqg7"},{"name":"Interview","_id":"ck4zcnv3q002vljc3m50jzhd5"},{"name":"JavaScript","_id":"ck4zcnv3w0030ljc3d6h3tpdk"},{"name":"Promise","_id":"ck4zcnv3y0036ljc3o32pkiw6"},{"name":"RunLoop","_id":"ck4zcnv41003bljc3gdd93h9v"},{"name":"MultiThreading","_id":"ck4zcnv43003fljc34qr47z0o"},{"name":"Layout","_id":"ck4zcnv45003kljc3omn98pjt"},{"name":"AutoLayout","_id":"ck4zcnv47003pljc3auv8ou1v"},{"name":"Animation","_id":"ck4zcnv48003rljc3wli97yor"},{"name":"Gesture","_id":"ck4zcnv48003tljc3srtf6oyo"},{"name":"iOS","_id":"ck4zcnv48003vljc3lb1156aq"},{"name":"PlutoSDR","_id":"ck4zcnv48003xljc3z7rxxxv5"},{"name":"Flutter","_id":"ck4zcnv510041ljc3veeintan"}]}}